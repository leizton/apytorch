#include <ATen/Tensor.h>
#include <ATen/core/dispatch/Dispatcher.h>

// @generated by torchgen/gen.py from Operators.cpp
// NOTE See [Sharded File] comment in VariableType

#ifndef AT_PER_OPERATOR_HEADERS
#include <ATen/Operators.h>
#else
#include <ATen/ops/set_data.h>
#include <ATen/ops/_fw_primal.h>
#include <ATen/ops/align_tensors.h>
#include <ATen/ops/_assert_async.h>
#include <ATen/ops/_assert_async.h>
#include <ATen/ops/_functional_assert_scalar.h>
#include <ATen/ops/_functional_assert_async.h>
#include <ATen/ops/_masked_scale.h>
#include <ATen/ops/_sobol_engine_draw.h>
#include <ATen/ops/_reshape_from_tensor.h>
#include <ATen/ops/alpha_dropout.h>
#include <ATen/ops/alpha_dropout.h>
#include <ATen/ops/view_as_real.h>
#include <ATen/ops/view_as_complex.h>
#include <ATen/ops/chalf.h>
#include <ATen/ops/conj_physical.h>
#include <ATen/ops/conj_physical.h>
#include <ATen/ops/conj_physical.h>
#include <ATen/ops/acos.h>
#include <ATen/ops/acos.h>
#include <ATen/ops/acos.h>
#include <ATen/ops/arccos.h>
#include <ATen/ops/arccos.h>
#include <ATen/ops/arccos.h>
#include <ATen/ops/any.h>
#include <ATen/ops/any.h>
#include <ATen/ops/any.h>
#include <ATen/ops/any.h>
#include <ATen/ops/any.h>
#include <ATen/ops/any.h>
#include <ATen/ops/arccosh.h>
#include <ATen/ops/arccosh.h>
#include <ATen/ops/arccosh.h>
#include <ATen/ops/asin.h>
#include <ATen/ops/asin.h>
#include <ATen/ops/asin.h>
#include <ATen/ops/atleast_1d.h>
#include <ATen/ops/atleast_1d.h>
#include <ATen/ops/copysign.h>
#include <ATen/ops/copysign.h>
#include <ATen/ops/copysign.h>
#include <ATen/ops/copysign.h>
#include <ATen/ops/copysign.h>
#include <ATen/ops/copysign.h>
#include <ATen/ops/logical_xor.h>
#include <ATen/ops/logical_xor.h>
#include <ATen/ops/logical_xor.h>
#include <ATen/ops/broadcast_to.h>
#include <ATen/ops/constant_pad_nd.h>
#include <ATen/ops/contiguous.h>
#include <ATen/ops/convolution_backward.h>
#include <ATen/ops/convolution_overrideable.h>
#include <ATen/ops/_convolution_double_backward.h>
#include <ATen/ops/conv2d.h>
#include <ATen/ops/conv2d.h>
#include <ATen/ops/_copy_from.h>
#include <ATen/ops/corrcoef.h>
#include <ATen/ops/cudnn_batch_norm.h>
#include <ATen/ops/_mps_convolution_transpose.h>
#include <ATen/ops/mps_convolution_transpose_backward.h>
#include <ATen/ops/cummaxmin_backward.h>
#include <ATen/ops/cumprod_backward.h>
#include <ATen/ops/fill_diagonal.h>
#include <ATen/ops/embedding.h>
#include <ATen/ops/_rowwise_prune.h>
#include <ATen/ops/row_stack.h>
#include <ATen/ops/row_stack.h>
#include <ATen/ops/_embedding_bag_backward.h>
#include <ATen/ops/_embedding_bag_dense_backward.h>
#include <ATen/ops/resize.h>
#include <ATen/ops/erfc.h>
#include <ATen/ops/erfc.h>
#include <ATen/ops/erfc.h>
#include <ATen/ops/floor_divide.h>
#include <ATen/ops/floor_divide.h>
#include <ATen/ops/floor_divide.h>
#include <ATen/ops/floor_divide.h>
#include <ATen/ops/floor_divide.h>
#include <ATen/ops/full.h>
#include <ATen/ops/full.h>
#include <ATen/ops/full.h>
#include <ATen/ops/full_like.h>
#include <ATen/ops/grid_sampler_2d.h>
#include <ATen/ops/_grid_sampler_2d_cpu_fallback_backward.h>
#include <ATen/ops/kaiser_window.h>
#include <ATen/ops/kaiser_window.h>
#include <ATen/ops/kaiser_window.h>
#include <ATen/ops/_fft_c2r.h>
#include <ATen/ops/_fft_c2r.h>
#include <ATen/ops/_cufft_set_plan_cache_max_size.h>
#include <ATen/ops/index_put.h>
#include <ATen/ops/index_put.h>
#include <ATen/ops/instance_norm.h>
#include <ATen/ops/isclose.h>
#include <ATen/ops/is_floating_point.h>
#include <ATen/ops/is_complex.h>
#include <ATen/ops/is_same_size.h>
#include <ATen/ops/kl_div.h>
#include <ATen/ops/_cslt_compress.h>
#include <ATen/ops/_cslt_sparse_mm_search.h>
#include <ATen/ops/fbgemm_pack_gemm_matrix_fp16.h>
#include <ATen/ops/margin_ranking_loss.h>
#include <ATen/ops/matmul.h>
#include <ATen/ops/matmul_backward.h>
#include <ATen/ops/matmul.h>
#include <ATen/ops/matrix_exp.h>
#include <ATen/ops/_compute_linear_combination.h>
#include <ATen/ops/_compute_linear_combination.h>
#include <ATen/ops/max_pool2d_backward.h>
#include <ATen/ops/mkldnn_max_pool2d_backward.h>
#include <ATen/ops/max_pool3d.h>
#include <ATen/ops/median.h>
#include <ATen/ops/median.h>
#include <ATen/ops/median.h>
#include <ATen/ops/median.h>
#include <ATen/ops/median.h>
#include <ATen/ops/nanmedian.h>
#include <ATen/ops/nanmedian.h>
#include <ATen/ops/nanmedian.h>
#include <ATen/ops/nanmedian.h>
#include <ATen/ops/nanmedian.h>
#include <ATen/ops/miopen_batch_norm.h>
#include <ATen/ops/miopen_convolution_transpose.h>
#include <ATen/ops/miopen_convolution_add_relu.h>
#include <ATen/ops/miopen_rnn_backward.h>
#include <ATen/ops/_convert_weight_to_int4pack.h>
#include <ATen/ops/multiply.h>
#include <ATen/ops/multiply.h>
#include <ATen/ops/multiply.h>
#include <ATen/ops/multiply.h>
#include <ATen/ops/multiply.h>
#include <ATen/ops/batch_norm_elemt.h>
#include <ATen/ops/batch_norm_elemt.h>
#include <ATen/ops/cdist.h>
#include <ATen/ops/mT.h>
#include <ATen/ops/adjoint.h>
#include <ATen/ops/channel_shuffle.h>
#include <ATen/ops/poisson_nll_loss.h>
#include <ATen/ops/deg2rad.h>
#include <ATen/ops/deg2rad.h>
#include <ATen/ops/deg2rad.h>
#include <ATen/ops/randperm.h>
#include <ATen/ops/randperm.h>
#include <ATen/ops/randperm.h>
#include <ATen/ops/randperm.h>
#include <ATen/ops/negative.h>
#include <ATen/ops/negative.h>
#include <ATen/ops/negative.h>
#include <ATen/ops/_reshape_copy.h>
#include <ATen/ops/relu.h>
#include <ATen/ops/relu.h>
#include <ATen/ops/infinitely_differentiable_gelu_backward.h>
#include <ATen/ops/hardshrink_backward.h>
#include <ATen/ops/hardshrink_backward.h>
#include <ATen/ops/sinc.h>
#include <ATen/ops/sinc.h>
#include <ATen/ops/sinc.h>
#include <ATen/ops/slice.h>
#include <ATen/ops/slice_inverse.h>
#include <ATen/ops/select_scatter.h>
#include <ATen/ops/smm.h>
#include <ATen/ops/unsafe_split_with_sizes.h>
#include <ATen/ops/dstack.h>
#include <ATen/ops/dstack.h>
#include <ATen/ops/prod.h>
#include <ATen/ops/prod.h>
#include <ATen/ops/prod.h>
#include <ATen/ops/prod.h>
#include <ATen/ops/prod.h>
#include <ATen/ops/tan.h>
#include <ATen/ops/tan.h>
#include <ATen/ops/tan.h>
#include <ATen/ops/trapezoid.h>
#include <ATen/ops/trapezoid.h>
#include <ATen/ops/_nested_tensor_from_mask.h>
#include <ATen/ops/_nested_tensor_from_mask_left_aligned.h>
#include <ATen/ops/_nested_tensor_size.h>
#include <ATen/ops/_nested_view_from_buffer_copy.h>
#include <ATen/ops/unique_dim_consecutive.h>
#include <ATen/ops/_unsafe_view.h>
#include <ATen/ops/unsqueeze.h>
#include <ATen/ops/unsqueeze.h>
#include <ATen/ops/_efficientzerotensor.h>
#include <ATen/ops/poisson.h>
#include <ATen/ops/sub.h>
#include <ATen/ops/sub.h>
#include <ATen/ops/sub.h>
#include <ATen/ops/sub.h>
#include <ATen/ops/sub.h>
#include <ATen/ops/subtract.h>
#include <ATen/ops/subtract.h>
#include <ATen/ops/subtract.h>
#include <ATen/ops/subtract.h>
#include <ATen/ops/subtract.h>
#include <ATen/ops/heaviside.h>
#include <ATen/ops/heaviside.h>
#include <ATen/ops/heaviside.h>
#include <ATen/ops/_addmm_activation.h>
#include <ATen/ops/_addmm_activation.h>
#include <ATen/ops/sparse_compressed_tensor.h>
#include <ATen/ops/sparse_bsr_tensor.h>
#include <ATen/ops/sparse_compressed_tensor.h>
#include <ATen/ops/sparse_bsr_tensor.h>
#include <ATen/ops/sparse_coo_tensor.h>
#include <ATen/ops/sparse_coo_tensor.h>
#include <ATen/ops/sparse_coo_tensor.h>
#include <ATen/ops/_validate_sparse_compressed_tensor_args.h>
#include <ATen/ops/sparse_resize_and_clear.h>
#include <ATen/ops/to_dense.h>
#include <ATen/ops/sparse_dim.h>
#include <ATen/ops/_dimI.h>
#include <ATen/ops/_nnz.h>
#include <ATen/ops/ccol_indices.h>
#include <ATen/ops/to_sparse_csr.h>
#include <ATen/ops/_to_sparse_csr.h>
#include <ATen/ops/to_sparse_bsr.h>
#include <ATen/ops/_to_sparse_bsr.h>
#include <ATen/ops/mkldnn_reorder_conv3d_weight.h>
#include <ATen/ops/q_scale.h>
#include <ATen/ops/q_per_channel_axis.h>
#include <ATen/ops/_make_per_tensor_quantized_tensor.h>
#include <ATen/ops/_make_per_channel_quantized_tensor.h>
#include <ATen/ops/fake_quantize_per_tensor_affine_cachemask_backward.h>
#include <ATen/ops/fake_quantize_per_channel_affine_cachemask_backward.h>
#include <ATen/ops/_saturate_weight_to_fp16.h>
#include <ATen/ops/_autocast_to_reduced_precision.h>
#include <ATen/ops/result_type.h>
#include <ATen/ops/result_type.h>
#include <ATen/ops/result_type.h>
#include <ATen/ops/result_type.h>
#include <ATen/ops/_thnn_fused_lstm_cell_backward.h>
#include <ATen/ops/lstm_cell.h>
#include <ATen/ops/quantized_rnn_relu_cell.h>
#include <ATen/ops/masked_fill.h>
#include <ATen/ops/masked_fill.h>
#include <ATen/ops/masked_fill.h>
#include <ATen/ops/masked_fill.h>
#include <ATen/ops/masked_scatter.h>
#include <ATen/ops/masked_scatter.h>
#include <ATen/ops/_masked_softmax_backward.h>
#include <ATen/ops/index_add.h>
#include <ATen/ops/index_add.h>
#include <ATen/ops/index_add.h>
#include <ATen/ops/index_add.h>
#include <ATen/ops/bitwise_or.h>
#include <ATen/ops/bitwise_or.h>
#include <ATen/ops/bitwise_or.h>
#include <ATen/ops/bitwise_or.h>
#include <ATen/ops/bitwise_or.h>
#include <ATen/ops/bitwise_or.h>
#include <ATen/ops/bitwise_or.h>
#include <ATen/ops/diag.h>
#include <ATen/ops/diag.h>
#include <ATen/ops/triu_indices.h>
#include <ATen/ops/trace.h>
#include <ATen/ops/greater_equal.h>
#include <ATen/ops/greater_equal.h>
#include <ATen/ops/greater_equal.h>
#include <ATen/ops/greater_equal.h>
#include <ATen/ops/greater_equal.h>
#include <ATen/ops/greater_equal.h>
#include <ATen/ops/take.h>
#include <ATen/ops/take.h>
#include <ATen/ops/index_select_backward.h>
#include <ATen/ops/argwhere.h>
#include <ATen/ops/svd.h>
#include <ATen/ops/svd.h>
#include <ATen/ops/geqrf.h>
#include <ATen/ops/geqrf.h>
#include <ATen/ops/orgqr.h>
#include <ATen/ops/orgqr.h>
#include <ATen/ops/erfinv.h>
#include <ATen/ops/erfinv.h>
#include <ATen/ops/erfinv.h>
#include <ATen/ops/signbit.h>
#include <ATen/ops/signbit.h>
#include <ATen/ops/dist.h>
#include <ATen/ops/_histogramdd_from_bin_cts.h>
#include <ATen/ops/fmod.h>
#include <ATen/ops/fmod.h>
#include <ATen/ops/fmod.h>
#include <ATen/ops/fmod.h>
#include <ATen/ops/fmod.h>
#include <ATen/ops/fmod.h>
#include <ATen/ops/remainder.h>
#include <ATen/ops/remainder.h>
#include <ATen/ops/remainder.h>
#include <ATen/ops/remainder.h>
#include <ATen/ops/remainder.h>
#include <ATen/ops/remainder.h>
#include <ATen/ops/remainder.h>
#include <ATen/ops/nanquantile.h>
#include <ATen/ops/nanquantile.h>
#include <ATen/ops/nanquantile.h>
#include <ATen/ops/nanquantile.h>
#include <ATen/ops/any.h>
#include <ATen/ops/any.h>
#include <ATen/ops/renorm.h>
#include <ATen/ops/renorm.h>
#include <ATen/ops/renorm.h>
#include <ATen/ops/unfold.h>
#include <ATen/ops/float_power.h>
#include <ATen/ops/float_power.h>
#include <ATen/ops/float_power.h>
#include <ATen/ops/float_power.h>
#include <ATen/ops/float_power.h>
#include <ATen/ops/float_power.h>
#include <ATen/ops/float_power.h>
#include <ATen/ops/float_power.h>
#include <ATen/ops/_foreach_clamp_max.h>
#include <ATen/ops/_foreach_clamp_max.h>
#include <ATen/ops/_foreach_clamp_max.h>
#include <ATen/ops/_foreach_clamp_max.h>
#include <ATen/ops/_foreach_clamp_max.h>
#include <ATen/ops/_foreach_clamp_max.h>
#include <ATen/ops/_foreach_abs.h>
#include <ATen/ops/_foreach_abs.h>
#include <ATen/ops/_foreach_expm1.h>
#include <ATen/ops/_foreach_expm1.h>
#include <ATen/ops/_foreach_log10.h>
#include <ATen/ops/_foreach_log10.h>
#include <ATen/ops/_foreach_sign.h>
#include <ATen/ops/_foreach_sign.h>
#include <ATen/ops/_foreach_sinh.h>
#include <ATen/ops/_foreach_sinh.h>
#include <ATen/ops/_foreach_tan.h>
#include <ATen/ops/_foreach_tan.h>
#include <ATen/ops/_foreach_copy.h>
#include <ATen/ops/searchsorted.h>
#include <ATen/ops/searchsorted.h>
#include <ATen/ops/searchsorted.h>
#include <ATen/ops/searchsorted.h>
#include <ATen/ops/smooth_l1_loss.h>
#include <ATen/ops/smooth_l1_loss.h>
#include <ATen/ops/elu.h>
#include <ATen/ops/elu.h>
#include <ATen/ops/elu.h>
#include <ATen/ops/glu_backward.h>
#include <ATen/ops/glu_backward.h>
#include <ATen/ops/hardtanh_backward.h>
#include <ATen/ops/hardtanh_backward.h>
#include <ATen/ops/leaky_relu_backward.h>
#include <ATen/ops/leaky_relu_backward.h>
#include <ATen/ops/softplus.h>
#include <ATen/ops/softplus.h>
#include <ATen/ops/mkldnn_adaptive_avg_pool2d.h>
#include <ATen/ops/mkldnn_adaptive_avg_pool2d.h>
#include <ATen/ops/_adaptive_avg_pool2d.h>
#include <ATen/ops/avg_pool3d.h>
#include <ATen/ops/avg_pool3d.h>
#include <ATen/ops/avg_pool3d_backward.h>
#include <ATen/ops/avg_pool3d_backward.h>
#include <ATen/ops/max_pool2d_with_indices_backward.h>
#include <ATen/ops/max_pool2d_with_indices_backward.h>
#include <ATen/ops/max_pool3d_with_indices.h>
#include <ATen/ops/max_pool3d_with_indices.h>
#include <ATen/ops/reflection_pad2d.h>
#include <ATen/ops/reflection_pad2d.h>
#include <ATen/ops/_upsample_bilinear2d_aa.h>
#include <ATen/ops/upsample_linear1d_backward.h>
#include <ATen/ops/upsample_linear1d_backward.h>
#include <ATen/ops/_upsample_bilinear2d_aa.h>
#include <ATen/ops/_upsample_bilinear2d_aa.h>
#include <ATen/ops/upsample_nearest1d_backward.h>
#include <ATen/ops/upsample_nearest1d_backward.h>
#include <ATen/ops/upsample_nearest2d_backward.h>
#include <ATen/ops/upsample_nearest2d_backward.h>
#include <ATen/ops/slow_conv_transpose3d.h>
#include <ATen/ops/slow_conv_transpose3d.h>
#include <ATen/ops/slow_conv3d_forward.h>
#include <ATen/ops/slow_conv3d_forward.h>
#include <ATen/ops/im2col.h>
#include <ATen/ops/im2col.h>
#include <ATen/ops/isneginf.h>
#include <ATen/ops/isneginf.h>
#include <ATen/ops/_add_batch_dim.h>
#include <ATen/ops/special_psi.h>
#include <ATen/ops/special_psi.h>
#include <ATen/ops/special_erfcx.h>
#include <ATen/ops/special_erfcx.h>
#include <ATen/ops/special_i0e.h>
#include <ATen/ops/special_i0e.h>
#include <ATen/ops/special_i1.h>
#include <ATen/ops/special_i1.h>
#include <ATen/ops/special_logit.h>
#include <ATen/ops/special_logit.h>
#include <ATen/ops/special_log_softmax.h>
#include <ATen/ops/special_gammaincc.h>
#include <ATen/ops/special_gammaincc.h>
#include <ATen/ops/special_multigammaln.h>
#include <ATen/ops/special_multigammaln.h>
#include <ATen/ops/fft_fft2.h>
#include <ATen/ops/fft_fft2.h>
#include <ATen/ops/fft_fftn.h>
#include <ATen/ops/fft_fftn.h>
#include <ATen/ops/fft_fftshift.h>
#include <ATen/ops/linalg_lu_factor.h>
#include <ATen/ops/linalg_lu_factor.h>
#include <ATen/ops/linalg_lu_solve.h>
#include <ATen/ops/linalg_lu_solve.h>
#include <ATen/ops/linalg_det.h>
#include <ATen/ops/linalg_det.h>
#include <ATen/ops/_linalg_slogdet.h>
#include <ATen/ops/_linalg_slogdet.h>
#include <ATen/ops/linalg_inv.h>
#include <ATen/ops/linalg_inv.h>
#include <ATen/ops/outer.h>
#include <ATen/ops/outer.h>
#include <ATen/ops/ger.h>
#include <ATen/ops/ger.h>
#include <ATen/ops/_linalg_svd.h>
#include <ATen/ops/_linalg_svd.h>
#include <ATen/ops/_linalg_solve_ex.h>
#include <ATen/ops/_linalg_solve_ex.h>
#include <ATen/ops/linalg_qr.h>
#include <ATen/ops/linalg_qr.h>
#include <ATen/ops/nested_to_padded_tensor.h>
#include <ATen/ops/_test_warn_in_autograd.h>
#include <ATen/ops/_test_autograd_multiple_dispatch_view.h>
#include <ATen/ops/diagonal_copy.h>
#include <ATen/ops/permute_copy.h>
#include <ATen/ops/select_copy.h>
#include <ATen/ops/slice_copy.h>
#include <ATen/ops/split_with_sizes_copy.h>
#include <ATen/ops/t_copy.h>
#include <ATen/ops/col_indices_copy.h>
#include <ATen/ops/unbind_copy.h>
#include <ATen/ops/unbind_copy.h>
#include <ATen/ops/split_with_sizes_copy.h>
#include <ATen/ops/alias_copy.h>
#include <ATen/ops/_scaled_dot_product_attention_math.h>
#include <ATen/ops/_scaled_dot_product_flash_attention_backward.h>
#include <ATen/ops/_triton_scaled_dot_attention.h>
#include <ATen/ops/special_chebyshev_polynomial_t.h>
#include <ATen/ops/special_chebyshev_polynomial_t.h>
#include <ATen/ops/special_chebyshev_polynomial_t.h>
#include <ATen/ops/special_chebyshev_polynomial_t.h>
#include <ATen/ops/special_chebyshev_polynomial_t.h>
#include <ATen/ops/special_chebyshev_polynomial_t.h>
#include <ATen/ops/special_scaled_modified_bessel_k1.h>
#include <ATen/ops/special_scaled_modified_bessel_k1.h>
#include <ATen/ops/_foobar.h>
#include <ATen/ops/_masked_scale.h>
#include <ATen/ops/constant_pad_nd.h>
#include <ATen/ops/convolution_backward.h>
#include <ATen/ops/convolution_overrideable.h>
#include <ATen/ops/_copy_from.h>
#include <ATen/ops/cudnn_batch_norm.h>
#include <ATen/ops/_mps_convolution_transpose.h>
#include <ATen/ops/mps_convolution_transpose_backward.h>
#include <ATen/ops/embedding.h>
#include <ATen/ops/_embedding_bag_dense_backward.h>
#include <ATen/ops/resize.h>
#include <ATen/ops/resize.h>
#include <ATen/ops/floor_divide.h>
#include <ATen/ops/full.h>
#include <ATen/ops/full_like.h>
#include <ATen/ops/grid_sampler_2d.h>
#include <ATen/ops/kaiser_window.h>
#include <ATen/ops/kaiser_window.h>
#include <ATen/ops/kaiser_window.h>
#include <ATen/ops/index_put.h>
#include <ATen/ops/matmul_backward.h>
#include <ATen/ops/max_pool2d_backward.h>
#include <ATen/ops/mkldnn_max_pool2d_backward.h>
#include <ATen/ops/median.h>
#include <ATen/ops/nanmedian.h>
#include <ATen/ops/miopen_batch_norm.h>
#include <ATen/ops/miopen_convolution_transpose.h>
#include <ATen/ops/miopen_rnn_backward.h>
#include <ATen/ops/channel_shuffle.h>
#include <ATen/ops/relu.h>
#include <ATen/ops/select_scatter.h>
#include <ATen/ops/unsafe_split_with_sizes.h>
#include <ATen/ops/prod.h>
#include <ATen/ops/_nested_tensor_from_mask.h>
#include <ATen/ops/_nested_tensor_size.h>
#include <ATen/ops/_nested_view_from_buffer_copy.h>
#include <ATen/ops/unique_dim_consecutive.h>
#include <ATen/ops/_unsafe_view.h>
#include <ATen/ops/_efficientzerotensor.h>
#include <ATen/ops/poisson.h>
#include <ATen/ops/sub.h>
#include <ATen/ops/sparse_coo_tensor.h>
#include <ATen/ops/sparse_resize_and_clear.h>
#include <ATen/ops/sparse_resize_and_clear.h>
#include <ATen/ops/_to_sparse_csr.h>
#include <ATen/ops/_to_sparse_bsr.h>
#include <ATen/ops/mkldnn_reorder_conv3d_weight.h>
#include <ATen/ops/_make_per_tensor_quantized_tensor.h>
#include <ATen/ops/_make_per_channel_quantized_tensor.h>
#include <ATen/ops/masked_fill.h>
#include <ATen/ops/masked_fill.h>
#include <ATen/ops/masked_scatter.h>
#include <ATen/ops/_masked_softmax_backward.h>
#include <ATen/ops/bitwise_or.h>
#include <ATen/ops/triu_indices.h>
#include <ATen/ops/trace.h>
#include <ATen/ops/dist.h>
#include <ATen/ops/_histogramdd_from_bin_cts.h>
#include <ATen/ops/remainder.h>
#include <ATen/ops/_foreach_clamp_max.h>
#include <ATen/ops/_foreach_clamp_max.h>
#include <ATen/ops/_foreach_clamp_max.h>
#include <ATen/ops/_foreach_abs.h>
#include <ATen/ops/_foreach_expm1.h>
#include <ATen/ops/_foreach_log10.h>
#include <ATen/ops/_foreach_sign.h>
#include <ATen/ops/_foreach_sinh.h>
#include <ATen/ops/_foreach_tan.h>
#include <ATen/ops/_foreach_copy.h>
#include <ATen/ops/_foreach_copy.h>
#include <ATen/ops/_adaptive_avg_pool2d.h>
#include <ATen/ops/_test_warn_in_autograd.h>
#include <ATen/ops/diagonal_copy.h>
#include <ATen/ops/permute_copy.h>
#include <ATen/ops/select_copy.h>
#include <ATen/ops/slice_copy.h>
#include <ATen/ops/t_copy.h>
#include <ATen/ops/col_indices_copy.h>
#include <ATen/ops/alias_copy.h>
#include <ATen/ops/_triton_scaled_dot_attention.h>
#include <ATen/ops/_foobar.h>
#endif



namespace at { namespace _ops {


STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(set_data, name, "aten::set_data")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(set_data, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(set_data, schema_str, "set_data(Tensor(a!) self, Tensor new_data) -> ()")

// aten::set_data(Tensor(a!) self, Tensor new_data) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<set_data::schema> create_set_data_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(set_data::name, set_data::overload_name)
      .typed<set_data::schema>();
}

// aten::set_data(Tensor(a!) self, Tensor new_data) -> ()
void set_data::call(at::Tensor & self, const at::Tensor & new_data) {
    
    static auto op = create_set_data_typed_handle();
    return op.call(self, new_data);
}

// aten::set_data(Tensor(a!) self, Tensor new_data) -> ()
void set_data::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & new_data) {
    
    static auto op = create_set_data_typed_handle();
    return op.redispatch(dispatchKeySet, self, new_data);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fw_primal, name, "aten::_fw_primal")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fw_primal, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fw_primal, schema_str, "_fw_primal(Tensor(a) self, int level) -> Tensor(a)")

// aten::_fw_primal(Tensor(a) self, int level) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<_fw_primal::schema> create__fw_primal_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_fw_primal::name, _fw_primal::overload_name)
      .typed<_fw_primal::schema>();
}

// aten::_fw_primal(Tensor(a) self, int level) -> Tensor(a)
at::Tensor _fw_primal::call(const at::Tensor & self, int64_t level) {
    
    static auto op = create__fw_primal_typed_handle();
    return op.call(self, level);
}

// aten::_fw_primal(Tensor(a) self, int level) -> Tensor(a)
at::Tensor _fw_primal::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t level) {
    
    static auto op = create__fw_primal_typed_handle();
    return op.redispatch(dispatchKeySet, self, level);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(align_tensors, name, "aten::align_tensors")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(align_tensors, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(align_tensors, schema_str, "align_tensors(Tensor[] tensors) -> Tensor[]")

// aten::align_tensors(Tensor[] tensors) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<align_tensors::schema> create_align_tensors_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(align_tensors::name, align_tensors::overload_name)
      .typed<align_tensors::schema>();
}

// aten::align_tensors(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> align_tensors::call(at::TensorList tensors) {
    
    static auto op = create_align_tensors_typed_handle();
    return op.call(tensors);
}

// aten::align_tensors(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> align_tensors::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors) {
    
    static auto op = create_align_tensors_typed_handle();
    return op.redispatch(dispatchKeySet, tensors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_assert_async, name, "aten::_assert_async")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_assert_async, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_assert_async, schema_str, "_assert_async(Tensor self) -> ()")

// aten::_assert_async(Tensor self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_assert_async::schema> create__assert_async_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_assert_async::name, _assert_async::overload_name)
      .typed<_assert_async::schema>();
}

// aten::_assert_async(Tensor self) -> ()
void _assert_async::call(const at::Tensor & self) {
    
    static auto op = create__assert_async_typed_handle();
    return op.call(self);
}

// aten::_assert_async(Tensor self) -> ()
void _assert_async::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__assert_async_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_assert_async_msg, name, "aten::_assert_async")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_assert_async_msg, overload_name, "msg")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_assert_async_msg, schema_str, "_assert_async.msg(Tensor self, str assert_msg) -> ()")

// aten::_assert_async.msg(Tensor self, str assert_msg) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_assert_async_msg::schema> create__assert_async_msg_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_assert_async_msg::name, _assert_async_msg::overload_name)
      .typed<_assert_async_msg::schema>();
}

// aten::_assert_async.msg(Tensor self, str assert_msg) -> ()
void _assert_async_msg::call(const at::Tensor & self, c10::string_view assert_msg) {
    
    static auto op = create__assert_async_msg_typed_handle();
    return op.call(self, assert_msg);
}

// aten::_assert_async.msg(Tensor self, str assert_msg) -> ()
void _assert_async_msg::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::string_view assert_msg) {
    
    static auto op = create__assert_async_msg_typed_handle();
    return op.redispatch(dispatchKeySet, self, assert_msg);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_functional_assert_scalar, name, "aten::_functional_assert_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_functional_assert_scalar, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_functional_assert_scalar, schema_str, "_functional_assert_scalar(Scalar self, str assert_msg, Tensor dep_token) -> Tensor")

// aten::_functional_assert_scalar(Scalar self, str assert_msg, Tensor dep_token) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_functional_assert_scalar::schema> create__functional_assert_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_functional_assert_scalar::name, _functional_assert_scalar::overload_name)
      .typed<_functional_assert_scalar::schema>();
}

// aten::_functional_assert_scalar(Scalar self, str assert_msg, Tensor dep_token) -> Tensor
at::Tensor _functional_assert_scalar::call(const at::Scalar & self, c10::string_view assert_msg, const at::Tensor & dep_token) {
    
    static auto op = create__functional_assert_scalar_typed_handle();
    return op.call(self, assert_msg, dep_token);
}

// aten::_functional_assert_scalar(Scalar self, str assert_msg, Tensor dep_token) -> Tensor
at::Tensor _functional_assert_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, c10::string_view assert_msg, const at::Tensor & dep_token) {
    
    static auto op = create__functional_assert_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, assert_msg, dep_token);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_functional_assert_async_msg, name, "aten::_functional_assert_async")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_functional_assert_async_msg, overload_name, "msg")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_functional_assert_async_msg, schema_str, "_functional_assert_async.msg(Tensor self, str assert_msg, Tensor dep_token) -> Tensor")

// aten::_functional_assert_async.msg(Tensor self, str assert_msg, Tensor dep_token) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_functional_assert_async_msg::schema> create__functional_assert_async_msg_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_functional_assert_async_msg::name, _functional_assert_async_msg::overload_name)
      .typed<_functional_assert_async_msg::schema>();
}

// aten::_functional_assert_async.msg(Tensor self, str assert_msg, Tensor dep_token) -> Tensor
at::Tensor _functional_assert_async_msg::call(const at::Tensor & self, c10::string_view assert_msg, const at::Tensor & dep_token) {
    
    static auto op = create__functional_assert_async_msg_typed_handle();
    return op.call(self, assert_msg, dep_token);
}

// aten::_functional_assert_async.msg(Tensor self, str assert_msg, Tensor dep_token) -> Tensor
at::Tensor _functional_assert_async_msg::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::string_view assert_msg, const at::Tensor & dep_token) {
    
    static auto op = create__functional_assert_async_msg_typed_handle();
    return op.redispatch(dispatchKeySet, self, assert_msg, dep_token);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_scale, name, "aten::_masked_scale")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_scale, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_scale, schema_str, "_masked_scale(Tensor self, Tensor mask, float scale) -> Tensor")

// aten::_masked_scale(Tensor self, Tensor mask, float scale) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_masked_scale::schema> create__masked_scale_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_masked_scale::name, _masked_scale::overload_name)
      .typed<_masked_scale::schema>();
}

// aten::_masked_scale(Tensor self, Tensor mask, float scale) -> Tensor
at::Tensor _masked_scale::call(const at::Tensor & self, const at::Tensor & mask, double scale) {
    
    static auto op = create__masked_scale_typed_handle();
    return op.call(self, mask, scale);
}

// aten::_masked_scale(Tensor self, Tensor mask, float scale) -> Tensor
at::Tensor _masked_scale::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask, double scale) {
    
    static auto op = create__masked_scale_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, scale);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sobol_engine_draw, name, "aten::_sobol_engine_draw")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sobol_engine_draw, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sobol_engine_draw, schema_str, "_sobol_engine_draw(Tensor quasi, int n, Tensor sobolstate, int dimension, int num_generated, ScalarType? dtype) -> (Tensor, Tensor)")

// aten::_sobol_engine_draw(Tensor quasi, int n, Tensor sobolstate, int dimension, int num_generated, ScalarType? dtype) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_sobol_engine_draw::schema> create__sobol_engine_draw_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sobol_engine_draw::name, _sobol_engine_draw::overload_name)
      .typed<_sobol_engine_draw::schema>();
}

// aten::_sobol_engine_draw(Tensor quasi, int n, Tensor sobolstate, int dimension, int num_generated, ScalarType? dtype) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _sobol_engine_draw::call(const at::Tensor & quasi, int64_t n, const at::Tensor & sobolstate, int64_t dimension, int64_t num_generated, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create__sobol_engine_draw_typed_handle();
    return op.call(quasi, n, sobolstate, dimension, num_generated, dtype);
}

// aten::_sobol_engine_draw(Tensor quasi, int n, Tensor sobolstate, int dimension, int num_generated, ScalarType? dtype) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _sobol_engine_draw::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & quasi, int64_t n, const at::Tensor & sobolstate, int64_t dimension, int64_t num_generated, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create__sobol_engine_draw_typed_handle();
    return op.redispatch(dispatchKeySet, quasi, n, sobolstate, dimension, num_generated, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_reshape_from_tensor, name, "aten::_reshape_from_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_reshape_from_tensor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_reshape_from_tensor, schema_str, "_reshape_from_tensor(Tensor self, Tensor shape) -> Tensor")

// aten::_reshape_from_tensor(Tensor self, Tensor shape) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_reshape_from_tensor::schema> create__reshape_from_tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_reshape_from_tensor::name, _reshape_from_tensor::overload_name)
      .typed<_reshape_from_tensor::schema>();
}

// aten::_reshape_from_tensor(Tensor self, Tensor shape) -> Tensor
at::Tensor _reshape_from_tensor::call(const at::Tensor & self, const at::Tensor & shape) {
    
    static auto op = create__reshape_from_tensor_typed_handle();
    return op.call(self, shape);
}

// aten::_reshape_from_tensor(Tensor self, Tensor shape) -> Tensor
at::Tensor _reshape_from_tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & shape) {
    
    static auto op = create__reshape_from_tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, shape);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alpha_dropout, name, "aten::alpha_dropout")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alpha_dropout, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alpha_dropout, schema_str, "alpha_dropout(Tensor input, float p, bool train) -> Tensor")

// aten::alpha_dropout(Tensor input, float p, bool train) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<alpha_dropout::schema> create_alpha_dropout_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(alpha_dropout::name, alpha_dropout::overload_name)
      .typed<alpha_dropout::schema>();
}

// aten::alpha_dropout(Tensor input, float p, bool train) -> Tensor
at::Tensor alpha_dropout::call(const at::Tensor & input, double p, bool train) {
    
    static auto op = create_alpha_dropout_typed_handle();
    return op.call(input, p, train);
}

// aten::alpha_dropout(Tensor input, float p, bool train) -> Tensor
at::Tensor alpha_dropout::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, double p, bool train) {
    
    static auto op = create_alpha_dropout_typed_handle();
    return op.redispatch(dispatchKeySet, input, p, train);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alpha_dropout_, name, "aten::alpha_dropout_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alpha_dropout_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alpha_dropout_, schema_str, "alpha_dropout_(Tensor(a!) self, float p, bool train) -> Tensor(a!)")

// aten::alpha_dropout_(Tensor(a!) self, float p, bool train) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<alpha_dropout_::schema> create_alpha_dropout__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(alpha_dropout_::name, alpha_dropout_::overload_name)
      .typed<alpha_dropout_::schema>();
}

// aten::alpha_dropout_(Tensor(a!) self, float p, bool train) -> Tensor(a!)
at::Tensor & alpha_dropout_::call(at::Tensor & self, double p, bool train) {
    
    static auto op = create_alpha_dropout__typed_handle();
    return op.call(self, p, train);
}

// aten::alpha_dropout_(Tensor(a!) self, float p, bool train) -> Tensor(a!)
at::Tensor & alpha_dropout_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, double p, bool train) {
    
    static auto op = create_alpha_dropout__typed_handle();
    return op.redispatch(dispatchKeySet, self, p, train);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_real, name, "aten::view_as_real")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_real, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_real, schema_str, "view_as_real(Tensor(a) self) -> Tensor(a)")

// aten::view_as_real(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<view_as_real::schema> create_view_as_real_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(view_as_real::name, view_as_real::overload_name)
      .typed<view_as_real::schema>();
}

// aten::view_as_real(Tensor(a) self) -> Tensor(a)
at::Tensor view_as_real::call(const at::Tensor & self) {
    
    static auto op = create_view_as_real_typed_handle();
    return op.call(self);
}

// aten::view_as_real(Tensor(a) self) -> Tensor(a)
at::Tensor view_as_real::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_view_as_real_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_complex, name, "aten::view_as_complex")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_complex, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_complex, schema_str, "view_as_complex(Tensor(a) self) -> Tensor(a)")

// aten::view_as_complex(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<view_as_complex::schema> create_view_as_complex_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(view_as_complex::name, view_as_complex::overload_name)
      .typed<view_as_complex::schema>();
}

// aten::view_as_complex(Tensor(a) self) -> Tensor(a)
at::Tensor view_as_complex::call(const at::Tensor & self) {
    
    static auto op = create_view_as_complex_typed_handle();
    return op.call(self);
}

// aten::view_as_complex(Tensor(a) self) -> Tensor(a)
at::Tensor view_as_complex::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_view_as_complex_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(chalf, name, "aten::chalf")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(chalf, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(chalf, schema_str, "chalf(Tensor self, *, MemoryFormat? memory_format=None) -> Tensor")

// aten::chalf(Tensor self, *, MemoryFormat? memory_format=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<chalf::schema> create_chalf_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(chalf::name, chalf::overload_name)
      .typed<chalf::schema>();
}

// aten::chalf(Tensor self, *, MemoryFormat? memory_format=None) -> Tensor
at::Tensor chalf::call(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create_chalf_typed_handle();
    return op.call(self, memory_format);
}

// aten::chalf(Tensor self, *, MemoryFormat? memory_format=None) -> Tensor
at::Tensor chalf::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create_chalf_typed_handle();
    return op.redispatch(dispatchKeySet, self, memory_format);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conj_physical, name, "aten::conj_physical")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conj_physical, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conj_physical, schema_str, "conj_physical(Tensor self) -> Tensor")

// aten::conj_physical(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<conj_physical::schema> create_conj_physical_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(conj_physical::name, conj_physical::overload_name)
      .typed<conj_physical::schema>();
}

// aten::conj_physical(Tensor self) -> Tensor
at::Tensor conj_physical::call(const at::Tensor & self) {
    
    static auto op = create_conj_physical_typed_handle();
    return op.call(self);
}

// aten::conj_physical(Tensor self) -> Tensor
at::Tensor conj_physical::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_conj_physical_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conj_physical_out, name, "aten::conj_physical")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conj_physical_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conj_physical_out, schema_str, "conj_physical.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::conj_physical.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<conj_physical_out::schema> create_conj_physical_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(conj_physical_out::name, conj_physical_out::overload_name)
      .typed<conj_physical_out::schema>();
}

// aten::conj_physical.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & conj_physical_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_conj_physical_out_typed_handle();
    return op.call(self, out);
}

// aten::conj_physical.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & conj_physical_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_conj_physical_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conj_physical_, name, "aten::conj_physical_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conj_physical_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conj_physical_, schema_str, "conj_physical_(Tensor(a!) self) -> Tensor(a!)")

// aten::conj_physical_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<conj_physical_::schema> create_conj_physical__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(conj_physical_::name, conj_physical_::overload_name)
      .typed<conj_physical_::schema>();
}

// aten::conj_physical_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & conj_physical_::call(at::Tensor & self) {
    
    static auto op = create_conj_physical__typed_handle();
    return op.call(self);
}

// aten::conj_physical_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & conj_physical_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_conj_physical__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acos, name, "aten::acos")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acos, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acos, schema_str, "acos(Tensor self) -> Tensor")

// aten::acos(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<acos::schema> create_acos_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(acos::name, acos::overload_name)
      .typed<acos::schema>();
}

// aten::acos(Tensor self) -> Tensor
at::Tensor acos::call(const at::Tensor & self) {
    
    static auto op = create_acos_typed_handle();
    return op.call(self);
}

// aten::acos(Tensor self) -> Tensor
at::Tensor acos::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_acos_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acos_, name, "aten::acos_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acos_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acos_, schema_str, "acos_(Tensor(a!) self) -> Tensor(a!)")

// aten::acos_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<acos_::schema> create_acos__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(acos_::name, acos_::overload_name)
      .typed<acos_::schema>();
}

// aten::acos_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & acos_::call(at::Tensor & self) {
    
    static auto op = create_acos__typed_handle();
    return op.call(self);
}

// aten::acos_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & acos_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_acos__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acos_out, name, "aten::acos")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acos_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acos_out, schema_str, "acos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::acos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<acos_out::schema> create_acos_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(acos_out::name, acos_out::overload_name)
      .typed<acos_out::schema>();
}

// aten::acos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & acos_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_acos_out_typed_handle();
    return op.call(self, out);
}

// aten::acos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & acos_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_acos_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccos, name, "aten::arccos")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccos, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccos, schema_str, "arccos(Tensor self) -> Tensor")

// aten::arccos(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<arccos::schema> create_arccos_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arccos::name, arccos::overload_name)
      .typed<arccos::schema>();
}

// aten::arccos(Tensor self) -> Tensor
at::Tensor arccos::call(const at::Tensor & self) {
    
    static auto op = create_arccos_typed_handle();
    return op.call(self);
}

// aten::arccos(Tensor self) -> Tensor
at::Tensor arccos::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_arccos_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccos_, name, "aten::arccos_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccos_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccos_, schema_str, "arccos_(Tensor(a!) self) -> Tensor(a!)")

// aten::arccos_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<arccos_::schema> create_arccos__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arccos_::name, arccos_::overload_name)
      .typed<arccos_::schema>();
}

// aten::arccos_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & arccos_::call(at::Tensor & self) {
    
    static auto op = create_arccos__typed_handle();
    return op.call(self);
}

// aten::arccos_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & arccos_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_arccos__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccos_out, name, "aten::arccos")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccos_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccos_out, schema_str, "arccos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::arccos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<arccos_out::schema> create_arccos_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arccos_out::name, arccos_out::overload_name)
      .typed<arccos_out::schema>();
}

// aten::arccos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & arccos_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_arccos_out_typed_handle();
    return op.call(self, out);
}

// aten::arccos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & arccos_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_arccos_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dim, name, "aten::any")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dim, overload_name, "dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dim, schema_str, "any.dim(Tensor self, int dim, bool keepdim=False) -> Tensor")

// aten::any.dim(Tensor self, int dim, bool keepdim=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<any_dim::schema> create_any_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(any_dim::name, any_dim::overload_name)
      .typed<any_dim::schema>();
}

// aten::any.dim(Tensor self, int dim, bool keepdim=False) -> Tensor
at::Tensor any_dim::call(const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_any_dim_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::any.dim(Tensor self, int dim, bool keepdim=False) -> Tensor
at::Tensor any_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_any_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dims, name, "aten::any")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dims, overload_name, "dims")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dims, schema_str, "any.dims(Tensor self, int[]? dim=None, bool keepdim=False) -> Tensor")

// aten::any.dims(Tensor self, int[]? dim=None, bool keepdim=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<any_dims::schema> create_any_dims_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(any_dims::name, any_dims::overload_name)
      .typed<any_dims::schema>();
}

// aten::any.dims(Tensor self, int[]? dim=None, bool keepdim=False) -> Tensor
at::Tensor any_dims::call(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
    
    static auto op = create_any_dims_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::any.dims(Tensor self, int[]? dim=None, bool keepdim=False) -> Tensor
at::Tensor any_dims::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
    
    static auto op = create_any_dims_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_out, name, "aten::any")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_out, schema_str, "any.out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::any.out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<any_out::schema> create_any_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(any_out::name, any_out::overload_name)
      .typed<any_out::schema>();
}

// aten::any.out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & any_out::call(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_any_out_typed_handle();
    return op.call(self, dim, keepdim, out);
}

// aten::any.out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & any_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_any_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dims_out, name, "aten::any")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dims_out, overload_name, "dims_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dims_out, schema_str, "any.dims_out(Tensor self, int[]? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::any.dims_out(Tensor self, int[]? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<any_dims_out::schema> create_any_dims_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(any_dims_out::name, any_dims_out::overload_name)
      .typed<any_dims_out::schema>();
}

// aten::any.dims_out(Tensor self, int[]? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & any_dims_out::call(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_any_dims_out_typed_handle();
    return op.call(self, dim, keepdim, out);
}

// aten::any.dims_out(Tensor self, int[]? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & any_dims_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_any_dims_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dimname, name, "aten::any")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dimname, schema_str, "any.dimname(Tensor self, Dimname dim, bool keepdim=False) -> Tensor")

// aten::any.dimname(Tensor self, Dimname dim, bool keepdim=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<any_dimname::schema> create_any_dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(any_dimname::name, any_dimname::overload_name)
      .typed<any_dimname::schema>();
}

// aten::any.dimname(Tensor self, Dimname dim, bool keepdim=False) -> Tensor
at::Tensor any_dimname::call(const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_any_dimname_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::any.dimname(Tensor self, Dimname dim, bool keepdim=False) -> Tensor
at::Tensor any_dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_any_dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dimname_out, name, "aten::any")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dimname_out, overload_name, "dimname_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_dimname_out, schema_str, "any.dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::any.dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<any_dimname_out::schema> create_any_dimname_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(any_dimname_out::name, any_dimname_out::overload_name)
      .typed<any_dimname_out::schema>();
}

// aten::any.dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & any_dimname_out::call(const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_any_dimname_out_typed_handle();
    return op.call(self, dim, keepdim, out);
}

// aten::any.dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & any_dimname_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_any_dimname_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccosh, name, "aten::arccosh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccosh, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccosh, schema_str, "arccosh(Tensor self) -> Tensor")

// aten::arccosh(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<arccosh::schema> create_arccosh_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arccosh::name, arccosh::overload_name)
      .typed<arccosh::schema>();
}

// aten::arccosh(Tensor self) -> Tensor
at::Tensor arccosh::call(const at::Tensor & self) {
    
    static auto op = create_arccosh_typed_handle();
    return op.call(self);
}

// aten::arccosh(Tensor self) -> Tensor
at::Tensor arccosh::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_arccosh_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccosh_, name, "aten::arccosh_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccosh_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccosh_, schema_str, "arccosh_(Tensor(a!) self) -> Tensor(a!)")

// aten::arccosh_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<arccosh_::schema> create_arccosh__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arccosh_::name, arccosh_::overload_name)
      .typed<arccosh_::schema>();
}

// aten::arccosh_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & arccosh_::call(at::Tensor & self) {
    
    static auto op = create_arccosh__typed_handle();
    return op.call(self);
}

// aten::arccosh_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & arccosh_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_arccosh__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccosh_out, name, "aten::arccosh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccosh_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arccosh_out, schema_str, "arccosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::arccosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<arccosh_out::schema> create_arccosh_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arccosh_out::name, arccosh_out::overload_name)
      .typed<arccosh_out::schema>();
}

// aten::arccosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & arccosh_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_arccosh_out_typed_handle();
    return op.call(self, out);
}

// aten::arccosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & arccosh_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_arccosh_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(asin, name, "aten::asin")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(asin, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(asin, schema_str, "asin(Tensor self) -> Tensor")

// aten::asin(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<asin::schema> create_asin_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(asin::name, asin::overload_name)
      .typed<asin::schema>();
}

// aten::asin(Tensor self) -> Tensor
at::Tensor asin::call(const at::Tensor & self) {
    
    static auto op = create_asin_typed_handle();
    return op.call(self);
}

// aten::asin(Tensor self) -> Tensor
at::Tensor asin::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_asin_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(asin_, name, "aten::asin_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(asin_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(asin_, schema_str, "asin_(Tensor(a!) self) -> Tensor(a!)")

// aten::asin_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<asin_::schema> create_asin__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(asin_::name, asin_::overload_name)
      .typed<asin_::schema>();
}

// aten::asin_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & asin_::call(at::Tensor & self) {
    
    static auto op = create_asin__typed_handle();
    return op.call(self);
}

// aten::asin_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & asin_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_asin__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(asin_out, name, "aten::asin")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(asin_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(asin_out, schema_str, "asin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::asin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<asin_out::schema> create_asin_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(asin_out::name, asin_out::overload_name)
      .typed<asin_out::schema>();
}

// aten::asin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & asin_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_asin_out_typed_handle();
    return op.call(self, out);
}

// aten::asin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & asin_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_asin_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_1d, name, "aten::atleast_1d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_1d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_1d, schema_str, "atleast_1d(Tensor self) -> Tensor")

// aten::atleast_1d(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<atleast_1d::schema> create_atleast_1d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(atleast_1d::name, atleast_1d::overload_name)
      .typed<atleast_1d::schema>();
}

// aten::atleast_1d(Tensor self) -> Tensor
at::Tensor atleast_1d::call(const at::Tensor & self) {
    
    static auto op = create_atleast_1d_typed_handle();
    return op.call(self);
}

// aten::atleast_1d(Tensor self) -> Tensor
at::Tensor atleast_1d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_atleast_1d_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_1d_Sequence, name, "aten::atleast_1d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_1d_Sequence, overload_name, "Sequence")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_1d_Sequence, schema_str, "atleast_1d.Sequence(Tensor[] tensors) -> Tensor[]")

// aten::atleast_1d.Sequence(Tensor[] tensors) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<atleast_1d_Sequence::schema> create_atleast_1d_Sequence_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(atleast_1d_Sequence::name, atleast_1d_Sequence::overload_name)
      .typed<atleast_1d_Sequence::schema>();
}

// aten::atleast_1d.Sequence(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> atleast_1d_Sequence::call(at::TensorList tensors) {
    
    static auto op = create_atleast_1d_Sequence_typed_handle();
    return op.call(tensors);
}

// aten::atleast_1d.Sequence(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> atleast_1d_Sequence::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors) {
    
    static auto op = create_atleast_1d_Sequence_typed_handle();
    return op.redispatch(dispatchKeySet, tensors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_out, name, "aten::copysign")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_out, schema_str, "copysign.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::copysign.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<copysign_out::schema> create_copysign_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(copysign_out::name, copysign_out::overload_name)
      .typed<copysign_out::schema>();
}

// aten::copysign.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & copysign_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_copysign_out_typed_handle();
    return op.call(self, other, out);
}

// aten::copysign.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & copysign_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_copysign_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_Tensor, name, "aten::copysign")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_Tensor, schema_str, "copysign.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::copysign.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<copysign_Tensor::schema> create_copysign_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(copysign_Tensor::name, copysign_Tensor::overload_name)
      .typed<copysign_Tensor::schema>();
}

// aten::copysign.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor copysign_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_copysign_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::copysign.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor copysign_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_copysign_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign__Tensor, name, "aten::copysign_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign__Tensor, schema_str, "copysign_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::copysign_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<copysign__Tensor::schema> create_copysign__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(copysign__Tensor::name, copysign__Tensor::overload_name)
      .typed<copysign__Tensor::schema>();
}

// aten::copysign_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & copysign__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_copysign__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::copysign_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & copysign__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_copysign__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_Scalar, name, "aten::copysign")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_Scalar, schema_str, "copysign.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::copysign.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<copysign_Scalar::schema> create_copysign_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(copysign_Scalar::name, copysign_Scalar::overload_name)
      .typed<copysign_Scalar::schema>();
}

// aten::copysign.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor copysign_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_copysign_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::copysign.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor copysign_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_copysign_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign__Scalar, name, "aten::copysign_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign__Scalar, schema_str, "copysign_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::copysign_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<copysign__Scalar::schema> create_copysign__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(copysign__Scalar::name, copysign__Scalar::overload_name)
      .typed<copysign__Scalar::schema>();
}

// aten::copysign_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & copysign__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_copysign__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::copysign_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & copysign__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_copysign__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_Scalar_out, name, "aten::copysign")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copysign_Scalar_out, schema_str, "copysign.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::copysign.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<copysign_Scalar_out::schema> create_copysign_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(copysign_Scalar_out::name, copysign_Scalar_out::overload_name)
      .typed<copysign_Scalar_out::schema>();
}

// aten::copysign.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & copysign_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_copysign_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::copysign.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & copysign_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_copysign_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_xor, name, "aten::logical_xor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_xor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_xor, schema_str, "logical_xor(Tensor self, Tensor other) -> Tensor")

// aten::logical_xor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<logical_xor::schema> create_logical_xor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logical_xor::name, logical_xor::overload_name)
      .typed<logical_xor::schema>();
}

// aten::logical_xor(Tensor self, Tensor other) -> Tensor
at::Tensor logical_xor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logical_xor_typed_handle();
    return op.call(self, other);
}

// aten::logical_xor(Tensor self, Tensor other) -> Tensor
at::Tensor logical_xor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logical_xor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_xor_, name, "aten::logical_xor_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_xor_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_xor_, schema_str, "logical_xor_(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::logical_xor_(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<logical_xor_::schema> create_logical_xor__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logical_xor_::name, logical_xor_::overload_name)
      .typed<logical_xor_::schema>();
}

// aten::logical_xor_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & logical_xor_::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logical_xor__typed_handle();
    return op.call(self, other);
}

// aten::logical_xor_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & logical_xor_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logical_xor__typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_xor_out, name, "aten::logical_xor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_xor_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_xor_out, schema_str, "logical_xor.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::logical_xor.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<logical_xor_out::schema> create_logical_xor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logical_xor_out::name, logical_xor_out::overload_name)
      .typed<logical_xor_out::schema>();
}

// aten::logical_xor.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logical_xor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_logical_xor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::logical_xor.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logical_xor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_logical_xor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(broadcast_to, name, "aten::broadcast_to")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(broadcast_to, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(broadcast_to, schema_str, "broadcast_to(Tensor(a) self, SymInt[] size) -> Tensor(a)")

// aten::broadcast_to(Tensor(a) self, SymInt[] size) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<broadcast_to::schema> create_broadcast_to_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(broadcast_to::name, broadcast_to::overload_name)
      .typed<broadcast_to::schema>();
}

// aten::broadcast_to(Tensor(a) self, SymInt[] size) -> Tensor(a)
at::Tensor broadcast_to::call(const at::Tensor & self, c10::SymIntArrayRef size) {
    
    static auto op = create_broadcast_to_typed_handle();
    return op.call(self, size);
}

// aten::broadcast_to(Tensor(a) self, SymInt[] size) -> Tensor(a)
at::Tensor broadcast_to::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size) {
    
    static auto op = create_broadcast_to_typed_handle();
    return op.redispatch(dispatchKeySet, self, size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(constant_pad_nd, name, "aten::constant_pad_nd")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(constant_pad_nd, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(constant_pad_nd, schema_str, "constant_pad_nd(Tensor self, SymInt[] pad, Scalar value=0) -> Tensor")

// aten::constant_pad_nd(Tensor self, SymInt[] pad, Scalar value=0) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<constant_pad_nd::schema> create_constant_pad_nd_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(constant_pad_nd::name, constant_pad_nd::overload_name)
      .typed<constant_pad_nd::schema>();
}

// aten::constant_pad_nd(Tensor self, SymInt[] pad, Scalar value=0) -> Tensor
at::Tensor constant_pad_nd::call(const at::Tensor & self, c10::SymIntArrayRef pad, const at::Scalar & value) {
    
    static auto op = create_constant_pad_nd_typed_handle();
    return op.call(self, pad, value);
}

// aten::constant_pad_nd(Tensor self, SymInt[] pad, Scalar value=0) -> Tensor
at::Tensor constant_pad_nd::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef pad, const at::Scalar & value) {
    
    static auto op = create_constant_pad_nd_typed_handle();
    return op.redispatch(dispatchKeySet, self, pad, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(contiguous, name, "aten::contiguous")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(contiguous, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(contiguous, schema_str, "contiguous(Tensor(a) self, *, MemoryFormat memory_format=contiguous_format) -> Tensor(a)")

// aten::contiguous(Tensor(a) self, *, MemoryFormat memory_format=contiguous_format) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<contiguous::schema> create_contiguous_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(contiguous::name, contiguous::overload_name)
      .typed<contiguous::schema>();
}

// aten::contiguous(Tensor(a) self, *, MemoryFormat memory_format=contiguous_format) -> Tensor(a)
at::Tensor contiguous::call(const at::Tensor & self, at::MemoryFormat memory_format) {
    
    static auto op = create_contiguous_typed_handle();
    return op.call(self, memory_format);
}

// aten::contiguous(Tensor(a) self, *, MemoryFormat memory_format=contiguous_format) -> Tensor(a)
at::Tensor contiguous::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::MemoryFormat memory_format) {
    
    static auto op = create_contiguous_typed_handle();
    return op.redispatch(dispatchKeySet, self, memory_format);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward, name, "aten::convolution_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward, schema_str, "convolution_backward(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor, Tensor, Tensor)")

// aten::convolution_backward(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<convolution_backward::schema> create_convolution_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(convolution_backward::name, convolution_backward::overload_name)
      .typed<convolution_backward::schema>();
}

// aten::convolution_backward(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> convolution_backward::call(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalSymIntArrayRef bias_sizes, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask) {
    
    static auto op = create_convolution_backward_typed_handle();
    return op.call(grad_output, input, weight, bias_sizes, stride, padding, dilation, transposed, output_padding, groups, output_mask);
}

// aten::convolution_backward(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> convolution_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalSymIntArrayRef bias_sizes, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask) {
    
    static auto op = create_convolution_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, input, weight, bias_sizes, stride, padding, dilation, transposed, output_padding, groups, output_mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_overrideable, name, "aten::convolution_overrideable")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_overrideable, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_overrideable, schema_str, "convolution_overrideable(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups) -> Tensor")

// aten::convolution_overrideable(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<convolution_overrideable::schema> create_convolution_overrideable_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(convolution_overrideable::name, convolution_overrideable::overload_name)
      .typed<convolution_overrideable::schema>();
}

// aten::convolution_overrideable(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups) -> Tensor
at::Tensor convolution_overrideable::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups) {
    
    static auto op = create_convolution_overrideable_typed_handle();
    return op.call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups);
}

// aten::convolution_overrideable(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups) -> Tensor
at::Tensor convolution_overrideable::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups) {
    
    static auto op = create_convolution_overrideable_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution_double_backward, name, "aten::_convolution_double_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution_double_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution_double_backward, schema_str, "_convolution_double_backward(Tensor? ggI, Tensor? ggW, Tensor? ggb, Tensor gO, Tensor weight, Tensor self, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor, Tensor, Tensor)")

// aten::_convolution_double_backward(Tensor? ggI, Tensor? ggW, Tensor? ggb, Tensor gO, Tensor weight, Tensor self, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_convolution_double_backward::schema> create__convolution_double_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_convolution_double_backward::name, _convolution_double_backward::overload_name)
      .typed<_convolution_double_backward::schema>();
}

// aten::_convolution_double_backward(Tensor? ggI, Tensor? ggW, Tensor? ggb, Tensor gO, Tensor weight, Tensor self, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _convolution_double_backward::call(const c10::optional<at::Tensor> & ggI, const c10::optional<at::Tensor> & ggW, const c10::optional<at::Tensor> & ggb, const at::Tensor & gO, const at::Tensor & weight, const at::Tensor & self, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask) {
    
    static auto op = create__convolution_double_backward_typed_handle();
    return op.call(ggI, ggW, ggb, gO, weight, self, stride, padding, dilation, transposed, output_padding, groups, output_mask);
}

// aten::_convolution_double_backward(Tensor? ggI, Tensor? ggW, Tensor? ggb, Tensor gO, Tensor weight, Tensor self, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _convolution_double_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const c10::optional<at::Tensor> & ggI, const c10::optional<at::Tensor> & ggW, const c10::optional<at::Tensor> & ggb, const at::Tensor & gO, const at::Tensor & weight, const at::Tensor & self, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask) {
    
    static auto op = create__convolution_double_backward_typed_handle();
    return op.redispatch(dispatchKeySet, ggI, ggW, ggb, gO, weight, self, stride, padding, dilation, transposed, output_padding, groups, output_mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conv2d, name, "aten::conv2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conv2d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conv2d, schema_str, "conv2d(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0, SymInt[2] dilation=1, SymInt groups=1) -> Tensor")

// aten::conv2d(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0, SymInt[2] dilation=1, SymInt groups=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<conv2d::schema> create_conv2d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(conv2d::name, conv2d::overload_name)
      .typed<conv2d::schema>();
}

// aten::conv2d(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0, SymInt[2] dilation=1, SymInt groups=1) -> Tensor
at::Tensor conv2d::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_conv2d_typed_handle();
    return op.call(input, weight, bias, stride, padding, dilation, groups);
}

// aten::conv2d(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0, SymInt[2] dilation=1, SymInt groups=1) -> Tensor
at::Tensor conv2d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_conv2d_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, dilation, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conv2d_padding, name, "aten::conv2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conv2d_padding, overload_name, "padding")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conv2d_padding, schema_str, "conv2d.padding(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=1, str padding=\"valid\", SymInt[2] dilation=1, SymInt groups=1) -> Tensor")

// aten::conv2d.padding(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=1, str padding="valid", SymInt[2] dilation=1, SymInt groups=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<conv2d_padding::schema> create_conv2d_padding_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(conv2d_padding::name, conv2d_padding::overload_name)
      .typed<conv2d_padding::schema>();
}

// aten::conv2d.padding(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=1, str padding="valid", SymInt[2] dilation=1, SymInt groups=1) -> Tensor
at::Tensor conv2d_padding::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::string_view padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_conv2d_padding_typed_handle();
    return op.call(input, weight, bias, stride, padding, dilation, groups);
}

// aten::conv2d.padding(Tensor input, Tensor weight, Tensor? bias=None, SymInt[2] stride=1, str padding="valid", SymInt[2] dilation=1, SymInt groups=1) -> Tensor
at::Tensor conv2d_padding::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::string_view padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_conv2d_padding_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, dilation, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_copy_from, name, "aten::_copy_from")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_copy_from, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_copy_from, schema_str, "_copy_from(Tensor self, Tensor dst, bool non_blocking=False) -> Tensor")

// aten::_copy_from(Tensor self, Tensor dst, bool non_blocking=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_copy_from::schema> create__copy_from_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_copy_from::name, _copy_from::overload_name)
      .typed<_copy_from::schema>();
}

// aten::_copy_from(Tensor self, Tensor dst, bool non_blocking=False) -> Tensor
at::Tensor _copy_from::call(const at::Tensor & self, const at::Tensor & dst, bool non_blocking) {
    
    static auto op = create__copy_from_typed_handle();
    return op.call(self, dst, non_blocking);
}

// aten::_copy_from(Tensor self, Tensor dst, bool non_blocking=False) -> Tensor
at::Tensor _copy_from::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & dst, bool non_blocking) {
    
    static auto op = create__copy_from_typed_handle();
    return op.redispatch(dispatchKeySet, self, dst, non_blocking);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(corrcoef, name, "aten::corrcoef")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(corrcoef, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(corrcoef, schema_str, "corrcoef(Tensor self) -> Tensor")

// aten::corrcoef(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<corrcoef::schema> create_corrcoef_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(corrcoef::name, corrcoef::overload_name)
      .typed<corrcoef::schema>();
}

// aten::corrcoef(Tensor self) -> Tensor
at::Tensor corrcoef::call(const at::Tensor & self) {
    
    static auto op = create_corrcoef_typed_handle();
    return op.call(self);
}

// aten::corrcoef(Tensor self) -> Tensor
at::Tensor corrcoef::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_corrcoef_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm, name, "aten::cudnn_batch_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm, schema_str, "cudnn_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor, Tensor)")

// aten::cudnn_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_batch_norm::schema> create_cudnn_batch_norm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_batch_norm::name, cudnn_batch_norm::overload_name)
      .typed<cudnn_batch_norm::schema>();
}

// aten::cudnn_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> cudnn_batch_norm::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon) {
    
    static auto op = create_cudnn_batch_norm_typed_handle();
    return op.call(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
}

// aten::cudnn_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> cudnn_batch_norm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon) {
    
    static auto op = create_cudnn_batch_norm_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_mps_convolution_transpose, name, "aten::_mps_convolution_transpose")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_mps_convolution_transpose, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_mps_convolution_transpose, schema_str, "_mps_convolution_transpose(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups) -> Tensor")

// aten::_mps_convolution_transpose(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_mps_convolution_transpose::schema> create__mps_convolution_transpose_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_mps_convolution_transpose::name, _mps_convolution_transpose::overload_name)
      .typed<_mps_convolution_transpose::schema>();
}

// aten::_mps_convolution_transpose(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups) -> Tensor
at::Tensor _mps_convolution_transpose::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create__mps_convolution_transpose_typed_handle();
    return op.call(self, weight, padding, output_padding, stride, dilation, groups);
}

// aten::_mps_convolution_transpose(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups) -> Tensor
at::Tensor _mps_convolution_transpose::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create__mps_convolution_transpose_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, padding, output_padding, stride, dilation, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mps_convolution_transpose_backward, name, "aten::mps_convolution_transpose_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mps_convolution_transpose_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mps_convolution_transpose_backward, schema_str, "mps_convolution_transpose_backward(Tensor self, Tensor grad_output, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool[2] output_mask) -> (Tensor, Tensor)")

// aten::mps_convolution_transpose_backward(Tensor self, Tensor grad_output, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool[2] output_mask) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<mps_convolution_transpose_backward::schema> create_mps_convolution_transpose_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mps_convolution_transpose_backward::name, mps_convolution_transpose_backward::overload_name)
      .typed<mps_convolution_transpose_backward::schema>();
}

// aten::mps_convolution_transpose_backward(Tensor self, Tensor grad_output, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool[2] output_mask) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> mps_convolution_transpose_backward::call(const at::Tensor & self, const at::Tensor & grad_output, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, ::std::array<bool,2> output_mask) {
    
    static auto op = create_mps_convolution_transpose_backward_typed_handle();
    return op.call(self, grad_output, weight, padding, output_padding, stride, dilation, groups, output_mask);
}

// aten::mps_convolution_transpose_backward(Tensor self, Tensor grad_output, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool[2] output_mask) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> mps_convolution_transpose_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & grad_output, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, ::std::array<bool,2> output_mask) {
    
    static auto op = create_mps_convolution_transpose_backward_typed_handle();
    return op.redispatch(dispatchKeySet, self, grad_output, weight, padding, output_padding, stride, dilation, groups, output_mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cummaxmin_backward, name, "aten::cummaxmin_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cummaxmin_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cummaxmin_backward, schema_str, "cummaxmin_backward(Tensor grad, Tensor input, Tensor indices, int dim) -> Tensor")

// aten::cummaxmin_backward(Tensor grad, Tensor input, Tensor indices, int dim) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cummaxmin_backward::schema> create_cummaxmin_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cummaxmin_backward::name, cummaxmin_backward::overload_name)
      .typed<cummaxmin_backward::schema>();
}

// aten::cummaxmin_backward(Tensor grad, Tensor input, Tensor indices, int dim) -> Tensor
at::Tensor cummaxmin_backward::call(const at::Tensor & grad, const at::Tensor & input, const at::Tensor & indices, int64_t dim) {
    
    static auto op = create_cummaxmin_backward_typed_handle();
    return op.call(grad, input, indices, dim);
}

// aten::cummaxmin_backward(Tensor grad, Tensor input, Tensor indices, int dim) -> Tensor
at::Tensor cummaxmin_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & input, const at::Tensor & indices, int64_t dim) {
    
    static auto op = create_cummaxmin_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, input, indices, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumprod_backward, name, "aten::cumprod_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumprod_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumprod_backward, schema_str, "cumprod_backward(Tensor grad, Tensor input, int dim, Tensor output) -> Tensor")

// aten::cumprod_backward(Tensor grad, Tensor input, int dim, Tensor output) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cumprod_backward::schema> create_cumprod_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cumprod_backward::name, cumprod_backward::overload_name)
      .typed<cumprod_backward::schema>();
}

// aten::cumprod_backward(Tensor grad, Tensor input, int dim, Tensor output) -> Tensor
at::Tensor cumprod_backward::call(const at::Tensor & grad, const at::Tensor & input, int64_t dim, const at::Tensor & output) {
    
    static auto op = create_cumprod_backward_typed_handle();
    return op.call(grad, input, dim, output);
}

// aten::cumprod_backward(Tensor grad, Tensor input, int dim, Tensor output) -> Tensor
at::Tensor cumprod_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & input, int64_t dim, const at::Tensor & output) {
    
    static auto op = create_cumprod_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, input, dim, output);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_diagonal_, name, "aten::fill_diagonal_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_diagonal_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_diagonal_, schema_str, "fill_diagonal_(Tensor(a!) self, Scalar fill_value, bool wrap=False) -> Tensor(a!)")

// aten::fill_diagonal_(Tensor(a!) self, Scalar fill_value, bool wrap=False) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fill_diagonal_::schema> create_fill_diagonal__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fill_diagonal_::name, fill_diagonal_::overload_name)
      .typed<fill_diagonal_::schema>();
}

// aten::fill_diagonal_(Tensor(a!) self, Scalar fill_value, bool wrap=False) -> Tensor(a!)
at::Tensor & fill_diagonal_::call(at::Tensor & self, const at::Scalar & fill_value, bool wrap) {
    
    static auto op = create_fill_diagonal__typed_handle();
    return op.call(self, fill_value, wrap);
}

// aten::fill_diagonal_(Tensor(a!) self, Scalar fill_value, bool wrap=False) -> Tensor(a!)
at::Tensor & fill_diagonal_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & fill_value, bool wrap) {
    
    static auto op = create_fill_diagonal__typed_handle();
    return op.redispatch(dispatchKeySet, self, fill_value, wrap);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding, name, "aten::embedding")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding, schema_str, "embedding(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False) -> Tensor")

// aten::embedding(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<embedding::schema> create_embedding_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(embedding::name, embedding::overload_name)
      .typed<embedding::schema>();
}

// aten::embedding(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False) -> Tensor
at::Tensor embedding::call(const at::Tensor & weight, const at::Tensor & indices, c10::SymInt padding_idx, bool scale_grad_by_freq, bool sparse) {
    
    static auto op = create_embedding_typed_handle();
    return op.call(weight, indices, padding_idx, scale_grad_by_freq, sparse);
}

// aten::embedding(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False) -> Tensor
at::Tensor embedding::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & weight, const at::Tensor & indices, c10::SymInt padding_idx, bool scale_grad_by_freq, bool sparse) {
    
    static auto op = create_embedding_typed_handle();
    return op.redispatch(dispatchKeySet, weight, indices, padding_idx, scale_grad_by_freq, sparse);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_rowwise_prune, name, "aten::_rowwise_prune")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_rowwise_prune, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_rowwise_prune, schema_str, "_rowwise_prune(Tensor weight, Tensor mask, ScalarType compressed_indices_dtype) -> (Tensor, Tensor)")

// aten::_rowwise_prune(Tensor weight, Tensor mask, ScalarType compressed_indices_dtype) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_rowwise_prune::schema> create__rowwise_prune_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_rowwise_prune::name, _rowwise_prune::overload_name)
      .typed<_rowwise_prune::schema>();
}

// aten::_rowwise_prune(Tensor weight, Tensor mask, ScalarType compressed_indices_dtype) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _rowwise_prune::call(const at::Tensor & weight, const at::Tensor & mask, at::ScalarType compressed_indices_dtype) {
    
    static auto op = create__rowwise_prune_typed_handle();
    return op.call(weight, mask, compressed_indices_dtype);
}

// aten::_rowwise_prune(Tensor weight, Tensor mask, ScalarType compressed_indices_dtype) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _rowwise_prune::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & weight, const at::Tensor & mask, at::ScalarType compressed_indices_dtype) {
    
    static auto op = create__rowwise_prune_typed_handle();
    return op.redispatch(dispatchKeySet, weight, mask, compressed_indices_dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(row_stack, name, "aten::row_stack")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(row_stack, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(row_stack, schema_str, "row_stack(Tensor[] tensors) -> Tensor")

// aten::row_stack(Tensor[] tensors) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<row_stack::schema> create_row_stack_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(row_stack::name, row_stack::overload_name)
      .typed<row_stack::schema>();
}

// aten::row_stack(Tensor[] tensors) -> Tensor
at::Tensor row_stack::call(at::TensorList tensors) {
    
    static auto op = create_row_stack_typed_handle();
    return op.call(tensors);
}

// aten::row_stack(Tensor[] tensors) -> Tensor
at::Tensor row_stack::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors) {
    
    static auto op = create_row_stack_typed_handle();
    return op.redispatch(dispatchKeySet, tensors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(row_stack_out, name, "aten::row_stack")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(row_stack_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(row_stack_out, schema_str, "row_stack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)")

// aten::row_stack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<row_stack_out::schema> create_row_stack_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(row_stack_out::name, row_stack_out::overload_name)
      .typed<row_stack_out::schema>();
}

// aten::row_stack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & row_stack_out::call(at::TensorList tensors, at::Tensor & out) {
    
    static auto op = create_row_stack_out_typed_handle();
    return op.call(tensors, out);
}

// aten::row_stack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & row_stack_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors, at::Tensor & out) {
    
    static auto op = create_row_stack_out_typed_handle();
    return op.redispatch(dispatchKeySet, tensors, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_backward, name, "aten::_embedding_bag_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_backward, schema_str, "_embedding_bag_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, bool sparse, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor")

// aten::_embedding_bag_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, bool sparse, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_embedding_bag_backward::schema> create__embedding_bag_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_embedding_bag_backward::name, _embedding_bag_backward::overload_name)
      .typed<_embedding_bag_backward::schema>();
}

// aten::_embedding_bag_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, bool sparse, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor
at::Tensor _embedding_bag_backward::call(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offsets, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
    
    static auto op = create__embedding_bag_backward_typed_handle();
    return op.call(grad, indices, offsets, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, sparse, per_sample_weights, padding_idx);
}

// aten::_embedding_bag_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, bool sparse, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor
at::Tensor _embedding_bag_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offsets, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
    
    static auto op = create__embedding_bag_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, indices, offsets, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, sparse, per_sample_weights, padding_idx);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_dense_backward, name, "aten::_embedding_bag_dense_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_dense_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_dense_backward, schema_str, "_embedding_bag_dense_backward(Tensor grad, Tensor indices, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor")

// aten::_embedding_bag_dense_backward(Tensor grad, Tensor indices, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_embedding_bag_dense_backward::schema> create__embedding_bag_dense_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_embedding_bag_dense_backward::name, _embedding_bag_dense_backward::overload_name)
      .typed<_embedding_bag_dense_backward::schema>();
}

// aten::_embedding_bag_dense_backward(Tensor grad, Tensor indices, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor
at::Tensor _embedding_bag_dense_backward::call(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
    
    static auto op = create__embedding_bag_dense_backward_typed_handle();
    return op.call(grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}

// aten::_embedding_bag_dense_backward(Tensor grad, Tensor indices, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor
at::Tensor _embedding_bag_dense_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
    
    static auto op = create__embedding_bag_dense_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(resize_, name, "aten::resize_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(resize_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(resize_, schema_str, "resize_(Tensor(a!) self, SymInt[] size, *, MemoryFormat? memory_format=None) -> Tensor(a!)")

// aten::resize_(Tensor(a!) self, SymInt[] size, *, MemoryFormat? memory_format=None) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<resize_::schema> create_resize__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(resize_::name, resize_::overload_name)
      .typed<resize_::schema>();
}

// aten::resize_(Tensor(a!) self, SymInt[] size, *, MemoryFormat? memory_format=None) -> Tensor(a!)
const at::Tensor & resize_::call(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create_resize__typed_handle();
    return op.call(self, size, memory_format);
}

// aten::resize_(Tensor(a!) self, SymInt[] size, *, MemoryFormat? memory_format=None) -> Tensor(a!)
const at::Tensor & resize_::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create_resize__typed_handle();
    return op.redispatch(dispatchKeySet, self, size, memory_format);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfc, name, "aten::erfc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfc, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfc, schema_str, "erfc(Tensor self) -> Tensor")

// aten::erfc(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<erfc::schema> create_erfc_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(erfc::name, erfc::overload_name)
      .typed<erfc::schema>();
}

// aten::erfc(Tensor self) -> Tensor
at::Tensor erfc::call(const at::Tensor & self) {
    
    static auto op = create_erfc_typed_handle();
    return op.call(self);
}

// aten::erfc(Tensor self) -> Tensor
at::Tensor erfc::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_erfc_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfc_, name, "aten::erfc_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfc_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfc_, schema_str, "erfc_(Tensor(a!) self) -> Tensor(a!)")

// aten::erfc_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<erfc_::schema> create_erfc__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(erfc_::name, erfc_::overload_name)
      .typed<erfc_::schema>();
}

// aten::erfc_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & erfc_::call(at::Tensor & self) {
    
    static auto op = create_erfc__typed_handle();
    return op.call(self);
}

// aten::erfc_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & erfc_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_erfc__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfc_out, name, "aten::erfc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfc_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfc_out, schema_str, "erfc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::erfc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<erfc_out::schema> create_erfc_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(erfc_out::name, erfc_out::overload_name)
      .typed<erfc_out::schema>();
}

// aten::erfc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & erfc_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_erfc_out_typed_handle();
    return op.call(self, out);
}

// aten::erfc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & erfc_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_erfc_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide, name, "aten::floor_divide")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide, schema_str, "floor_divide(Tensor self, Tensor other) -> Tensor")

// aten::floor_divide(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<floor_divide::schema> create_floor_divide_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(floor_divide::name, floor_divide::overload_name)
      .typed<floor_divide::schema>();
}

// aten::floor_divide(Tensor self, Tensor other) -> Tensor
at::Tensor floor_divide::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_floor_divide_typed_handle();
    return op.call(self, other);
}

// aten::floor_divide(Tensor self, Tensor other) -> Tensor
at::Tensor floor_divide::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_floor_divide_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide__Tensor, name, "aten::floor_divide_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide__Tensor, schema_str, "floor_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::floor_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<floor_divide__Tensor::schema> create_floor_divide__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(floor_divide__Tensor::name, floor_divide__Tensor::overload_name)
      .typed<floor_divide__Tensor::schema>();
}

// aten::floor_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & floor_divide__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_floor_divide__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::floor_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & floor_divide__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_floor_divide__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide_out, name, "aten::floor_divide")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide_out, schema_str, "floor_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::floor_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<floor_divide_out::schema> create_floor_divide_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(floor_divide_out::name, floor_divide_out::overload_name)
      .typed<floor_divide_out::schema>();
}

// aten::floor_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & floor_divide_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_floor_divide_out_typed_handle();
    return op.call(self, other, out);
}

// aten::floor_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & floor_divide_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_floor_divide_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide_Scalar, name, "aten::floor_divide")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide_Scalar, schema_str, "floor_divide.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::floor_divide.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<floor_divide_Scalar::schema> create_floor_divide_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(floor_divide_Scalar::name, floor_divide_Scalar::overload_name)
      .typed<floor_divide_Scalar::schema>();
}

// aten::floor_divide.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor floor_divide_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_floor_divide_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::floor_divide.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor floor_divide_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_floor_divide_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide__Scalar, name, "aten::floor_divide_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide__Scalar, schema_str, "floor_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::floor_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<floor_divide__Scalar::schema> create_floor_divide__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(floor_divide__Scalar::name, floor_divide__Scalar::overload_name)
      .typed<floor_divide__Scalar::schema>();
}

// aten::floor_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & floor_divide__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_floor_divide__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::floor_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & floor_divide__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_floor_divide__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_names, name, "aten::full")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_names, overload_name, "names")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_names, schema_str, "full.names(int[] size, Scalar fill_value, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::full.names(int[] size, Scalar fill_value, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<full_names::schema> create_full_names_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(full_names::name, full_names::overload_name)
      .typed<full_names::schema>();
}

// aten::full.names(int[] size, Scalar fill_value, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor full_names::call(at::IntArrayRef size, const at::Scalar & fill_value, c10::optional<at::DimnameList> names, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_full_names_typed_handle();
    return op.call(size, fill_value, names, dtype, layout, device, pin_memory);
}

// aten::full.names(int[] size, Scalar fill_value, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor full_names::redispatch(c10::DispatchKeySet dispatchKeySet, at::IntArrayRef size, const at::Scalar & fill_value, c10::optional<at::DimnameList> names, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_full_names_typed_handle();
    return op.redispatch(dispatchKeySet, size, fill_value, names, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full, name, "aten::full")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full, schema_str, "full(SymInt[] size, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::full(SymInt[] size, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<full::schema> create_full_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(full::name, full::overload_name)
      .typed<full::schema>();
}

// aten::full(SymInt[] size, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor full::call(c10::SymIntArrayRef size, const at::Scalar & fill_value, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_full_typed_handle();
    return op.call(size, fill_value, dtype, layout, device, pin_memory);
}

// aten::full(SymInt[] size, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor full::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, const at::Scalar & fill_value, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_full_typed_handle();
    return op.redispatch(dispatchKeySet, size, fill_value, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_out, name, "aten::full")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_out, schema_str, "full.out(SymInt[] size, Scalar fill_value, *, Tensor(a!) out) -> Tensor(a!)")

// aten::full.out(SymInt[] size, Scalar fill_value, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<full_out::schema> create_full_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(full_out::name, full_out::overload_name)
      .typed<full_out::schema>();
}

// aten::full.out(SymInt[] size, Scalar fill_value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & full_out::call(c10::SymIntArrayRef size, const at::Scalar & fill_value, at::Tensor & out) {
    
    static auto op = create_full_out_typed_handle();
    return op.call(size, fill_value, out);
}

// aten::full.out(SymInt[] size, Scalar fill_value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & full_out::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, const at::Scalar & fill_value, at::Tensor & out) {
    
    static auto op = create_full_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, fill_value, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_like, name, "aten::full_like")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_like, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_like, schema_str, "full_like(Tensor self, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor")

// aten::full_like(Tensor self, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<full_like::schema> create_full_like_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(full_like::name, full_like::overload_name)
      .typed<full_like::schema>();
}

// aten::full_like(Tensor self, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor
at::Tensor full_like::call(const at::Tensor & self, const at::Scalar & fill_value, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create_full_like_typed_handle();
    return op.call(self, fill_value, dtype, layout, device, pin_memory, memory_format);
}

// aten::full_like(Tensor self, Scalar fill_value, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, MemoryFormat? memory_format=None) -> Tensor
at::Tensor full_like::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & fill_value, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create_full_like_typed_handle();
    return op.redispatch(dispatchKeySet, self, fill_value, dtype, layout, device, pin_memory, memory_format);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d, name, "aten::grid_sampler_2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d, schema_str, "grid_sampler_2d(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> Tensor")

// aten::grid_sampler_2d(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<grid_sampler_2d::schema> create_grid_sampler_2d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(grid_sampler_2d::name, grid_sampler_2d::overload_name)
      .typed<grid_sampler_2d::schema>();
}

// aten::grid_sampler_2d(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> Tensor
at::Tensor grid_sampler_2d::call(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
    
    static auto op = create_grid_sampler_2d_typed_handle();
    return op.call(input, grid, interpolation_mode, padding_mode, align_corners);
}

// aten::grid_sampler_2d(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> Tensor
at::Tensor grid_sampler_2d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
    
    static auto op = create_grid_sampler_2d_typed_handle();
    return op.redispatch(dispatchKeySet, input, grid, interpolation_mode, padding_mode, align_corners);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_grid_sampler_2d_cpu_fallback_backward, name, "aten::_grid_sampler_2d_cpu_fallback_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_grid_sampler_2d_cpu_fallback_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_grid_sampler_2d_cpu_fallback_backward, schema_str, "_grid_sampler_2d_cpu_fallback_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> (Tensor, Tensor)")

// aten::_grid_sampler_2d_cpu_fallback_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_grid_sampler_2d_cpu_fallback_backward::schema> create__grid_sampler_2d_cpu_fallback_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_grid_sampler_2d_cpu_fallback_backward::name, _grid_sampler_2d_cpu_fallback_backward::overload_name)
      .typed<_grid_sampler_2d_cpu_fallback_backward::schema>();
}

// aten::_grid_sampler_2d_cpu_fallback_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _grid_sampler_2d_cpu_fallback_backward::call(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
    
    static auto op = create__grid_sampler_2d_cpu_fallback_backward_typed_handle();
    return op.call(grad_output, input, grid, interpolation_mode, padding_mode, align_corners);
}

// aten::_grid_sampler_2d_cpu_fallback_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _grid_sampler_2d_cpu_fallback_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
    
    static auto op = create__grid_sampler_2d_cpu_fallback_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, input, grid, interpolation_mode, padding_mode, align_corners);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window, name, "aten::kaiser_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window, schema_str, "kaiser_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::kaiser_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<kaiser_window::schema> create_kaiser_window_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(kaiser_window::name, kaiser_window::overload_name)
      .typed<kaiser_window::schema>();
}

// aten::kaiser_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor kaiser_window::call(int64_t window_length, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_kaiser_window_typed_handle();
    return op.call(window_length, dtype, layout, device, pin_memory);
}

// aten::kaiser_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor kaiser_window::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_kaiser_window_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_periodic, name, "aten::kaiser_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_periodic, overload_name, "periodic")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_periodic, schema_str, "kaiser_window.periodic(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::kaiser_window.periodic(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<kaiser_window_periodic::schema> create_kaiser_window_periodic_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(kaiser_window_periodic::name, kaiser_window_periodic::overload_name)
      .typed<kaiser_window_periodic::schema>();
}

// aten::kaiser_window.periodic(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor kaiser_window_periodic::call(int64_t window_length, bool periodic, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_kaiser_window_periodic_typed_handle();
    return op.call(window_length, periodic, dtype, layout, device, pin_memory);
}

// aten::kaiser_window.periodic(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor kaiser_window_periodic::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, bool periodic, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_kaiser_window_periodic_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, periodic, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_beta, name, "aten::kaiser_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_beta, overload_name, "beta")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_beta, schema_str, "kaiser_window.beta(int window_length, bool periodic, float beta, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::kaiser_window.beta(int window_length, bool periodic, float beta, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<kaiser_window_beta::schema> create_kaiser_window_beta_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(kaiser_window_beta::name, kaiser_window_beta::overload_name)
      .typed<kaiser_window_beta::schema>();
}

// aten::kaiser_window.beta(int window_length, bool periodic, float beta, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor kaiser_window_beta::call(int64_t window_length, bool periodic, double beta, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_kaiser_window_beta_typed_handle();
    return op.call(window_length, periodic, beta, dtype, layout, device, pin_memory);
}

// aten::kaiser_window.beta(int window_length, bool periodic, float beta, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor kaiser_window_beta::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, bool periodic, double beta, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_kaiser_window_beta_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, periodic, beta, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fft_c2r, name, "aten::_fft_c2r")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fft_c2r, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fft_c2r, schema_str, "_fft_c2r(Tensor self, int[] dim, int normalization, SymInt last_dim_size) -> Tensor")

// aten::_fft_c2r(Tensor self, int[] dim, int normalization, SymInt last_dim_size) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_fft_c2r::schema> create__fft_c2r_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_fft_c2r::name, _fft_c2r::overload_name)
      .typed<_fft_c2r::schema>();
}

// aten::_fft_c2r(Tensor self, int[] dim, int normalization, SymInt last_dim_size) -> Tensor
at::Tensor _fft_c2r::call(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size) {
    
    static auto op = create__fft_c2r_typed_handle();
    return op.call(self, dim, normalization, last_dim_size);
}

// aten::_fft_c2r(Tensor self, int[] dim, int normalization, SymInt last_dim_size) -> Tensor
at::Tensor _fft_c2r::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size) {
    
    static auto op = create__fft_c2r_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, normalization, last_dim_size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fft_c2r_out, name, "aten::_fft_c2r")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fft_c2r_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fft_c2r_out, schema_str, "_fft_c2r.out(Tensor self, int[] dim, int normalization, SymInt last_dim_size, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_fft_c2r.out(Tensor self, int[] dim, int normalization, SymInt last_dim_size, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_fft_c2r_out::schema> create__fft_c2r_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_fft_c2r_out::name, _fft_c2r_out::overload_name)
      .typed<_fft_c2r_out::schema>();
}

// aten::_fft_c2r.out(Tensor self, int[] dim, int normalization, SymInt last_dim_size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _fft_c2r_out::call(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size, at::Tensor & out) {
    
    static auto op = create__fft_c2r_out_typed_handle();
    return op.call(self, dim, normalization, last_dim_size, out);
}

// aten::_fft_c2r.out(Tensor self, int[] dim, int normalization, SymInt last_dim_size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _fft_c2r_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size, at::Tensor & out) {
    
    static auto op = create__fft_c2r_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, normalization, last_dim_size, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cufft_set_plan_cache_max_size, name, "aten::_cufft_set_plan_cache_max_size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cufft_set_plan_cache_max_size, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cufft_set_plan_cache_max_size, schema_str, "_cufft_set_plan_cache_max_size(DeviceIndex device_index, int max_size) -> ()")

// aten::_cufft_set_plan_cache_max_size(DeviceIndex device_index, int max_size) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_cufft_set_plan_cache_max_size::schema> create__cufft_set_plan_cache_max_size_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cufft_set_plan_cache_max_size::name, _cufft_set_plan_cache_max_size::overload_name)
      .typed<_cufft_set_plan_cache_max_size::schema>();
}

// aten::_cufft_set_plan_cache_max_size(DeviceIndex device_index, int max_size) -> ()
void _cufft_set_plan_cache_max_size::call(at::DeviceIndex device_index, int64_t max_size) {
    
    static auto op = create__cufft_set_plan_cache_max_size_typed_handle();
    return op.call(device_index, max_size);
}

// aten::_cufft_set_plan_cache_max_size(DeviceIndex device_index, int max_size) -> ()
void _cufft_set_plan_cache_max_size::redispatch(c10::DispatchKeySet dispatchKeySet, at::DeviceIndex device_index, int64_t max_size) {
    
    static auto op = create__cufft_set_plan_cache_max_size_typed_handle();
    return op.redispatch(dispatchKeySet, device_index, max_size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_put_, name, "aten::index_put_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_put_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_put_, schema_str, "index_put_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor(a!)")

// aten::index_put_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<index_put_::schema> create_index_put__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_put_::name, index_put_::overload_name)
      .typed<index_put_::schema>();
}

// aten::index_put_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor(a!)
at::Tensor & index_put_::call(at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate) {
    
    static auto op = create_index_put__typed_handle();
    return op.call(self, indices, values, accumulate);
}

// aten::index_put_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor(a!)
at::Tensor & index_put_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate) {
    
    static auto op = create_index_put__typed_handle();
    return op.redispatch(dispatchKeySet, self, indices, values, accumulate);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_put, name, "aten::index_put")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_put, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_put, schema_str, "index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor")

// aten::index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<index_put::schema> create_index_put_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_put::name, index_put::overload_name)
      .typed<index_put::schema>();
}

// aten::index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor
at::Tensor index_put::call(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate) {
    
    static auto op = create_index_put_typed_handle();
    return op.call(self, indices, values, accumulate);
}

// aten::index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor
at::Tensor index_put::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate) {
    
    static auto op = create_index_put_typed_handle();
    return op.redispatch(dispatchKeySet, self, indices, values, accumulate);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(instance_norm, name, "aten::instance_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(instance_norm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(instance_norm, schema_str, "instance_norm(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool use_input_stats, float momentum, float eps, bool cudnn_enabled) -> Tensor")

// aten::instance_norm(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool use_input_stats, float momentum, float eps, bool cudnn_enabled) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<instance_norm::schema> create_instance_norm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(instance_norm::name, instance_norm::overload_name)
      .typed<instance_norm::schema>();
}

// aten::instance_norm(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool use_input_stats, float momentum, float eps, bool cudnn_enabled) -> Tensor
at::Tensor instance_norm::call(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool use_input_stats, double momentum, double eps, bool cudnn_enabled) {
    
    static auto op = create_instance_norm_typed_handle();
    return op.call(input, weight, bias, running_mean, running_var, use_input_stats, momentum, eps, cudnn_enabled);
}

// aten::instance_norm(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool use_input_stats, float momentum, float eps, bool cudnn_enabled) -> Tensor
at::Tensor instance_norm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool use_input_stats, double momentum, double eps, bool cudnn_enabled) {
    
    static auto op = create_instance_norm_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, running_mean, running_var, use_input_stats, momentum, eps, cudnn_enabled);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(isclose, name, "aten::isclose")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(isclose, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(isclose, schema_str, "isclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -> Tensor")

// aten::isclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<isclose::schema> create_isclose_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(isclose::name, isclose::overload_name)
      .typed<isclose::schema>();
}

// aten::isclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -> Tensor
at::Tensor isclose::call(const at::Tensor & self, const at::Tensor & other, double rtol, double atol, bool equal_nan) {
    
    static auto op = create_isclose_typed_handle();
    return op.call(self, other, rtol, atol, equal_nan);
}

// aten::isclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -> Tensor
at::Tensor isclose::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, double rtol, double atol, bool equal_nan) {
    
    static auto op = create_isclose_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, rtol, atol, equal_nan);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_floating_point, name, "aten::is_floating_point")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_floating_point, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_floating_point, schema_str, "is_floating_point(Tensor self) -> bool")

// aten::is_floating_point(Tensor self) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<is_floating_point::schema> create_is_floating_point_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(is_floating_point::name, is_floating_point::overload_name)
      .typed<is_floating_point::schema>();
}

// aten::is_floating_point(Tensor self) -> bool
bool is_floating_point::call(const at::Tensor & self) {
    
    static auto op = create_is_floating_point_typed_handle();
    return op.call(self);
}

// aten::is_floating_point(Tensor self) -> bool
bool is_floating_point::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_is_floating_point_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_complex, name, "aten::is_complex")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_complex, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_complex, schema_str, "is_complex(Tensor self) -> bool")

// aten::is_complex(Tensor self) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<is_complex::schema> create_is_complex_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(is_complex::name, is_complex::overload_name)
      .typed<is_complex::schema>();
}

// aten::is_complex(Tensor self) -> bool
bool is_complex::call(const at::Tensor & self) {
    
    static auto op = create_is_complex_typed_handle();
    return op.call(self);
}

// aten::is_complex(Tensor self) -> bool
bool is_complex::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_is_complex_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_same_size, name, "aten::is_same_size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_same_size, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_same_size, schema_str, "is_same_size(Tensor self, Tensor other) -> bool")

// aten::is_same_size(Tensor self, Tensor other) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<is_same_size::schema> create_is_same_size_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(is_same_size::name, is_same_size::overload_name)
      .typed<is_same_size::schema>();
}

// aten::is_same_size(Tensor self, Tensor other) -> bool
bool is_same_size::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_is_same_size_typed_handle();
    return op.call(self, other);
}

// aten::is_same_size(Tensor self, Tensor other) -> bool
bool is_same_size::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_is_same_size_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kl_div, name, "aten::kl_div")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kl_div, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kl_div, schema_str, "kl_div(Tensor self, Tensor target, int reduction=Mean, *, bool log_target=False) -> Tensor")

// aten::kl_div(Tensor self, Tensor target, int reduction=Mean, *, bool log_target=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<kl_div::schema> create_kl_div_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(kl_div::name, kl_div::overload_name)
      .typed<kl_div::schema>();
}

// aten::kl_div(Tensor self, Tensor target, int reduction=Mean, *, bool log_target=False) -> Tensor
at::Tensor kl_div::call(const at::Tensor & self, const at::Tensor & target, int64_t reduction, bool log_target) {
    
    static auto op = create_kl_div_typed_handle();
    return op.call(self, target, reduction, log_target);
}

// aten::kl_div(Tensor self, Tensor target, int reduction=Mean, *, bool log_target=False) -> Tensor
at::Tensor kl_div::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & target, int64_t reduction, bool log_target) {
    
    static auto op = create_kl_div_typed_handle();
    return op.redispatch(dispatchKeySet, self, target, reduction, log_target);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cslt_compress, name, "aten::_cslt_compress")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cslt_compress, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cslt_compress, schema_str, "_cslt_compress(Tensor input) -> Tensor")

// aten::_cslt_compress(Tensor input) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_cslt_compress::schema> create__cslt_compress_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cslt_compress::name, _cslt_compress::overload_name)
      .typed<_cslt_compress::schema>();
}

// aten::_cslt_compress(Tensor input) -> Tensor
at::Tensor _cslt_compress::call(const at::Tensor & input) {
    
    static auto op = create__cslt_compress_typed_handle();
    return op.call(input);
}

// aten::_cslt_compress(Tensor input) -> Tensor
at::Tensor _cslt_compress::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input) {
    
    static auto op = create__cslt_compress_typed_handle();
    return op.redispatch(dispatchKeySet, input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cslt_sparse_mm_search, name, "aten::_cslt_sparse_mm_search")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cslt_sparse_mm_search, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cslt_sparse_mm_search, schema_str, "_cslt_sparse_mm_search(Tensor compressed_A, Tensor dense_B, Tensor? bias=None, Tensor? alpha=None, ScalarType? out_dtype=None, bool transpose_result=False) -> int")

// aten::_cslt_sparse_mm_search(Tensor compressed_A, Tensor dense_B, Tensor? bias=None, Tensor? alpha=None, ScalarType? out_dtype=None, bool transpose_result=False) -> int
static C10_NOINLINE c10::TypedOperatorHandle<_cslt_sparse_mm_search::schema> create__cslt_sparse_mm_search_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cslt_sparse_mm_search::name, _cslt_sparse_mm_search::overload_name)
      .typed<_cslt_sparse_mm_search::schema>();
}

// aten::_cslt_sparse_mm_search(Tensor compressed_A, Tensor dense_B, Tensor? bias=None, Tensor? alpha=None, ScalarType? out_dtype=None, bool transpose_result=False) -> int
int64_t _cslt_sparse_mm_search::call(const at::Tensor & compressed_A, const at::Tensor & dense_B, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & alpha, c10::optional<at::ScalarType> out_dtype, bool transpose_result) {
    
    static auto op = create__cslt_sparse_mm_search_typed_handle();
    return op.call(compressed_A, dense_B, bias, alpha, out_dtype, transpose_result);
}

// aten::_cslt_sparse_mm_search(Tensor compressed_A, Tensor dense_B, Tensor? bias=None, Tensor? alpha=None, ScalarType? out_dtype=None, bool transpose_result=False) -> int
int64_t _cslt_sparse_mm_search::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & compressed_A, const at::Tensor & dense_B, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & alpha, c10::optional<at::ScalarType> out_dtype, bool transpose_result) {
    
    static auto op = create__cslt_sparse_mm_search_typed_handle();
    return op.redispatch(dispatchKeySet, compressed_A, dense_B, bias, alpha, out_dtype, transpose_result);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fbgemm_pack_gemm_matrix_fp16, name, "aten::fbgemm_pack_gemm_matrix_fp16")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fbgemm_pack_gemm_matrix_fp16, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fbgemm_pack_gemm_matrix_fp16, schema_str, "fbgemm_pack_gemm_matrix_fp16(Tensor input) -> Tensor")

// aten::fbgemm_pack_gemm_matrix_fp16(Tensor input) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fbgemm_pack_gemm_matrix_fp16::schema> create_fbgemm_pack_gemm_matrix_fp16_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fbgemm_pack_gemm_matrix_fp16::name, fbgemm_pack_gemm_matrix_fp16::overload_name)
      .typed<fbgemm_pack_gemm_matrix_fp16::schema>();
}

// aten::fbgemm_pack_gemm_matrix_fp16(Tensor input) -> Tensor
at::Tensor fbgemm_pack_gemm_matrix_fp16::call(const at::Tensor & input) {
    
    static auto op = create_fbgemm_pack_gemm_matrix_fp16_typed_handle();
    return op.call(input);
}

// aten::fbgemm_pack_gemm_matrix_fp16(Tensor input) -> Tensor
at::Tensor fbgemm_pack_gemm_matrix_fp16::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input) {
    
    static auto op = create_fbgemm_pack_gemm_matrix_fp16_typed_handle();
    return op.redispatch(dispatchKeySet, input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(margin_ranking_loss, name, "aten::margin_ranking_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(margin_ranking_loss, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(margin_ranking_loss, schema_str, "margin_ranking_loss(Tensor input1, Tensor input2, Tensor target, float margin=0.0, int reduction=Mean) -> Tensor")

// aten::margin_ranking_loss(Tensor input1, Tensor input2, Tensor target, float margin=0.0, int reduction=Mean) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<margin_ranking_loss::schema> create_margin_ranking_loss_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(margin_ranking_loss::name, margin_ranking_loss::overload_name)
      .typed<margin_ranking_loss::schema>();
}

// aten::margin_ranking_loss(Tensor input1, Tensor input2, Tensor target, float margin=0.0, int reduction=Mean) -> Tensor
at::Tensor margin_ranking_loss::call(const at::Tensor & input1, const at::Tensor & input2, const at::Tensor & target, double margin, int64_t reduction) {
    
    static auto op = create_margin_ranking_loss_typed_handle();
    return op.call(input1, input2, target, margin, reduction);
}

// aten::margin_ranking_loss(Tensor input1, Tensor input2, Tensor target, float margin=0.0, int reduction=Mean) -> Tensor
at::Tensor margin_ranking_loss::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input1, const at::Tensor & input2, const at::Tensor & target, double margin, int64_t reduction) {
    
    static auto op = create_margin_ranking_loss_typed_handle();
    return op.redispatch(dispatchKeySet, input1, input2, target, margin, reduction);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul, name, "aten::matmul")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul, schema_str, "matmul(Tensor self, Tensor other) -> Tensor")

// aten::matmul(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<matmul::schema> create_matmul_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(matmul::name, matmul::overload_name)
      .typed<matmul::schema>();
}

// aten::matmul(Tensor self, Tensor other) -> Tensor
at::Tensor matmul::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_matmul_typed_handle();
    return op.call(self, other);
}

// aten::matmul(Tensor self, Tensor other) -> Tensor
at::Tensor matmul::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_matmul_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul_backward, name, "aten::matmul_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul_backward, schema_str, "matmul_backward(Tensor grad, Tensor self, Tensor other, bool[2] mask) -> (Tensor, Tensor)")

// aten::matmul_backward(Tensor grad, Tensor self, Tensor other, bool[2] mask) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<matmul_backward::schema> create_matmul_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(matmul_backward::name, matmul_backward::overload_name)
      .typed<matmul_backward::schema>();
}

// aten::matmul_backward(Tensor grad, Tensor self, Tensor other, bool[2] mask) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> matmul_backward::call(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & other, ::std::array<bool,2> mask) {
    
    static auto op = create_matmul_backward_typed_handle();
    return op.call(grad, self, other, mask);
}

// aten::matmul_backward(Tensor grad, Tensor self, Tensor other, bool[2] mask) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> matmul_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & self, const at::Tensor & other, ::std::array<bool,2> mask) {
    
    static auto op = create_matmul_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, self, other, mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul_out, name, "aten::matmul")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul_out, schema_str, "matmul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::matmul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<matmul_out::schema> create_matmul_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(matmul_out::name, matmul_out::overload_name)
      .typed<matmul_out::schema>();
}

// aten::matmul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & matmul_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_matmul_out_typed_handle();
    return op.call(self, other, out);
}

// aten::matmul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & matmul_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_matmul_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matrix_exp, name, "aten::matrix_exp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matrix_exp, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matrix_exp, schema_str, "matrix_exp(Tensor self) -> Tensor")

// aten::matrix_exp(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<matrix_exp::schema> create_matrix_exp_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(matrix_exp::name, matrix_exp::overload_name)
      .typed<matrix_exp::schema>();
}

// aten::matrix_exp(Tensor self) -> Tensor
at::Tensor matrix_exp::call(const at::Tensor & self) {
    
    static auto op = create_matrix_exp_typed_handle();
    return op.call(self);
}

// aten::matrix_exp(Tensor self) -> Tensor
at::Tensor matrix_exp::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_matrix_exp_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_compute_linear_combination, name, "aten::_compute_linear_combination")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_compute_linear_combination, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_compute_linear_combination, schema_str, "_compute_linear_combination(Tensor input, Tensor coefficients) -> Tensor")

// aten::_compute_linear_combination(Tensor input, Tensor coefficients) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_compute_linear_combination::schema> create__compute_linear_combination_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_compute_linear_combination::name, _compute_linear_combination::overload_name)
      .typed<_compute_linear_combination::schema>();
}

// aten::_compute_linear_combination(Tensor input, Tensor coefficients) -> Tensor
at::Tensor _compute_linear_combination::call(const at::Tensor & input, const at::Tensor & coefficients) {
    
    static auto op = create__compute_linear_combination_typed_handle();
    return op.call(input, coefficients);
}

// aten::_compute_linear_combination(Tensor input, Tensor coefficients) -> Tensor
at::Tensor _compute_linear_combination::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & coefficients) {
    
    static auto op = create__compute_linear_combination_typed_handle();
    return op.redispatch(dispatchKeySet, input, coefficients);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_compute_linear_combination_out, name, "aten::_compute_linear_combination")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_compute_linear_combination_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_compute_linear_combination_out, schema_str, "_compute_linear_combination.out(Tensor input, Tensor coefficients, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_compute_linear_combination.out(Tensor input, Tensor coefficients, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_compute_linear_combination_out::schema> create__compute_linear_combination_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_compute_linear_combination_out::name, _compute_linear_combination_out::overload_name)
      .typed<_compute_linear_combination_out::schema>();
}

// aten::_compute_linear_combination.out(Tensor input, Tensor coefficients, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _compute_linear_combination_out::call(const at::Tensor & input, const at::Tensor & coefficients, at::Tensor & out) {
    
    static auto op = create__compute_linear_combination_out_typed_handle();
    return op.call(input, coefficients, out);
}

// aten::_compute_linear_combination.out(Tensor input, Tensor coefficients, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _compute_linear_combination_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & coefficients, at::Tensor & out) {
    
    static auto op = create__compute_linear_combination_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, coefficients, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_backward, name, "aten::max_pool2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_backward, schema_str, "max_pool2d_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> Tensor")

// aten::max_pool2d_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<max_pool2d_backward::schema> create_max_pool2d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool2d_backward::name, max_pool2d_backward::overload_name)
      .typed<max_pool2d_backward::schema>();
}

// aten::max_pool2d_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor max_pool2d_backward::call(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool2d_backward_typed_handle();
    return op.call(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode);
}

// aten::max_pool2d_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor max_pool2d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool2d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool2d_backward, name, "aten::mkldnn_max_pool2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool2d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool2d_backward, schema_str, "mkldnn_max_pool2d_backward(Tensor grad_output, Tensor output, Tensor input, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> Tensor")

// aten::mkldnn_max_pool2d_backward(Tensor grad_output, Tensor output, Tensor input, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_max_pool2d_backward::schema> create_mkldnn_max_pool2d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_max_pool2d_backward::name, mkldnn_max_pool2d_backward::overload_name)
      .typed<mkldnn_max_pool2d_backward::schema>();
}

// aten::mkldnn_max_pool2d_backward(Tensor grad_output, Tensor output, Tensor input, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor mkldnn_max_pool2d_backward::call(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_mkldnn_max_pool2d_backward_typed_handle();
    return op.call(grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode);
}

// aten::mkldnn_max_pool2d_backward(Tensor grad_output, Tensor output, Tensor input, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor mkldnn_max_pool2d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_mkldnn_max_pool2d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool3d, name, "aten::max_pool3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool3d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool3d, schema_str, "max_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> Tensor")

// aten::max_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<max_pool3d::schema> create_max_pool3d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool3d::name, max_pool3d::overload_name)
      .typed<max_pool3d::schema>();
}

// aten::max_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor max_pool3d::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool3d_typed_handle();
    return op.call(self, kernel_size, stride, padding, dilation, ceil_mode);
}

// aten::max_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor max_pool3d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool3d_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, dilation, ceil_mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median, name, "aten::median")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median, schema_str, "median(Tensor self) -> Tensor")

// aten::median(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<median::schema> create_median_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(median::name, median::overload_name)
      .typed<median::schema>();
}

// aten::median(Tensor self) -> Tensor
at::Tensor median::call(const at::Tensor & self) {
    
    static auto op = create_median_typed_handle();
    return op.call(self);
}

// aten::median(Tensor self) -> Tensor
at::Tensor median::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_median_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_dim, name, "aten::median")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_dim, overload_name, "dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_dim, schema_str, "median.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)")

// aten::median.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)
static C10_NOINLINE c10::TypedOperatorHandle<median_dim::schema> create_median_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(median_dim::name, median_dim::overload_name)
      .typed<median_dim::schema>();
}

// aten::median.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> median_dim::call(const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_median_dim_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::median.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> median_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_median_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_dim_values, name, "aten::median")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_dim_values, overload_name, "dim_values")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_dim_values, schema_str, "median.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)")

// aten::median.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
static C10_NOINLINE c10::TypedOperatorHandle<median_dim_values::schema> create_median_dim_values_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(median_dim_values::name, median_dim_values::overload_name)
      .typed<median_dim_values::schema>();
}

// aten::median.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> median_dim_values::call(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_median_dim_values_typed_handle();
    return op.call(self, dim, keepdim, values, indices);
}

// aten::median.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> median_dim_values::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_median_dim_values_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, values, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_names_dim, name, "aten::median")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_names_dim, overload_name, "names_dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_names_dim, schema_str, "median.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)")

// aten::median.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
static C10_NOINLINE c10::TypedOperatorHandle<median_names_dim::schema> create_median_names_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(median_names_dim::name, median_names_dim::overload_name)
      .typed<median_names_dim::schema>();
}

// aten::median.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> median_names_dim::call(const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_median_names_dim_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::median.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> median_names_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_median_names_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_names_dim_values, name, "aten::median")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_names_dim_values, overload_name, "names_dim_values")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_names_dim_values, schema_str, "median.names_dim_values(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)")

// aten::median.names_dim_values(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
static C10_NOINLINE c10::TypedOperatorHandle<median_names_dim_values::schema> create_median_names_dim_values_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(median_names_dim_values::name, median_names_dim_values::overload_name)
      .typed<median_names_dim_values::schema>();
}

// aten::median.names_dim_values(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> median_names_dim_values::call(const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_median_names_dim_values_typed_handle();
    return op.call(self, dim, keepdim, values, indices);
}

// aten::median.names_dim_values(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> median_names_dim_values::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_median_names_dim_values_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, values, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian, name, "aten::nanmedian")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian, schema_str, "nanmedian(Tensor self) -> Tensor")

// aten::nanmedian(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<nanmedian::schema> create_nanmedian_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanmedian::name, nanmedian::overload_name)
      .typed<nanmedian::schema>();
}

// aten::nanmedian(Tensor self) -> Tensor
at::Tensor nanmedian::call(const at::Tensor & self) {
    
    static auto op = create_nanmedian_typed_handle();
    return op.call(self);
}

// aten::nanmedian(Tensor self) -> Tensor
at::Tensor nanmedian::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_nanmedian_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_dim, name, "aten::nanmedian")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_dim, overload_name, "dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_dim, schema_str, "nanmedian.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)")

// aten::nanmedian.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)
static C10_NOINLINE c10::TypedOperatorHandle<nanmedian_dim::schema> create_nanmedian_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanmedian_dim::name, nanmedian_dim::overload_name)
      .typed<nanmedian_dim::schema>();
}

// aten::nanmedian.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> nanmedian_dim::call(const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_nanmedian_dim_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::nanmedian.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> nanmedian_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_nanmedian_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_dim_values, name, "aten::nanmedian")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_dim_values, overload_name, "dim_values")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_dim_values, schema_str, "nanmedian.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)")

// aten::nanmedian.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
static C10_NOINLINE c10::TypedOperatorHandle<nanmedian_dim_values::schema> create_nanmedian_dim_values_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanmedian_dim_values::name, nanmedian_dim_values::overload_name)
      .typed<nanmedian_dim_values::schema>();
}

// aten::nanmedian.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> nanmedian_dim_values::call(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_nanmedian_dim_values_typed_handle();
    return op.call(self, dim, keepdim, values, indices);
}

// aten::nanmedian.dim_values(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> nanmedian_dim_values::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_nanmedian_dim_values_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, values, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_names_dim, name, "aten::nanmedian")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_names_dim, overload_name, "names_dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_names_dim, schema_str, "nanmedian.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)")

// aten::nanmedian.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
static C10_NOINLINE c10::TypedOperatorHandle<nanmedian_names_dim::schema> create_nanmedian_names_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanmedian_names_dim::name, nanmedian_names_dim::overload_name)
      .typed<nanmedian_names_dim::schema>();
}

// aten::nanmedian.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> nanmedian_names_dim::call(const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_nanmedian_names_dim_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::nanmedian.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> nanmedian_names_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_nanmedian_names_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_names_dim_values, name, "aten::nanmedian")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_names_dim_values, overload_name, "names_dim_values")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_names_dim_values, schema_str, "nanmedian.names_dim_values(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)")

// aten::nanmedian.names_dim_values(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
static C10_NOINLINE c10::TypedOperatorHandle<nanmedian_names_dim_values::schema> create_nanmedian_names_dim_values_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanmedian_names_dim_values::name, nanmedian_names_dim_values::overload_name)
      .typed<nanmedian_names_dim_values::schema>();
}

// aten::nanmedian.names_dim_values(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> nanmedian_names_dim_values::call(const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_nanmedian_names_dim_values_typed_handle();
    return op.call(self, dim, keepdim, values, indices);
}

// aten::nanmedian.names_dim_values(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> nanmedian_names_dim_values::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_nanmedian_names_dim_values_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, values, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm, name, "aten::miopen_batch_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm, schema_str, "miopen_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor)")

// aten::miopen_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<miopen_batch_norm::schema> create_miopen_batch_norm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_batch_norm::name, miopen_batch_norm::overload_name)
      .typed<miopen_batch_norm::schema>();
}

// aten::miopen_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> miopen_batch_norm::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon) {
    
    static auto op = create_miopen_batch_norm_typed_handle();
    return op.call(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
}

// aten::miopen_batch_norm(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> miopen_batch_norm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon) {
    
    static auto op = create_miopen_batch_norm_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_transpose, name, "aten::miopen_convolution_transpose")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_transpose, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_transpose, schema_str, "miopen_convolution_transpose(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic) -> Tensor")

// aten::miopen_convolution_transpose(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<miopen_convolution_transpose::schema> create_miopen_convolution_transpose_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_convolution_transpose::name, miopen_convolution_transpose::overload_name)
      .typed<miopen_convolution_transpose::schema>();
}

// aten::miopen_convolution_transpose(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic) -> Tensor
at::Tensor miopen_convolution_transpose::call(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic) {
    
    static auto op = create_miopen_convolution_transpose_typed_handle();
    return op.call(self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic);
}

// aten::miopen_convolution_transpose(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic) -> Tensor
at::Tensor miopen_convolution_transpose::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic) {
    
    static auto op = create_miopen_convolution_transpose_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_add_relu, name, "aten::miopen_convolution_add_relu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_add_relu, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_add_relu, schema_str, "miopen_convolution_add_relu(Tensor self, Tensor weight, Tensor z, Scalar? alpha, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, SymInt groups) -> Tensor")

// aten::miopen_convolution_add_relu(Tensor self, Tensor weight, Tensor z, Scalar? alpha, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, SymInt groups) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<miopen_convolution_add_relu::schema> create_miopen_convolution_add_relu_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_convolution_add_relu::name, miopen_convolution_add_relu::overload_name)
      .typed<miopen_convolution_add_relu::schema>();
}

// aten::miopen_convolution_add_relu(Tensor self, Tensor weight, Tensor z, Scalar? alpha, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, SymInt groups) -> Tensor
at::Tensor miopen_convolution_add_relu::call(const at::Tensor & self, const at::Tensor & weight, const at::Tensor & z, const c10::optional<at::Scalar> & alpha, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_miopen_convolution_add_relu_typed_handle();
    return op.call(self, weight, z, alpha, bias, stride, padding, dilation, groups);
}

// aten::miopen_convolution_add_relu(Tensor self, Tensor weight, Tensor z, Scalar? alpha, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, SymInt groups) -> Tensor
at::Tensor miopen_convolution_add_relu::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, const at::Tensor & z, const c10::optional<at::Scalar> & alpha, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_miopen_convolution_add_relu_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, z, alpha, bias, stride, padding, dilation, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_rnn_backward, name, "aten::miopen_rnn_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_rnn_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_rnn_backward, schema_str, "miopen_rnn_backward(Tensor input, Tensor[] weight, int weight_stride0, Tensor weight_buf, Tensor hx, Tensor? cx, Tensor output, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state, Tensor reserve, bool[4] output_mask) -> (Tensor, Tensor, Tensor, Tensor[])")

// aten::miopen_rnn_backward(Tensor input, Tensor[] weight, int weight_stride0, Tensor weight_buf, Tensor hx, Tensor? cx, Tensor output, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state, Tensor reserve, bool[4] output_mask) -> (Tensor, Tensor, Tensor, Tensor[])
static C10_NOINLINE c10::TypedOperatorHandle<miopen_rnn_backward::schema> create_miopen_rnn_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_rnn_backward::name, miopen_rnn_backward::overload_name)
      .typed<miopen_rnn_backward::schema>();
}

// aten::miopen_rnn_backward(Tensor input, Tensor[] weight, int weight_stride0, Tensor weight_buf, Tensor hx, Tensor? cx, Tensor output, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state, Tensor reserve, bool[4] output_mask) -> (Tensor, Tensor, Tensor, Tensor[])
::std::tuple<at::Tensor,at::Tensor,at::Tensor,::std::vector<at::Tensor>> miopen_rnn_backward::call(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask) {
    
    static auto op = create_miopen_rnn_backward_typed_handle();
    return op.call(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask);
}

// aten::miopen_rnn_backward(Tensor input, Tensor[] weight, int weight_stride0, Tensor weight_buf, Tensor hx, Tensor? cx, Tensor output, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state, Tensor reserve, bool[4] output_mask) -> (Tensor, Tensor, Tensor, Tensor[])
::std::tuple<at::Tensor,at::Tensor,at::Tensor,::std::vector<at::Tensor>> miopen_rnn_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask) {
    
    static auto op = create_miopen_rnn_backward_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convert_weight_to_int4pack, name, "aten::_convert_weight_to_int4pack")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convert_weight_to_int4pack, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convert_weight_to_int4pack, schema_str, "_convert_weight_to_int4pack(Tensor self, int innerKTiles) -> Tensor")

// aten::_convert_weight_to_int4pack(Tensor self, int innerKTiles) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_convert_weight_to_int4pack::schema> create__convert_weight_to_int4pack_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_convert_weight_to_int4pack::name, _convert_weight_to_int4pack::overload_name)
      .typed<_convert_weight_to_int4pack::schema>();
}

// aten::_convert_weight_to_int4pack(Tensor self, int innerKTiles) -> Tensor
at::Tensor _convert_weight_to_int4pack::call(const at::Tensor & self, int64_t innerKTiles) {
    
    static auto op = create__convert_weight_to_int4pack_typed_handle();
    return op.call(self, innerKTiles);
}

// aten::_convert_weight_to_int4pack(Tensor self, int innerKTiles) -> Tensor
at::Tensor _convert_weight_to_int4pack::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t innerKTiles) {
    
    static auto op = create__convert_weight_to_int4pack_typed_handle();
    return op.redispatch(dispatchKeySet, self, innerKTiles);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply_Tensor, name, "aten::multiply")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply_Tensor, schema_str, "multiply.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::multiply.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<multiply_Tensor::schema> create_multiply_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multiply_Tensor::name, multiply_Tensor::overload_name)
      .typed<multiply_Tensor::schema>();
}

// aten::multiply.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor multiply_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_multiply_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::multiply.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor multiply_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_multiply_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply__Tensor, name, "aten::multiply_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply__Tensor, schema_str, "multiply_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::multiply_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<multiply__Tensor::schema> create_multiply__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multiply__Tensor::name, multiply__Tensor::overload_name)
      .typed<multiply__Tensor::schema>();
}

// aten::multiply_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & multiply__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_multiply__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::multiply_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & multiply__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_multiply__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply_out, name, "aten::multiply")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply_out, schema_str, "multiply.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::multiply.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<multiply_out::schema> create_multiply_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multiply_out::name, multiply_out::overload_name)
      .typed<multiply_out::schema>();
}

// aten::multiply.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & multiply_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_multiply_out_typed_handle();
    return op.call(self, other, out);
}

// aten::multiply.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & multiply_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_multiply_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply_Scalar, name, "aten::multiply")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply_Scalar, schema_str, "multiply.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::multiply.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<multiply_Scalar::schema> create_multiply_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multiply_Scalar::name, multiply_Scalar::overload_name)
      .typed<multiply_Scalar::schema>();
}

// aten::multiply.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor multiply_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_multiply_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::multiply.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor multiply_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_multiply_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply__Scalar, name, "aten::multiply_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multiply__Scalar, schema_str, "multiply_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::multiply_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<multiply__Scalar::schema> create_multiply__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multiply__Scalar::name, multiply__Scalar::overload_name)
      .typed<multiply__Scalar::schema>();
}

// aten::multiply_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & multiply__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_multiply__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::multiply_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & multiply__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_multiply__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_elemt, name, "aten::batch_norm_elemt")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_elemt, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_elemt, schema_str, "batch_norm_elemt(Tensor input, Tensor? weight, Tensor? bias, Tensor mean, Tensor invstd, float eps) -> Tensor")

// aten::batch_norm_elemt(Tensor input, Tensor? weight, Tensor? bias, Tensor mean, Tensor invstd, float eps) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<batch_norm_elemt::schema> create_batch_norm_elemt_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(batch_norm_elemt::name, batch_norm_elemt::overload_name)
      .typed<batch_norm_elemt::schema>();
}

// aten::batch_norm_elemt(Tensor input, Tensor? weight, Tensor? bias, Tensor mean, Tensor invstd, float eps) -> Tensor
at::Tensor batch_norm_elemt::call(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & invstd, double eps) {
    
    static auto op = create_batch_norm_elemt_typed_handle();
    return op.call(input, weight, bias, mean, invstd, eps);
}

// aten::batch_norm_elemt(Tensor input, Tensor? weight, Tensor? bias, Tensor mean, Tensor invstd, float eps) -> Tensor
at::Tensor batch_norm_elemt::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & invstd, double eps) {
    
    static auto op = create_batch_norm_elemt_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, mean, invstd, eps);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_elemt_out, name, "aten::batch_norm_elemt")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_elemt_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_elemt_out, schema_str, "batch_norm_elemt.out(Tensor input, Tensor? weight, Tensor? bias, Tensor mean, Tensor invstd, float eps, *, Tensor(a!) out) -> Tensor(a!)")

// aten::batch_norm_elemt.out(Tensor input, Tensor? weight, Tensor? bias, Tensor mean, Tensor invstd, float eps, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<batch_norm_elemt_out::schema> create_batch_norm_elemt_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(batch_norm_elemt_out::name, batch_norm_elemt_out::overload_name)
      .typed<batch_norm_elemt_out::schema>();
}

// aten::batch_norm_elemt.out(Tensor input, Tensor? weight, Tensor? bias, Tensor mean, Tensor invstd, float eps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & batch_norm_elemt_out::call(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & invstd, double eps, at::Tensor & out) {
    
    static auto op = create_batch_norm_elemt_out_typed_handle();
    return op.call(input, weight, bias, mean, invstd, eps, out);
}

// aten::batch_norm_elemt.out(Tensor input, Tensor? weight, Tensor? bias, Tensor mean, Tensor invstd, float eps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & batch_norm_elemt_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & invstd, double eps, at::Tensor & out) {
    
    static auto op = create_batch_norm_elemt_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, mean, invstd, eps, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cdist, name, "aten::cdist")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cdist, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cdist, schema_str, "cdist(Tensor x1, Tensor x2, float p=2, int? compute_mode=None) -> Tensor")

// aten::cdist(Tensor x1, Tensor x2, float p=2, int? compute_mode=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cdist::schema> create_cdist_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cdist::name, cdist::overload_name)
      .typed<cdist::schema>();
}

// aten::cdist(Tensor x1, Tensor x2, float p=2, int? compute_mode=None) -> Tensor
at::Tensor cdist::call(const at::Tensor & x1, const at::Tensor & x2, double p, c10::optional<int64_t> compute_mode) {
    
    static auto op = create_cdist_typed_handle();
    return op.call(x1, x2, p, compute_mode);
}

// aten::cdist(Tensor x1, Tensor x2, float p=2, int? compute_mode=None) -> Tensor
at::Tensor cdist::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x1, const at::Tensor & x2, double p, c10::optional<int64_t> compute_mode) {
    
    static auto op = create_cdist_typed_handle();
    return op.redispatch(dispatchKeySet, x1, x2, p, compute_mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mT, name, "aten::mT")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mT, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mT, schema_str, "mT(Tensor(a) self) -> Tensor(a)")

// aten::mT(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<mT::schema> create_mT_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mT::name, mT::overload_name)
      .typed<mT::schema>();
}

// aten::mT(Tensor(a) self) -> Tensor(a)
at::Tensor mT::call(const at::Tensor & self) {
    
    static auto op = create_mT_typed_handle();
    return op.call(self);
}

// aten::mT(Tensor(a) self) -> Tensor(a)
at::Tensor mT::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_mT_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(adjoint, name, "aten::adjoint")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(adjoint, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(adjoint, schema_str, "adjoint(Tensor(a) self) -> Tensor(a)")

// aten::adjoint(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<adjoint::schema> create_adjoint_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(adjoint::name, adjoint::overload_name)
      .typed<adjoint::schema>();
}

// aten::adjoint(Tensor(a) self) -> Tensor(a)
at::Tensor adjoint::call(const at::Tensor & self) {
    
    static auto op = create_adjoint_typed_handle();
    return op.call(self);
}

// aten::adjoint(Tensor(a) self) -> Tensor(a)
at::Tensor adjoint::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_adjoint_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(channel_shuffle, name, "aten::channel_shuffle")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(channel_shuffle, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(channel_shuffle, schema_str, "channel_shuffle(Tensor self, SymInt groups) -> Tensor")

// aten::channel_shuffle(Tensor self, SymInt groups) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<channel_shuffle::schema> create_channel_shuffle_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(channel_shuffle::name, channel_shuffle::overload_name)
      .typed<channel_shuffle::schema>();
}

// aten::channel_shuffle(Tensor self, SymInt groups) -> Tensor
at::Tensor channel_shuffle::call(const at::Tensor & self, c10::SymInt groups) {
    
    static auto op = create_channel_shuffle_typed_handle();
    return op.call(self, groups);
}

// aten::channel_shuffle(Tensor self, SymInt groups) -> Tensor
at::Tensor channel_shuffle::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymInt groups) {
    
    static auto op = create_channel_shuffle_typed_handle();
    return op.redispatch(dispatchKeySet, self, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(poisson_nll_loss, name, "aten::poisson_nll_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(poisson_nll_loss, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(poisson_nll_loss, schema_str, "poisson_nll_loss(Tensor input, Tensor target, bool log_input, bool full, float eps, int reduction) -> Tensor")

// aten::poisson_nll_loss(Tensor input, Tensor target, bool log_input, bool full, float eps, int reduction) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<poisson_nll_loss::schema> create_poisson_nll_loss_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(poisson_nll_loss::name, poisson_nll_loss::overload_name)
      .typed<poisson_nll_loss::schema>();
}

// aten::poisson_nll_loss(Tensor input, Tensor target, bool log_input, bool full, float eps, int reduction) -> Tensor
at::Tensor poisson_nll_loss::call(const at::Tensor & input, const at::Tensor & target, bool log_input, bool full, double eps, int64_t reduction) {
    
    static auto op = create_poisson_nll_loss_typed_handle();
    return op.call(input, target, log_input, full, eps, reduction);
}

// aten::poisson_nll_loss(Tensor input, Tensor target, bool log_input, bool full, float eps, int reduction) -> Tensor
at::Tensor poisson_nll_loss::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & target, bool log_input, bool full, double eps, int64_t reduction) {
    
    static auto op = create_poisson_nll_loss_typed_handle();
    return op.redispatch(dispatchKeySet, input, target, log_input, full, eps, reduction);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(deg2rad, name, "aten::deg2rad")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(deg2rad, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(deg2rad, schema_str, "deg2rad(Tensor self) -> Tensor")

// aten::deg2rad(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<deg2rad::schema> create_deg2rad_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(deg2rad::name, deg2rad::overload_name)
      .typed<deg2rad::schema>();
}

// aten::deg2rad(Tensor self) -> Tensor
at::Tensor deg2rad::call(const at::Tensor & self) {
    
    static auto op = create_deg2rad_typed_handle();
    return op.call(self);
}

// aten::deg2rad(Tensor self) -> Tensor
at::Tensor deg2rad::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_deg2rad_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(deg2rad_, name, "aten::deg2rad_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(deg2rad_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(deg2rad_, schema_str, "deg2rad_(Tensor(a!) self) -> Tensor(a!)")

// aten::deg2rad_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<deg2rad_::schema> create_deg2rad__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(deg2rad_::name, deg2rad_::overload_name)
      .typed<deg2rad_::schema>();
}

// aten::deg2rad_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & deg2rad_::call(at::Tensor & self) {
    
    static auto op = create_deg2rad__typed_handle();
    return op.call(self);
}

// aten::deg2rad_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & deg2rad_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_deg2rad__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(deg2rad_out, name, "aten::deg2rad")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(deg2rad_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(deg2rad_out, schema_str, "deg2rad.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::deg2rad.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<deg2rad_out::schema> create_deg2rad_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(deg2rad_out::name, deg2rad_out::overload_name)
      .typed<deg2rad_out::schema>();
}

// aten::deg2rad.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & deg2rad_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_deg2rad_out_typed_handle();
    return op.call(self, out);
}

// aten::deg2rad.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & deg2rad_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_deg2rad_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm, name, "aten::randperm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm, schema_str, "randperm(SymInt n, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::randperm(SymInt n, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<randperm::schema> create_randperm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randperm::name, randperm::overload_name)
      .typed<randperm::schema>();
}

// aten::randperm(SymInt n, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randperm::call(c10::SymInt n, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randperm_typed_handle();
    return op.call(n, dtype, layout, device, pin_memory);
}

// aten::randperm(SymInt n, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randperm::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymInt n, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randperm_typed_handle();
    return op.redispatch(dispatchKeySet, n, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm_generator, name, "aten::randperm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm_generator, overload_name, "generator")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm_generator, schema_str, "randperm.generator(SymInt n, *, Generator? generator, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::randperm.generator(SymInt n, *, Generator? generator, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<randperm_generator::schema> create_randperm_generator_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randperm_generator::name, randperm_generator::overload_name)
      .typed<randperm_generator::schema>();
}

// aten::randperm.generator(SymInt n, *, Generator? generator, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randperm_generator::call(c10::SymInt n, c10::optional<at::Generator> generator, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randperm_generator_typed_handle();
    return op.call(n, generator, dtype, layout, device, pin_memory);
}

// aten::randperm.generator(SymInt n, *, Generator? generator, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randperm_generator::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymInt n, c10::optional<at::Generator> generator, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randperm_generator_typed_handle();
    return op.redispatch(dispatchKeySet, n, generator, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm_out, name, "aten::randperm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm_out, schema_str, "randperm.out(SymInt n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::randperm.out(SymInt n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<randperm_out::schema> create_randperm_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randperm_out::name, randperm_out::overload_name)
      .typed<randperm_out::schema>();
}

// aten::randperm.out(SymInt n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randperm_out::call(c10::SymInt n, at::Tensor & out) {
    
    static auto op = create_randperm_out_typed_handle();
    return op.call(n, out);
}

// aten::randperm.out(SymInt n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randperm_out::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymInt n, at::Tensor & out) {
    
    static auto op = create_randperm_out_typed_handle();
    return op.redispatch(dispatchKeySet, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm_generator_out, name, "aten::randperm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm_generator_out, overload_name, "generator_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randperm_generator_out, schema_str, "randperm.generator_out(SymInt n, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)")

// aten::randperm.generator_out(SymInt n, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<randperm_generator_out::schema> create_randperm_generator_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randperm_generator_out::name, randperm_generator_out::overload_name)
      .typed<randperm_generator_out::schema>();
}

// aten::randperm.generator_out(SymInt n, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randperm_generator_out::call(c10::SymInt n, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_randperm_generator_out_typed_handle();
    return op.call(n, generator, out);
}

// aten::randperm.generator_out(SymInt n, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randperm_generator_out::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymInt n, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_randperm_generator_out_typed_handle();
    return op.redispatch(dispatchKeySet, n, generator, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(negative, name, "aten::negative")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(negative, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(negative, schema_str, "negative(Tensor self) -> Tensor")

// aten::negative(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<negative::schema> create_negative_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(negative::name, negative::overload_name)
      .typed<negative::schema>();
}

// aten::negative(Tensor self) -> Tensor
at::Tensor negative::call(const at::Tensor & self) {
    
    static auto op = create_negative_typed_handle();
    return op.call(self);
}

// aten::negative(Tensor self) -> Tensor
at::Tensor negative::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_negative_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(negative_, name, "aten::negative_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(negative_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(negative_, schema_str, "negative_(Tensor(a!) self) -> Tensor(a!)")

// aten::negative_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<negative_::schema> create_negative__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(negative_::name, negative_::overload_name)
      .typed<negative_::schema>();
}

// aten::negative_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & negative_::call(at::Tensor & self) {
    
    static auto op = create_negative__typed_handle();
    return op.call(self);
}

// aten::negative_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & negative_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_negative__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(negative_out, name, "aten::negative")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(negative_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(negative_out, schema_str, "negative.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::negative.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<negative_out::schema> create_negative_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(negative_out::name, negative_out::overload_name)
      .typed<negative_out::schema>();
}

// aten::negative.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & negative_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_negative_out_typed_handle();
    return op.call(self, out);
}

// aten::negative.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & negative_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_negative_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_reshape_copy, name, "aten::_reshape_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_reshape_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_reshape_copy, schema_str, "_reshape_copy(Tensor self, SymInt[] size) -> Tensor")

// aten::_reshape_copy(Tensor self, SymInt[] size) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_reshape_copy::schema> create__reshape_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_reshape_copy::name, _reshape_copy::overload_name)
      .typed<_reshape_copy::schema>();
}

// aten::_reshape_copy(Tensor self, SymInt[] size) -> Tensor
at::Tensor _reshape_copy::call(const at::Tensor & self, c10::SymIntArrayRef size) {
    
    static auto op = create__reshape_copy_typed_handle();
    return op.call(self, size);
}

// aten::_reshape_copy(Tensor self, SymInt[] size) -> Tensor
at::Tensor _reshape_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size) {
    
    static auto op = create__reshape_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu, name, "aten::relu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu, schema_str, "relu(Tensor self) -> Tensor")

// aten::relu(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<relu::schema> create_relu_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(relu::name, relu::overload_name)
      .typed<relu::schema>();
}

// aten::relu(Tensor self) -> Tensor
at::Tensor relu::call(const at::Tensor & self) {
    
    static auto op = create_relu_typed_handle();
    return op.call(self);
}

// aten::relu(Tensor self) -> Tensor
at::Tensor relu::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_relu_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu_, name, "aten::relu_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu_, schema_str, "relu_(Tensor(a!) self) -> Tensor(a!)")

// aten::relu_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<relu_::schema> create_relu__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(relu_::name, relu_::overload_name)
      .typed<relu_::schema>();
}

// aten::relu_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & relu_::call(at::Tensor & self) {
    
    static auto op = create_relu__typed_handle();
    return op.call(self);
}

// aten::relu_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & relu_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_relu__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(infinitely_differentiable_gelu_backward, name, "aten::infinitely_differentiable_gelu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(infinitely_differentiable_gelu_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(infinitely_differentiable_gelu_backward, schema_str, "infinitely_differentiable_gelu_backward(Tensor grad, Tensor self) -> Tensor")

// aten::infinitely_differentiable_gelu_backward(Tensor grad, Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<infinitely_differentiable_gelu_backward::schema> create_infinitely_differentiable_gelu_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(infinitely_differentiable_gelu_backward::name, infinitely_differentiable_gelu_backward::overload_name)
      .typed<infinitely_differentiable_gelu_backward::schema>();
}

// aten::infinitely_differentiable_gelu_backward(Tensor grad, Tensor self) -> Tensor
at::Tensor infinitely_differentiable_gelu_backward::call(const at::Tensor & grad, const at::Tensor & self) {
    
    static auto op = create_infinitely_differentiable_gelu_backward_typed_handle();
    return op.call(grad, self);
}

// aten::infinitely_differentiable_gelu_backward(Tensor grad, Tensor self) -> Tensor
at::Tensor infinitely_differentiable_gelu_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & self) {
    
    static auto op = create_infinitely_differentiable_gelu_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardshrink_backward_grad_input, name, "aten::hardshrink_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardshrink_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardshrink_backward_grad_input, schema_str, "hardshrink_backward.grad_input(Tensor grad_out, Tensor self, Scalar lambd, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::hardshrink_backward.grad_input(Tensor grad_out, Tensor self, Scalar lambd, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<hardshrink_backward_grad_input::schema> create_hardshrink_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(hardshrink_backward_grad_input::name, hardshrink_backward_grad_input::overload_name)
      .typed<hardshrink_backward_grad_input::schema>();
}

// aten::hardshrink_backward.grad_input(Tensor grad_out, Tensor self, Scalar lambd, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & hardshrink_backward_grad_input::call(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
    
    static auto op = create_hardshrink_backward_grad_input_typed_handle();
    return op.call(grad_out, self, lambd, grad_input);
}

// aten::hardshrink_backward.grad_input(Tensor grad_out, Tensor self, Scalar lambd, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & hardshrink_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
    
    static auto op = create_hardshrink_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_out, self, lambd, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardshrink_backward, name, "aten::hardshrink_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardshrink_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardshrink_backward, schema_str, "hardshrink_backward(Tensor grad_out, Tensor self, Scalar lambd) -> Tensor")

// aten::hardshrink_backward(Tensor grad_out, Tensor self, Scalar lambd) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<hardshrink_backward::schema> create_hardshrink_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(hardshrink_backward::name, hardshrink_backward::overload_name)
      .typed<hardshrink_backward::schema>();
}

// aten::hardshrink_backward(Tensor grad_out, Tensor self, Scalar lambd) -> Tensor
at::Tensor hardshrink_backward::call(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd) {
    
    static auto op = create_hardshrink_backward_typed_handle();
    return op.call(grad_out, self, lambd);
}

// aten::hardshrink_backward(Tensor grad_out, Tensor self, Scalar lambd) -> Tensor
at::Tensor hardshrink_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd) {
    
    static auto op = create_hardshrink_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_out, self, lambd);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sinc, name, "aten::sinc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sinc, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sinc, schema_str, "sinc(Tensor self) -> Tensor")

// aten::sinc(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sinc::schema> create_sinc_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sinc::name, sinc::overload_name)
      .typed<sinc::schema>();
}

// aten::sinc(Tensor self) -> Tensor
at::Tensor sinc::call(const at::Tensor & self) {
    
    static auto op = create_sinc_typed_handle();
    return op.call(self);
}

// aten::sinc(Tensor self) -> Tensor
at::Tensor sinc::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_sinc_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sinc_, name, "aten::sinc_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sinc_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sinc_, schema_str, "sinc_(Tensor(a!) self) -> Tensor(a!)")

// aten::sinc_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sinc_::schema> create_sinc__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sinc_::name, sinc_::overload_name)
      .typed<sinc_::schema>();
}

// aten::sinc_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & sinc_::call(at::Tensor & self) {
    
    static auto op = create_sinc__typed_handle();
    return op.call(self);
}

// aten::sinc_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & sinc_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_sinc__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sinc_out, name, "aten::sinc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sinc_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sinc_out, schema_str, "sinc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::sinc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sinc_out::schema> create_sinc_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sinc_out::name, sinc_out::overload_name)
      .typed<sinc_out::schema>();
}

// aten::sinc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sinc_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_sinc_out_typed_handle();
    return op.call(self, out);
}

// aten::sinc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sinc_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_sinc_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_Tensor, name, "aten::slice")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_Tensor, schema_str, "slice.Tensor(Tensor(a) self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor(a)")

// aten::slice.Tensor(Tensor(a) self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<slice_Tensor::schema> create_slice_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(slice_Tensor::name, slice_Tensor::overload_name)
      .typed<slice_Tensor::schema>();
}

// aten::slice.Tensor(Tensor(a) self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor(a)
at::Tensor slice_Tensor::call(const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step) {
    
    static auto op = create_slice_Tensor_typed_handle();
    return op.call(self, dim, start, end, step);
}

// aten::slice.Tensor(Tensor(a) self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor(a)
at::Tensor slice_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step) {
    
    static auto op = create_slice_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, start, end, step);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_inverse, name, "aten::slice_inverse")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_inverse, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_inverse, schema_str, "slice_inverse(Tensor(a) self, Tensor src, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor(a)")

// aten::slice_inverse(Tensor(a) self, Tensor src, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<slice_inverse::schema> create_slice_inverse_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(slice_inverse::name, slice_inverse::overload_name)
      .typed<slice_inverse::schema>();
}

// aten::slice_inverse(Tensor(a) self, Tensor src, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor(a)
at::Tensor slice_inverse::call(const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step) {
    
    static auto op = create_slice_inverse_typed_handle();
    return op.call(self, src, dim, start, end, step);
}

// aten::slice_inverse(Tensor(a) self, Tensor src, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor(a)
at::Tensor slice_inverse::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step) {
    
    static auto op = create_slice_inverse_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, dim, start, end, step);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_scatter, name, "aten::select_scatter")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_scatter, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_scatter, schema_str, "select_scatter(Tensor self, Tensor src, int dim, SymInt index) -> Tensor")

// aten::select_scatter(Tensor self, Tensor src, int dim, SymInt index) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<select_scatter::schema> create_select_scatter_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(select_scatter::name, select_scatter::overload_name)
      .typed<select_scatter::schema>();
}

// aten::select_scatter(Tensor self, Tensor src, int dim, SymInt index) -> Tensor
at::Tensor select_scatter::call(const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::SymInt index) {
    
    static auto op = create_select_scatter_typed_handle();
    return op.call(self, src, dim, index);
}

// aten::select_scatter(Tensor self, Tensor src, int dim, SymInt index) -> Tensor
at::Tensor select_scatter::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::SymInt index) {
    
    static auto op = create_select_scatter_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, dim, index);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(smm, name, "aten::smm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(smm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(smm, schema_str, "smm(Tensor self, Tensor mat2) -> Tensor")

// aten::smm(Tensor self, Tensor mat2) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<smm::schema> create_smm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(smm::name, smm::overload_name)
      .typed<smm::schema>();
}

// aten::smm(Tensor self, Tensor mat2) -> Tensor
at::Tensor smm::call(const at::Tensor & self, const at::Tensor & mat2) {
    
    static auto op = create_smm_typed_handle();
    return op.call(self, mat2);
}

// aten::smm(Tensor self, Tensor mat2) -> Tensor
at::Tensor smm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mat2) {
    
    static auto op = create_smm_typed_handle();
    return op.redispatch(dispatchKeySet, self, mat2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsafe_split_with_sizes, name, "aten::unsafe_split_with_sizes")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsafe_split_with_sizes, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsafe_split_with_sizes, schema_str, "unsafe_split_with_sizes(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]")

// aten::unsafe_split_with_sizes(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<unsafe_split_with_sizes::schema> create_unsafe_split_with_sizes_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unsafe_split_with_sizes::name, unsafe_split_with_sizes::overload_name)
      .typed<unsafe_split_with_sizes::schema>();
}

// aten::unsafe_split_with_sizes(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]
::std::vector<at::Tensor> unsafe_split_with_sizes::call(const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim) {
    
    static auto op = create_unsafe_split_with_sizes_typed_handle();
    return op.call(self, split_sizes, dim);
}

// aten::unsafe_split_with_sizes(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]
::std::vector<at::Tensor> unsafe_split_with_sizes::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim) {
    
    static auto op = create_unsafe_split_with_sizes_typed_handle();
    return op.redispatch(dispatchKeySet, self, split_sizes, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dstack, name, "aten::dstack")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dstack, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dstack, schema_str, "dstack(Tensor[] tensors) -> Tensor")

// aten::dstack(Tensor[] tensors) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<dstack::schema> create_dstack_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(dstack::name, dstack::overload_name)
      .typed<dstack::schema>();
}

// aten::dstack(Tensor[] tensors) -> Tensor
at::Tensor dstack::call(at::TensorList tensors) {
    
    static auto op = create_dstack_typed_handle();
    return op.call(tensors);
}

// aten::dstack(Tensor[] tensors) -> Tensor
at::Tensor dstack::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors) {
    
    static auto op = create_dstack_typed_handle();
    return op.redispatch(dispatchKeySet, tensors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dstack_out, name, "aten::dstack")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dstack_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dstack_out, schema_str, "dstack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)")

// aten::dstack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<dstack_out::schema> create_dstack_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(dstack_out::name, dstack_out::overload_name)
      .typed<dstack_out::schema>();
}

// aten::dstack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & dstack_out::call(at::TensorList tensors, at::Tensor & out) {
    
    static auto op = create_dstack_out_typed_handle();
    return op.call(tensors, out);
}

// aten::dstack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & dstack_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors, at::Tensor & out) {
    
    static auto op = create_dstack_out_typed_handle();
    return op.redispatch(dispatchKeySet, tensors, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod, name, "aten::prod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod, schema_str, "prod(Tensor self, *, ScalarType? dtype=None) -> Tensor")

// aten::prod(Tensor self, *, ScalarType? dtype=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<prod::schema> create_prod_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(prod::name, prod::overload_name)
      .typed<prod::schema>();
}

// aten::prod(Tensor self, *, ScalarType? dtype=None) -> Tensor
at::Tensor prod::call(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_prod_typed_handle();
    return op.call(self, dtype);
}

// aten::prod(Tensor self, *, ScalarType? dtype=None) -> Tensor
at::Tensor prod::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_prod_typed_handle();
    return op.redispatch(dispatchKeySet, self, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_dim_int, name, "aten::prod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_dim_int, overload_name, "dim_int")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_dim_int, schema_str, "prod.dim_int(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor")

// aten::prod.dim_int(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<prod_dim_int::schema> create_prod_dim_int_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(prod_dim_int::name, prod_dim_int::overload_name)
      .typed<prod_dim_int::schema>();
}

// aten::prod.dim_int(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
at::Tensor prod_dim_int::call(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_prod_dim_int_typed_handle();
    return op.call(self, dim, keepdim, dtype);
}

// aten::prod.dim_int(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
at::Tensor prod_dim_int::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_prod_dim_int_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_int_out, name, "aten::prod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_int_out, overload_name, "int_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_int_out, schema_str, "prod.int_out(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)")

// aten::prod.int_out(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<prod_int_out::schema> create_prod_int_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(prod_int_out::name, prod_int_out::overload_name)
      .typed<prod_int_out::schema>();
}

// aten::prod.int_out(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & prod_int_out::call(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_prod_int_out_typed_handle();
    return op.call(self, dim, keepdim, dtype, out);
}

// aten::prod.int_out(Tensor self, int dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & prod_int_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_prod_int_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, dtype, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_dim_Dimname, name, "aten::prod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_dim_Dimname, overload_name, "dim_Dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_dim_Dimname, schema_str, "prod.dim_Dimname(Tensor self, Dimname dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor")

// aten::prod.dim_Dimname(Tensor self, Dimname dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<prod_dim_Dimname::schema> create_prod_dim_Dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(prod_dim_Dimname::name, prod_dim_Dimname::overload_name)
      .typed<prod_dim_Dimname::schema>();
}

// aten::prod.dim_Dimname(Tensor self, Dimname dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
at::Tensor prod_dim_Dimname::call(const at::Tensor & self, at::Dimname dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_prod_dim_Dimname_typed_handle();
    return op.call(self, dim, keepdim, dtype);
}

// aten::prod.dim_Dimname(Tensor self, Dimname dim, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
at::Tensor prod_dim_Dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_prod_dim_Dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_Dimname_out, name, "aten::prod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_Dimname_out, overload_name, "Dimname_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_Dimname_out, schema_str, "prod.Dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)")

// aten::prod.Dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<prod_Dimname_out::schema> create_prod_Dimname_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(prod_Dimname_out::name, prod_Dimname_out::overload_name)
      .typed<prod_Dimname_out::schema>();
}

// aten::prod.Dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & prod_Dimname_out::call(const at::Tensor & self, at::Dimname dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_prod_Dimname_out_typed_handle();
    return op.call(self, dim, keepdim, dtype, out);
}

// aten::prod.Dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & prod_Dimname_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_prod_Dimname_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, dtype, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tan, name, "aten::tan")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tan, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tan, schema_str, "tan(Tensor self) -> Tensor")

// aten::tan(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<tan::schema> create_tan_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(tan::name, tan::overload_name)
      .typed<tan::schema>();
}

// aten::tan(Tensor self) -> Tensor
at::Tensor tan::call(const at::Tensor & self) {
    
    static auto op = create_tan_typed_handle();
    return op.call(self);
}

// aten::tan(Tensor self) -> Tensor
at::Tensor tan::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_tan_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tan_, name, "aten::tan_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tan_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tan_, schema_str, "tan_(Tensor(a!) self) -> Tensor(a!)")

// aten::tan_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<tan_::schema> create_tan__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(tan_::name, tan_::overload_name)
      .typed<tan_::schema>();
}

// aten::tan_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & tan_::call(at::Tensor & self) {
    
    static auto op = create_tan__typed_handle();
    return op.call(self);
}

// aten::tan_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & tan_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_tan__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tan_out, name, "aten::tan")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tan_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tan_out, schema_str, "tan.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::tan.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<tan_out::schema> create_tan_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(tan_out::name, tan_out::overload_name)
      .typed<tan_out::schema>();
}

// aten::tan.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & tan_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_tan_out_typed_handle();
    return op.call(self, out);
}

// aten::tan.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & tan_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_tan_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trapezoid_x, name, "aten::trapezoid")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trapezoid_x, overload_name, "x")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trapezoid_x, schema_str, "trapezoid.x(Tensor y, Tensor x, *, int dim=-1) -> Tensor")

// aten::trapezoid.x(Tensor y, Tensor x, *, int dim=-1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<trapezoid_x::schema> create_trapezoid_x_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(trapezoid_x::name, trapezoid_x::overload_name)
      .typed<trapezoid_x::schema>();
}

// aten::trapezoid.x(Tensor y, Tensor x, *, int dim=-1) -> Tensor
at::Tensor trapezoid_x::call(const at::Tensor & y, const at::Tensor & x, int64_t dim) {
    
    static auto op = create_trapezoid_x_typed_handle();
    return op.call(y, x, dim);
}

// aten::trapezoid.x(Tensor y, Tensor x, *, int dim=-1) -> Tensor
at::Tensor trapezoid_x::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & y, const at::Tensor & x, int64_t dim) {
    
    static auto op = create_trapezoid_x_typed_handle();
    return op.redispatch(dispatchKeySet, y, x, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trapezoid_dx, name, "aten::trapezoid")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trapezoid_dx, overload_name, "dx")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trapezoid_dx, schema_str, "trapezoid.dx(Tensor y, *, Scalar dx=1, int dim=-1) -> Tensor")

// aten::trapezoid.dx(Tensor y, *, Scalar dx=1, int dim=-1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<trapezoid_dx::schema> create_trapezoid_dx_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(trapezoid_dx::name, trapezoid_dx::overload_name)
      .typed<trapezoid_dx::schema>();
}

// aten::trapezoid.dx(Tensor y, *, Scalar dx=1, int dim=-1) -> Tensor
at::Tensor trapezoid_dx::call(const at::Tensor & y, const at::Scalar & dx, int64_t dim) {
    
    static auto op = create_trapezoid_dx_typed_handle();
    return op.call(y, dx, dim);
}

// aten::trapezoid.dx(Tensor y, *, Scalar dx=1, int dim=-1) -> Tensor
at::Tensor trapezoid_dx::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & y, const at::Scalar & dx, int64_t dim) {
    
    static auto op = create_trapezoid_dx_typed_handle();
    return op.redispatch(dispatchKeySet, y, dx, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_from_mask, name, "aten::_nested_tensor_from_mask")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_from_mask, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_from_mask, schema_str, "_nested_tensor_from_mask(Tensor t, Tensor mask, bool mask_check=True) -> Tensor")

// aten::_nested_tensor_from_mask(Tensor t, Tensor mask, bool mask_check=True) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_nested_tensor_from_mask::schema> create__nested_tensor_from_mask_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_nested_tensor_from_mask::name, _nested_tensor_from_mask::overload_name)
      .typed<_nested_tensor_from_mask::schema>();
}

// aten::_nested_tensor_from_mask(Tensor t, Tensor mask, bool mask_check=True) -> Tensor
at::Tensor _nested_tensor_from_mask::call(const at::Tensor & t, const at::Tensor & mask, bool mask_check) {
    
    static auto op = create__nested_tensor_from_mask_typed_handle();
    return op.call(t, mask, mask_check);
}

// aten::_nested_tensor_from_mask(Tensor t, Tensor mask, bool mask_check=True) -> Tensor
at::Tensor _nested_tensor_from_mask::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & t, const at::Tensor & mask, bool mask_check) {
    
    static auto op = create__nested_tensor_from_mask_typed_handle();
    return op.redispatch(dispatchKeySet, t, mask, mask_check);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_from_mask_left_aligned, name, "aten::_nested_tensor_from_mask_left_aligned")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_from_mask_left_aligned, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_from_mask_left_aligned, schema_str, "_nested_tensor_from_mask_left_aligned(Tensor t, Tensor mask) -> bool")

// aten::_nested_tensor_from_mask_left_aligned(Tensor t, Tensor mask) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<_nested_tensor_from_mask_left_aligned::schema> create__nested_tensor_from_mask_left_aligned_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_nested_tensor_from_mask_left_aligned::name, _nested_tensor_from_mask_left_aligned::overload_name)
      .typed<_nested_tensor_from_mask_left_aligned::schema>();
}

// aten::_nested_tensor_from_mask_left_aligned(Tensor t, Tensor mask) -> bool
bool _nested_tensor_from_mask_left_aligned::call(const at::Tensor & t, const at::Tensor & mask) {
    
    static auto op = create__nested_tensor_from_mask_left_aligned_typed_handle();
    return op.call(t, mask);
}

// aten::_nested_tensor_from_mask_left_aligned(Tensor t, Tensor mask) -> bool
bool _nested_tensor_from_mask_left_aligned::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & t, const at::Tensor & mask) {
    
    static auto op = create__nested_tensor_from_mask_left_aligned_typed_handle();
    return op.redispatch(dispatchKeySet, t, mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_size, name, "aten::_nested_tensor_size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_size, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_size, schema_str, "_nested_tensor_size(Tensor self) -> Tensor")

// aten::_nested_tensor_size(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_nested_tensor_size::schema> create__nested_tensor_size_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_nested_tensor_size::name, _nested_tensor_size::overload_name)
      .typed<_nested_tensor_size::schema>();
}

// aten::_nested_tensor_size(Tensor self) -> Tensor
at::Tensor _nested_tensor_size::call(const at::Tensor & self) {
    
    static auto op = create__nested_tensor_size_typed_handle();
    return op.call(self);
}

// aten::_nested_tensor_size(Tensor self) -> Tensor
at::Tensor _nested_tensor_size::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__nested_tensor_size_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_view_from_buffer_copy, name, "aten::_nested_view_from_buffer_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_view_from_buffer_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_view_from_buffer_copy, schema_str, "_nested_view_from_buffer_copy(Tensor self, Tensor nested_size, Tensor nested_strides, Tensor offsets) -> Tensor")

// aten::_nested_view_from_buffer_copy(Tensor self, Tensor nested_size, Tensor nested_strides, Tensor offsets) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_nested_view_from_buffer_copy::schema> create__nested_view_from_buffer_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_nested_view_from_buffer_copy::name, _nested_view_from_buffer_copy::overload_name)
      .typed<_nested_view_from_buffer_copy::schema>();
}

// aten::_nested_view_from_buffer_copy(Tensor self, Tensor nested_size, Tensor nested_strides, Tensor offsets) -> Tensor
at::Tensor _nested_view_from_buffer_copy::call(const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets) {
    
    static auto op = create__nested_view_from_buffer_copy_typed_handle();
    return op.call(self, nested_size, nested_strides, offsets);
}

// aten::_nested_view_from_buffer_copy(Tensor self, Tensor nested_size, Tensor nested_strides, Tensor offsets) -> Tensor
at::Tensor _nested_view_from_buffer_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets) {
    
    static auto op = create__nested_view_from_buffer_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, nested_size, nested_strides, offsets);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unique_dim_consecutive, name, "aten::unique_dim_consecutive")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unique_dim_consecutive, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unique_dim_consecutive, schema_str, "unique_dim_consecutive(Tensor self, int dim, bool return_inverse=False, bool return_counts=False) -> (Tensor, Tensor, Tensor)")

// aten::unique_dim_consecutive(Tensor self, int dim, bool return_inverse=False, bool return_counts=False) -> (Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<unique_dim_consecutive::schema> create_unique_dim_consecutive_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unique_dim_consecutive::name, unique_dim_consecutive::overload_name)
      .typed<unique_dim_consecutive::schema>();
}

// aten::unique_dim_consecutive(Tensor self, int dim, bool return_inverse=False, bool return_counts=False) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> unique_dim_consecutive::call(const at::Tensor & self, int64_t dim, bool return_inverse, bool return_counts) {
    
    static auto op = create_unique_dim_consecutive_typed_handle();
    return op.call(self, dim, return_inverse, return_counts);
}

// aten::unique_dim_consecutive(Tensor self, int dim, bool return_inverse=False, bool return_counts=False) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> unique_dim_consecutive::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool return_inverse, bool return_counts) {
    
    static auto op = create_unique_dim_consecutive_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, return_inverse, return_counts);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unsafe_view, name, "aten::_unsafe_view")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unsafe_view, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unsafe_view, schema_str, "_unsafe_view(Tensor self, SymInt[] size) -> Tensor")

// aten::_unsafe_view(Tensor self, SymInt[] size) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_unsafe_view::schema> create__unsafe_view_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_unsafe_view::name, _unsafe_view::overload_name)
      .typed<_unsafe_view::schema>();
}

// aten::_unsafe_view(Tensor self, SymInt[] size) -> Tensor
at::Tensor _unsafe_view::call(const at::Tensor & self, c10::SymIntArrayRef size) {
    
    static auto op = create__unsafe_view_typed_handle();
    return op.call(self, size);
}

// aten::_unsafe_view(Tensor self, SymInt[] size) -> Tensor
at::Tensor _unsafe_view::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size) {
    
    static auto op = create__unsafe_view_typed_handle();
    return op.redispatch(dispatchKeySet, self, size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze, name, "aten::unsqueeze")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze, schema_str, "unsqueeze(Tensor(a) self, int dim) -> Tensor(a)")

// aten::unsqueeze(Tensor(a) self, int dim) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<unsqueeze::schema> create_unsqueeze_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unsqueeze::name, unsqueeze::overload_name)
      .typed<unsqueeze::schema>();
}

// aten::unsqueeze(Tensor(a) self, int dim) -> Tensor(a)
at::Tensor unsqueeze::call(const at::Tensor & self, int64_t dim) {
    
    static auto op = create_unsqueeze_typed_handle();
    return op.call(self, dim);
}

// aten::unsqueeze(Tensor(a) self, int dim) -> Tensor(a)
at::Tensor unsqueeze::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim) {
    
    static auto op = create_unsqueeze_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze_, name, "aten::unsqueeze_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze_, schema_str, "unsqueeze_(Tensor(a!) self, int dim) -> Tensor(a!)")

// aten::unsqueeze_(Tensor(a!) self, int dim) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<unsqueeze_::schema> create_unsqueeze__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unsqueeze_::name, unsqueeze_::overload_name)
      .typed<unsqueeze_::schema>();
}

// aten::unsqueeze_(Tensor(a!) self, int dim) -> Tensor(a!)
at::Tensor & unsqueeze_::call(at::Tensor & self, int64_t dim) {
    
    static auto op = create_unsqueeze__typed_handle();
    return op.call(self, dim);
}

// aten::unsqueeze_(Tensor(a!) self, int dim) -> Tensor(a!)
at::Tensor & unsqueeze_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, int64_t dim) {
    
    static auto op = create_unsqueeze__typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_efficientzerotensor, name, "aten::_efficientzerotensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_efficientzerotensor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_efficientzerotensor, schema_str, "_efficientzerotensor(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::_efficientzerotensor(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_efficientzerotensor::schema> create__efficientzerotensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_efficientzerotensor::name, _efficientzerotensor::overload_name)
      .typed<_efficientzerotensor::schema>();
}

// aten::_efficientzerotensor(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor _efficientzerotensor::call(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create__efficientzerotensor_typed_handle();
    return op.call(size, dtype, layout, device, pin_memory);
}

// aten::_efficientzerotensor(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor _efficientzerotensor::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create__efficientzerotensor_typed_handle();
    return op.redispatch(dispatchKeySet, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(poisson, name, "aten::poisson")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(poisson, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(poisson, schema_str, "poisson(Tensor self, Generator? generator=None) -> Tensor")

// aten::poisson(Tensor self, Generator? generator=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<poisson::schema> create_poisson_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(poisson::name, poisson::overload_name)
      .typed<poisson::schema>();
}

// aten::poisson(Tensor self, Generator? generator=None) -> Tensor
at::Tensor poisson::call(const at::Tensor & self, c10::optional<at::Generator> generator) {
    
    static auto op = create_poisson_typed_handle();
    return op.call(self, generator);
}

// aten::poisson(Tensor self, Generator? generator=None) -> Tensor
at::Tensor poisson::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Generator> generator) {
    
    static auto op = create_poisson_typed_handle();
    return op.redispatch(dispatchKeySet, self, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_out, name, "aten::sub")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_out, schema_str, "sub.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")

// aten::sub.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sub_out::schema> create_sub_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sub_out::name, sub_out::overload_name)
      .typed<sub_out::schema>();
}

// aten::sub.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sub_out::call(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_sub_out_typed_handle();
    return op.call(self, other, alpha, out);
}

// aten::sub.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sub_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_sub_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_Tensor, name, "aten::sub")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_Tensor, schema_str, "sub.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor")

// aten::sub.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sub_Tensor::schema> create_sub_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sub_Tensor::name, sub_Tensor::overload_name)
      .typed<sub_Tensor::schema>();
}

// aten::sub.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor
at::Tensor sub_Tensor::call(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create_sub_Tensor_typed_handle();
    return op.call(self, other, alpha);
}

// aten::sub.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor
at::Tensor sub_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create_sub_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub__Tensor, name, "aten::sub_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub__Tensor, schema_str, "sub_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)")

// aten::sub_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sub__Tensor::schema> create_sub__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sub__Tensor::name, sub__Tensor::overload_name)
      .typed<sub__Tensor::schema>();
}

// aten::sub_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)
at::Tensor & sub__Tensor::call(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create_sub__Tensor_typed_handle();
    return op.call(self, other, alpha);
}

// aten::sub_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)
at::Tensor & sub__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create_sub__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_Scalar, name, "aten::sub")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_Scalar, schema_str, "sub.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor")

// aten::sub.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sub_Scalar::schema> create_sub_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sub_Scalar::name, sub_Scalar::overload_name)
      .typed<sub_Scalar::schema>();
}

// aten::sub.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor
at::Tensor sub_Scalar::call(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    
    static auto op = create_sub_Scalar_typed_handle();
    return op.call(self, other, alpha);
}

// aten::sub.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor
at::Tensor sub_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    
    static auto op = create_sub_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub__Scalar, name, "aten::sub_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub__Scalar, schema_str, "sub_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)")

// aten::sub_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sub__Scalar::schema> create_sub__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sub__Scalar::name, sub__Scalar::overload_name)
      .typed<sub__Scalar::schema>();
}

// aten::sub_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)
at::Tensor & sub__Scalar::call(at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    
    static auto op = create_sub__Scalar_typed_handle();
    return op.call(self, other, alpha);
}

// aten::sub_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)
at::Tensor & sub__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    
    static auto op = create_sub__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract_out, name, "aten::subtract")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract_out, schema_str, "subtract.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")

// aten::subtract.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<subtract_out::schema> create_subtract_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(subtract_out::name, subtract_out::overload_name)
      .typed<subtract_out::schema>();
}

// aten::subtract.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & subtract_out::call(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_subtract_out_typed_handle();
    return op.call(self, other, alpha, out);
}

// aten::subtract.out(Tensor self, Tensor other, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & subtract_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_subtract_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract_Tensor, name, "aten::subtract")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract_Tensor, schema_str, "subtract.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor")

// aten::subtract.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<subtract_Tensor::schema> create_subtract_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(subtract_Tensor::name, subtract_Tensor::overload_name)
      .typed<subtract_Tensor::schema>();
}

// aten::subtract.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor
at::Tensor subtract_Tensor::call(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create_subtract_Tensor_typed_handle();
    return op.call(self, other, alpha);
}

// aten::subtract.Tensor(Tensor self, Tensor other, *, Scalar alpha=1) -> Tensor
at::Tensor subtract_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create_subtract_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract__Tensor, name, "aten::subtract_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract__Tensor, schema_str, "subtract_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)")

// aten::subtract_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<subtract__Tensor::schema> create_subtract__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(subtract__Tensor::name, subtract__Tensor::overload_name)
      .typed<subtract__Tensor::schema>();
}

// aten::subtract_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)
at::Tensor & subtract__Tensor::call(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create_subtract__Tensor_typed_handle();
    return op.call(self, other, alpha);
}

// aten::subtract_.Tensor(Tensor(a!) self, Tensor other, *, Scalar alpha=1) -> Tensor(a!)
at::Tensor & subtract__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create_subtract__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract_Scalar, name, "aten::subtract")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract_Scalar, schema_str, "subtract.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor")

// aten::subtract.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<subtract_Scalar::schema> create_subtract_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(subtract_Scalar::name, subtract_Scalar::overload_name)
      .typed<subtract_Scalar::schema>();
}

// aten::subtract.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor
at::Tensor subtract_Scalar::call(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    
    static auto op = create_subtract_Scalar_typed_handle();
    return op.call(self, other, alpha);
}

// aten::subtract.Scalar(Tensor self, Scalar other, Scalar alpha=1) -> Tensor
at::Tensor subtract_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    
    static auto op = create_subtract_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract__Scalar, name, "aten::subtract_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(subtract__Scalar, schema_str, "subtract_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)")

// aten::subtract_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<subtract__Scalar::schema> create_subtract__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(subtract__Scalar::name, subtract__Scalar::overload_name)
      .typed<subtract__Scalar::schema>();
}

// aten::subtract_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)
at::Tensor & subtract__Scalar::call(at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    
    static auto op = create_subtract__Scalar_typed_handle();
    return op.call(self, other, alpha);
}

// aten::subtract_.Scalar(Tensor(a!) self, Scalar other, Scalar alpha=1) -> Tensor(a!)
at::Tensor & subtract__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    
    static auto op = create_subtract__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(heaviside_out, name, "aten::heaviside")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(heaviside_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(heaviside_out, schema_str, "heaviside.out(Tensor self, Tensor values, *, Tensor(a!) out) -> Tensor(a!)")

// aten::heaviside.out(Tensor self, Tensor values, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<heaviside_out::schema> create_heaviside_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(heaviside_out::name, heaviside_out::overload_name)
      .typed<heaviside_out::schema>();
}

// aten::heaviside.out(Tensor self, Tensor values, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & heaviside_out::call(const at::Tensor & self, const at::Tensor & values, at::Tensor & out) {
    
    static auto op = create_heaviside_out_typed_handle();
    return op.call(self, values, out);
}

// aten::heaviside.out(Tensor self, Tensor values, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & heaviside_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & values, at::Tensor & out) {
    
    static auto op = create_heaviside_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, values, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(heaviside, name, "aten::heaviside")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(heaviside, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(heaviside, schema_str, "heaviside(Tensor self, Tensor values) -> Tensor")

// aten::heaviside(Tensor self, Tensor values) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<heaviside::schema> create_heaviside_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(heaviside::name, heaviside::overload_name)
      .typed<heaviside::schema>();
}

// aten::heaviside(Tensor self, Tensor values) -> Tensor
at::Tensor heaviside::call(const at::Tensor & self, const at::Tensor & values) {
    
    static auto op = create_heaviside_typed_handle();
    return op.call(self, values);
}

// aten::heaviside(Tensor self, Tensor values) -> Tensor
at::Tensor heaviside::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & values) {
    
    static auto op = create_heaviside_typed_handle();
    return op.redispatch(dispatchKeySet, self, values);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(heaviside_, name, "aten::heaviside_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(heaviside_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(heaviside_, schema_str, "heaviside_(Tensor(a!) self, Tensor values) -> Tensor(a!)")

// aten::heaviside_(Tensor(a!) self, Tensor values) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<heaviside_::schema> create_heaviside__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(heaviside_::name, heaviside_::overload_name)
      .typed<heaviside_::schema>();
}

// aten::heaviside_(Tensor(a!) self, Tensor values) -> Tensor(a!)
at::Tensor & heaviside_::call(at::Tensor & self, const at::Tensor & values) {
    
    static auto op = create_heaviside__typed_handle();
    return op.call(self, values);
}

// aten::heaviside_(Tensor(a!) self, Tensor values) -> Tensor(a!)
at::Tensor & heaviside_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & values) {
    
    static auto op = create_heaviside__typed_handle();
    return op.redispatch(dispatchKeySet, self, values);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_addmm_activation_out, name, "aten::_addmm_activation")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_addmm_activation_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_addmm_activation_out, schema_str, "_addmm_activation.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, bool use_gelu=False, Tensor(a!) out) -> Tensor(a!)")

// aten::_addmm_activation.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, bool use_gelu=False, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_addmm_activation_out::schema> create__addmm_activation_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_addmm_activation_out::name, _addmm_activation_out::overload_name)
      .typed<_addmm_activation_out::schema>();
}

// aten::_addmm_activation.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, bool use_gelu=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _addmm_activation_out::call(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu, at::Tensor & out) {
    
    static auto op = create__addmm_activation_out_typed_handle();
    return op.call(self, mat1, mat2, beta, alpha, use_gelu, out);
}

// aten::_addmm_activation.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, bool use_gelu=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _addmm_activation_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu, at::Tensor & out) {
    
    static auto op = create__addmm_activation_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, mat1, mat2, beta, alpha, use_gelu, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_addmm_activation, name, "aten::_addmm_activation")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_addmm_activation, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_addmm_activation, schema_str, "_addmm_activation(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, bool use_gelu=False) -> Tensor")

// aten::_addmm_activation(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, bool use_gelu=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_addmm_activation::schema> create__addmm_activation_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_addmm_activation::name, _addmm_activation::overload_name)
      .typed<_addmm_activation::schema>();
}

// aten::_addmm_activation(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, bool use_gelu=False) -> Tensor
at::Tensor _addmm_activation::call(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu) {
    
    static auto op = create__addmm_activation_typed_handle();
    return op.call(self, mat1, mat2, beta, alpha, use_gelu);
}

// aten::_addmm_activation(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, bool use_gelu=False) -> Tensor
at::Tensor _addmm_activation::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu) {
    
    static auto op = create__addmm_activation_typed_handle();
    return op.redispatch(dispatchKeySet, self, mat1, mat2, beta, alpha, use_gelu);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_compressed_tensor_comp_plain_value_size, name, "aten::sparse_compressed_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_compressed_tensor_comp_plain_value_size, overload_name, "comp_plain_value_size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_compressed_tensor_comp_plain_value_size, schema_str, "sparse_compressed_tensor.comp_plain_value_size(Tensor compressed_indices, Tensor plain_indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor")

// aten::sparse_compressed_tensor.comp_plain_value_size(Tensor compressed_indices, Tensor plain_indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_compressed_tensor_comp_plain_value_size::schema> create_sparse_compressed_tensor_comp_plain_value_size_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_compressed_tensor_comp_plain_value_size::name, sparse_compressed_tensor_comp_plain_value_size::overload_name)
      .typed<sparse_compressed_tensor_comp_plain_value_size::schema>();
}

// aten::sparse_compressed_tensor.comp_plain_value_size(Tensor compressed_indices, Tensor plain_indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_compressed_tensor_comp_plain_value_size::call(const at::Tensor & compressed_indices, const at::Tensor & plain_indices, const at::Tensor & values, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_compressed_tensor_comp_plain_value_size_typed_handle();
    return op.call(compressed_indices, plain_indices, values, size, dtype, layout, device, pin_memory);
}

// aten::sparse_compressed_tensor.comp_plain_value_size(Tensor compressed_indices, Tensor plain_indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_compressed_tensor_comp_plain_value_size::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & compressed_indices, const at::Tensor & plain_indices, const at::Tensor & values, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_compressed_tensor_comp_plain_value_size_typed_handle();
    return op.redispatch(dispatchKeySet, compressed_indices, plain_indices, values, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsr_tensor_crow_col_value_size, name, "aten::sparse_bsr_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsr_tensor_crow_col_value_size, overload_name, "crow_col_value_size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsr_tensor_crow_col_value_size, schema_str, "sparse_bsr_tensor.crow_col_value_size(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor")

// aten::sparse_bsr_tensor.crow_col_value_size(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_bsr_tensor_crow_col_value_size::schema> create_sparse_bsr_tensor_crow_col_value_size_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_bsr_tensor_crow_col_value_size::name, sparse_bsr_tensor_crow_col_value_size::overload_name)
      .typed<sparse_bsr_tensor_crow_col_value_size::schema>();
}

// aten::sparse_bsr_tensor.crow_col_value_size(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_bsr_tensor_crow_col_value_size::call(const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_bsr_tensor_crow_col_value_size_typed_handle();
    return op.call(crow_indices, col_indices, values, size, dtype, layout, device, pin_memory);
}

// aten::sparse_bsr_tensor.crow_col_value_size(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_bsr_tensor_crow_col_value_size::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_bsr_tensor_crow_col_value_size_typed_handle();
    return op.redispatch(dispatchKeySet, crow_indices, col_indices, values, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_compressed_tensor_comp_plain_value, name, "aten::sparse_compressed_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_compressed_tensor_comp_plain_value, overload_name, "comp_plain_value")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_compressed_tensor_comp_plain_value, schema_str, "sparse_compressed_tensor.comp_plain_value(Tensor compressed_indices, Tensor plain_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor")

// aten::sparse_compressed_tensor.comp_plain_value(Tensor compressed_indices, Tensor plain_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_compressed_tensor_comp_plain_value::schema> create_sparse_compressed_tensor_comp_plain_value_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_compressed_tensor_comp_plain_value::name, sparse_compressed_tensor_comp_plain_value::overload_name)
      .typed<sparse_compressed_tensor_comp_plain_value::schema>();
}

// aten::sparse_compressed_tensor.comp_plain_value(Tensor compressed_indices, Tensor plain_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_compressed_tensor_comp_plain_value::call(const at::Tensor & compressed_indices, const at::Tensor & plain_indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_compressed_tensor_comp_plain_value_typed_handle();
    return op.call(compressed_indices, plain_indices, values, dtype, layout, device, pin_memory);
}

// aten::sparse_compressed_tensor.comp_plain_value(Tensor compressed_indices, Tensor plain_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_compressed_tensor_comp_plain_value::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & compressed_indices, const at::Tensor & plain_indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_compressed_tensor_comp_plain_value_typed_handle();
    return op.redispatch(dispatchKeySet, compressed_indices, plain_indices, values, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsr_tensor_crow_col_value, name, "aten::sparse_bsr_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsr_tensor_crow_col_value, overload_name, "crow_col_value")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsr_tensor_crow_col_value, schema_str, "sparse_bsr_tensor.crow_col_value(Tensor crow_indices, Tensor col_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor")

// aten::sparse_bsr_tensor.crow_col_value(Tensor crow_indices, Tensor col_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_bsr_tensor_crow_col_value::schema> create_sparse_bsr_tensor_crow_col_value_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_bsr_tensor_crow_col_value::name, sparse_bsr_tensor_crow_col_value::overload_name)
      .typed<sparse_bsr_tensor_crow_col_value::schema>();
}

// aten::sparse_bsr_tensor.crow_col_value(Tensor crow_indices, Tensor col_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_bsr_tensor_crow_col_value::call(const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_bsr_tensor_crow_col_value_typed_handle();
    return op.call(crow_indices, col_indices, values, dtype, layout, device, pin_memory);
}

// aten::sparse_bsr_tensor.crow_col_value(Tensor crow_indices, Tensor col_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_bsr_tensor_crow_col_value::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_bsr_tensor_crow_col_value_typed_handle();
    return op.redispatch(dispatchKeySet, crow_indices, col_indices, values, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_size, name, "aten::sparse_coo_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_size, overload_name, "size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_size, schema_str, "sparse_coo_tensor.size(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor")

// aten::sparse_coo_tensor.size(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_coo_tensor_size::schema> create_sparse_coo_tensor_size_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_coo_tensor_size::name, sparse_coo_tensor_size::overload_name)
      .typed<sparse_coo_tensor_size::schema>();
}

// aten::sparse_coo_tensor.size(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_coo_tensor_size::call(at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_coo_tensor_size_typed_handle();
    return op.call(size, dtype, layout, device, pin_memory);
}

// aten::sparse_coo_tensor.size(int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_coo_tensor_size::redispatch(c10::DispatchKeySet dispatchKeySet, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_coo_tensor_size_typed_handle();
    return op.redispatch(dispatchKeySet, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_indices, name, "aten::sparse_coo_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_indices, overload_name, "indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_indices, schema_str, "sparse_coo_tensor.indices(Tensor indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor")

// aten::sparse_coo_tensor.indices(Tensor indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_coo_tensor_indices::schema> create_sparse_coo_tensor_indices_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_coo_tensor_indices::name, sparse_coo_tensor_indices::overload_name)
      .typed<sparse_coo_tensor_indices::schema>();
}

// aten::sparse_coo_tensor.indices(Tensor indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor
at::Tensor sparse_coo_tensor_indices::call(const at::Tensor & indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<bool> is_coalesced) {
    
    static auto op = create_sparse_coo_tensor_indices_typed_handle();
    return op.call(indices, values, dtype, layout, device, pin_memory, is_coalesced);
}

// aten::sparse_coo_tensor.indices(Tensor indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor
at::Tensor sparse_coo_tensor_indices::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<bool> is_coalesced) {
    
    static auto op = create_sparse_coo_tensor_indices_typed_handle();
    return op.redispatch(dispatchKeySet, indices, values, dtype, layout, device, pin_memory, is_coalesced);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_indices_size, name, "aten::sparse_coo_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_indices_size, overload_name, "indices_size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_indices_size, schema_str, "sparse_coo_tensor.indices_size(Tensor indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor")

// aten::sparse_coo_tensor.indices_size(Tensor indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_coo_tensor_indices_size::schema> create_sparse_coo_tensor_indices_size_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_coo_tensor_indices_size::name, sparse_coo_tensor_indices_size::overload_name)
      .typed<sparse_coo_tensor_indices_size::schema>();
}

// aten::sparse_coo_tensor.indices_size(Tensor indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor
at::Tensor sparse_coo_tensor_indices_size::call(const at::Tensor & indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<bool> is_coalesced) {
    
    static auto op = create_sparse_coo_tensor_indices_size_typed_handle();
    return op.call(indices, values, size, dtype, layout, device, pin_memory, is_coalesced);
}

// aten::sparse_coo_tensor.indices_size(Tensor indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor
at::Tensor sparse_coo_tensor_indices_size::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<bool> is_coalesced) {
    
    static auto op = create_sparse_coo_tensor_indices_size_typed_handle();
    return op.redispatch(dispatchKeySet, indices, values, size, dtype, layout, device, pin_memory, is_coalesced);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_compressed_tensor_args, name, "aten::_validate_sparse_compressed_tensor_args")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_compressed_tensor_args, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_compressed_tensor_args, schema_str, "_validate_sparse_compressed_tensor_args(Tensor compressed_indices, Tensor plain_indices, Tensor values, int[] size, Layout layout) -> ()")

// aten::_validate_sparse_compressed_tensor_args(Tensor compressed_indices, Tensor plain_indices, Tensor values, int[] size, Layout layout) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_validate_sparse_compressed_tensor_args::schema> create__validate_sparse_compressed_tensor_args_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_validate_sparse_compressed_tensor_args::name, _validate_sparse_compressed_tensor_args::overload_name)
      .typed<_validate_sparse_compressed_tensor_args::schema>();
}

// aten::_validate_sparse_compressed_tensor_args(Tensor compressed_indices, Tensor plain_indices, Tensor values, int[] size, Layout layout) -> ()
void _validate_sparse_compressed_tensor_args::call(const at::Tensor & compressed_indices, const at::Tensor & plain_indices, const at::Tensor & values, at::IntArrayRef size, at::Layout layout) {
    
    static auto op = create__validate_sparse_compressed_tensor_args_typed_handle();
    return op.call(compressed_indices, plain_indices, values, size, layout);
}

// aten::_validate_sparse_compressed_tensor_args(Tensor compressed_indices, Tensor plain_indices, Tensor values, int[] size, Layout layout) -> ()
void _validate_sparse_compressed_tensor_args::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & compressed_indices, const at::Tensor & plain_indices, const at::Tensor & values, at::IntArrayRef size, at::Layout layout) {
    
    static auto op = create__validate_sparse_compressed_tensor_args_typed_handle();
    return op.redispatch(dispatchKeySet, compressed_indices, plain_indices, values, size, layout);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_and_clear_, name, "aten::sparse_resize_and_clear_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_and_clear_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_and_clear_, schema_str, "sparse_resize_and_clear_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)")

// aten::sparse_resize_and_clear_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sparse_resize_and_clear_::schema> create_sparse_resize_and_clear__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_resize_and_clear_::name, sparse_resize_and_clear_::overload_name)
      .typed<sparse_resize_and_clear_::schema>();
}

// aten::sparse_resize_and_clear_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)
const at::Tensor & sparse_resize_and_clear_::call(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
    
    static auto op = create_sparse_resize_and_clear__typed_handle();
    return op.call(self, size, sparse_dim, dense_dim);
}

// aten::sparse_resize_and_clear_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)
const at::Tensor & sparse_resize_and_clear_::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
    
    static auto op = create_sparse_resize_and_clear__typed_handle();
    return op.redispatch(dispatchKeySet, self, size, sparse_dim, dense_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_dense, name, "aten::to_dense")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_dense, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_dense, schema_str, "to_dense(Tensor self, ScalarType? dtype=None, *, bool? masked_grad=None) -> Tensor")

// aten::to_dense(Tensor self, ScalarType? dtype=None, *, bool? masked_grad=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<to_dense::schema> create_to_dense_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_dense::name, to_dense::overload_name)
      .typed<to_dense::schema>();
}

// aten::to_dense(Tensor self, ScalarType? dtype=None, *, bool? masked_grad=None) -> Tensor
at::Tensor to_dense::call(const at::Tensor & self, c10::optional<at::ScalarType> dtype, c10::optional<bool> masked_grad) {
    
    static auto op = create_to_dense_typed_handle();
    return op.call(self, dtype, masked_grad);
}

// aten::to_dense(Tensor self, ScalarType? dtype=None, *, bool? masked_grad=None) -> Tensor
at::Tensor to_dense::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::ScalarType> dtype, c10::optional<bool> masked_grad) {
    
    static auto op = create_to_dense_typed_handle();
    return op.redispatch(dispatchKeySet, self, dtype, masked_grad);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_dim, name, "aten::sparse_dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_dim, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_dim, schema_str, "sparse_dim(Tensor self) -> int")

// aten::sparse_dim(Tensor self) -> int
static C10_NOINLINE c10::TypedOperatorHandle<sparse_dim::schema> create_sparse_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_dim::name, sparse_dim::overload_name)
      .typed<sparse_dim::schema>();
}

// aten::sparse_dim(Tensor self) -> int
int64_t sparse_dim::call(const at::Tensor & self) {
    
    static auto op = create_sparse_dim_typed_handle();
    return op.call(self);
}

// aten::sparse_dim(Tensor self) -> int
int64_t sparse_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_sparse_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_dimI, name, "aten::_dimI")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_dimI, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_dimI, schema_str, "_dimI(Tensor self) -> int")

// aten::_dimI(Tensor self) -> int
static C10_NOINLINE c10::TypedOperatorHandle<_dimI::schema> create__dimI_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_dimI::name, _dimI::overload_name)
      .typed<_dimI::schema>();
}

// aten::_dimI(Tensor self) -> int
int64_t _dimI::call(const at::Tensor & self) {
    
    static auto op = create__dimI_typed_handle();
    return op.call(self);
}

// aten::_dimI(Tensor self) -> int
int64_t _dimI::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__dimI_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nnz, name, "aten::_nnz")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nnz, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nnz, schema_str, "_nnz(Tensor self) -> int")

// aten::_nnz(Tensor self) -> int
static C10_NOINLINE c10::TypedOperatorHandle<_nnz::schema> create__nnz_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_nnz::name, _nnz::overload_name)
      .typed<_nnz::schema>();
}

// aten::_nnz(Tensor self) -> int
int64_t _nnz::call(const at::Tensor & self) {
    
    static auto op = create__nnz_typed_handle();
    return op.call(self);
}

// aten::_nnz(Tensor self) -> int
int64_t _nnz::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__nnz_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ccol_indices, name, "aten::ccol_indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ccol_indices, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ccol_indices, schema_str, "ccol_indices(Tensor(a) self) -> Tensor(a)")

// aten::ccol_indices(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<ccol_indices::schema> create_ccol_indices_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(ccol_indices::name, ccol_indices::overload_name)
      .typed<ccol_indices::schema>();
}

// aten::ccol_indices(Tensor(a) self) -> Tensor(a)
at::Tensor ccol_indices::call(const at::Tensor & self) {
    
    static auto op = create_ccol_indices_typed_handle();
    return op.call(self);
}

// aten::ccol_indices(Tensor(a) self) -> Tensor(a)
at::Tensor ccol_indices::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_ccol_indices_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse_csr, name, "aten::to_sparse_csr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse_csr, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse_csr, schema_str, "to_sparse_csr(Tensor self, int? dense_dim=None) -> Tensor")

// aten::to_sparse_csr(Tensor self, int? dense_dim=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<to_sparse_csr::schema> create_to_sparse_csr_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_sparse_csr::name, to_sparse_csr::overload_name)
      .typed<to_sparse_csr::schema>();
}

// aten::to_sparse_csr(Tensor self, int? dense_dim=None) -> Tensor
at::Tensor to_sparse_csr::call(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
    
    static auto op = create_to_sparse_csr_typed_handle();
    return op.call(self, dense_dim);
}

// aten::to_sparse_csr(Tensor self, int? dense_dim=None) -> Tensor
at::Tensor to_sparse_csr::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<int64_t> dense_dim) {
    
    static auto op = create_to_sparse_csr_typed_handle();
    return op.redispatch(dispatchKeySet, self, dense_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_csr, name, "aten::_to_sparse_csr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_csr, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_csr, schema_str, "_to_sparse_csr(Tensor self, int? dense_dim=None) -> Tensor")

// aten::_to_sparse_csr(Tensor self, int? dense_dim=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_to_sparse_csr::schema> create__to_sparse_csr_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_to_sparse_csr::name, _to_sparse_csr::overload_name)
      .typed<_to_sparse_csr::schema>();
}

// aten::_to_sparse_csr(Tensor self, int? dense_dim=None) -> Tensor
at::Tensor _to_sparse_csr::call(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
    
    static auto op = create__to_sparse_csr_typed_handle();
    return op.call(self, dense_dim);
}

// aten::_to_sparse_csr(Tensor self, int? dense_dim=None) -> Tensor
at::Tensor _to_sparse_csr::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<int64_t> dense_dim) {
    
    static auto op = create__to_sparse_csr_typed_handle();
    return op.redispatch(dispatchKeySet, self, dense_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse_bsr, name, "aten::to_sparse_bsr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse_bsr, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse_bsr, schema_str, "to_sparse_bsr(Tensor self, int[2] blocksize, int? dense_dim=None) -> Tensor")

// aten::to_sparse_bsr(Tensor self, int[2] blocksize, int? dense_dim=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<to_sparse_bsr::schema> create_to_sparse_bsr_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_sparse_bsr::name, to_sparse_bsr::overload_name)
      .typed<to_sparse_bsr::schema>();
}

// aten::to_sparse_bsr(Tensor self, int[2] blocksize, int? dense_dim=None) -> Tensor
at::Tensor to_sparse_bsr::call(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
    
    static auto op = create_to_sparse_bsr_typed_handle();
    return op.call(self, blocksize, dense_dim);
}

// aten::to_sparse_bsr(Tensor self, int[2] blocksize, int? dense_dim=None) -> Tensor
at::Tensor to_sparse_bsr::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
    
    static auto op = create_to_sparse_bsr_typed_handle();
    return op.redispatch(dispatchKeySet, self, blocksize, dense_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_bsr, name, "aten::_to_sparse_bsr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_bsr, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_bsr, schema_str, "_to_sparse_bsr(Tensor self, int[2] blocksize, int? dense_dim=None) -> Tensor")

// aten::_to_sparse_bsr(Tensor self, int[2] blocksize, int? dense_dim=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_to_sparse_bsr::schema> create__to_sparse_bsr_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_to_sparse_bsr::name, _to_sparse_bsr::overload_name)
      .typed<_to_sparse_bsr::schema>();
}

// aten::_to_sparse_bsr(Tensor self, int[2] blocksize, int? dense_dim=None) -> Tensor
at::Tensor _to_sparse_bsr::call(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
    
    static auto op = create__to_sparse_bsr_typed_handle();
    return op.call(self, blocksize, dense_dim);
}

// aten::_to_sparse_bsr(Tensor self, int[2] blocksize, int? dense_dim=None) -> Tensor
at::Tensor _to_sparse_bsr::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
    
    static auto op = create__to_sparse_bsr_typed_handle();
    return op.redispatch(dispatchKeySet, self, blocksize, dense_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_reorder_conv3d_weight, name, "aten::mkldnn_reorder_conv3d_weight")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_reorder_conv3d_weight, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_reorder_conv3d_weight, schema_str, "mkldnn_reorder_conv3d_weight(Tensor self, SymInt[3] padding=0, SymInt[3] stride=1, SymInt[3] dilation=1, SymInt groups=1) -> Tensor")

// aten::mkldnn_reorder_conv3d_weight(Tensor self, SymInt[3] padding=0, SymInt[3] stride=1, SymInt[3] dilation=1, SymInt groups=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_reorder_conv3d_weight::schema> create_mkldnn_reorder_conv3d_weight_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_reorder_conv3d_weight::name, mkldnn_reorder_conv3d_weight::overload_name)
      .typed<mkldnn_reorder_conv3d_weight::schema>();
}

// aten::mkldnn_reorder_conv3d_weight(Tensor self, SymInt[3] padding=0, SymInt[3] stride=1, SymInt[3] dilation=1, SymInt groups=1) -> Tensor
at::Tensor mkldnn_reorder_conv3d_weight::call(const at::Tensor & self, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_mkldnn_reorder_conv3d_weight_typed_handle();
    return op.call(self, padding, stride, dilation, groups);
}

// aten::mkldnn_reorder_conv3d_weight(Tensor self, SymInt[3] padding=0, SymInt[3] stride=1, SymInt[3] dilation=1, SymInt groups=1) -> Tensor
at::Tensor mkldnn_reorder_conv3d_weight::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_mkldnn_reorder_conv3d_weight_typed_handle();
    return op.redispatch(dispatchKeySet, self, padding, stride, dilation, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(q_scale, name, "aten::q_scale")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(q_scale, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(q_scale, schema_str, "q_scale(Tensor self) -> float")

// aten::q_scale(Tensor self) -> float
static C10_NOINLINE c10::TypedOperatorHandle<q_scale::schema> create_q_scale_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(q_scale::name, q_scale::overload_name)
      .typed<q_scale::schema>();
}

// aten::q_scale(Tensor self) -> float
double q_scale::call(const at::Tensor & self) {
    
    static auto op = create_q_scale_typed_handle();
    return op.call(self);
}

// aten::q_scale(Tensor self) -> float
double q_scale::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_q_scale_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(q_per_channel_axis, name, "aten::q_per_channel_axis")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(q_per_channel_axis, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(q_per_channel_axis, schema_str, "q_per_channel_axis(Tensor self) -> int")

// aten::q_per_channel_axis(Tensor self) -> int
static C10_NOINLINE c10::TypedOperatorHandle<q_per_channel_axis::schema> create_q_per_channel_axis_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(q_per_channel_axis::name, q_per_channel_axis::overload_name)
      .typed<q_per_channel_axis::schema>();
}

// aten::q_per_channel_axis(Tensor self) -> int
int64_t q_per_channel_axis::call(const at::Tensor & self) {
    
    static auto op = create_q_per_channel_axis_typed_handle();
    return op.call(self);
}

// aten::q_per_channel_axis(Tensor self) -> int
int64_t q_per_channel_axis::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_q_per_channel_axis_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_tensor_quantized_tensor, name, "aten::_make_per_tensor_quantized_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_tensor_quantized_tensor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_tensor_quantized_tensor, schema_str, "_make_per_tensor_quantized_tensor(Tensor self, float scale, int zero_point) -> Tensor")

// aten::_make_per_tensor_quantized_tensor(Tensor self, float scale, int zero_point) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_make_per_tensor_quantized_tensor::schema> create__make_per_tensor_quantized_tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_make_per_tensor_quantized_tensor::name, _make_per_tensor_quantized_tensor::overload_name)
      .typed<_make_per_tensor_quantized_tensor::schema>();
}

// aten::_make_per_tensor_quantized_tensor(Tensor self, float scale, int zero_point) -> Tensor
at::Tensor _make_per_tensor_quantized_tensor::call(const at::Tensor & self, double scale, int64_t zero_point) {
    
    static auto op = create__make_per_tensor_quantized_tensor_typed_handle();
    return op.call(self, scale, zero_point);
}

// aten::_make_per_tensor_quantized_tensor(Tensor self, float scale, int zero_point) -> Tensor
at::Tensor _make_per_tensor_quantized_tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double scale, int64_t zero_point) {
    
    static auto op = create__make_per_tensor_quantized_tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, scale, zero_point);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_channel_quantized_tensor, name, "aten::_make_per_channel_quantized_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_channel_quantized_tensor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_channel_quantized_tensor, schema_str, "_make_per_channel_quantized_tensor(Tensor self, Tensor scale, Tensor zero_point, int axis) -> Tensor")

// aten::_make_per_channel_quantized_tensor(Tensor self, Tensor scale, Tensor zero_point, int axis) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_make_per_channel_quantized_tensor::schema> create__make_per_channel_quantized_tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_make_per_channel_quantized_tensor::name, _make_per_channel_quantized_tensor::overload_name)
      .typed<_make_per_channel_quantized_tensor::schema>();
}

// aten::_make_per_channel_quantized_tensor(Tensor self, Tensor scale, Tensor zero_point, int axis) -> Tensor
at::Tensor _make_per_channel_quantized_tensor::call(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis) {
    
    static auto op = create__make_per_channel_quantized_tensor_typed_handle();
    return op.call(self, scale, zero_point, axis);
}

// aten::_make_per_channel_quantized_tensor(Tensor self, Tensor scale, Tensor zero_point, int axis) -> Tensor
at::Tensor _make_per_channel_quantized_tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis) {
    
    static auto op = create__make_per_channel_quantized_tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, scale, zero_point, axis);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_tensor_affine_cachemask_backward, name, "aten::fake_quantize_per_tensor_affine_cachemask_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_tensor_affine_cachemask_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_tensor_affine_cachemask_backward, schema_str, "fake_quantize_per_tensor_affine_cachemask_backward(Tensor grad, Tensor mask) -> Tensor")

// aten::fake_quantize_per_tensor_affine_cachemask_backward(Tensor grad, Tensor mask) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fake_quantize_per_tensor_affine_cachemask_backward::schema> create_fake_quantize_per_tensor_affine_cachemask_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fake_quantize_per_tensor_affine_cachemask_backward::name, fake_quantize_per_tensor_affine_cachemask_backward::overload_name)
      .typed<fake_quantize_per_tensor_affine_cachemask_backward::schema>();
}

// aten::fake_quantize_per_tensor_affine_cachemask_backward(Tensor grad, Tensor mask) -> Tensor
at::Tensor fake_quantize_per_tensor_affine_cachemask_backward::call(const at::Tensor & grad, const at::Tensor & mask) {
    
    static auto op = create_fake_quantize_per_tensor_affine_cachemask_backward_typed_handle();
    return op.call(grad, mask);
}

// aten::fake_quantize_per_tensor_affine_cachemask_backward(Tensor grad, Tensor mask) -> Tensor
at::Tensor fake_quantize_per_tensor_affine_cachemask_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & mask) {
    
    static auto op = create_fake_quantize_per_tensor_affine_cachemask_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine_cachemask_backward, name, "aten::fake_quantize_per_channel_affine_cachemask_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine_cachemask_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine_cachemask_backward, schema_str, "fake_quantize_per_channel_affine_cachemask_backward(Tensor grad, Tensor mask) -> Tensor")

// aten::fake_quantize_per_channel_affine_cachemask_backward(Tensor grad, Tensor mask) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fake_quantize_per_channel_affine_cachemask_backward::schema> create_fake_quantize_per_channel_affine_cachemask_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fake_quantize_per_channel_affine_cachemask_backward::name, fake_quantize_per_channel_affine_cachemask_backward::overload_name)
      .typed<fake_quantize_per_channel_affine_cachemask_backward::schema>();
}

// aten::fake_quantize_per_channel_affine_cachemask_backward(Tensor grad, Tensor mask) -> Tensor
at::Tensor fake_quantize_per_channel_affine_cachemask_backward::call(const at::Tensor & grad, const at::Tensor & mask) {
    
    static auto op = create_fake_quantize_per_channel_affine_cachemask_backward_typed_handle();
    return op.call(grad, mask);
}

// aten::fake_quantize_per_channel_affine_cachemask_backward(Tensor grad, Tensor mask) -> Tensor
at::Tensor fake_quantize_per_channel_affine_cachemask_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & mask) {
    
    static auto op = create_fake_quantize_per_channel_affine_cachemask_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_saturate_weight_to_fp16, name, "aten::_saturate_weight_to_fp16")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_saturate_weight_to_fp16, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_saturate_weight_to_fp16, schema_str, "_saturate_weight_to_fp16(Tensor weight) -> Tensor")

// aten::_saturate_weight_to_fp16(Tensor weight) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_saturate_weight_to_fp16::schema> create__saturate_weight_to_fp16_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_saturate_weight_to_fp16::name, _saturate_weight_to_fp16::overload_name)
      .typed<_saturate_weight_to_fp16::schema>();
}

// aten::_saturate_weight_to_fp16(Tensor weight) -> Tensor
at::Tensor _saturate_weight_to_fp16::call(const at::Tensor & weight) {
    
    static auto op = create__saturate_weight_to_fp16_typed_handle();
    return op.call(weight);
}

// aten::_saturate_weight_to_fp16(Tensor weight) -> Tensor
at::Tensor _saturate_weight_to_fp16::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & weight) {
    
    static auto op = create__saturate_weight_to_fp16_typed_handle();
    return op.redispatch(dispatchKeySet, weight);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_autocast_to_reduced_precision, name, "aten::_autocast_to_reduced_precision")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_autocast_to_reduced_precision, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_autocast_to_reduced_precision, schema_str, "_autocast_to_reduced_precision(Tensor(a) self, bool cuda_enabled, bool cpu_enabled, ScalarType cuda_dtype, ScalarType cpu_dtype) -> Tensor(a)")

// aten::_autocast_to_reduced_precision(Tensor(a) self, bool cuda_enabled, bool cpu_enabled, ScalarType cuda_dtype, ScalarType cpu_dtype) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<_autocast_to_reduced_precision::schema> create__autocast_to_reduced_precision_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_autocast_to_reduced_precision::name, _autocast_to_reduced_precision::overload_name)
      .typed<_autocast_to_reduced_precision::schema>();
}

// aten::_autocast_to_reduced_precision(Tensor(a) self, bool cuda_enabled, bool cpu_enabled, ScalarType cuda_dtype, ScalarType cpu_dtype) -> Tensor(a)
at::Tensor _autocast_to_reduced_precision::call(const at::Tensor & self, bool cuda_enabled, bool cpu_enabled, at::ScalarType cuda_dtype, at::ScalarType cpu_dtype) {
    
    static auto op = create__autocast_to_reduced_precision_typed_handle();
    return op.call(self, cuda_enabled, cpu_enabled, cuda_dtype, cpu_dtype);
}

// aten::_autocast_to_reduced_precision(Tensor(a) self, bool cuda_enabled, bool cpu_enabled, ScalarType cuda_dtype, ScalarType cpu_dtype) -> Tensor(a)
at::Tensor _autocast_to_reduced_precision::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool cuda_enabled, bool cpu_enabled, at::ScalarType cuda_dtype, at::ScalarType cpu_dtype) {
    
    static auto op = create__autocast_to_reduced_precision_typed_handle();
    return op.redispatch(dispatchKeySet, self, cuda_enabled, cpu_enabled, cuda_dtype, cpu_dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Tensor, name, "aten::result_type")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Tensor, schema_str, "result_type.Tensor(Tensor tensor, Tensor other) -> ScalarType")

// aten::result_type.Tensor(Tensor tensor, Tensor other) -> ScalarType
static C10_NOINLINE c10::TypedOperatorHandle<result_type_Tensor::schema> create_result_type_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(result_type_Tensor::name, result_type_Tensor::overload_name)
      .typed<result_type_Tensor::schema>();
}

// aten::result_type.Tensor(Tensor tensor, Tensor other) -> ScalarType
at::ScalarType result_type_Tensor::call(const at::Tensor & tensor, const at::Tensor & other) {
    
    static auto op = create_result_type_Tensor_typed_handle();
    return op.call(tensor, other);
}

// aten::result_type.Tensor(Tensor tensor, Tensor other) -> ScalarType
at::ScalarType result_type_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & tensor, const at::Tensor & other) {
    
    static auto op = create_result_type_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, tensor, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Scalar, name, "aten::result_type")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Scalar, schema_str, "result_type.Scalar(Tensor tensor, Scalar other) -> ScalarType")

// aten::result_type.Scalar(Tensor tensor, Scalar other) -> ScalarType
static C10_NOINLINE c10::TypedOperatorHandle<result_type_Scalar::schema> create_result_type_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(result_type_Scalar::name, result_type_Scalar::overload_name)
      .typed<result_type_Scalar::schema>();
}

// aten::result_type.Scalar(Tensor tensor, Scalar other) -> ScalarType
at::ScalarType result_type_Scalar::call(const at::Tensor & tensor, const at::Scalar & other) {
    
    static auto op = create_result_type_Scalar_typed_handle();
    return op.call(tensor, other);
}

// aten::result_type.Scalar(Tensor tensor, Scalar other) -> ScalarType
at::ScalarType result_type_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & tensor, const at::Scalar & other) {
    
    static auto op = create_result_type_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, tensor, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Scalar_Tensor, name, "aten::result_type")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Scalar_Tensor, overload_name, "Scalar_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Scalar_Tensor, schema_str, "result_type.Scalar_Tensor(Scalar scalar, Tensor tensor) -> ScalarType")

// aten::result_type.Scalar_Tensor(Scalar scalar, Tensor tensor) -> ScalarType
static C10_NOINLINE c10::TypedOperatorHandle<result_type_Scalar_Tensor::schema> create_result_type_Scalar_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(result_type_Scalar_Tensor::name, result_type_Scalar_Tensor::overload_name)
      .typed<result_type_Scalar_Tensor::schema>();
}

// aten::result_type.Scalar_Tensor(Scalar scalar, Tensor tensor) -> ScalarType
at::ScalarType result_type_Scalar_Tensor::call(const at::Scalar & scalar, const at::Tensor & tensor) {
    
    static auto op = create_result_type_Scalar_Tensor_typed_handle();
    return op.call(scalar, tensor);
}

// aten::result_type.Scalar_Tensor(Scalar scalar, Tensor tensor) -> ScalarType
at::ScalarType result_type_Scalar_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & scalar, const at::Tensor & tensor) {
    
    static auto op = create_result_type_Scalar_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, scalar, tensor);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Scalar_Scalar, name, "aten::result_type")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Scalar_Scalar, overload_name, "Scalar_Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(result_type_Scalar_Scalar, schema_str, "result_type.Scalar_Scalar(Scalar scalar1, Scalar scalar2) -> ScalarType")

// aten::result_type.Scalar_Scalar(Scalar scalar1, Scalar scalar2) -> ScalarType
static C10_NOINLINE c10::TypedOperatorHandle<result_type_Scalar_Scalar::schema> create_result_type_Scalar_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(result_type_Scalar_Scalar::name, result_type_Scalar_Scalar::overload_name)
      .typed<result_type_Scalar_Scalar::schema>();
}

// aten::result_type.Scalar_Scalar(Scalar scalar1, Scalar scalar2) -> ScalarType
at::ScalarType result_type_Scalar_Scalar::call(const at::Scalar & scalar1, const at::Scalar & scalar2) {
    
    static auto op = create_result_type_Scalar_Scalar_typed_handle();
    return op.call(scalar1, scalar2);
}

// aten::result_type.Scalar_Scalar(Scalar scalar1, Scalar scalar2) -> ScalarType
at::ScalarType result_type_Scalar_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & scalar1, const at::Scalar & scalar2) {
    
    static auto op = create_result_type_Scalar_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, scalar1, scalar2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_thnn_fused_lstm_cell_backward, name, "aten::_thnn_fused_lstm_cell_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_thnn_fused_lstm_cell_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_thnn_fused_lstm_cell_backward, schema_str, "_thnn_fused_lstm_cell_backward(Tensor? grad_hy, Tensor? grad_cy, Tensor cx, Tensor cy, Tensor workspace, bool has_bias) -> (Tensor, Tensor, Tensor, Tensor, Tensor)")

// aten::_thnn_fused_lstm_cell_backward(Tensor? grad_hy, Tensor? grad_cy, Tensor cx, Tensor cy, Tensor workspace, bool has_bias) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_thnn_fused_lstm_cell_backward::schema> create__thnn_fused_lstm_cell_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_thnn_fused_lstm_cell_backward::name, _thnn_fused_lstm_cell_backward::overload_name)
      .typed<_thnn_fused_lstm_cell_backward::schema>();
}

// aten::_thnn_fused_lstm_cell_backward(Tensor? grad_hy, Tensor? grad_cy, Tensor cx, Tensor cy, Tensor workspace, bool has_bias) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _thnn_fused_lstm_cell_backward::call(const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, const at::Tensor & cx, const at::Tensor & cy, const at::Tensor & workspace, bool has_bias) {
    
    static auto op = create__thnn_fused_lstm_cell_backward_typed_handle();
    return op.call(grad_hy, grad_cy, cx, cy, workspace, has_bias);
}

// aten::_thnn_fused_lstm_cell_backward(Tensor? grad_hy, Tensor? grad_cy, Tensor cx, Tensor cy, Tensor workspace, bool has_bias) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _thnn_fused_lstm_cell_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, const at::Tensor & cx, const at::Tensor & cy, const at::Tensor & workspace, bool has_bias) {
    
    static auto op = create__thnn_fused_lstm_cell_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_hy, grad_cy, cx, cy, workspace, has_bias);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lstm_cell, name, "aten::lstm_cell")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lstm_cell, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lstm_cell, schema_str, "lstm_cell(Tensor input, Tensor[] hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -> (Tensor, Tensor)")

// aten::lstm_cell(Tensor input, Tensor[] hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<lstm_cell::schema> create_lstm_cell_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lstm_cell::name, lstm_cell::overload_name)
      .typed<lstm_cell::schema>();
}

// aten::lstm_cell(Tensor input, Tensor[] hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> lstm_cell::call(const at::Tensor & input, at::TensorList hx, const at::Tensor & w_ih, const at::Tensor & w_hh, const c10::optional<at::Tensor> & b_ih, const c10::optional<at::Tensor> & b_hh) {
    
    static auto op = create_lstm_cell_typed_handle();
    return op.call(input, hx, w_ih, w_hh, b_ih, b_hh);
}

// aten::lstm_cell(Tensor input, Tensor[] hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> lstm_cell::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, at::TensorList hx, const at::Tensor & w_ih, const at::Tensor & w_hh, const c10::optional<at::Tensor> & b_ih, const c10::optional<at::Tensor> & b_hh) {
    
    static auto op = create_lstm_cell_typed_handle();
    return op.redispatch(dispatchKeySet, input, hx, w_ih, w_hh, b_ih, b_hh);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_rnn_relu_cell, name, "aten::quantized_rnn_relu_cell")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_rnn_relu_cell, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_rnn_relu_cell, schema_str, "quantized_rnn_relu_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -> Tensor")

// aten::quantized_rnn_relu_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<quantized_rnn_relu_cell::schema> create_quantized_rnn_relu_cell_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(quantized_rnn_relu_cell::name, quantized_rnn_relu_cell::overload_name)
      .typed<quantized_rnn_relu_cell::schema>();
}

// aten::quantized_rnn_relu_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -> Tensor
at::Tensor quantized_rnn_relu_cell::call(const at::Tensor & input, const at::Tensor & hx, const at::Tensor & w_ih, const at::Tensor & w_hh, const at::Tensor & b_ih, const at::Tensor & b_hh, const at::Tensor & packed_ih, const at::Tensor & packed_hh, const at::Tensor & col_offsets_ih, const at::Tensor & col_offsets_hh, const at::Scalar & scale_ih, const at::Scalar & scale_hh, const at::Scalar & zero_point_ih, const at::Scalar & zero_point_hh) {
    
    static auto op = create_quantized_rnn_relu_cell_typed_handle();
    return op.call(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh);
}

// aten::quantized_rnn_relu_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -> Tensor
at::Tensor quantized_rnn_relu_cell::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & hx, const at::Tensor & w_ih, const at::Tensor & w_hh, const at::Tensor & b_ih, const at::Tensor & b_hh, const at::Tensor & packed_ih, const at::Tensor & packed_hh, const at::Tensor & col_offsets_ih, const at::Tensor & col_offsets_hh, const at::Scalar & scale_ih, const at::Scalar & scale_hh, const at::Scalar & zero_point_ih, const at::Scalar & zero_point_hh) {
    
    static auto op = create_quantized_rnn_relu_cell_typed_handle();
    return op.redispatch(dispatchKeySet, input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill__Scalar, name, "aten::masked_fill_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill__Scalar, schema_str, "masked_fill_.Scalar(Tensor(a!) self, Tensor mask, Scalar value) -> Tensor(a!)")

// aten::masked_fill_.Scalar(Tensor(a!) self, Tensor mask, Scalar value) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<masked_fill__Scalar::schema> create_masked_fill__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_fill__Scalar::name, masked_fill__Scalar::overload_name)
      .typed<masked_fill__Scalar::schema>();
}

// aten::masked_fill_.Scalar(Tensor(a!) self, Tensor mask, Scalar value) -> Tensor(a!)
at::Tensor & masked_fill__Scalar::call(at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
    
    static auto op = create_masked_fill__Scalar_typed_handle();
    return op.call(self, mask, value);
}

// aten::masked_fill_.Scalar(Tensor(a!) self, Tensor mask, Scalar value) -> Tensor(a!)
at::Tensor & masked_fill__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
    
    static auto op = create_masked_fill__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Scalar, name, "aten::masked_fill")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Scalar, schema_str, "masked_fill.Scalar(Tensor self, Tensor mask, Scalar value) -> Tensor")

// aten::masked_fill.Scalar(Tensor self, Tensor mask, Scalar value) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<masked_fill_Scalar::schema> create_masked_fill_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_fill_Scalar::name, masked_fill_Scalar::overload_name)
      .typed<masked_fill_Scalar::schema>();
}

// aten::masked_fill.Scalar(Tensor self, Tensor mask, Scalar value) -> Tensor
at::Tensor masked_fill_Scalar::call(const at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
    
    static auto op = create_masked_fill_Scalar_typed_handle();
    return op.call(self, mask, value);
}

// aten::masked_fill.Scalar(Tensor self, Tensor mask, Scalar value) -> Tensor
at::Tensor masked_fill_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
    
    static auto op = create_masked_fill_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill__Tensor, name, "aten::masked_fill_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill__Tensor, schema_str, "masked_fill_.Tensor(Tensor(a!) self, Tensor mask, Tensor value) -> Tensor(a!)")

// aten::masked_fill_.Tensor(Tensor(a!) self, Tensor mask, Tensor value) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<masked_fill__Tensor::schema> create_masked_fill__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_fill__Tensor::name, masked_fill__Tensor::overload_name)
      .typed<masked_fill__Tensor::schema>();
}

// aten::masked_fill_.Tensor(Tensor(a!) self, Tensor mask, Tensor value) -> Tensor(a!)
at::Tensor & masked_fill__Tensor::call(at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
    
    static auto op = create_masked_fill__Tensor_typed_handle();
    return op.call(self, mask, value);
}

// aten::masked_fill_.Tensor(Tensor(a!) self, Tensor mask, Tensor value) -> Tensor(a!)
at::Tensor & masked_fill__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
    
    static auto op = create_masked_fill__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Tensor, name, "aten::masked_fill")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Tensor, schema_str, "masked_fill.Tensor(Tensor self, Tensor mask, Tensor value) -> Tensor")

// aten::masked_fill.Tensor(Tensor self, Tensor mask, Tensor value) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<masked_fill_Tensor::schema> create_masked_fill_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_fill_Tensor::name, masked_fill_Tensor::overload_name)
      .typed<masked_fill_Tensor::schema>();
}

// aten::masked_fill.Tensor(Tensor self, Tensor mask, Tensor value) -> Tensor
at::Tensor masked_fill_Tensor::call(const at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
    
    static auto op = create_masked_fill_Tensor_typed_handle();
    return op.call(self, mask, value);
}

// aten::masked_fill.Tensor(Tensor self, Tensor mask, Tensor value) -> Tensor
at::Tensor masked_fill_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
    
    static auto op = create_masked_fill_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_scatter_, name, "aten::masked_scatter_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_scatter_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_scatter_, schema_str, "masked_scatter_(Tensor(a!) self, Tensor mask, Tensor source) -> Tensor(a!)")

// aten::masked_scatter_(Tensor(a!) self, Tensor mask, Tensor source) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<masked_scatter_::schema> create_masked_scatter__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_scatter_::name, masked_scatter_::overload_name)
      .typed<masked_scatter_::schema>();
}

// aten::masked_scatter_(Tensor(a!) self, Tensor mask, Tensor source) -> Tensor(a!)
at::Tensor & masked_scatter_::call(at::Tensor & self, const at::Tensor & mask, const at::Tensor & source) {
    
    static auto op = create_masked_scatter__typed_handle();
    return op.call(self, mask, source);
}

// aten::masked_scatter_(Tensor(a!) self, Tensor mask, Tensor source) -> Tensor(a!)
at::Tensor & masked_scatter_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & mask, const at::Tensor & source) {
    
    static auto op = create_masked_scatter__typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, source);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_scatter, name, "aten::masked_scatter")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_scatter, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_scatter, schema_str, "masked_scatter(Tensor self, Tensor mask, Tensor source) -> Tensor")

// aten::masked_scatter(Tensor self, Tensor mask, Tensor source) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<masked_scatter::schema> create_masked_scatter_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_scatter::name, masked_scatter::overload_name)
      .typed<masked_scatter::schema>();
}

// aten::masked_scatter(Tensor self, Tensor mask, Tensor source) -> Tensor
at::Tensor masked_scatter::call(const at::Tensor & self, const at::Tensor & mask, const at::Tensor & source) {
    
    static auto op = create_masked_scatter_typed_handle();
    return op.call(self, mask, source);
}

// aten::masked_scatter(Tensor self, Tensor mask, Tensor source) -> Tensor
at::Tensor masked_scatter::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask, const at::Tensor & source) {
    
    static auto op = create_masked_scatter_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, source);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_softmax_backward, name, "aten::_masked_softmax_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_softmax_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_softmax_backward, schema_str, "_masked_softmax_backward(Tensor grad_output, Tensor output, Tensor mask, int? dim=None) -> Tensor")

// aten::_masked_softmax_backward(Tensor grad_output, Tensor output, Tensor mask, int? dim=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_masked_softmax_backward::schema> create__masked_softmax_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_masked_softmax_backward::name, _masked_softmax_backward::overload_name)
      .typed<_masked_softmax_backward::schema>();
}

// aten::_masked_softmax_backward(Tensor grad_output, Tensor output, Tensor mask, int? dim=None) -> Tensor
at::Tensor _masked_softmax_backward::call(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & mask, c10::optional<int64_t> dim) {
    
    static auto op = create__masked_softmax_backward_typed_handle();
    return op.call(grad_output, output, mask, dim);
}

// aten::_masked_softmax_backward(Tensor grad_output, Tensor output, Tensor mask, int? dim=None) -> Tensor
at::Tensor _masked_softmax_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & mask, c10::optional<int64_t> dim) {
    
    static auto op = create__masked_softmax_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output, mask, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add_out, name, "aten::index_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add_out, schema_str, "index_add.out(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")

// aten::index_add.out(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<index_add_out::schema> create_index_add_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_add_out::name, index_add_out::overload_name)
      .typed<index_add_out::schema>();
}

// aten::index_add.out(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_add_out::call(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_index_add_out_typed_handle();
    return op.call(self, dim, index, source, alpha, out);
}

// aten::index_add.out(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_add_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_index_add_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, source, alpha, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add_, name, "aten::index_add_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add_, schema_str, "index_add_(Tensor(a!) self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor(a!)")

// aten::index_add_(Tensor(a!) self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<index_add_::schema> create_index_add__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_add_::name, index_add_::overload_name)
      .typed<index_add_::schema>();
}

// aten::index_add_(Tensor(a!) self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor(a!)
at::Tensor & index_add_::call(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
    
    static auto op = create_index_add__typed_handle();
    return op.call(self, dim, index, source, alpha);
}

// aten::index_add_(Tensor(a!) self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor(a!)
at::Tensor & index_add_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
    
    static auto op = create_index_add__typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, source, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add, name, "aten::index_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add, schema_str, "index_add(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor")

// aten::index_add(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<index_add::schema> create_index_add_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_add::name, index_add::overload_name)
      .typed<index_add::schema>();
}

// aten::index_add(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor
at::Tensor index_add::call(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
    
    static auto op = create_index_add_typed_handle();
    return op.call(self, dim, index, source, alpha);
}

// aten::index_add(Tensor self, int dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor
at::Tensor index_add::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
    
    static auto op = create_index_add_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, source, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add_dimname, name, "aten::index_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add_dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_add_dimname, schema_str, "index_add.dimname(Tensor self, Dimname dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor")

// aten::index_add.dimname(Tensor self, Dimname dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<index_add_dimname::schema> create_index_add_dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_add_dimname::name, index_add_dimname::overload_name)
      .typed<index_add_dimname::schema>();
}

// aten::index_add.dimname(Tensor self, Dimname dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor
at::Tensor index_add_dimname::call(const at::Tensor & self, at::Dimname dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
    
    static auto op = create_index_add_dimname_typed_handle();
    return op.call(self, dim, index, source, alpha);
}

// aten::index_add.dimname(Tensor self, Dimname dim, Tensor index, Tensor source, *, Scalar alpha=1) -> Tensor
at::Tensor index_add_dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
    
    static auto op = create_index_add_dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, source, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Tensor_out, name, "aten::bitwise_or")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Tensor_out, schema_str, "bitwise_or.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_or.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_or_Tensor_out::schema> create_bitwise_or_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_or_Tensor_out::name, bitwise_or_Tensor_out::overload_name)
      .typed<bitwise_or_Tensor_out::schema>();
}

// aten::bitwise_or.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_or_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_or_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_or.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_or_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_or_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar_out, name, "aten::bitwise_or")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar_out, schema_str, "bitwise_or.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_or.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_or_Scalar_out::schema> create_bitwise_or_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_or_Scalar_out::name, bitwise_or_Scalar_out::overload_name)
      .typed<bitwise_or_Scalar_out::schema>();
}

// aten::bitwise_or.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_or_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_or_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_or.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_or_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_or_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar, name, "aten::bitwise_or")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar, schema_str, "bitwise_or.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::bitwise_or.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_or_Scalar::schema> create_bitwise_or_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_or_Scalar::name, bitwise_or_Scalar::overload_name)
      .typed<bitwise_or_Scalar::schema>();
}

// aten::bitwise_or.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_or_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_or_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_or.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_or_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_or_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar_Tensor, name, "aten::bitwise_or")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar_Tensor, overload_name, "Scalar_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar_Tensor, schema_str, "bitwise_or.Scalar_Tensor(Scalar self, Tensor other) -> Tensor")

// aten::bitwise_or.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_or_Scalar_Tensor::schema> create_bitwise_or_Scalar_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_or_Scalar_Tensor::name, bitwise_or_Scalar_Tensor::overload_name)
      .typed<bitwise_or_Scalar_Tensor::schema>();
}

// aten::bitwise_or.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_or_Scalar_Tensor::call(const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_or_Scalar_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_or.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_or_Scalar_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_or_Scalar_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Tensor, name, "aten::bitwise_or")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Tensor, schema_str, "bitwise_or.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::bitwise_or.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_or_Tensor::schema> create_bitwise_or_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_or_Tensor::name, bitwise_or_Tensor::overload_name)
      .typed<bitwise_or_Tensor::schema>();
}

// aten::bitwise_or.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_or_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_or_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_or.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_or_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_or_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or__Scalar, name, "aten::bitwise_or_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or__Scalar, schema_str, "bitwise_or_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::bitwise_or_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_or__Scalar::schema> create_bitwise_or__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_or__Scalar::name, bitwise_or__Scalar::overload_name)
      .typed<bitwise_or__Scalar::schema>();
}

// aten::bitwise_or_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_or__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_or__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_or_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_or__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_or__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or__Tensor, name, "aten::bitwise_or_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or__Tensor, schema_str, "bitwise_or_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::bitwise_or_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_or__Tensor::schema> create_bitwise_or__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_or__Tensor::name, bitwise_or__Tensor::overload_name)
      .typed<bitwise_or__Tensor::schema>();
}

// aten::bitwise_or_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_or__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_or__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_or_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_or__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_or__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diag_out, name, "aten::diag")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diag_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diag_out, schema_str, "diag.out(Tensor self, int diagonal=0, *, Tensor(a!) out) -> Tensor(a!)")

// aten::diag.out(Tensor self, int diagonal=0, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<diag_out::schema> create_diag_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(diag_out::name, diag_out::overload_name)
      .typed<diag_out::schema>();
}

// aten::diag.out(Tensor self, int diagonal=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & diag_out::call(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
    
    static auto op = create_diag_out_typed_handle();
    return op.call(self, diagonal, out);
}

// aten::diag.out(Tensor self, int diagonal=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & diag_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
    
    static auto op = create_diag_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, diagonal, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diag, name, "aten::diag")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diag, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diag, schema_str, "diag(Tensor self, int diagonal=0) -> Tensor")

// aten::diag(Tensor self, int diagonal=0) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<diag::schema> create_diag_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(diag::name, diag::overload_name)
      .typed<diag::schema>();
}

// aten::diag(Tensor self, int diagonal=0) -> Tensor
at::Tensor diag::call(const at::Tensor & self, int64_t diagonal) {
    
    static auto op = create_diag_typed_handle();
    return op.call(self, diagonal);
}

// aten::diag(Tensor self, int diagonal=0) -> Tensor
at::Tensor diag::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t diagonal) {
    
    static auto op = create_diag_typed_handle();
    return op.redispatch(dispatchKeySet, self, diagonal);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(triu_indices, name, "aten::triu_indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(triu_indices, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(triu_indices, schema_str, "triu_indices(int row, int col, int offset=0, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::triu_indices(int row, int col, int offset=0, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<triu_indices::schema> create_triu_indices_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(triu_indices::name, triu_indices::overload_name)
      .typed<triu_indices::schema>();
}

// aten::triu_indices(int row, int col, int offset=0, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor triu_indices::call(int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_triu_indices_typed_handle();
    return op.call(row, col, offset, dtype, layout, device, pin_memory);
}

// aten::triu_indices(int row, int col, int offset=0, *, ScalarType? dtype=long, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor triu_indices::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_triu_indices_typed_handle();
    return op.redispatch(dispatchKeySet, row, col, offset, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trace, name, "aten::trace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trace, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trace, schema_str, "trace(Tensor self) -> Tensor")

// aten::trace(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<trace::schema> create_trace_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(trace::name, trace::overload_name)
      .typed<trace::schema>();
}

// aten::trace(Tensor self) -> Tensor
at::Tensor trace::call(const at::Tensor & self) {
    
    static auto op = create_trace_typed_handle();
    return op.call(self);
}

// aten::trace(Tensor self) -> Tensor
at::Tensor trace::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_trace_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Scalar_out, name, "aten::greater_equal")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Scalar_out, schema_str, "greater_equal.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::greater_equal.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<greater_equal_Scalar_out::schema> create_greater_equal_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(greater_equal_Scalar_out::name, greater_equal_Scalar_out::overload_name)
      .typed<greater_equal_Scalar_out::schema>();
}

// aten::greater_equal.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & greater_equal_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_greater_equal_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::greater_equal.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & greater_equal_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_greater_equal_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Scalar, name, "aten::greater_equal")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Scalar, schema_str, "greater_equal.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::greater_equal.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<greater_equal_Scalar::schema> create_greater_equal_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(greater_equal_Scalar::name, greater_equal_Scalar::overload_name)
      .typed<greater_equal_Scalar::schema>();
}

// aten::greater_equal.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor greater_equal_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_greater_equal_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::greater_equal.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor greater_equal_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_greater_equal_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Tensor_out, name, "aten::greater_equal")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Tensor_out, schema_str, "greater_equal.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::greater_equal.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<greater_equal_Tensor_out::schema> create_greater_equal_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(greater_equal_Tensor_out::name, greater_equal_Tensor_out::overload_name)
      .typed<greater_equal_Tensor_out::schema>();
}

// aten::greater_equal.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & greater_equal_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_greater_equal_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::greater_equal.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & greater_equal_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_greater_equal_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Tensor, name, "aten::greater_equal")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal_Tensor, schema_str, "greater_equal.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::greater_equal.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<greater_equal_Tensor::schema> create_greater_equal_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(greater_equal_Tensor::name, greater_equal_Tensor::overload_name)
      .typed<greater_equal_Tensor::schema>();
}

// aten::greater_equal.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor greater_equal_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_greater_equal_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::greater_equal.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor greater_equal_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_greater_equal_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal__Scalar, name, "aten::greater_equal_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal__Scalar, schema_str, "greater_equal_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::greater_equal_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<greater_equal__Scalar::schema> create_greater_equal__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(greater_equal__Scalar::name, greater_equal__Scalar::overload_name)
      .typed<greater_equal__Scalar::schema>();
}

// aten::greater_equal_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & greater_equal__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_greater_equal__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::greater_equal_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & greater_equal__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_greater_equal__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal__Tensor, name, "aten::greater_equal_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(greater_equal__Tensor, schema_str, "greater_equal_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::greater_equal_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<greater_equal__Tensor::schema> create_greater_equal__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(greater_equal__Tensor::name, greater_equal__Tensor::overload_name)
      .typed<greater_equal__Tensor::schema>();
}

// aten::greater_equal_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & greater_equal__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_greater_equal__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::greater_equal_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & greater_equal__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_greater_equal__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take_out, name, "aten::take")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take_out, schema_str, "take.out(Tensor self, Tensor index, *, Tensor(a!) out) -> Tensor(a!)")

// aten::take.out(Tensor self, Tensor index, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<take_out::schema> create_take_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(take_out::name, take_out::overload_name)
      .typed<take_out::schema>();
}

// aten::take.out(Tensor self, Tensor index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & take_out::call(const at::Tensor & self, const at::Tensor & index, at::Tensor & out) {
    
    static auto op = create_take_out_typed_handle();
    return op.call(self, index, out);
}

// aten::take.out(Tensor self, Tensor index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & take_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & index, at::Tensor & out) {
    
    static auto op = create_take_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, index, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take, name, "aten::take")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take, schema_str, "take(Tensor self, Tensor index) -> Tensor")

// aten::take(Tensor self, Tensor index) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<take::schema> create_take_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(take::name, take::overload_name)
      .typed<take::schema>();
}

// aten::take(Tensor self, Tensor index) -> Tensor
at::Tensor take::call(const at::Tensor & self, const at::Tensor & index) {
    
    static auto op = create_take_typed_handle();
    return op.call(self, index);
}

// aten::take(Tensor self, Tensor index) -> Tensor
at::Tensor take::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & index) {
    
    static auto op = create_take_typed_handle();
    return op.redispatch(dispatchKeySet, self, index);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_backward, name, "aten::index_select_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_backward, schema_str, "index_select_backward(Tensor grad, SymInt[] self_sizes, int dim, Tensor index) -> Tensor")

// aten::index_select_backward(Tensor grad, SymInt[] self_sizes, int dim, Tensor index) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<index_select_backward::schema> create_index_select_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_select_backward::name, index_select_backward::overload_name)
      .typed<index_select_backward::schema>();
}

// aten::index_select_backward(Tensor grad, SymInt[] self_sizes, int dim, Tensor index) -> Tensor
at::Tensor index_select_backward::call(const at::Tensor & grad, c10::SymIntArrayRef self_sizes, int64_t dim, const at::Tensor & index) {
    
    static auto op = create_index_select_backward_typed_handle();
    return op.call(grad, self_sizes, dim, index);
}

// aten::index_select_backward(Tensor grad, SymInt[] self_sizes, int dim, Tensor index) -> Tensor
at::Tensor index_select_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, c10::SymIntArrayRef self_sizes, int64_t dim, const at::Tensor & index) {
    
    static auto op = create_index_select_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, self_sizes, dim, index);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(argwhere, name, "aten::argwhere")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(argwhere, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(argwhere, schema_str, "argwhere(Tensor self) -> Tensor")

// aten::argwhere(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<argwhere::schema> create_argwhere_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(argwhere::name, argwhere::overload_name)
      .typed<argwhere::schema>();
}

// aten::argwhere(Tensor self) -> Tensor
at::Tensor argwhere::call(const at::Tensor & self) {
    
    static auto op = create_argwhere_typed_handle();
    return op.call(self);
}

// aten::argwhere(Tensor self) -> Tensor
at::Tensor argwhere::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_argwhere_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(svd_U, name, "aten::svd")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(svd_U, overload_name, "U")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(svd_U, schema_str, "svd.U(Tensor self, bool some=True, bool compute_uv=True, *, Tensor(a!) U, Tensor(b!) S, Tensor(c!) V) -> (Tensor(a!) U, Tensor(b!) S, Tensor(c!) V)")

// aten::svd.U(Tensor self, bool some=True, bool compute_uv=True, *, Tensor(a!) U, Tensor(b!) S, Tensor(c!) V) -> (Tensor(a!) U, Tensor(b!) S, Tensor(c!) V)
static C10_NOINLINE c10::TypedOperatorHandle<svd_U::schema> create_svd_U_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(svd_U::name, svd_U::overload_name)
      .typed<svd_U::schema>();
}

// aten::svd.U(Tensor self, bool some=True, bool compute_uv=True, *, Tensor(a!) U, Tensor(b!) S, Tensor(c!) V) -> (Tensor(a!) U, Tensor(b!) S, Tensor(c!) V)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> svd_U::call(const at::Tensor & self, bool some, bool compute_uv, at::Tensor & U, at::Tensor & S, at::Tensor & V) {
    
    static auto op = create_svd_U_typed_handle();
    return op.call(self, some, compute_uv, U, S, V);
}

// aten::svd.U(Tensor self, bool some=True, bool compute_uv=True, *, Tensor(a!) U, Tensor(b!) S, Tensor(c!) V) -> (Tensor(a!) U, Tensor(b!) S, Tensor(c!) V)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> svd_U::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool some, bool compute_uv, at::Tensor & U, at::Tensor & S, at::Tensor & V) {
    
    static auto op = create_svd_U_typed_handle();
    return op.redispatch(dispatchKeySet, self, some, compute_uv, U, S, V);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(svd, name, "aten::svd")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(svd, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(svd, schema_str, "svd(Tensor self, bool some=True, bool compute_uv=True) -> (Tensor U, Tensor S, Tensor V)")

// aten::svd(Tensor self, bool some=True, bool compute_uv=True) -> (Tensor U, Tensor S, Tensor V)
static C10_NOINLINE c10::TypedOperatorHandle<svd::schema> create_svd_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(svd::name, svd::overload_name)
      .typed<svd::schema>();
}

// aten::svd(Tensor self, bool some=True, bool compute_uv=True) -> (Tensor U, Tensor S, Tensor V)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> svd::call(const at::Tensor & self, bool some, bool compute_uv) {
    
    static auto op = create_svd_typed_handle();
    return op.call(self, some, compute_uv);
}

// aten::svd(Tensor self, bool some=True, bool compute_uv=True) -> (Tensor U, Tensor S, Tensor V)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> svd::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool some, bool compute_uv) {
    
    static auto op = create_svd_typed_handle();
    return op.redispatch(dispatchKeySet, self, some, compute_uv);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geqrf_a, name, "aten::geqrf")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geqrf_a, overload_name, "a")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geqrf_a, schema_str, "geqrf.a(Tensor self, *, Tensor(a!) a, Tensor(b!) tau) -> (Tensor(a!) a, Tensor(b!) tau)")

// aten::geqrf.a(Tensor self, *, Tensor(a!) a, Tensor(b!) tau) -> (Tensor(a!) a, Tensor(b!) tau)
static C10_NOINLINE c10::TypedOperatorHandle<geqrf_a::schema> create_geqrf_a_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(geqrf_a::name, geqrf_a::overload_name)
      .typed<geqrf_a::schema>();
}

// aten::geqrf.a(Tensor self, *, Tensor(a!) a, Tensor(b!) tau) -> (Tensor(a!) a, Tensor(b!) tau)
::std::tuple<at::Tensor &,at::Tensor &> geqrf_a::call(const at::Tensor & self, at::Tensor & a, at::Tensor & tau) {
    
    static auto op = create_geqrf_a_typed_handle();
    return op.call(self, a, tau);
}

// aten::geqrf.a(Tensor self, *, Tensor(a!) a, Tensor(b!) tau) -> (Tensor(a!) a, Tensor(b!) tau)
::std::tuple<at::Tensor &,at::Tensor &> geqrf_a::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & a, at::Tensor & tau) {
    
    static auto op = create_geqrf_a_typed_handle();
    return op.redispatch(dispatchKeySet, self, a, tau);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geqrf, name, "aten::geqrf")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geqrf, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geqrf, schema_str, "geqrf(Tensor self) -> (Tensor a, Tensor tau)")

// aten::geqrf(Tensor self) -> (Tensor a, Tensor tau)
static C10_NOINLINE c10::TypedOperatorHandle<geqrf::schema> create_geqrf_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(geqrf::name, geqrf::overload_name)
      .typed<geqrf::schema>();
}

// aten::geqrf(Tensor self) -> (Tensor a, Tensor tau)
::std::tuple<at::Tensor,at::Tensor> geqrf::call(const at::Tensor & self) {
    
    static auto op = create_geqrf_typed_handle();
    return op.call(self);
}

// aten::geqrf(Tensor self) -> (Tensor a, Tensor tau)
::std::tuple<at::Tensor,at::Tensor> geqrf::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_geqrf_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(orgqr, name, "aten::orgqr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(orgqr, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(orgqr, schema_str, "orgqr(Tensor self, Tensor input2) -> Tensor")

// aten::orgqr(Tensor self, Tensor input2) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<orgqr::schema> create_orgqr_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(orgqr::name, orgqr::overload_name)
      .typed<orgqr::schema>();
}

// aten::orgqr(Tensor self, Tensor input2) -> Tensor
at::Tensor orgqr::call(const at::Tensor & self, const at::Tensor & input2) {
    
    static auto op = create_orgqr_typed_handle();
    return op.call(self, input2);
}

// aten::orgqr(Tensor self, Tensor input2) -> Tensor
at::Tensor orgqr::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & input2) {
    
    static auto op = create_orgqr_typed_handle();
    return op.redispatch(dispatchKeySet, self, input2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(orgqr_out, name, "aten::orgqr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(orgqr_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(orgqr_out, schema_str, "orgqr.out(Tensor self, Tensor input2, *, Tensor(a!) out) -> Tensor(a!)")

// aten::orgqr.out(Tensor self, Tensor input2, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<orgqr_out::schema> create_orgqr_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(orgqr_out::name, orgqr_out::overload_name)
      .typed<orgqr_out::schema>();
}

// aten::orgqr.out(Tensor self, Tensor input2, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & orgqr_out::call(const at::Tensor & self, const at::Tensor & input2, at::Tensor & out) {
    
    static auto op = create_orgqr_out_typed_handle();
    return op.call(self, input2, out);
}

// aten::orgqr.out(Tensor self, Tensor input2, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & orgqr_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & input2, at::Tensor & out) {
    
    static auto op = create_orgqr_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, input2, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfinv, name, "aten::erfinv")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfinv, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfinv, schema_str, "erfinv(Tensor self) -> Tensor")

// aten::erfinv(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<erfinv::schema> create_erfinv_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(erfinv::name, erfinv::overload_name)
      .typed<erfinv::schema>();
}

// aten::erfinv(Tensor self) -> Tensor
at::Tensor erfinv::call(const at::Tensor & self) {
    
    static auto op = create_erfinv_typed_handle();
    return op.call(self);
}

// aten::erfinv(Tensor self) -> Tensor
at::Tensor erfinv::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_erfinv_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfinv_, name, "aten::erfinv_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfinv_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfinv_, schema_str, "erfinv_(Tensor(a!) self) -> Tensor(a!)")

// aten::erfinv_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<erfinv_::schema> create_erfinv__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(erfinv_::name, erfinv_::overload_name)
      .typed<erfinv_::schema>();
}

// aten::erfinv_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & erfinv_::call(at::Tensor & self) {
    
    static auto op = create_erfinv__typed_handle();
    return op.call(self);
}

// aten::erfinv_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & erfinv_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_erfinv__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfinv_out, name, "aten::erfinv")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfinv_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(erfinv_out, schema_str, "erfinv.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::erfinv.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<erfinv_out::schema> create_erfinv_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(erfinv_out::name, erfinv_out::overload_name)
      .typed<erfinv_out::schema>();
}

// aten::erfinv.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & erfinv_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_erfinv_out_typed_handle();
    return op.call(self, out);
}

// aten::erfinv.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & erfinv_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_erfinv_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(signbit, name, "aten::signbit")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(signbit, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(signbit, schema_str, "signbit(Tensor self) -> Tensor")

// aten::signbit(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<signbit::schema> create_signbit_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(signbit::name, signbit::overload_name)
      .typed<signbit::schema>();
}

// aten::signbit(Tensor self) -> Tensor
at::Tensor signbit::call(const at::Tensor & self) {
    
    static auto op = create_signbit_typed_handle();
    return op.call(self);
}

// aten::signbit(Tensor self) -> Tensor
at::Tensor signbit::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_signbit_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(signbit_out, name, "aten::signbit")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(signbit_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(signbit_out, schema_str, "signbit.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::signbit.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<signbit_out::schema> create_signbit_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(signbit_out::name, signbit_out::overload_name)
      .typed<signbit_out::schema>();
}

// aten::signbit.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & signbit_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_signbit_out_typed_handle();
    return op.call(self, out);
}

// aten::signbit.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & signbit_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_signbit_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dist, name, "aten::dist")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dist, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dist, schema_str, "dist(Tensor self, Tensor other, Scalar p=2) -> Tensor")

// aten::dist(Tensor self, Tensor other, Scalar p=2) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<dist::schema> create_dist_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(dist::name, dist::overload_name)
      .typed<dist::schema>();
}

// aten::dist(Tensor self, Tensor other, Scalar p=2) -> Tensor
at::Tensor dist::call(const at::Tensor & self, const at::Tensor & other, const at::Scalar & p) {
    
    static auto op = create_dist_typed_handle();
    return op.call(self, other, p);
}

// aten::dist(Tensor self, Tensor other, Scalar p=2) -> Tensor
at::Tensor dist::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, const at::Scalar & p) {
    
    static auto op = create_dist_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, p);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_histogramdd_from_bin_cts, name, "aten::_histogramdd_from_bin_cts")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_histogramdd_from_bin_cts, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_histogramdd_from_bin_cts, schema_str, "_histogramdd_from_bin_cts(Tensor self, int[] bins, *, float[]? range=None, Tensor? weight=None, bool density=False) -> Tensor")

// aten::_histogramdd_from_bin_cts(Tensor self, int[] bins, *, float[]? range=None, Tensor? weight=None, bool density=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_histogramdd_from_bin_cts::schema> create__histogramdd_from_bin_cts_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_histogramdd_from_bin_cts::name, _histogramdd_from_bin_cts::overload_name)
      .typed<_histogramdd_from_bin_cts::schema>();
}

// aten::_histogramdd_from_bin_cts(Tensor self, int[] bins, *, float[]? range=None, Tensor? weight=None, bool density=False) -> Tensor
at::Tensor _histogramdd_from_bin_cts::call(const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
    
    static auto op = create__histogramdd_from_bin_cts_typed_handle();
    return op.call(self, bins, range, weight, density);
}

// aten::_histogramdd_from_bin_cts(Tensor self, int[] bins, *, float[]? range=None, Tensor? weight=None, bool density=False) -> Tensor
at::Tensor _histogramdd_from_bin_cts::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
    
    static auto op = create__histogramdd_from_bin_cts_typed_handle();
    return op.redispatch(dispatchKeySet, self, bins, range, weight, density);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Scalar_out, name, "aten::fmod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Scalar_out, schema_str, "fmod.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::fmod.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fmod_Scalar_out::schema> create_fmod_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fmod_Scalar_out::name, fmod_Scalar_out::overload_name)
      .typed<fmod_Scalar_out::schema>();
}

// aten::fmod.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fmod_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_fmod_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::fmod.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fmod_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_fmod_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Scalar, name, "aten::fmod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Scalar, schema_str, "fmod.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::fmod.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fmod_Scalar::schema> create_fmod_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fmod_Scalar::name, fmod_Scalar::overload_name)
      .typed<fmod_Scalar::schema>();
}

// aten::fmod.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor fmod_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_fmod_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::fmod.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor fmod_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_fmod_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod__Scalar, name, "aten::fmod_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod__Scalar, schema_str, "fmod_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::fmod_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fmod__Scalar::schema> create_fmod__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fmod__Scalar::name, fmod__Scalar::overload_name)
      .typed<fmod__Scalar::schema>();
}

// aten::fmod_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & fmod__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_fmod__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::fmod_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & fmod__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_fmod__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Tensor_out, name, "aten::fmod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Tensor_out, schema_str, "fmod.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::fmod.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fmod_Tensor_out::schema> create_fmod_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fmod_Tensor_out::name, fmod_Tensor_out::overload_name)
      .typed<fmod_Tensor_out::schema>();
}

// aten::fmod.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fmod_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_fmod_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::fmod.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fmod_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_fmod_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Tensor, name, "aten::fmod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod_Tensor, schema_str, "fmod.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::fmod.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fmod_Tensor::schema> create_fmod_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fmod_Tensor::name, fmod_Tensor::overload_name)
      .typed<fmod_Tensor::schema>();
}

// aten::fmod.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor fmod_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_fmod_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::fmod.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor fmod_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_fmod_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod__Tensor, name, "aten::fmod_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fmod__Tensor, schema_str, "fmod_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::fmod_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fmod__Tensor::schema> create_fmod__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fmod__Tensor::name, fmod__Tensor::overload_name)
      .typed<fmod__Tensor::schema>();
}

// aten::fmod_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & fmod__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_fmod__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::fmod_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & fmod__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_fmod__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar_out, name, "aten::remainder")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar_out, schema_str, "remainder.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::remainder.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<remainder_Scalar_out::schema> create_remainder_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(remainder_Scalar_out::name, remainder_Scalar_out::overload_name)
      .typed<remainder_Scalar_out::schema>();
}

// aten::remainder.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & remainder_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_remainder_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::remainder.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & remainder_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_remainder_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar, name, "aten::remainder")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar, schema_str, "remainder.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::remainder.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<remainder_Scalar::schema> create_remainder_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(remainder_Scalar::name, remainder_Scalar::overload_name)
      .typed<remainder_Scalar::schema>();
}

// aten::remainder.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor remainder_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_remainder_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::remainder.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor remainder_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_remainder_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder__Scalar, name, "aten::remainder_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder__Scalar, schema_str, "remainder_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::remainder_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<remainder__Scalar::schema> create_remainder__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(remainder__Scalar::name, remainder__Scalar::overload_name)
      .typed<remainder__Scalar::schema>();
}

// aten::remainder_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & remainder__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_remainder__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::remainder_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & remainder__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_remainder__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Tensor_out, name, "aten::remainder")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Tensor_out, schema_str, "remainder.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::remainder.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<remainder_Tensor_out::schema> create_remainder_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(remainder_Tensor_out::name, remainder_Tensor_out::overload_name)
      .typed<remainder_Tensor_out::schema>();
}

// aten::remainder.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & remainder_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_remainder_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::remainder.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & remainder_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_remainder_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Tensor, name, "aten::remainder")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Tensor, schema_str, "remainder.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::remainder.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<remainder_Tensor::schema> create_remainder_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(remainder_Tensor::name, remainder_Tensor::overload_name)
      .typed<remainder_Tensor::schema>();
}

// aten::remainder.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor remainder_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_remainder_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::remainder.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor remainder_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_remainder_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder__Tensor, name, "aten::remainder_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder__Tensor, schema_str, "remainder_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::remainder_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<remainder__Tensor::schema> create_remainder__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(remainder__Tensor::name, remainder__Tensor::overload_name)
      .typed<remainder__Tensor::schema>();
}

// aten::remainder_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & remainder__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_remainder__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::remainder_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & remainder__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_remainder__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar_Tensor, name, "aten::remainder")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar_Tensor, overload_name, "Scalar_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar_Tensor, schema_str, "remainder.Scalar_Tensor(Scalar self, Tensor other) -> Tensor")

// aten::remainder.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<remainder_Scalar_Tensor::schema> create_remainder_Scalar_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(remainder_Scalar_Tensor::name, remainder_Scalar_Tensor::overload_name)
      .typed<remainder_Scalar_Tensor::schema>();
}

// aten::remainder.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor remainder_Scalar_Tensor::call(const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_remainder_Scalar_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::remainder.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor remainder_Scalar_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_remainder_Scalar_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile, name, "aten::nanquantile")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile, schema_str, "nanquantile(Tensor self, Tensor q, int? dim=None, bool keepdim=False, *, str interpolation='linear') -> Tensor")

// aten::nanquantile(Tensor self, Tensor q, int? dim=None, bool keepdim=False, *, str interpolation='linear') -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<nanquantile::schema> create_nanquantile_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanquantile::name, nanquantile::overload_name)
      .typed<nanquantile::schema>();
}

// aten::nanquantile(Tensor self, Tensor q, int? dim=None, bool keepdim=False, *, str interpolation='linear') -> Tensor
at::Tensor nanquantile::call(const at::Tensor & self, const at::Tensor & q, c10::optional<int64_t> dim, bool keepdim, c10::string_view interpolation) {
    
    static auto op = create_nanquantile_typed_handle();
    return op.call(self, q, dim, keepdim, interpolation);
}

// aten::nanquantile(Tensor self, Tensor q, int? dim=None, bool keepdim=False, *, str interpolation='linear') -> Tensor
at::Tensor nanquantile::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & q, c10::optional<int64_t> dim, bool keepdim, c10::string_view interpolation) {
    
    static auto op = create_nanquantile_typed_handle();
    return op.redispatch(dispatchKeySet, self, q, dim, keepdim, interpolation);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile_out, name, "aten::nanquantile")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile_out, schema_str, "nanquantile.out(Tensor self, Tensor q, int? dim=None, bool keepdim=False, *, str interpolation='linear', Tensor(a!) out) -> Tensor(a!)")

// aten::nanquantile.out(Tensor self, Tensor q, int? dim=None, bool keepdim=False, *, str interpolation='linear', Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<nanquantile_out::schema> create_nanquantile_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanquantile_out::name, nanquantile_out::overload_name)
      .typed<nanquantile_out::schema>();
}

// aten::nanquantile.out(Tensor self, Tensor q, int? dim=None, bool keepdim=False, *, str interpolation='linear', Tensor(a!) out) -> Tensor(a!)
at::Tensor & nanquantile_out::call(const at::Tensor & self, const at::Tensor & q, c10::optional<int64_t> dim, bool keepdim, c10::string_view interpolation, at::Tensor & out) {
    
    static auto op = create_nanquantile_out_typed_handle();
    return op.call(self, q, dim, keepdim, interpolation, out);
}

// aten::nanquantile.out(Tensor self, Tensor q, int? dim=None, bool keepdim=False, *, str interpolation='linear', Tensor(a!) out) -> Tensor(a!)
at::Tensor & nanquantile_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & q, c10::optional<int64_t> dim, bool keepdim, c10::string_view interpolation, at::Tensor & out) {
    
    static auto op = create_nanquantile_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, q, dim, keepdim, interpolation, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile_scalar, name, "aten::nanquantile")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile_scalar, overload_name, "scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile_scalar, schema_str, "nanquantile.scalar(Tensor self, float q, int? dim=None, bool keepdim=False, *, str interpolation='linear') -> Tensor")

// aten::nanquantile.scalar(Tensor self, float q, int? dim=None, bool keepdim=False, *, str interpolation='linear') -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<nanquantile_scalar::schema> create_nanquantile_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanquantile_scalar::name, nanquantile_scalar::overload_name)
      .typed<nanquantile_scalar::schema>();
}

// aten::nanquantile.scalar(Tensor self, float q, int? dim=None, bool keepdim=False, *, str interpolation='linear') -> Tensor
at::Tensor nanquantile_scalar::call(const at::Tensor & self, double q, c10::optional<int64_t> dim, bool keepdim, c10::string_view interpolation) {
    
    static auto op = create_nanquantile_scalar_typed_handle();
    return op.call(self, q, dim, keepdim, interpolation);
}

// aten::nanquantile.scalar(Tensor self, float q, int? dim=None, bool keepdim=False, *, str interpolation='linear') -> Tensor
at::Tensor nanquantile_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double q, c10::optional<int64_t> dim, bool keepdim, c10::string_view interpolation) {
    
    static auto op = create_nanquantile_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, q, dim, keepdim, interpolation);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile_scalar_out, name, "aten::nanquantile")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile_scalar_out, overload_name, "scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanquantile_scalar_out, schema_str, "nanquantile.scalar_out(Tensor self, float q, int? dim=None, bool keepdim=False, *, str interpolation='linear', Tensor(a!) out) -> Tensor(a!)")

// aten::nanquantile.scalar_out(Tensor self, float q, int? dim=None, bool keepdim=False, *, str interpolation='linear', Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<nanquantile_scalar_out::schema> create_nanquantile_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanquantile_scalar_out::name, nanquantile_scalar_out::overload_name)
      .typed<nanquantile_scalar_out::schema>();
}

// aten::nanquantile.scalar_out(Tensor self, float q, int? dim=None, bool keepdim=False, *, str interpolation='linear', Tensor(a!) out) -> Tensor(a!)
at::Tensor & nanquantile_scalar_out::call(const at::Tensor & self, double q, c10::optional<int64_t> dim, bool keepdim, c10::string_view interpolation, at::Tensor & out) {
    
    static auto op = create_nanquantile_scalar_out_typed_handle();
    return op.call(self, q, dim, keepdim, interpolation, out);
}

// aten::nanquantile.scalar_out(Tensor self, float q, int? dim=None, bool keepdim=False, *, str interpolation='linear', Tensor(a!) out) -> Tensor(a!)
at::Tensor & nanquantile_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double q, c10::optional<int64_t> dim, bool keepdim, c10::string_view interpolation, at::Tensor & out) {
    
    static auto op = create_nanquantile_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, q, dim, keepdim, interpolation, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any, name, "aten::any")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any, schema_str, "any(Tensor self) -> Tensor")

// aten::any(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<any::schema> create_any_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(any::name, any::overload_name)
      .typed<any::schema>();
}

// aten::any(Tensor self) -> Tensor
at::Tensor any::call(const at::Tensor & self) {
    
    static auto op = create_any_typed_handle();
    return op.call(self);
}

// aten::any(Tensor self) -> Tensor
at::Tensor any::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_any_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_all_out, name, "aten::any")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_all_out, overload_name, "all_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(any_all_out, schema_str, "any.all_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::any.all_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<any_all_out::schema> create_any_all_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(any_all_out::name, any_all_out::overload_name)
      .typed<any_all_out::schema>();
}

// aten::any.all_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & any_all_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_any_all_out_typed_handle();
    return op.call(self, out);
}

// aten::any.all_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & any_all_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_any_all_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(renorm_out, name, "aten::renorm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(renorm_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(renorm_out, schema_str, "renorm.out(Tensor self, Scalar p, int dim, Scalar maxnorm, *, Tensor(a!) out) -> Tensor(a!)")

// aten::renorm.out(Tensor self, Scalar p, int dim, Scalar maxnorm, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<renorm_out::schema> create_renorm_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(renorm_out::name, renorm_out::overload_name)
      .typed<renorm_out::schema>();
}

// aten::renorm.out(Tensor self, Scalar p, int dim, Scalar maxnorm, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & renorm_out::call(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm, at::Tensor & out) {
    
    static auto op = create_renorm_out_typed_handle();
    return op.call(self, p, dim, maxnorm, out);
}

// aten::renorm.out(Tensor self, Scalar p, int dim, Scalar maxnorm, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & renorm_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm, at::Tensor & out) {
    
    static auto op = create_renorm_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, p, dim, maxnorm, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(renorm, name, "aten::renorm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(renorm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(renorm, schema_str, "renorm(Tensor self, Scalar p, int dim, Scalar maxnorm) -> Tensor")

// aten::renorm(Tensor self, Scalar p, int dim, Scalar maxnorm) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<renorm::schema> create_renorm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(renorm::name, renorm::overload_name)
      .typed<renorm::schema>();
}

// aten::renorm(Tensor self, Scalar p, int dim, Scalar maxnorm) -> Tensor
at::Tensor renorm::call(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
    
    static auto op = create_renorm_typed_handle();
    return op.call(self, p, dim, maxnorm);
}

// aten::renorm(Tensor self, Scalar p, int dim, Scalar maxnorm) -> Tensor
at::Tensor renorm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
    
    static auto op = create_renorm_typed_handle();
    return op.redispatch(dispatchKeySet, self, p, dim, maxnorm);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(renorm_, name, "aten::renorm_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(renorm_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(renorm_, schema_str, "renorm_(Tensor(a!) self, Scalar p, int dim, Scalar maxnorm) -> Tensor(a!)")

// aten::renorm_(Tensor(a!) self, Scalar p, int dim, Scalar maxnorm) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<renorm_::schema> create_renorm__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(renorm_::name, renorm_::overload_name)
      .typed<renorm_::schema>();
}

// aten::renorm_(Tensor(a!) self, Scalar p, int dim, Scalar maxnorm) -> Tensor(a!)
at::Tensor & renorm_::call(at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
    
    static auto op = create_renorm__typed_handle();
    return op.call(self, p, dim, maxnorm);
}

// aten::renorm_(Tensor(a!) self, Scalar p, int dim, Scalar maxnorm) -> Tensor(a!)
at::Tensor & renorm_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
    
    static auto op = create_renorm__typed_handle();
    return op.redispatch(dispatchKeySet, self, p, dim, maxnorm);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unfold, name, "aten::unfold")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unfold, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unfold, schema_str, "unfold(Tensor(a) self, int dimension, int size, int step) -> Tensor(a)")

// aten::unfold(Tensor(a) self, int dimension, int size, int step) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<unfold::schema> create_unfold_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unfold::name, unfold::overload_name)
      .typed<unfold::schema>();
}

// aten::unfold(Tensor(a) self, int dimension, int size, int step) -> Tensor(a)
at::Tensor unfold::call(const at::Tensor & self, int64_t dimension, int64_t size, int64_t step) {
    
    static auto op = create_unfold_typed_handle();
    return op.call(self, dimension, size, step);
}

// aten::unfold(Tensor(a) self, int dimension, int size, int step) -> Tensor(a)
at::Tensor unfold::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dimension, int64_t size, int64_t step) {
    
    static auto op = create_unfold_typed_handle();
    return op.redispatch(dispatchKeySet, self, dimension, size, step);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Tensor_out, name, "aten::float_power")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Tensor_out, overload_name, "Tensor_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Tensor_out, schema_str, "float_power.Tensor_Tensor_out(Tensor self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)")

// aten::float_power.Tensor_Tensor_out(Tensor self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<float_power_Tensor_Tensor_out::schema> create_float_power_Tensor_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(float_power_Tensor_Tensor_out::name, float_power_Tensor_Tensor_out::overload_name)
      .typed<float_power_Tensor_Tensor_out::schema>();
}

// aten::float_power.Tensor_Tensor_out(Tensor self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & float_power_Tensor_Tensor_out::call(const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
    
    static auto op = create_float_power_Tensor_Tensor_out_typed_handle();
    return op.call(self, exponent, out);
}

// aten::float_power.Tensor_Tensor_out(Tensor self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & float_power_Tensor_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
    
    static auto op = create_float_power_Tensor_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Tensor, name, "aten::float_power")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Tensor, overload_name, "Tensor_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Tensor, schema_str, "float_power.Tensor_Tensor(Tensor self, Tensor exponent) -> Tensor")

// aten::float_power.Tensor_Tensor(Tensor self, Tensor exponent) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<float_power_Tensor_Tensor::schema> create_float_power_Tensor_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(float_power_Tensor_Tensor::name, float_power_Tensor_Tensor::overload_name)
      .typed<float_power_Tensor_Tensor::schema>();
}

// aten::float_power.Tensor_Tensor(Tensor self, Tensor exponent) -> Tensor
at::Tensor float_power_Tensor_Tensor::call(const at::Tensor & self, const at::Tensor & exponent) {
    
    static auto op = create_float_power_Tensor_Tensor_typed_handle();
    return op.call(self, exponent);
}

// aten::float_power.Tensor_Tensor(Tensor self, Tensor exponent) -> Tensor
at::Tensor float_power_Tensor_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & exponent) {
    
    static auto op = create_float_power_Tensor_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Scalar_out, name, "aten::float_power")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Scalar_out, schema_str, "float_power.Scalar_out(Scalar self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)")

// aten::float_power.Scalar_out(Scalar self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<float_power_Scalar_out::schema> create_float_power_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(float_power_Scalar_out::name, float_power_Scalar_out::overload_name)
      .typed<float_power_Scalar_out::schema>();
}

// aten::float_power.Scalar_out(Scalar self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & float_power_Scalar_out::call(const at::Scalar & self, const at::Tensor & exponent, at::Tensor & out) {
    
    static auto op = create_float_power_Scalar_out_typed_handle();
    return op.call(self, exponent, out);
}

// aten::float_power.Scalar_out(Scalar self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & float_power_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & exponent, at::Tensor & out) {
    
    static auto op = create_float_power_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Scalar, name, "aten::float_power")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Scalar, schema_str, "float_power.Scalar(Scalar self, Tensor exponent) -> Tensor")

// aten::float_power.Scalar(Scalar self, Tensor exponent) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<float_power_Scalar::schema> create_float_power_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(float_power_Scalar::name, float_power_Scalar::overload_name)
      .typed<float_power_Scalar::schema>();
}

// aten::float_power.Scalar(Scalar self, Tensor exponent) -> Tensor
at::Tensor float_power_Scalar::call(const at::Scalar & self, const at::Tensor & exponent) {
    
    static auto op = create_float_power_Scalar_typed_handle();
    return op.call(self, exponent);
}

// aten::float_power.Scalar(Scalar self, Tensor exponent) -> Tensor
at::Tensor float_power_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & exponent) {
    
    static auto op = create_float_power_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Scalar_out, name, "aten::float_power")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Scalar_out, overload_name, "Tensor_Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Scalar_out, schema_str, "float_power.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)")

// aten::float_power.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<float_power_Tensor_Scalar_out::schema> create_float_power_Tensor_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(float_power_Tensor_Scalar_out::name, float_power_Tensor_Scalar_out::overload_name)
      .typed<float_power_Tensor_Scalar_out::schema>();
}

// aten::float_power.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & float_power_Tensor_Scalar_out::call(const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
    
    static auto op = create_float_power_Tensor_Scalar_out_typed_handle();
    return op.call(self, exponent, out);
}

// aten::float_power.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & float_power_Tensor_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
    
    static auto op = create_float_power_Tensor_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Scalar, name, "aten::float_power")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Scalar, overload_name, "Tensor_Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power_Tensor_Scalar, schema_str, "float_power.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor")

// aten::float_power.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<float_power_Tensor_Scalar::schema> create_float_power_Tensor_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(float_power_Tensor_Scalar::name, float_power_Tensor_Scalar::overload_name)
      .typed<float_power_Tensor_Scalar::schema>();
}

// aten::float_power.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor
at::Tensor float_power_Tensor_Scalar::call(const at::Tensor & self, const at::Scalar & exponent) {
    
    static auto op = create_float_power_Tensor_Scalar_typed_handle();
    return op.call(self, exponent);
}

// aten::float_power.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor
at::Tensor float_power_Tensor_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & exponent) {
    
    static auto op = create_float_power_Tensor_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power__Scalar, name, "aten::float_power_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power__Scalar, schema_str, "float_power_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)")

// aten::float_power_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<float_power__Scalar::schema> create_float_power__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(float_power__Scalar::name, float_power__Scalar::overload_name)
      .typed<float_power__Scalar::schema>();
}

// aten::float_power_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)
at::Tensor & float_power__Scalar::call(at::Tensor & self, const at::Scalar & exponent) {
    
    static auto op = create_float_power__Scalar_typed_handle();
    return op.call(self, exponent);
}

// aten::float_power_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)
at::Tensor & float_power__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & exponent) {
    
    static auto op = create_float_power__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power__Tensor, name, "aten::float_power_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(float_power__Tensor, schema_str, "float_power_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)")

// aten::float_power_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<float_power__Tensor::schema> create_float_power__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(float_power__Tensor::name, float_power__Tensor::overload_name)
      .typed<float_power__Tensor::schema>();
}

// aten::float_power_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)
at::Tensor & float_power__Tensor::call(at::Tensor & self, const at::Tensor & exponent) {
    
    static auto op = create_float_power__Tensor_typed_handle();
    return op.call(self, exponent);
}

// aten::float_power_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)
at::Tensor & float_power__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & exponent) {
    
    static auto op = create_float_power__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_Scalar, name, "aten::_foreach_clamp_max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_Scalar, schema_str, "_foreach_clamp_max.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]")

// aten::_foreach_clamp_max.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_max_Scalar::schema> create__foreach_clamp_max_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_max_Scalar::name, _foreach_clamp_max_Scalar::overload_name)
      .typed<_foreach_clamp_max_Scalar::schema>();
}

// aten::_foreach_clamp_max.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_max_Scalar::call(at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_clamp_max_Scalar_typed_handle();
    return op.call(self, scalar);
}

// aten::_foreach_clamp_max.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_max_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_clamp_max_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max__Scalar, name, "aten::_foreach_clamp_max_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max__Scalar, schema_str, "_foreach_clamp_max_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()")

// aten::_foreach_clamp_max_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_max__Scalar::schema> create__foreach_clamp_max__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_max__Scalar::name, _foreach_clamp_max__Scalar::overload_name)
      .typed<_foreach_clamp_max__Scalar::schema>();
}

// aten::_foreach_clamp_max_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
void _foreach_clamp_max__Scalar::call(at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_clamp_max__Scalar_typed_handle();
    return op.call(self, scalar);
}

// aten::_foreach_clamp_max_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
void _foreach_clamp_max__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_clamp_max__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_List, name, "aten::_foreach_clamp_max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_List, schema_str, "_foreach_clamp_max.List(Tensor[] self, Tensor[] other) -> Tensor[]")

// aten::_foreach_clamp_max.List(Tensor[] self, Tensor[] other) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_max_List::schema> create__foreach_clamp_max_List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_max_List::name, _foreach_clamp_max_List::overload_name)
      .typed<_foreach_clamp_max_List::schema>();
}

// aten::_foreach_clamp_max.List(Tensor[] self, Tensor[] other) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_max_List::call(at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_clamp_max_List_typed_handle();
    return op.call(self, other);
}

// aten::_foreach_clamp_max.List(Tensor[] self, Tensor[] other) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_max_List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_clamp_max_List_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max__List, name, "aten::_foreach_clamp_max_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max__List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max__List, schema_str, "_foreach_clamp_max_.List(Tensor(a!)[] self, Tensor[] other) -> ()")

// aten::_foreach_clamp_max_.List(Tensor(a!)[] self, Tensor[] other) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_max__List::schema> create__foreach_clamp_max__List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_max__List::name, _foreach_clamp_max__List::overload_name)
      .typed<_foreach_clamp_max__List::schema>();
}

// aten::_foreach_clamp_max_.List(Tensor(a!)[] self, Tensor[] other) -> ()
void _foreach_clamp_max__List::call(at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_clamp_max__List_typed_handle();
    return op.call(self, other);
}

// aten::_foreach_clamp_max_.List(Tensor(a!)[] self, Tensor[] other) -> ()
void _foreach_clamp_max__List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_clamp_max__List_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_ScalarList, name, "aten::_foreach_clamp_max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_ScalarList, overload_name, "ScalarList")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_ScalarList, schema_str, "_foreach_clamp_max.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]")

// aten::_foreach_clamp_max.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_max_ScalarList::schema> create__foreach_clamp_max_ScalarList_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_max_ScalarList::name, _foreach_clamp_max_ScalarList::overload_name)
      .typed<_foreach_clamp_max_ScalarList::schema>();
}

// aten::_foreach_clamp_max.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_max_ScalarList::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_clamp_max_ScalarList_typed_handle();
    return op.call(self, scalars);
}

// aten::_foreach_clamp_max.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_max_ScalarList::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_clamp_max_ScalarList_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max__ScalarList, name, "aten::_foreach_clamp_max_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max__ScalarList, overload_name, "ScalarList")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max__ScalarList, schema_str, "_foreach_clamp_max_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()")

// aten::_foreach_clamp_max_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_max__ScalarList::schema> create__foreach_clamp_max__ScalarList_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_max__ScalarList::name, _foreach_clamp_max__ScalarList::overload_name)
      .typed<_foreach_clamp_max__ScalarList::schema>();
}

// aten::_foreach_clamp_max_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
void _foreach_clamp_max__ScalarList::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_clamp_max__ScalarList_typed_handle();
    return op.call(self, scalars);
}

// aten::_foreach_clamp_max_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
void _foreach_clamp_max__ScalarList::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_clamp_max__ScalarList_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_abs, name, "aten::_foreach_abs")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_abs, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_abs, schema_str, "_foreach_abs(Tensor[] self) -> Tensor[]")

// aten::_foreach_abs(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_abs::schema> create__foreach_abs_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_abs::name, _foreach_abs::overload_name)
      .typed<_foreach_abs::schema>();
}

// aten::_foreach_abs(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_abs::call(at::TensorList self) {
    
    static auto op = create__foreach_abs_typed_handle();
    return op.call(self);
}

// aten::_foreach_abs(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_abs::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_abs_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_abs_, name, "aten::_foreach_abs_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_abs_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_abs_, schema_str, "_foreach_abs_(Tensor(a!)[] self) -> ()")

// aten::_foreach_abs_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_abs_::schema> create__foreach_abs__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_abs_::name, _foreach_abs_::overload_name)
      .typed<_foreach_abs_::schema>();
}

// aten::_foreach_abs_(Tensor(a!)[] self) -> ()
void _foreach_abs_::call(at::TensorList self) {
    
    static auto op = create__foreach_abs__typed_handle();
    return op.call(self);
}

// aten::_foreach_abs_(Tensor(a!)[] self) -> ()
void _foreach_abs_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_abs__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_expm1, name, "aten::_foreach_expm1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_expm1, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_expm1, schema_str, "_foreach_expm1(Tensor[] self) -> Tensor[]")

// aten::_foreach_expm1(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_expm1::schema> create__foreach_expm1_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_expm1::name, _foreach_expm1::overload_name)
      .typed<_foreach_expm1::schema>();
}

// aten::_foreach_expm1(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_expm1::call(at::TensorList self) {
    
    static auto op = create__foreach_expm1_typed_handle();
    return op.call(self);
}

// aten::_foreach_expm1(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_expm1::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_expm1_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_expm1_, name, "aten::_foreach_expm1_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_expm1_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_expm1_, schema_str, "_foreach_expm1_(Tensor(a!)[] self) -> ()")

// aten::_foreach_expm1_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_expm1_::schema> create__foreach_expm1__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_expm1_::name, _foreach_expm1_::overload_name)
      .typed<_foreach_expm1_::schema>();
}

// aten::_foreach_expm1_(Tensor(a!)[] self) -> ()
void _foreach_expm1_::call(at::TensorList self) {
    
    static auto op = create__foreach_expm1__typed_handle();
    return op.call(self);
}

// aten::_foreach_expm1_(Tensor(a!)[] self) -> ()
void _foreach_expm1_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_expm1__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_log10, name, "aten::_foreach_log10")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_log10, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_log10, schema_str, "_foreach_log10(Tensor[] self) -> Tensor[]")

// aten::_foreach_log10(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_log10::schema> create__foreach_log10_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_log10::name, _foreach_log10::overload_name)
      .typed<_foreach_log10::schema>();
}

// aten::_foreach_log10(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_log10::call(at::TensorList self) {
    
    static auto op = create__foreach_log10_typed_handle();
    return op.call(self);
}

// aten::_foreach_log10(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_log10::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_log10_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_log10_, name, "aten::_foreach_log10_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_log10_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_log10_, schema_str, "_foreach_log10_(Tensor(a!)[] self) -> ()")

// aten::_foreach_log10_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_log10_::schema> create__foreach_log10__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_log10_::name, _foreach_log10_::overload_name)
      .typed<_foreach_log10_::schema>();
}

// aten::_foreach_log10_(Tensor(a!)[] self) -> ()
void _foreach_log10_::call(at::TensorList self) {
    
    static auto op = create__foreach_log10__typed_handle();
    return op.call(self);
}

// aten::_foreach_log10_(Tensor(a!)[] self) -> ()
void _foreach_log10_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_log10__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sign, name, "aten::_foreach_sign")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sign, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sign, schema_str, "_foreach_sign(Tensor[] self) -> Tensor[]")

// aten::_foreach_sign(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_sign::schema> create__foreach_sign_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_sign::name, _foreach_sign::overload_name)
      .typed<_foreach_sign::schema>();
}

// aten::_foreach_sign(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_sign::call(at::TensorList self) {
    
    static auto op = create__foreach_sign_typed_handle();
    return op.call(self);
}

// aten::_foreach_sign(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_sign::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_sign_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sign_, name, "aten::_foreach_sign_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sign_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sign_, schema_str, "_foreach_sign_(Tensor(a!)[] self) -> ()")

// aten::_foreach_sign_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_sign_::schema> create__foreach_sign__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_sign_::name, _foreach_sign_::overload_name)
      .typed<_foreach_sign_::schema>();
}

// aten::_foreach_sign_(Tensor(a!)[] self) -> ()
void _foreach_sign_::call(at::TensorList self) {
    
    static auto op = create__foreach_sign__typed_handle();
    return op.call(self);
}

// aten::_foreach_sign_(Tensor(a!)[] self) -> ()
void _foreach_sign_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_sign__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sinh, name, "aten::_foreach_sinh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sinh, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sinh, schema_str, "_foreach_sinh(Tensor[] self) -> Tensor[]")

// aten::_foreach_sinh(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_sinh::schema> create__foreach_sinh_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_sinh::name, _foreach_sinh::overload_name)
      .typed<_foreach_sinh::schema>();
}

// aten::_foreach_sinh(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_sinh::call(at::TensorList self) {
    
    static auto op = create__foreach_sinh_typed_handle();
    return op.call(self);
}

// aten::_foreach_sinh(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_sinh::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_sinh_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sinh_, name, "aten::_foreach_sinh_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sinh_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sinh_, schema_str, "_foreach_sinh_(Tensor(a!)[] self) -> ()")

// aten::_foreach_sinh_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_sinh_::schema> create__foreach_sinh__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_sinh_::name, _foreach_sinh_::overload_name)
      .typed<_foreach_sinh_::schema>();
}

// aten::_foreach_sinh_(Tensor(a!)[] self) -> ()
void _foreach_sinh_::call(at::TensorList self) {
    
    static auto op = create__foreach_sinh__typed_handle();
    return op.call(self);
}

// aten::_foreach_sinh_(Tensor(a!)[] self) -> ()
void _foreach_sinh_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_sinh__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_tan, name, "aten::_foreach_tan")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_tan, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_tan, schema_str, "_foreach_tan(Tensor[] self) -> Tensor[]")

// aten::_foreach_tan(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_tan::schema> create__foreach_tan_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_tan::name, _foreach_tan::overload_name)
      .typed<_foreach_tan::schema>();
}

// aten::_foreach_tan(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_tan::call(at::TensorList self) {
    
    static auto op = create__foreach_tan_typed_handle();
    return op.call(self);
}

// aten::_foreach_tan(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_tan::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_tan_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_tan_, name, "aten::_foreach_tan_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_tan_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_tan_, schema_str, "_foreach_tan_(Tensor(a!)[] self) -> ()")

// aten::_foreach_tan_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_tan_::schema> create__foreach_tan__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_tan_::name, _foreach_tan_::overload_name)
      .typed<_foreach_tan_::schema>();
}

// aten::_foreach_tan_(Tensor(a!)[] self) -> ()
void _foreach_tan_::call(at::TensorList self) {
    
    static auto op = create__foreach_tan__typed_handle();
    return op.call(self);
}

// aten::_foreach_tan_(Tensor(a!)[] self) -> ()
void _foreach_tan_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_tan__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_copy_, name, "aten::_foreach_copy_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_copy_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_copy_, schema_str, "_foreach_copy_(Tensor(a!)[] self, Tensor[] src, bool non_blocking=False) -> ()")

// aten::_foreach_copy_(Tensor(a!)[] self, Tensor[] src, bool non_blocking=False) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_copy_::schema> create__foreach_copy__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_copy_::name, _foreach_copy_::overload_name)
      .typed<_foreach_copy_::schema>();
}

// aten::_foreach_copy_(Tensor(a!)[] self, Tensor[] src, bool non_blocking=False) -> ()
void _foreach_copy_::call(at::TensorList self, at::TensorList src, bool non_blocking) {
    
    static auto op = create__foreach_copy__typed_handle();
    return op.call(self, src, non_blocking);
}

// aten::_foreach_copy_(Tensor(a!)[] self, Tensor[] src, bool non_blocking=False) -> ()
void _foreach_copy_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList src, bool non_blocking) {
    
    static auto op = create__foreach_copy__typed_handle();
    return op.redispatch(dispatchKeySet, self, src, non_blocking);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Tensor, name, "aten::searchsorted")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Tensor, schema_str, "searchsorted.Tensor(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor")

// aten::searchsorted.Tensor(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<searchsorted_Tensor::schema> create_searchsorted_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(searchsorted_Tensor::name, searchsorted_Tensor::overload_name)
      .typed<searchsorted_Tensor::schema>();
}

// aten::searchsorted.Tensor(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor
at::Tensor searchsorted_Tensor::call(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
    
    static auto op = create_searchsorted_Tensor_typed_handle();
    return op.call(sorted_sequence, self, out_int32, right, side, sorter);
}

// aten::searchsorted.Tensor(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor
at::Tensor searchsorted_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
    
    static auto op = create_searchsorted_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, sorted_sequence, self, out_int32, right, side, sorter);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Tensor_out, name, "aten::searchsorted")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Tensor_out, schema_str, "searchsorted.Tensor_out(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)")

// aten::searchsorted.Tensor_out(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<searchsorted_Tensor_out::schema> create_searchsorted_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(searchsorted_Tensor_out::name, searchsorted_Tensor_out::overload_name)
      .typed<searchsorted_Tensor_out::schema>();
}

// aten::searchsorted.Tensor_out(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & searchsorted_Tensor_out::call(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
    
    static auto op = create_searchsorted_Tensor_out_typed_handle();
    return op.call(sorted_sequence, self, out_int32, right, side, sorter, out);
}

// aten::searchsorted.Tensor_out(Tensor sorted_sequence, Tensor self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & searchsorted_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
    
    static auto op = create_searchsorted_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, sorted_sequence, self, out_int32, right, side, sorter, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Scalar, name, "aten::searchsorted")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Scalar, schema_str, "searchsorted.Scalar(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor")

// aten::searchsorted.Scalar(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<searchsorted_Scalar::schema> create_searchsorted_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(searchsorted_Scalar::name, searchsorted_Scalar::overload_name)
      .typed<searchsorted_Scalar::schema>();
}

// aten::searchsorted.Scalar(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor
at::Tensor searchsorted_Scalar::call(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
    
    static auto op = create_searchsorted_Scalar_typed_handle();
    return op.call(sorted_sequence, self, out_int32, right, side, sorter);
}

// aten::searchsorted.Scalar(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None) -> Tensor
at::Tensor searchsorted_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
    
    static auto op = create_searchsorted_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, sorted_sequence, self, out_int32, right, side, sorter);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Scalar_out, name, "aten::searchsorted")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(searchsorted_Scalar_out, schema_str, "searchsorted.Scalar_out(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)")

// aten::searchsorted.Scalar_out(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<searchsorted_Scalar_out::schema> create_searchsorted_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(searchsorted_Scalar_out::name, searchsorted_Scalar_out::overload_name)
      .typed<searchsorted_Scalar_out::schema>();
}

// aten::searchsorted.Scalar_out(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & searchsorted_Scalar_out::call(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
    
    static auto op = create_searchsorted_Scalar_out_typed_handle();
    return op.call(sorted_sequence, self, out_int32, right, side, sorter, out);
}

// aten::searchsorted.Scalar_out(Tensor sorted_sequence, Scalar self, *, bool out_int32=False, bool right=False, str? side=None, Tensor? sorter=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & searchsorted_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
    
    static auto op = create_searchsorted_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, sorted_sequence, self, out_int32, right, side, sorter, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(smooth_l1_loss_out, name, "aten::smooth_l1_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(smooth_l1_loss_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(smooth_l1_loss_out, schema_str, "smooth_l1_loss.out(Tensor self, Tensor target, int reduction=Mean, float beta=1.0, *, Tensor(a!) out) -> Tensor(a!)")

// aten::smooth_l1_loss.out(Tensor self, Tensor target, int reduction=Mean, float beta=1.0, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<smooth_l1_loss_out::schema> create_smooth_l1_loss_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(smooth_l1_loss_out::name, smooth_l1_loss_out::overload_name)
      .typed<smooth_l1_loss_out::schema>();
}

// aten::smooth_l1_loss.out(Tensor self, Tensor target, int reduction=Mean, float beta=1.0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & smooth_l1_loss_out::call(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & out) {
    
    static auto op = create_smooth_l1_loss_out_typed_handle();
    return op.call(self, target, reduction, beta, out);
}

// aten::smooth_l1_loss.out(Tensor self, Tensor target, int reduction=Mean, float beta=1.0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & smooth_l1_loss_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & out) {
    
    static auto op = create_smooth_l1_loss_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, target, reduction, beta, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(smooth_l1_loss, name, "aten::smooth_l1_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(smooth_l1_loss, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(smooth_l1_loss, schema_str, "smooth_l1_loss(Tensor self, Tensor target, int reduction=Mean, float beta=1.0) -> Tensor")

// aten::smooth_l1_loss(Tensor self, Tensor target, int reduction=Mean, float beta=1.0) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<smooth_l1_loss::schema> create_smooth_l1_loss_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(smooth_l1_loss::name, smooth_l1_loss::overload_name)
      .typed<smooth_l1_loss::schema>();
}

// aten::smooth_l1_loss(Tensor self, Tensor target, int reduction=Mean, float beta=1.0) -> Tensor
at::Tensor smooth_l1_loss::call(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
    
    static auto op = create_smooth_l1_loss_typed_handle();
    return op.call(self, target, reduction, beta);
}

// aten::smooth_l1_loss(Tensor self, Tensor target, int reduction=Mean, float beta=1.0) -> Tensor
at::Tensor smooth_l1_loss::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
    
    static auto op = create_smooth_l1_loss_typed_handle();
    return op.redispatch(dispatchKeySet, self, target, reduction, beta);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_out, name, "aten::elu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_out, schema_str, "elu.out(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1, *, Tensor(a!) out) -> Tensor(a!)")

// aten::elu.out(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<elu_out::schema> create_elu_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(elu_out::name, elu_out::overload_name)
      .typed<elu_out::schema>();
}

// aten::elu.out(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & elu_out::call(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, at::Tensor & out) {
    
    static auto op = create_elu_out_typed_handle();
    return op.call(self, alpha, scale, input_scale, out);
}

// aten::elu.out(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & elu_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, at::Tensor & out) {
    
    static auto op = create_elu_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, alpha, scale, input_scale, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu, name, "aten::elu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu, schema_str, "elu(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor")

// aten::elu(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<elu::schema> create_elu_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(elu::name, elu::overload_name)
      .typed<elu::schema>();
}

// aten::elu(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor
at::Tensor elu::call(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
    
    static auto op = create_elu_typed_handle();
    return op.call(self, alpha, scale, input_scale);
}

// aten::elu(Tensor self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor
at::Tensor elu::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
    
    static auto op = create_elu_typed_handle();
    return op.redispatch(dispatchKeySet, self, alpha, scale, input_scale);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_, name, "aten::elu_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_, schema_str, "elu_(Tensor(a!) self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor(a!)")

// aten::elu_(Tensor(a!) self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<elu_::schema> create_elu__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(elu_::name, elu_::overload_name)
      .typed<elu_::schema>();
}

// aten::elu_(Tensor(a!) self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor(a!)
at::Tensor & elu_::call(at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
    
    static auto op = create_elu__typed_handle();
    return op.call(self, alpha, scale, input_scale);
}

// aten::elu_(Tensor(a!) self, Scalar alpha=1, Scalar scale=1, Scalar input_scale=1) -> Tensor(a!)
at::Tensor & elu_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
    
    static auto op = create_elu__typed_handle();
    return op.redispatch(dispatchKeySet, self, alpha, scale, input_scale);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(glu_backward_grad_input, name, "aten::glu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(glu_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(glu_backward_grad_input, schema_str, "glu_backward.grad_input(Tensor grad_output, Tensor self, int dim, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::glu_backward.grad_input(Tensor grad_output, Tensor self, int dim, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<glu_backward_grad_input::schema> create_glu_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(glu_backward_grad_input::name, glu_backward_grad_input::overload_name)
      .typed<glu_backward_grad_input::schema>();
}

// aten::glu_backward.grad_input(Tensor grad_output, Tensor self, int dim, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & glu_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim, at::Tensor & grad_input) {
    
    static auto op = create_glu_backward_grad_input_typed_handle();
    return op.call(grad_output, self, dim, grad_input);
}

// aten::glu_backward.grad_input(Tensor grad_output, Tensor self, int dim, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & glu_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, int64_t dim, at::Tensor & grad_input) {
    
    static auto op = create_glu_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, dim, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(glu_backward, name, "aten::glu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(glu_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(glu_backward, schema_str, "glu_backward(Tensor grad_output, Tensor self, int dim) -> Tensor")

// aten::glu_backward(Tensor grad_output, Tensor self, int dim) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<glu_backward::schema> create_glu_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(glu_backward::name, glu_backward::overload_name)
      .typed<glu_backward::schema>();
}

// aten::glu_backward(Tensor grad_output, Tensor self, int dim) -> Tensor
at::Tensor glu_backward::call(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim) {
    
    static auto op = create_glu_backward_typed_handle();
    return op.call(grad_output, self, dim);
}

// aten::glu_backward(Tensor grad_output, Tensor self, int dim) -> Tensor
at::Tensor glu_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, int64_t dim) {
    
    static auto op = create_glu_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardtanh_backward_grad_input, name, "aten::hardtanh_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardtanh_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardtanh_backward_grad_input, schema_str, "hardtanh_backward.grad_input(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::hardtanh_backward.grad_input(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<hardtanh_backward_grad_input::schema> create_hardtanh_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(hardtanh_backward_grad_input::name, hardtanh_backward_grad_input::overload_name)
      .typed<hardtanh_backward_grad_input::schema>();
}

// aten::hardtanh_backward.grad_input(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & hardtanh_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & grad_input) {
    
    static auto op = create_hardtanh_backward_grad_input_typed_handle();
    return op.call(grad_output, self, min_val, max_val, grad_input);
}

// aten::hardtanh_backward.grad_input(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & hardtanh_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & grad_input) {
    
    static auto op = create_hardtanh_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, min_val, max_val, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardtanh_backward, name, "aten::hardtanh_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardtanh_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardtanh_backward, schema_str, "hardtanh_backward(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val) -> Tensor")

// aten::hardtanh_backward(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<hardtanh_backward::schema> create_hardtanh_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(hardtanh_backward::name, hardtanh_backward::overload_name)
      .typed<hardtanh_backward::schema>();
}

// aten::hardtanh_backward(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val) -> Tensor
at::Tensor hardtanh_backward::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
    
    static auto op = create_hardtanh_backward_typed_handle();
    return op.call(grad_output, self, min_val, max_val);
}

// aten::hardtanh_backward(Tensor grad_output, Tensor self, Scalar min_val, Scalar max_val) -> Tensor
at::Tensor hardtanh_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
    
    static auto op = create_hardtanh_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, min_val, max_val);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(leaky_relu_backward_grad_input, name, "aten::leaky_relu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(leaky_relu_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(leaky_relu_backward_grad_input, schema_str, "leaky_relu_backward.grad_input(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::leaky_relu_backward.grad_input(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<leaky_relu_backward_grad_input::schema> create_leaky_relu_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(leaky_relu_backward_grad_input::name, leaky_relu_backward_grad_input::overload_name)
      .typed<leaky_relu_backward_grad_input::schema>();
}

// aten::leaky_relu_backward.grad_input(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & leaky_relu_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result, at::Tensor & grad_input) {
    
    static auto op = create_leaky_relu_backward_grad_input_typed_handle();
    return op.call(grad_output, self, negative_slope, self_is_result, grad_input);
}

// aten::leaky_relu_backward.grad_input(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & leaky_relu_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result, at::Tensor & grad_input) {
    
    static auto op = create_leaky_relu_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, negative_slope, self_is_result, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(leaky_relu_backward, name, "aten::leaky_relu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(leaky_relu_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(leaky_relu_backward, schema_str, "leaky_relu_backward(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result) -> Tensor")

// aten::leaky_relu_backward(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<leaky_relu_backward::schema> create_leaky_relu_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(leaky_relu_backward::name, leaky_relu_backward::overload_name)
      .typed<leaky_relu_backward::schema>();
}

// aten::leaky_relu_backward(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result) -> Tensor
at::Tensor leaky_relu_backward::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
    
    static auto op = create_leaky_relu_backward_typed_handle();
    return op.call(grad_output, self, negative_slope, self_is_result);
}

// aten::leaky_relu_backward(Tensor grad_output, Tensor self, Scalar negative_slope, bool self_is_result) -> Tensor
at::Tensor leaky_relu_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
    
    static auto op = create_leaky_relu_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, negative_slope, self_is_result);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus_out, name, "aten::softplus")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus_out, schema_str, "softplus.out(Tensor self, Scalar beta=1, Scalar threshold=20, *, Tensor(a!) out) -> Tensor(a!)")

// aten::softplus.out(Tensor self, Scalar beta=1, Scalar threshold=20, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<softplus_out::schema> create_softplus_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(softplus_out::name, softplus_out::overload_name)
      .typed<softplus_out::schema>();
}

// aten::softplus.out(Tensor self, Scalar beta=1, Scalar threshold=20, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & softplus_out::call(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & out) {
    
    static auto op = create_softplus_out_typed_handle();
    return op.call(self, beta, threshold, out);
}

// aten::softplus.out(Tensor self, Scalar beta=1, Scalar threshold=20, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & softplus_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & out) {
    
    static auto op = create_softplus_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, beta, threshold, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus, name, "aten::softplus")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus, schema_str, "softplus(Tensor self, Scalar beta=1, Scalar threshold=20) -> Tensor")

// aten::softplus(Tensor self, Scalar beta=1, Scalar threshold=20) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<softplus::schema> create_softplus_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(softplus::name, softplus::overload_name)
      .typed<softplus::schema>();
}

// aten::softplus(Tensor self, Scalar beta=1, Scalar threshold=20) -> Tensor
at::Tensor softplus::call(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
    
    static auto op = create_softplus_typed_handle();
    return op.call(self, beta, threshold);
}

// aten::softplus(Tensor self, Scalar beta=1, Scalar threshold=20) -> Tensor
at::Tensor softplus::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
    
    static auto op = create_softplus_typed_handle();
    return op.redispatch(dispatchKeySet, self, beta, threshold);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d, name, "aten::mkldnn_adaptive_avg_pool2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d, schema_str, "mkldnn_adaptive_avg_pool2d(Tensor self, int[2] output_size) -> Tensor")

// aten::mkldnn_adaptive_avg_pool2d(Tensor self, int[2] output_size) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_adaptive_avg_pool2d::schema> create_mkldnn_adaptive_avg_pool2d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_adaptive_avg_pool2d::name, mkldnn_adaptive_avg_pool2d::overload_name)
      .typed<mkldnn_adaptive_avg_pool2d::schema>();
}

// aten::mkldnn_adaptive_avg_pool2d(Tensor self, int[2] output_size) -> Tensor
at::Tensor mkldnn_adaptive_avg_pool2d::call(const at::Tensor & self, at::IntArrayRef output_size) {
    
    static auto op = create_mkldnn_adaptive_avg_pool2d_typed_handle();
    return op.call(self, output_size);
}

// aten::mkldnn_adaptive_avg_pool2d(Tensor self, int[2] output_size) -> Tensor
at::Tensor mkldnn_adaptive_avg_pool2d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef output_size) {
    
    static auto op = create_mkldnn_adaptive_avg_pool2d_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d_out, name, "aten::mkldnn_adaptive_avg_pool2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d_out, schema_str, "mkldnn_adaptive_avg_pool2d.out(Tensor self, int[2] output_size, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mkldnn_adaptive_avg_pool2d.out(Tensor self, int[2] output_size, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_adaptive_avg_pool2d_out::schema> create_mkldnn_adaptive_avg_pool2d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_adaptive_avg_pool2d_out::name, mkldnn_adaptive_avg_pool2d_out::overload_name)
      .typed<mkldnn_adaptive_avg_pool2d_out::schema>();
}

// aten::mkldnn_adaptive_avg_pool2d.out(Tensor self, int[2] output_size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_adaptive_avg_pool2d_out::call(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out) {
    
    static auto op = create_mkldnn_adaptive_avg_pool2d_out_typed_handle();
    return op.call(self, output_size, out);
}

// aten::mkldnn_adaptive_avg_pool2d.out(Tensor self, int[2] output_size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_adaptive_avg_pool2d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out) {
    
    static auto op = create_mkldnn_adaptive_avg_pool2d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_adaptive_avg_pool2d, name, "aten::_adaptive_avg_pool2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_adaptive_avg_pool2d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_adaptive_avg_pool2d, schema_str, "_adaptive_avg_pool2d(Tensor self, SymInt[2] output_size) -> Tensor")

// aten::_adaptive_avg_pool2d(Tensor self, SymInt[2] output_size) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_adaptive_avg_pool2d::schema> create__adaptive_avg_pool2d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_adaptive_avg_pool2d::name, _adaptive_avg_pool2d::overload_name)
      .typed<_adaptive_avg_pool2d::schema>();
}

// aten::_adaptive_avg_pool2d(Tensor self, SymInt[2] output_size) -> Tensor
at::Tensor _adaptive_avg_pool2d::call(const at::Tensor & self, c10::SymIntArrayRef output_size) {
    
    static auto op = create__adaptive_avg_pool2d_typed_handle();
    return op.call(self, output_size);
}

// aten::_adaptive_avg_pool2d(Tensor self, SymInt[2] output_size) -> Tensor
at::Tensor _adaptive_avg_pool2d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size) {
    
    static auto op = create__adaptive_avg_pool2d_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d_out, name, "aten::avg_pool3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d_out, schema_str, "avg_pool3d.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::avg_pool3d.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<avg_pool3d_out::schema> create_avg_pool3d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(avg_pool3d_out::name, avg_pool3d_out::overload_name)
      .typed<avg_pool3d_out::schema>();
}

// aten::avg_pool3d.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & avg_pool3d_out::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
    
    static auto op = create_avg_pool3d_out_typed_handle();
    return op.call(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}

// aten::avg_pool3d.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & avg_pool3d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
    
    static auto op = create_avg_pool3d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d, name, "aten::avg_pool3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d, schema_str, "avg_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None) -> Tensor")

// aten::avg_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<avg_pool3d::schema> create_avg_pool3d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(avg_pool3d::name, avg_pool3d::overload_name)
      .typed<avg_pool3d::schema>();
}

// aten::avg_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None) -> Tensor
at::Tensor avg_pool3d::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    
    static auto op = create_avg_pool3d_typed_handle();
    return op.call(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}

// aten::avg_pool3d(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, bool ceil_mode=False, bool count_include_pad=True, int? divisor_override=None) -> Tensor
at::Tensor avg_pool3d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    
    static auto op = create_avg_pool3d_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d_backward_grad_input, name, "aten::avg_pool3d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d_backward_grad_input, schema_str, "avg_pool3d_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::avg_pool3d_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<avg_pool3d_backward_grad_input::schema> create_avg_pool3d_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(avg_pool3d_backward_grad_input::name, avg_pool3d_backward_grad_input::overload_name)
      .typed<avg_pool3d_backward_grad_input::schema>();
}

// aten::avg_pool3d_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & avg_pool3d_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
    
    static auto op = create_avg_pool3d_backward_grad_input_typed_handle();
    return op.call(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}

// aten::avg_pool3d_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & avg_pool3d_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
    
    static auto op = create_avg_pool3d_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d_backward, name, "aten::avg_pool3d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool3d_backward, schema_str, "avg_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override) -> Tensor")

// aten::avg_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<avg_pool3d_backward::schema> create_avg_pool3d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(avg_pool3d_backward::name, avg_pool3d_backward::overload_name)
      .typed<avg_pool3d_backward::schema>();
}

// aten::avg_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override) -> Tensor
at::Tensor avg_pool3d_backward::call(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    
    static auto op = create_avg_pool3d_backward_typed_handle();
    return op.call(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}

// aten::avg_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] stride, int[3] padding, bool ceil_mode, bool count_include_pad, int? divisor_override) -> Tensor
at::Tensor avg_pool3d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    
    static auto op = create_avg_pool3d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices_backward_grad_input, name, "aten::max_pool2d_with_indices_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices_backward_grad_input, schema_str, "max_pool2d_with_indices_backward.grad_input(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::max_pool2d_with_indices_backward.grad_input(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<max_pool2d_with_indices_backward_grad_input::schema> create_max_pool2d_with_indices_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool2d_with_indices_backward_grad_input::name, max_pool2d_with_indices_backward_grad_input::overload_name)
      .typed<max_pool2d_with_indices_backward_grad_input::schema>();
}

// aten::max_pool2d_with_indices_backward.grad_input(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & max_pool2d_with_indices_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
    
    static auto op = create_max_pool2d_with_indices_backward_grad_input_typed_handle();
    return op.call(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}

// aten::max_pool2d_with_indices_backward.grad_input(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & max_pool2d_with_indices_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
    
    static auto op = create_max_pool2d_with_indices_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices_backward, name, "aten::max_pool2d_with_indices_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices_backward, schema_str, "max_pool2d_with_indices_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices) -> Tensor")

// aten::max_pool2d_with_indices_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<max_pool2d_with_indices_backward::schema> create_max_pool2d_with_indices_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool2d_with_indices_backward::name, max_pool2d_with_indices_backward::overload_name)
      .typed<max_pool2d_with_indices_backward::schema>();
}

// aten::max_pool2d_with_indices_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices) -> Tensor
at::Tensor max_pool2d_with_indices_backward::call(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
    
    static auto op = create_max_pool2d_with_indices_backward_typed_handle();
    return op.call(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}

// aten::max_pool2d_with_indices_backward(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride, int[2] padding, int[2] dilation, bool ceil_mode, Tensor indices) -> Tensor
at::Tensor max_pool2d_with_indices_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
    
    static auto op = create_max_pool2d_with_indices_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool3d_with_indices_out, name, "aten::max_pool3d_with_indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool3d_with_indices_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool3d_with_indices_out, schema_str, "max_pool3d_with_indices.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))")

// aten::max_pool3d_with_indices.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<max_pool3d_with_indices_out::schema> create_max_pool3d_with_indices_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool3d_with_indices_out::name, max_pool3d_with_indices_out::overload_name)
      .typed<max_pool3d_with_indices_out::schema>();
}

// aten::max_pool3d_with_indices.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> max_pool3d_with_indices_out::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
    
    static auto op = create_max_pool3d_with_indices_out_typed_handle();
    return op.call(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}

// aten::max_pool3d_with_indices.out(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> max_pool3d_with_indices_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
    
    static auto op = create_max_pool3d_with_indices_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool3d_with_indices, name, "aten::max_pool3d_with_indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool3d_with_indices, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool3d_with_indices, schema_str, "max_pool3d_with_indices(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)")

// aten::max_pool3d_with_indices(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<max_pool3d_with_indices::schema> create_max_pool3d_with_indices_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool3d_with_indices::name, max_pool3d_with_indices::overload_name)
      .typed<max_pool3d_with_indices::schema>();
}

// aten::max_pool3d_with_indices(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> max_pool3d_with_indices::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool3d_with_indices_typed_handle();
    return op.call(self, kernel_size, stride, padding, dilation, ceil_mode);
}

// aten::max_pool3d_with_indices(Tensor self, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> max_pool3d_with_indices::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool3d_with_indices_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, dilation, ceil_mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad2d_out, name, "aten::reflection_pad2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad2d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad2d_out, schema_str, "reflection_pad2d.out(Tensor self, SymInt[4] padding, *, Tensor(a!) out) -> Tensor(a!)")

// aten::reflection_pad2d.out(Tensor self, SymInt[4] padding, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<reflection_pad2d_out::schema> create_reflection_pad2d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(reflection_pad2d_out::name, reflection_pad2d_out::overload_name)
      .typed<reflection_pad2d_out::schema>();
}

// aten::reflection_pad2d.out(Tensor self, SymInt[4] padding, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & reflection_pad2d_out::call(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
    
    static auto op = create_reflection_pad2d_out_typed_handle();
    return op.call(self, padding, out);
}

// aten::reflection_pad2d.out(Tensor self, SymInt[4] padding, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & reflection_pad2d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
    
    static auto op = create_reflection_pad2d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, padding, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad2d, name, "aten::reflection_pad2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad2d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad2d, schema_str, "reflection_pad2d(Tensor self, SymInt[4] padding) -> Tensor")

// aten::reflection_pad2d(Tensor self, SymInt[4] padding) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<reflection_pad2d::schema> create_reflection_pad2d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(reflection_pad2d::name, reflection_pad2d::overload_name)
      .typed<reflection_pad2d::schema>();
}

// aten::reflection_pad2d(Tensor self, SymInt[4] padding) -> Tensor
at::Tensor reflection_pad2d::call(const at::Tensor & self, c10::SymIntArrayRef padding) {
    
    static auto op = create_reflection_pad2d_typed_handle();
    return op.call(self, padding);
}

// aten::reflection_pad2d(Tensor self, SymInt[4] padding) -> Tensor
at::Tensor reflection_pad2d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef padding) {
    
    static auto op = create_reflection_pad2d_typed_handle();
    return op.redispatch(dispatchKeySet, self, padding);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_vec, name, "aten::_upsample_bilinear2d_aa")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_vec, overload_name, "vec")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_vec, schema_str, "_upsample_bilinear2d_aa.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor")

// aten::_upsample_bilinear2d_aa.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_upsample_bilinear2d_aa_vec::schema> create__upsample_bilinear2d_aa_vec_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_upsample_bilinear2d_aa_vec::name, _upsample_bilinear2d_aa_vec::overload_name)
      .typed<_upsample_bilinear2d_aa_vec::schema>();
}

// aten::_upsample_bilinear2d_aa.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor
at::Tensor _upsample_bilinear2d_aa_vec::call(const at::Tensor & input, at::OptionalSymIntArrayRef output_size, bool align_corners, c10::optional<at::ArrayRef<double>> scale_factors) {
    
    static auto op = create__upsample_bilinear2d_aa_vec_typed_handle();
    return op.call(input, output_size, align_corners, scale_factors);
}

// aten::_upsample_bilinear2d_aa.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor
at::Tensor _upsample_bilinear2d_aa_vec::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, at::OptionalSymIntArrayRef output_size, bool align_corners, c10::optional<at::ArrayRef<double>> scale_factors) {
    
    static auto op = create__upsample_bilinear2d_aa_vec_typed_handle();
    return op.redispatch(dispatchKeySet, input, output_size, align_corners, scale_factors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_linear1d_backward_grad_input, name, "aten::upsample_linear1d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_linear1d_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_linear1d_backward_grad_input, schema_str, "upsample_linear1d_backward.grad_input(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, bool align_corners, float? scales=None, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::upsample_linear1d_backward.grad_input(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, bool align_corners, float? scales=None, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<upsample_linear1d_backward_grad_input::schema> create_upsample_linear1d_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_linear1d_backward_grad_input::name, upsample_linear1d_backward_grad_input::overload_name)
      .typed<upsample_linear1d_backward_grad_input::schema>();
}

// aten::upsample_linear1d_backward.grad_input(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, bool align_corners, float? scales=None, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & upsample_linear1d_backward_grad_input::call(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales, at::Tensor & grad_input) {
    
    static auto op = create_upsample_linear1d_backward_grad_input_typed_handle();
    return op.call(grad_output, output_size, input_size, align_corners, scales, grad_input);
}

// aten::upsample_linear1d_backward.grad_input(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, bool align_corners, float? scales=None, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & upsample_linear1d_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales, at::Tensor & grad_input) {
    
    static auto op = create_upsample_linear1d_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output_size, input_size, align_corners, scales, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_linear1d_backward, name, "aten::upsample_linear1d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_linear1d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_linear1d_backward, schema_str, "upsample_linear1d_backward(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, bool align_corners, float? scales=None) -> Tensor")

// aten::upsample_linear1d_backward(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, bool align_corners, float? scales=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<upsample_linear1d_backward::schema> create_upsample_linear1d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_linear1d_backward::name, upsample_linear1d_backward::overload_name)
      .typed<upsample_linear1d_backward::schema>();
}

// aten::upsample_linear1d_backward(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, bool align_corners, float? scales=None) -> Tensor
at::Tensor upsample_linear1d_backward::call(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
    
    static auto op = create_upsample_linear1d_backward_typed_handle();
    return op.call(grad_output, output_size, input_size, align_corners, scales);
}

// aten::upsample_linear1d_backward(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, bool align_corners, float? scales=None) -> Tensor
at::Tensor upsample_linear1d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
    
    static auto op = create_upsample_linear1d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output_size, input_size, align_corners, scales);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_out, name, "aten::_upsample_bilinear2d_aa")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_out, schema_str, "_upsample_bilinear2d_aa.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_upsample_bilinear2d_aa.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_upsample_bilinear2d_aa_out::schema> create__upsample_bilinear2d_aa_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_upsample_bilinear2d_aa_out::name, _upsample_bilinear2d_aa_out::overload_name)
      .typed<_upsample_bilinear2d_aa_out::schema>();
}

// aten::_upsample_bilinear2d_aa.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _upsample_bilinear2d_aa_out::call(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
    
    static auto op = create__upsample_bilinear2d_aa_out_typed_handle();
    return op.call(self, output_size, align_corners, scales_h, scales_w, out);
}

// aten::_upsample_bilinear2d_aa.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _upsample_bilinear2d_aa_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
    
    static auto op = create__upsample_bilinear2d_aa_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, align_corners, scales_h, scales_w, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa, name, "aten::_upsample_bilinear2d_aa")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa, schema_str, "_upsample_bilinear2d_aa(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor")

// aten::_upsample_bilinear2d_aa(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_upsample_bilinear2d_aa::schema> create__upsample_bilinear2d_aa_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_upsample_bilinear2d_aa::name, _upsample_bilinear2d_aa::overload_name)
      .typed<_upsample_bilinear2d_aa::schema>();
}

// aten::_upsample_bilinear2d_aa(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor _upsample_bilinear2d_aa::call(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create__upsample_bilinear2d_aa_typed_handle();
    return op.call(self, output_size, align_corners, scales_h, scales_w);
}

// aten::_upsample_bilinear2d_aa(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor _upsample_bilinear2d_aa::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create__upsample_bilinear2d_aa_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, align_corners, scales_h, scales_w);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest1d_backward_grad_input, name, "aten::upsample_nearest1d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest1d_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest1d_backward_grad_input, schema_str, "upsample_nearest1d_backward.grad_input(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, float? scales=None, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::upsample_nearest1d_backward.grad_input(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, float? scales=None, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<upsample_nearest1d_backward_grad_input::schema> create_upsample_nearest1d_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_nearest1d_backward_grad_input::name, upsample_nearest1d_backward_grad_input::overload_name)
      .typed<upsample_nearest1d_backward_grad_input::schema>();
}

// aten::upsample_nearest1d_backward.grad_input(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, float? scales=None, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & upsample_nearest1d_backward_grad_input::call(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
    
    static auto op = create_upsample_nearest1d_backward_grad_input_typed_handle();
    return op.call(grad_output, output_size, input_size, scales, grad_input);
}

// aten::upsample_nearest1d_backward.grad_input(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, float? scales=None, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & upsample_nearest1d_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
    
    static auto op = create_upsample_nearest1d_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output_size, input_size, scales, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest1d_backward, name, "aten::upsample_nearest1d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest1d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest1d_backward, schema_str, "upsample_nearest1d_backward(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, float? scales=None) -> Tensor")

// aten::upsample_nearest1d_backward(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, float? scales=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<upsample_nearest1d_backward::schema> create_upsample_nearest1d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_nearest1d_backward::name, upsample_nearest1d_backward::overload_name)
      .typed<upsample_nearest1d_backward::schema>();
}

// aten::upsample_nearest1d_backward(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, float? scales=None) -> Tensor
at::Tensor upsample_nearest1d_backward::call(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
    
    static auto op = create_upsample_nearest1d_backward_typed_handle();
    return op.call(grad_output, output_size, input_size, scales);
}

// aten::upsample_nearest1d_backward(Tensor grad_output, SymInt[1] output_size, SymInt[3] input_size, float? scales=None) -> Tensor
at::Tensor upsample_nearest1d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
    
    static auto op = create_upsample_nearest1d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output_size, input_size, scales);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest2d_backward_grad_input, name, "aten::upsample_nearest2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest2d_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest2d_backward_grad_input, schema_str, "upsample_nearest2d_backward.grad_input(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::upsample_nearest2d_backward.grad_input(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<upsample_nearest2d_backward_grad_input::schema> create_upsample_nearest2d_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_nearest2d_backward_grad_input::name, upsample_nearest2d_backward_grad_input::overload_name)
      .typed<upsample_nearest2d_backward_grad_input::schema>();
}

// aten::upsample_nearest2d_backward.grad_input(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & upsample_nearest2d_backward_grad_input::call(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
    
    static auto op = create_upsample_nearest2d_backward_grad_input_typed_handle();
    return op.call(grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}

// aten::upsample_nearest2d_backward.grad_input(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & upsample_nearest2d_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
    
    static auto op = create_upsample_nearest2d_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest2d_backward, name, "aten::upsample_nearest2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest2d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest2d_backward, schema_str, "upsample_nearest2d_backward(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None) -> Tensor")

// aten::upsample_nearest2d_backward(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<upsample_nearest2d_backward::schema> create_upsample_nearest2d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_nearest2d_backward::name, upsample_nearest2d_backward::overload_name)
      .typed<upsample_nearest2d_backward::schema>();
}

// aten::upsample_nearest2d_backward(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor upsample_nearest2d_backward::call(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create_upsample_nearest2d_backward_typed_handle();
    return op.call(grad_output, output_size, input_size, scales_h, scales_w);
}

// aten::upsample_nearest2d_backward(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor upsample_nearest2d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create_upsample_nearest2d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output_size, input_size, scales_h, scales_w);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv_transpose3d_out, name, "aten::slow_conv_transpose3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv_transpose3d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv_transpose3d_out, schema_str, "slow_conv_transpose3d.out(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias=None, SymInt[3] stride=1, SymInt[3] padding=0, SymInt[3] output_padding=0, SymInt[3] dilation=1, *, Tensor(a!) out) -> Tensor(a!)")

// aten::slow_conv_transpose3d.out(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias=None, SymInt[3] stride=1, SymInt[3] padding=0, SymInt[3] output_padding=0, SymInt[3] dilation=1, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<slow_conv_transpose3d_out::schema> create_slow_conv_transpose3d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(slow_conv_transpose3d_out::name, slow_conv_transpose3d_out::overload_name)
      .typed<slow_conv_transpose3d_out::schema>();
}

// aten::slow_conv_transpose3d.out(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias=None, SymInt[3] stride=1, SymInt[3] padding=0, SymInt[3] output_padding=0, SymInt[3] dilation=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & slow_conv_transpose3d_out::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
    
    static auto op = create_slow_conv_transpose3d_out_typed_handle();
    return op.call(self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}

// aten::slow_conv_transpose3d.out(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias=None, SymInt[3] stride=1, SymInt[3] padding=0, SymInt[3] output_padding=0, SymInt[3] dilation=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & slow_conv_transpose3d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
    
    static auto op = create_slow_conv_transpose3d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv_transpose3d, name, "aten::slow_conv_transpose3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv_transpose3d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv_transpose3d, schema_str, "slow_conv_transpose3d(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias=None, SymInt[3] stride=1, SymInt[3] padding=0, SymInt[3] output_padding=0, SymInt[3] dilation=1) -> Tensor")

// aten::slow_conv_transpose3d(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias=None, SymInt[3] stride=1, SymInt[3] padding=0, SymInt[3] output_padding=0, SymInt[3] dilation=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<slow_conv_transpose3d::schema> create_slow_conv_transpose3d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(slow_conv_transpose3d::name, slow_conv_transpose3d::overload_name)
      .typed<slow_conv_transpose3d::schema>();
}

// aten::slow_conv_transpose3d(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias=None, SymInt[3] stride=1, SymInt[3] padding=0, SymInt[3] output_padding=0, SymInt[3] dilation=1) -> Tensor
at::Tensor slow_conv_transpose3d::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
    
    static auto op = create_slow_conv_transpose3d_typed_handle();
    return op.call(self, weight, kernel_size, bias, stride, padding, output_padding, dilation);
}

// aten::slow_conv_transpose3d(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias=None, SymInt[3] stride=1, SymInt[3] padding=0, SymInt[3] output_padding=0, SymInt[3] dilation=1) -> Tensor
at::Tensor slow_conv_transpose3d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
    
    static auto op = create_slow_conv_transpose3d_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, kernel_size, bias, stride, padding, output_padding, dilation);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv3d_forward_output, name, "aten::slow_conv3d_forward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv3d_forward_output, overload_name, "output")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv3d_forward_output, schema_str, "slow_conv3d_forward.output(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias, SymInt[3] stride, SymInt[3] padding, *, Tensor(a!) output) -> Tensor(a!)")

// aten::slow_conv3d_forward.output(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias, SymInt[3] stride, SymInt[3] padding, *, Tensor(a!) output) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<slow_conv3d_forward_output::schema> create_slow_conv3d_forward_output_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(slow_conv3d_forward_output::name, slow_conv3d_forward_output::overload_name)
      .typed<slow_conv3d_forward_output::schema>();
}

// aten::slow_conv3d_forward.output(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias, SymInt[3] stride, SymInt[3] padding, *, Tensor(a!) output) -> Tensor(a!)
at::Tensor & slow_conv3d_forward_output::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
    
    static auto op = create_slow_conv3d_forward_output_typed_handle();
    return op.call(self, weight, kernel_size, bias, stride, padding, output);
}

// aten::slow_conv3d_forward.output(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias, SymInt[3] stride, SymInt[3] padding, *, Tensor(a!) output) -> Tensor(a!)
at::Tensor & slow_conv3d_forward_output::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
    
    static auto op = create_slow_conv3d_forward_output_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, kernel_size, bias, stride, padding, output);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv3d_forward, name, "aten::slow_conv3d_forward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv3d_forward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slow_conv3d_forward, schema_str, "slow_conv3d_forward(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias, SymInt[3] stride, SymInt[3] padding) -> Tensor")

// aten::slow_conv3d_forward(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias, SymInt[3] stride, SymInt[3] padding) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<slow_conv3d_forward::schema> create_slow_conv3d_forward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(slow_conv3d_forward::name, slow_conv3d_forward::overload_name)
      .typed<slow_conv3d_forward::schema>();
}

// aten::slow_conv3d_forward(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias, SymInt[3] stride, SymInt[3] padding) -> Tensor
at::Tensor slow_conv3d_forward::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
    
    static auto op = create_slow_conv3d_forward_typed_handle();
    return op.call(self, weight, kernel_size, bias, stride, padding);
}

// aten::slow_conv3d_forward(Tensor self, Tensor weight, SymInt[3] kernel_size, Tensor? bias, SymInt[3] stride, SymInt[3] padding) -> Tensor
at::Tensor slow_conv3d_forward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
    
    static auto op = create_slow_conv3d_forward_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, kernel_size, bias, stride, padding);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(im2col_out, name, "aten::im2col")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(im2col_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(im2col_out, schema_str, "im2col.out(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) out) -> Tensor(a!)")

// aten::im2col.out(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<im2col_out::schema> create_im2col_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(im2col_out::name, im2col_out::overload_name)
      .typed<im2col_out::schema>();
}

// aten::im2col.out(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & im2col_out::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
    
    static auto op = create_im2col_out_typed_handle();
    return op.call(self, kernel_size, dilation, padding, stride, out);
}

// aten::im2col.out(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & im2col_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
    
    static auto op = create_im2col_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, dilation, padding, stride, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(im2col, name, "aten::im2col")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(im2col, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(im2col, schema_str, "im2col(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -> Tensor")

// aten::im2col(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<im2col::schema> create_im2col_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(im2col::name, im2col::overload_name)
      .typed<im2col::schema>();
}

// aten::im2col(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -> Tensor
at::Tensor im2col::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
    
    static auto op = create_im2col_typed_handle();
    return op.call(self, kernel_size, dilation, padding, stride);
}

// aten::im2col(Tensor self, int[2] kernel_size, int[2] dilation, int[2] padding, int[2] stride) -> Tensor
at::Tensor im2col::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
    
    static auto op = create_im2col_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, dilation, padding, stride);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(isneginf, name, "aten::isneginf")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(isneginf, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(isneginf, schema_str, "isneginf(Tensor self) -> Tensor")

// aten::isneginf(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<isneginf::schema> create_isneginf_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(isneginf::name, isneginf::overload_name)
      .typed<isneginf::schema>();
}

// aten::isneginf(Tensor self) -> Tensor
at::Tensor isneginf::call(const at::Tensor & self) {
    
    static auto op = create_isneginf_typed_handle();
    return op.call(self);
}

// aten::isneginf(Tensor self) -> Tensor
at::Tensor isneginf::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_isneginf_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(isneginf_out, name, "aten::isneginf")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(isneginf_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(isneginf_out, schema_str, "isneginf.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::isneginf.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<isneginf_out::schema> create_isneginf_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(isneginf_out::name, isneginf_out::overload_name)
      .typed<isneginf_out::schema>();
}

// aten::isneginf.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & isneginf_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_isneginf_out_typed_handle();
    return op.call(self, out);
}

// aten::isneginf.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & isneginf_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_isneginf_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_add_batch_dim, name, "aten::_add_batch_dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_add_batch_dim, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_add_batch_dim, schema_str, "_add_batch_dim(Tensor self, int batch_dim, int level) -> Tensor")

// aten::_add_batch_dim(Tensor self, int batch_dim, int level) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_add_batch_dim::schema> create__add_batch_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_add_batch_dim::name, _add_batch_dim::overload_name)
      .typed<_add_batch_dim::schema>();
}

// aten::_add_batch_dim(Tensor self, int batch_dim, int level) -> Tensor
at::Tensor _add_batch_dim::call(const at::Tensor & self, int64_t batch_dim, int64_t level) {
    
    static auto op = create__add_batch_dim_typed_handle();
    return op.call(self, batch_dim, level);
}

// aten::_add_batch_dim(Tensor self, int batch_dim, int level) -> Tensor
at::Tensor _add_batch_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t batch_dim, int64_t level) {
    
    static auto op = create__add_batch_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, batch_dim, level);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_psi, name, "aten::special_psi")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_psi, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_psi, schema_str, "special_psi(Tensor self) -> Tensor")

// aten::special_psi(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_psi::schema> create_special_psi_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_psi::name, special_psi::overload_name)
      .typed<special_psi::schema>();
}

// aten::special_psi(Tensor self) -> Tensor
at::Tensor special_psi::call(const at::Tensor & self) {
    
    static auto op = create_special_psi_typed_handle();
    return op.call(self);
}

// aten::special_psi(Tensor self) -> Tensor
at::Tensor special_psi::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_psi_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_psi_out, name, "aten::special_psi")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_psi_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_psi_out, schema_str, "special_psi.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_psi.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_psi_out::schema> create_special_psi_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_psi_out::name, special_psi_out::overload_name)
      .typed<special_psi_out::schema>();
}

// aten::special_psi.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_psi_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_psi_out_typed_handle();
    return op.call(self, out);
}

// aten::special_psi.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_psi_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_psi_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfcx, name, "aten::special_erfcx")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfcx, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfcx, schema_str, "special_erfcx(Tensor self) -> Tensor")

// aten::special_erfcx(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_erfcx::schema> create_special_erfcx_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_erfcx::name, special_erfcx::overload_name)
      .typed<special_erfcx::schema>();
}

// aten::special_erfcx(Tensor self) -> Tensor
at::Tensor special_erfcx::call(const at::Tensor & self) {
    
    static auto op = create_special_erfcx_typed_handle();
    return op.call(self);
}

// aten::special_erfcx(Tensor self) -> Tensor
at::Tensor special_erfcx::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_erfcx_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfcx_out, name, "aten::special_erfcx")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfcx_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfcx_out, schema_str, "special_erfcx.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_erfcx.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_erfcx_out::schema> create_special_erfcx_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_erfcx_out::name, special_erfcx_out::overload_name)
      .typed<special_erfcx_out::schema>();
}

// aten::special_erfcx.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_erfcx_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_erfcx_out_typed_handle();
    return op.call(self, out);
}

// aten::special_erfcx.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_erfcx_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_erfcx_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i0e, name, "aten::special_i0e")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i0e, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i0e, schema_str, "special_i0e(Tensor self) -> Tensor")

// aten::special_i0e(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_i0e::schema> create_special_i0e_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_i0e::name, special_i0e::overload_name)
      .typed<special_i0e::schema>();
}

// aten::special_i0e(Tensor self) -> Tensor
at::Tensor special_i0e::call(const at::Tensor & self) {
    
    static auto op = create_special_i0e_typed_handle();
    return op.call(self);
}

// aten::special_i0e(Tensor self) -> Tensor
at::Tensor special_i0e::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_i0e_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i0e_out, name, "aten::special_i0e")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i0e_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i0e_out, schema_str, "special_i0e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_i0e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_i0e_out::schema> create_special_i0e_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_i0e_out::name, special_i0e_out::overload_name)
      .typed<special_i0e_out::schema>();
}

// aten::special_i0e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_i0e_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_i0e_out_typed_handle();
    return op.call(self, out);
}

// aten::special_i0e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_i0e_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_i0e_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1, name, "aten::special_i1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1, schema_str, "special_i1(Tensor self) -> Tensor")

// aten::special_i1(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_i1::schema> create_special_i1_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_i1::name, special_i1::overload_name)
      .typed<special_i1::schema>();
}

// aten::special_i1(Tensor self) -> Tensor
at::Tensor special_i1::call(const at::Tensor & self) {
    
    static auto op = create_special_i1_typed_handle();
    return op.call(self);
}

// aten::special_i1(Tensor self) -> Tensor
at::Tensor special_i1::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_i1_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1_out, name, "aten::special_i1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1_out, schema_str, "special_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_i1_out::schema> create_special_i1_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_i1_out::name, special_i1_out::overload_name)
      .typed<special_i1_out::schema>();
}

// aten::special_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_i1_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_i1_out_typed_handle();
    return op.call(self, out);
}

// aten::special_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_i1_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_i1_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logit, name, "aten::special_logit")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logit, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logit, schema_str, "special_logit(Tensor self, float? eps=None) -> Tensor")

// aten::special_logit(Tensor self, float? eps=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_logit::schema> create_special_logit_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_logit::name, special_logit::overload_name)
      .typed<special_logit::schema>();
}

// aten::special_logit(Tensor self, float? eps=None) -> Tensor
at::Tensor special_logit::call(const at::Tensor & self, c10::optional<double> eps) {
    
    static auto op = create_special_logit_typed_handle();
    return op.call(self, eps);
}

// aten::special_logit(Tensor self, float? eps=None) -> Tensor
at::Tensor special_logit::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<double> eps) {
    
    static auto op = create_special_logit_typed_handle();
    return op.redispatch(dispatchKeySet, self, eps);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logit_out, name, "aten::special_logit")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logit_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logit_out, schema_str, "special_logit.out(Tensor self, float? eps=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_logit.out(Tensor self, float? eps=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_logit_out::schema> create_special_logit_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_logit_out::name, special_logit_out::overload_name)
      .typed<special_logit_out::schema>();
}

// aten::special_logit.out(Tensor self, float? eps=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_logit_out::call(const at::Tensor & self, c10::optional<double> eps, at::Tensor & out) {
    
    static auto op = create_special_logit_out_typed_handle();
    return op.call(self, eps, out);
}

// aten::special_logit.out(Tensor self, float? eps=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_logit_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<double> eps, at::Tensor & out) {
    
    static auto op = create_special_logit_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, eps, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_log_softmax, name, "aten::special_log_softmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_log_softmax, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_log_softmax, schema_str, "special_log_softmax(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor")

// aten::special_log_softmax(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_log_softmax::schema> create_special_log_softmax_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_log_softmax::name, special_log_softmax::overload_name)
      .typed<special_log_softmax::schema>();
}

// aten::special_log_softmax(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor
at::Tensor special_log_softmax::call(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_special_log_softmax_typed_handle();
    return op.call(self, dim, dtype);
}

// aten::special_log_softmax(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor
at::Tensor special_log_softmax::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_special_log_softmax_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammaincc_out, name, "aten::special_gammaincc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammaincc_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammaincc_out, schema_str, "special_gammaincc.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_gammaincc.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_gammaincc_out::schema> create_special_gammaincc_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_gammaincc_out::name, special_gammaincc_out::overload_name)
      .typed<special_gammaincc_out::schema>();
}

// aten::special_gammaincc.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_gammaincc_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_special_gammaincc_out_typed_handle();
    return op.call(self, other, out);
}

// aten::special_gammaincc.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_gammaincc_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_special_gammaincc_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammaincc, name, "aten::special_gammaincc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammaincc, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammaincc, schema_str, "special_gammaincc(Tensor self, Tensor other) -> Tensor")

// aten::special_gammaincc(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_gammaincc::schema> create_special_gammaincc_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_gammaincc::name, special_gammaincc::overload_name)
      .typed<special_gammaincc::schema>();
}

// aten::special_gammaincc(Tensor self, Tensor other) -> Tensor
at::Tensor special_gammaincc::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_special_gammaincc_typed_handle();
    return op.call(self, other);
}

// aten::special_gammaincc(Tensor self, Tensor other) -> Tensor
at::Tensor special_gammaincc::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_special_gammaincc_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_multigammaln, name, "aten::special_multigammaln")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_multigammaln, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_multigammaln, schema_str, "special_multigammaln(Tensor self, int p) -> Tensor")

// aten::special_multigammaln(Tensor self, int p) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_multigammaln::schema> create_special_multigammaln_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_multigammaln::name, special_multigammaln::overload_name)
      .typed<special_multigammaln::schema>();
}

// aten::special_multigammaln(Tensor self, int p) -> Tensor
at::Tensor special_multigammaln::call(const at::Tensor & self, int64_t p) {
    
    static auto op = create_special_multigammaln_typed_handle();
    return op.call(self, p);
}

// aten::special_multigammaln(Tensor self, int p) -> Tensor
at::Tensor special_multigammaln::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t p) {
    
    static auto op = create_special_multigammaln_typed_handle();
    return op.redispatch(dispatchKeySet, self, p);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_multigammaln_out, name, "aten::special_multigammaln")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_multigammaln_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_multigammaln_out, schema_str, "special_multigammaln.out(Tensor self, int p, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_multigammaln.out(Tensor self, int p, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_multigammaln_out::schema> create_special_multigammaln_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_multigammaln_out::name, special_multigammaln_out::overload_name)
      .typed<special_multigammaln_out::schema>();
}

// aten::special_multigammaln.out(Tensor self, int p, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_multigammaln_out::call(const at::Tensor & self, int64_t p, at::Tensor & out) {
    
    static auto op = create_special_multigammaln_out_typed_handle();
    return op.call(self, p, out);
}

// aten::special_multigammaln.out(Tensor self, int p, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_multigammaln_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t p, at::Tensor & out) {
    
    static auto op = create_special_multigammaln_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, p, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fft2, name, "aten::fft_fft2")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fft2, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fft2, schema_str, "fft_fft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None) -> Tensor")

// aten::fft_fft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fft_fft2::schema> create_fft_fft2_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fft_fft2::name, fft_fft2::overload_name)
      .typed<fft_fft2::schema>();
}

// aten::fft_fft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None) -> Tensor
at::Tensor fft_fft2::call(const at::Tensor & self, at::OptionalSymIntArrayRef s, at::IntArrayRef dim, c10::optional<c10::string_view> norm) {
    
    static auto op = create_fft_fft2_typed_handle();
    return op.call(self, s, dim, norm);
}

// aten::fft_fft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None) -> Tensor
at::Tensor fft_fft2::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalSymIntArrayRef s, at::IntArrayRef dim, c10::optional<c10::string_view> norm) {
    
    static auto op = create_fft_fft2_typed_handle();
    return op.redispatch(dispatchKeySet, self, s, dim, norm);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fft2_out, name, "aten::fft_fft2")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fft2_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fft2_out, schema_str, "fft_fft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::fft_fft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fft_fft2_out::schema> create_fft_fft2_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fft_fft2_out::name, fft_fft2_out::overload_name)
      .typed<fft_fft2_out::schema>();
}

// aten::fft_fft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fft_fft2_out::call(const at::Tensor & self, at::OptionalSymIntArrayRef s, at::IntArrayRef dim, c10::optional<c10::string_view> norm, at::Tensor & out) {
    
    static auto op = create_fft_fft2_out_typed_handle();
    return op.call(self, s, dim, norm, out);
}

// aten::fft_fft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fft_fft2_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalSymIntArrayRef s, at::IntArrayRef dim, c10::optional<c10::string_view> norm, at::Tensor & out) {
    
    static auto op = create_fft_fft2_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, s, dim, norm, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fftn, name, "aten::fft_fftn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fftn, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fftn, schema_str, "fft_fftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor")

// aten::fft_fftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fft_fftn::schema> create_fft_fftn_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fft_fftn::name, fft_fftn::overload_name)
      .typed<fft_fftn::schema>();
}

// aten::fft_fftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor
at::Tensor fft_fftn::call(const at::Tensor & self, at::OptionalSymIntArrayRef s, at::OptionalIntArrayRef dim, c10::optional<c10::string_view> norm) {
    
    static auto op = create_fft_fftn_typed_handle();
    return op.call(self, s, dim, norm);
}

// aten::fft_fftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor
at::Tensor fft_fftn::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalSymIntArrayRef s, at::OptionalIntArrayRef dim, c10::optional<c10::string_view> norm) {
    
    static auto op = create_fft_fftn_typed_handle();
    return op.redispatch(dispatchKeySet, self, s, dim, norm);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fftn_out, name, "aten::fft_fftn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fftn_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fftn_out, schema_str, "fft_fftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::fft_fftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fft_fftn_out::schema> create_fft_fftn_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fft_fftn_out::name, fft_fftn_out::overload_name)
      .typed<fft_fftn_out::schema>();
}

// aten::fft_fftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fft_fftn_out::call(const at::Tensor & self, at::OptionalSymIntArrayRef s, at::OptionalIntArrayRef dim, c10::optional<c10::string_view> norm, at::Tensor & out) {
    
    static auto op = create_fft_fftn_out_typed_handle();
    return op.call(self, s, dim, norm, out);
}

// aten::fft_fftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fft_fftn_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalSymIntArrayRef s, at::OptionalIntArrayRef dim, c10::optional<c10::string_view> norm, at::Tensor & out) {
    
    static auto op = create_fft_fftn_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, s, dim, norm, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fftshift, name, "aten::fft_fftshift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fftshift, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_fftshift, schema_str, "fft_fftshift(Tensor self, int[1]? dim=None) -> Tensor")

// aten::fft_fftshift(Tensor self, int[1]? dim=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fft_fftshift::schema> create_fft_fftshift_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fft_fftshift::name, fft_fftshift::overload_name)
      .typed<fft_fftshift::schema>();
}

// aten::fft_fftshift(Tensor self, int[1]? dim=None) -> Tensor
at::Tensor fft_fftshift::call(const at::Tensor & self, at::OptionalIntArrayRef dim) {
    
    static auto op = create_fft_fftshift_typed_handle();
    return op.call(self, dim);
}

// aten::fft_fftshift(Tensor self, int[1]? dim=None) -> Tensor
at::Tensor fft_fftshift::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalIntArrayRef dim) {
    
    static auto op = create_fft_fftshift_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_factor, name, "aten::linalg_lu_factor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_factor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_factor, schema_str, "linalg_lu_factor(Tensor A, *, bool pivot=True) -> (Tensor LU, Tensor pivots)")

// aten::linalg_lu_factor(Tensor A, *, bool pivot=True) -> (Tensor LU, Tensor pivots)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_lu_factor::schema> create_linalg_lu_factor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_lu_factor::name, linalg_lu_factor::overload_name)
      .typed<linalg_lu_factor::schema>();
}

// aten::linalg_lu_factor(Tensor A, *, bool pivot=True) -> (Tensor LU, Tensor pivots)
::std::tuple<at::Tensor,at::Tensor> linalg_lu_factor::call(const at::Tensor & A, bool pivot) {
    
    static auto op = create_linalg_lu_factor_typed_handle();
    return op.call(A, pivot);
}

// aten::linalg_lu_factor(Tensor A, *, bool pivot=True) -> (Tensor LU, Tensor pivots)
::std::tuple<at::Tensor,at::Tensor> linalg_lu_factor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, bool pivot) {
    
    static auto op = create_linalg_lu_factor_typed_handle();
    return op.redispatch(dispatchKeySet, A, pivot);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_factor_out, name, "aten::linalg_lu_factor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_factor_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_factor_out, schema_str, "linalg_lu_factor.out(Tensor A, *, bool pivot=True, Tensor(a!) LU, Tensor(b!) pivots) -> (Tensor(a!) LU, Tensor(b!) pivots)")

// aten::linalg_lu_factor.out(Tensor A, *, bool pivot=True, Tensor(a!) LU, Tensor(b!) pivots) -> (Tensor(a!) LU, Tensor(b!) pivots)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_lu_factor_out::schema> create_linalg_lu_factor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_lu_factor_out::name, linalg_lu_factor_out::overload_name)
      .typed<linalg_lu_factor_out::schema>();
}

// aten::linalg_lu_factor.out(Tensor A, *, bool pivot=True, Tensor(a!) LU, Tensor(b!) pivots) -> (Tensor(a!) LU, Tensor(b!) pivots)
::std::tuple<at::Tensor &,at::Tensor &> linalg_lu_factor_out::call(const at::Tensor & A, bool pivot, at::Tensor & LU, at::Tensor & pivots) {
    
    static auto op = create_linalg_lu_factor_out_typed_handle();
    return op.call(A, pivot, LU, pivots);
}

// aten::linalg_lu_factor.out(Tensor A, *, bool pivot=True, Tensor(a!) LU, Tensor(b!) pivots) -> (Tensor(a!) LU, Tensor(b!) pivots)
::std::tuple<at::Tensor &,at::Tensor &> linalg_lu_factor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, bool pivot, at::Tensor & LU, at::Tensor & pivots) {
    
    static auto op = create_linalg_lu_factor_out_typed_handle();
    return op.redispatch(dispatchKeySet, A, pivot, LU, pivots);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_solve, name, "aten::linalg_lu_solve")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_solve, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_solve, schema_str, "linalg_lu_solve(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False) -> Tensor")

// aten::linalg_lu_solve(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_lu_solve::schema> create_linalg_lu_solve_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_lu_solve::name, linalg_lu_solve::overload_name)
      .typed<linalg_lu_solve::schema>();
}

// aten::linalg_lu_solve(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False) -> Tensor
at::Tensor linalg_lu_solve::call(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint) {
    
    static auto op = create_linalg_lu_solve_typed_handle();
    return op.call(LU, pivots, B, left, adjoint);
}

// aten::linalg_lu_solve(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False) -> Tensor
at::Tensor linalg_lu_solve::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint) {
    
    static auto op = create_linalg_lu_solve_typed_handle();
    return op.redispatch(dispatchKeySet, LU, pivots, B, left, adjoint);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_solve_out, name, "aten::linalg_lu_solve")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_solve_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_solve_out, schema_str, "linalg_lu_solve.out(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_lu_solve.out(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_lu_solve_out::schema> create_linalg_lu_solve_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_lu_solve_out::name, linalg_lu_solve_out::overload_name)
      .typed<linalg_lu_solve_out::schema>();
}

// aten::linalg_lu_solve.out(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_lu_solve_out::call(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint, at::Tensor & out) {
    
    static auto op = create_linalg_lu_solve_out_typed_handle();
    return op.call(LU, pivots, B, left, adjoint, out);
}

// aten::linalg_lu_solve.out(Tensor LU, Tensor pivots, Tensor B, *, bool left=True, bool adjoint=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_lu_solve_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint, at::Tensor & out) {
    
    static auto op = create_linalg_lu_solve_out_typed_handle();
    return op.redispatch(dispatchKeySet, LU, pivots, B, left, adjoint, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_det, name, "aten::linalg_det")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_det, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_det, schema_str, "linalg_det(Tensor A) -> Tensor")

// aten::linalg_det(Tensor A) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_det::schema> create_linalg_det_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_det::name, linalg_det::overload_name)
      .typed<linalg_det::schema>();
}

// aten::linalg_det(Tensor A) -> Tensor
at::Tensor linalg_det::call(const at::Tensor & A) {
    
    static auto op = create_linalg_det_typed_handle();
    return op.call(A);
}

// aten::linalg_det(Tensor A) -> Tensor
at::Tensor linalg_det::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A) {
    
    static auto op = create_linalg_det_typed_handle();
    return op.redispatch(dispatchKeySet, A);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_det_out, name, "aten::linalg_det")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_det_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_det_out, schema_str, "linalg_det.out(Tensor A, *, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_det.out(Tensor A, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_det_out::schema> create_linalg_det_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_det_out::name, linalg_det_out::overload_name)
      .typed<linalg_det_out::schema>();
}

// aten::linalg_det.out(Tensor A, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_det_out::call(const at::Tensor & A, at::Tensor & out) {
    
    static auto op = create_linalg_det_out_typed_handle();
    return op.call(A, out);
}

// aten::linalg_det.out(Tensor A, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_det_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, at::Tensor & out) {
    
    static auto op = create_linalg_det_out_typed_handle();
    return op.redispatch(dispatchKeySet, A, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_slogdet, name, "aten::_linalg_slogdet")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_slogdet, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_slogdet, schema_str, "_linalg_slogdet(Tensor A) -> (Tensor sign, Tensor logabsdet, Tensor LU, Tensor pivots)")

// aten::_linalg_slogdet(Tensor A) -> (Tensor sign, Tensor logabsdet, Tensor LU, Tensor pivots)
static C10_NOINLINE c10::TypedOperatorHandle<_linalg_slogdet::schema> create__linalg_slogdet_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_linalg_slogdet::name, _linalg_slogdet::overload_name)
      .typed<_linalg_slogdet::schema>();
}

// aten::_linalg_slogdet(Tensor A) -> (Tensor sign, Tensor logabsdet, Tensor LU, Tensor pivots)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _linalg_slogdet::call(const at::Tensor & A) {
    
    static auto op = create__linalg_slogdet_typed_handle();
    return op.call(A);
}

// aten::_linalg_slogdet(Tensor A) -> (Tensor sign, Tensor logabsdet, Tensor LU, Tensor pivots)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _linalg_slogdet::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A) {
    
    static auto op = create__linalg_slogdet_typed_handle();
    return op.redispatch(dispatchKeySet, A);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_slogdet_sign, name, "aten::_linalg_slogdet")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_slogdet_sign, overload_name, "sign")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_slogdet_sign, schema_str, "_linalg_slogdet.sign(Tensor A, *, Tensor(a!) sign, Tensor(b!) logabsdet, Tensor(c!) LU, Tensor(d!) pivots) -> (Tensor(a!) sign, Tensor(b!) logabsdet, Tensor(c!) LU, Tensor(d!) pivots)")

// aten::_linalg_slogdet.sign(Tensor A, *, Tensor(a!) sign, Tensor(b!) logabsdet, Tensor(c!) LU, Tensor(d!) pivots) -> (Tensor(a!) sign, Tensor(b!) logabsdet, Tensor(c!) LU, Tensor(d!) pivots)
static C10_NOINLINE c10::TypedOperatorHandle<_linalg_slogdet_sign::schema> create__linalg_slogdet_sign_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_linalg_slogdet_sign::name, _linalg_slogdet_sign::overload_name)
      .typed<_linalg_slogdet_sign::schema>();
}

// aten::_linalg_slogdet.sign(Tensor A, *, Tensor(a!) sign, Tensor(b!) logabsdet, Tensor(c!) LU, Tensor(d!) pivots) -> (Tensor(a!) sign, Tensor(b!) logabsdet, Tensor(c!) LU, Tensor(d!) pivots)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_slogdet_sign::call(const at::Tensor & A, at::Tensor & sign, at::Tensor & logabsdet, at::Tensor & LU, at::Tensor & pivots) {
    
    static auto op = create__linalg_slogdet_sign_typed_handle();
    return op.call(A, sign, logabsdet, LU, pivots);
}

// aten::_linalg_slogdet.sign(Tensor A, *, Tensor(a!) sign, Tensor(b!) logabsdet, Tensor(c!) LU, Tensor(d!) pivots) -> (Tensor(a!) sign, Tensor(b!) logabsdet, Tensor(c!) LU, Tensor(d!) pivots)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_slogdet_sign::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, at::Tensor & sign, at::Tensor & logabsdet, at::Tensor & LU, at::Tensor & pivots) {
    
    static auto op = create__linalg_slogdet_sign_typed_handle();
    return op.redispatch(dispatchKeySet, A, sign, logabsdet, LU, pivots);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_inv, name, "aten::linalg_inv")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_inv, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_inv, schema_str, "linalg_inv(Tensor A) -> Tensor")

// aten::linalg_inv(Tensor A) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_inv::schema> create_linalg_inv_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_inv::name, linalg_inv::overload_name)
      .typed<linalg_inv::schema>();
}

// aten::linalg_inv(Tensor A) -> Tensor
at::Tensor linalg_inv::call(const at::Tensor & A) {
    
    static auto op = create_linalg_inv_typed_handle();
    return op.call(A);
}

// aten::linalg_inv(Tensor A) -> Tensor
at::Tensor linalg_inv::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A) {
    
    static auto op = create_linalg_inv_typed_handle();
    return op.redispatch(dispatchKeySet, A);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_inv_out, name, "aten::linalg_inv")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_inv_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_inv_out, schema_str, "linalg_inv.out(Tensor A, *, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_inv.out(Tensor A, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_inv_out::schema> create_linalg_inv_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_inv_out::name, linalg_inv_out::overload_name)
      .typed<linalg_inv_out::schema>();
}

// aten::linalg_inv.out(Tensor A, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_inv_out::call(const at::Tensor & A, at::Tensor & out) {
    
    static auto op = create_linalg_inv_out_typed_handle();
    return op.call(A, out);
}

// aten::linalg_inv.out(Tensor A, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_inv_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, at::Tensor & out) {
    
    static auto op = create_linalg_inv_out_typed_handle();
    return op.redispatch(dispatchKeySet, A, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(outer, name, "aten::outer")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(outer, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(outer, schema_str, "outer(Tensor self, Tensor vec2) -> Tensor")

// aten::outer(Tensor self, Tensor vec2) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<outer::schema> create_outer_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(outer::name, outer::overload_name)
      .typed<outer::schema>();
}

// aten::outer(Tensor self, Tensor vec2) -> Tensor
at::Tensor outer::call(const at::Tensor & self, const at::Tensor & vec2) {
    
    static auto op = create_outer_typed_handle();
    return op.call(self, vec2);
}

// aten::outer(Tensor self, Tensor vec2) -> Tensor
at::Tensor outer::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & vec2) {
    
    static auto op = create_outer_typed_handle();
    return op.redispatch(dispatchKeySet, self, vec2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(outer_out, name, "aten::outer")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(outer_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(outer_out, schema_str, "outer.out(Tensor self, Tensor vec2, *, Tensor(a!) out) -> Tensor(a!)")

// aten::outer.out(Tensor self, Tensor vec2, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<outer_out::schema> create_outer_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(outer_out::name, outer_out::overload_name)
      .typed<outer_out::schema>();
}

// aten::outer.out(Tensor self, Tensor vec2, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & outer_out::call(const at::Tensor & self, const at::Tensor & vec2, at::Tensor & out) {
    
    static auto op = create_outer_out_typed_handle();
    return op.call(self, vec2, out);
}

// aten::outer.out(Tensor self, Tensor vec2, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & outer_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & vec2, at::Tensor & out) {
    
    static auto op = create_outer_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, vec2, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ger, name, "aten::ger")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ger, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ger, schema_str, "ger(Tensor self, Tensor vec2) -> Tensor")

// aten::ger(Tensor self, Tensor vec2) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<ger::schema> create_ger_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(ger::name, ger::overload_name)
      .typed<ger::schema>();
}

// aten::ger(Tensor self, Tensor vec2) -> Tensor
at::Tensor ger::call(const at::Tensor & self, const at::Tensor & vec2) {
    
    static auto op = create_ger_typed_handle();
    return op.call(self, vec2);
}

// aten::ger(Tensor self, Tensor vec2) -> Tensor
at::Tensor ger::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & vec2) {
    
    static auto op = create_ger_typed_handle();
    return op.redispatch(dispatchKeySet, self, vec2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ger_out, name, "aten::ger")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ger_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ger_out, schema_str, "ger.out(Tensor self, Tensor vec2, *, Tensor(a!) out) -> Tensor(a!)")

// aten::ger.out(Tensor self, Tensor vec2, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<ger_out::schema> create_ger_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(ger_out::name, ger_out::overload_name)
      .typed<ger_out::schema>();
}

// aten::ger.out(Tensor self, Tensor vec2, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & ger_out::call(const at::Tensor & self, const at::Tensor & vec2, at::Tensor & out) {
    
    static auto op = create_ger_out_typed_handle();
    return op.call(self, vec2, out);
}

// aten::ger.out(Tensor self, Tensor vec2, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & ger_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & vec2, at::Tensor & out) {
    
    static auto op = create_ger_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, vec2, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_svd, name, "aten::_linalg_svd")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_svd, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_svd, schema_str, "_linalg_svd(Tensor A, bool full_matrices=False, bool compute_uv=True, *, str? driver=None) -> (Tensor U, Tensor S, Tensor Vh)")

// aten::_linalg_svd(Tensor A, bool full_matrices=False, bool compute_uv=True, *, str? driver=None) -> (Tensor U, Tensor S, Tensor Vh)
static C10_NOINLINE c10::TypedOperatorHandle<_linalg_svd::schema> create__linalg_svd_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_linalg_svd::name, _linalg_svd::overload_name)
      .typed<_linalg_svd::schema>();
}

// aten::_linalg_svd(Tensor A, bool full_matrices=False, bool compute_uv=True, *, str? driver=None) -> (Tensor U, Tensor S, Tensor Vh)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _linalg_svd::call(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver) {
    
    static auto op = create__linalg_svd_typed_handle();
    return op.call(A, full_matrices, compute_uv, driver);
}

// aten::_linalg_svd(Tensor A, bool full_matrices=False, bool compute_uv=True, *, str? driver=None) -> (Tensor U, Tensor S, Tensor Vh)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _linalg_svd::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver) {
    
    static auto op = create__linalg_svd_typed_handle();
    return op.redispatch(dispatchKeySet, A, full_matrices, compute_uv, driver);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_svd_U, name, "aten::_linalg_svd")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_svd_U, overload_name, "U")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_svd_U, schema_str, "_linalg_svd.U(Tensor A, bool full_matrices=False, bool compute_uv=True, *, str? driver=None, Tensor(a!) U, Tensor(b!) S, Tensor(c!) Vh) -> (Tensor(a!) U, Tensor(b!) S, Tensor(c!) Vh)")

// aten::_linalg_svd.U(Tensor A, bool full_matrices=False, bool compute_uv=True, *, str? driver=None, Tensor(a!) U, Tensor(b!) S, Tensor(c!) Vh) -> (Tensor(a!) U, Tensor(b!) S, Tensor(c!) Vh)
static C10_NOINLINE c10::TypedOperatorHandle<_linalg_svd_U::schema> create__linalg_svd_U_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_linalg_svd_U::name, _linalg_svd_U::overload_name)
      .typed<_linalg_svd_U::schema>();
}

// aten::_linalg_svd.U(Tensor A, bool full_matrices=False, bool compute_uv=True, *, str? driver=None, Tensor(a!) U, Tensor(b!) S, Tensor(c!) Vh) -> (Tensor(a!) U, Tensor(b!) S, Tensor(c!) Vh)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_svd_U::call(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver, at::Tensor & U, at::Tensor & S, at::Tensor & Vh) {
    
    static auto op = create__linalg_svd_U_typed_handle();
    return op.call(A, full_matrices, compute_uv, driver, U, S, Vh);
}

// aten::_linalg_svd.U(Tensor A, bool full_matrices=False, bool compute_uv=True, *, str? driver=None, Tensor(a!) U, Tensor(b!) S, Tensor(c!) Vh) -> (Tensor(a!) U, Tensor(b!) S, Tensor(c!) Vh)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_svd_U::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver, at::Tensor & U, at::Tensor & S, at::Tensor & Vh) {
    
    static auto op = create__linalg_svd_U_typed_handle();
    return op.redispatch(dispatchKeySet, A, full_matrices, compute_uv, driver, U, S, Vh);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_solve_ex, name, "aten::_linalg_solve_ex")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_solve_ex, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_solve_ex, schema_str, "_linalg_solve_ex(Tensor A, Tensor B, *, bool left=True, bool check_errors=False) -> (Tensor result, Tensor LU, Tensor pivots, Tensor info)")

// aten::_linalg_solve_ex(Tensor A, Tensor B, *, bool left=True, bool check_errors=False) -> (Tensor result, Tensor LU, Tensor pivots, Tensor info)
static C10_NOINLINE c10::TypedOperatorHandle<_linalg_solve_ex::schema> create__linalg_solve_ex_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_linalg_solve_ex::name, _linalg_solve_ex::overload_name)
      .typed<_linalg_solve_ex::schema>();
}

// aten::_linalg_solve_ex(Tensor A, Tensor B, *, bool left=True, bool check_errors=False) -> (Tensor result, Tensor LU, Tensor pivots, Tensor info)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _linalg_solve_ex::call(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors) {
    
    static auto op = create__linalg_solve_ex_typed_handle();
    return op.call(A, B, left, check_errors);
}

// aten::_linalg_solve_ex(Tensor A, Tensor B, *, bool left=True, bool check_errors=False) -> (Tensor result, Tensor LU, Tensor pivots, Tensor info)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _linalg_solve_ex::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors) {
    
    static auto op = create__linalg_solve_ex_typed_handle();
    return op.redispatch(dispatchKeySet, A, B, left, check_errors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_solve_ex_result, name, "aten::_linalg_solve_ex")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_solve_ex_result, overload_name, "result")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_solve_ex_result, schema_str, "_linalg_solve_ex.result(Tensor A, Tensor B, *, bool left=True, bool check_errors=False, Tensor(a!) result, Tensor(b!) LU, Tensor(c!) pivots, Tensor(d!) info) -> (Tensor(a!) result, Tensor(b!) LU, Tensor(c!) pivots, Tensor(d!) info)")

// aten::_linalg_solve_ex.result(Tensor A, Tensor B, *, bool left=True, bool check_errors=False, Tensor(a!) result, Tensor(b!) LU, Tensor(c!) pivots, Tensor(d!) info) -> (Tensor(a!) result, Tensor(b!) LU, Tensor(c!) pivots, Tensor(d!) info)
static C10_NOINLINE c10::TypedOperatorHandle<_linalg_solve_ex_result::schema> create__linalg_solve_ex_result_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_linalg_solve_ex_result::name, _linalg_solve_ex_result::overload_name)
      .typed<_linalg_solve_ex_result::schema>();
}

// aten::_linalg_solve_ex.result(Tensor A, Tensor B, *, bool left=True, bool check_errors=False, Tensor(a!) result, Tensor(b!) LU, Tensor(c!) pivots, Tensor(d!) info) -> (Tensor(a!) result, Tensor(b!) LU, Tensor(c!) pivots, Tensor(d!) info)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_solve_ex_result::call(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
    
    static auto op = create__linalg_solve_ex_result_typed_handle();
    return op.call(A, B, left, check_errors, result, LU, pivots, info);
}

// aten::_linalg_solve_ex.result(Tensor A, Tensor B, *, bool left=True, bool check_errors=False, Tensor(a!) result, Tensor(b!) LU, Tensor(c!) pivots, Tensor(d!) info) -> (Tensor(a!) result, Tensor(b!) LU, Tensor(c!) pivots, Tensor(d!) info)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_solve_ex_result::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
    
    static auto op = create__linalg_solve_ex_result_typed_handle();
    return op.redispatch(dispatchKeySet, A, B, left, check_errors, result, LU, pivots, info);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_qr, name, "aten::linalg_qr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_qr, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_qr, schema_str, "linalg_qr(Tensor A, str mode='reduced') -> (Tensor Q, Tensor R)")

// aten::linalg_qr(Tensor A, str mode='reduced') -> (Tensor Q, Tensor R)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_qr::schema> create_linalg_qr_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_qr::name, linalg_qr::overload_name)
      .typed<linalg_qr::schema>();
}

// aten::linalg_qr(Tensor A, str mode='reduced') -> (Tensor Q, Tensor R)
::std::tuple<at::Tensor,at::Tensor> linalg_qr::call(const at::Tensor & A, c10::string_view mode) {
    
    static auto op = create_linalg_qr_typed_handle();
    return op.call(A, mode);
}

// aten::linalg_qr(Tensor A, str mode='reduced') -> (Tensor Q, Tensor R)
::std::tuple<at::Tensor,at::Tensor> linalg_qr::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, c10::string_view mode) {
    
    static auto op = create_linalg_qr_typed_handle();
    return op.redispatch(dispatchKeySet, A, mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_qr_out, name, "aten::linalg_qr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_qr_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_qr_out, schema_str, "linalg_qr.out(Tensor A, str mode='reduced', *, Tensor(a!) Q, Tensor(b!) R) -> (Tensor(a!) Q, Tensor(b!) R)")

// aten::linalg_qr.out(Tensor A, str mode='reduced', *, Tensor(a!) Q, Tensor(b!) R) -> (Tensor(a!) Q, Tensor(b!) R)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_qr_out::schema> create_linalg_qr_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_qr_out::name, linalg_qr_out::overload_name)
      .typed<linalg_qr_out::schema>();
}

// aten::linalg_qr.out(Tensor A, str mode='reduced', *, Tensor(a!) Q, Tensor(b!) R) -> (Tensor(a!) Q, Tensor(b!) R)
::std::tuple<at::Tensor &,at::Tensor &> linalg_qr_out::call(const at::Tensor & A, c10::string_view mode, at::Tensor & Q, at::Tensor & R) {
    
    static auto op = create_linalg_qr_out_typed_handle();
    return op.call(A, mode, Q, R);
}

// aten::linalg_qr.out(Tensor A, str mode='reduced', *, Tensor(a!) Q, Tensor(b!) R) -> (Tensor(a!) Q, Tensor(b!) R)
::std::tuple<at::Tensor &,at::Tensor &> linalg_qr_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, c10::string_view mode, at::Tensor & Q, at::Tensor & R) {
    
    static auto op = create_linalg_qr_out_typed_handle();
    return op.redispatch(dispatchKeySet, A, mode, Q, R);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nested_to_padded_tensor, name, "aten::nested_to_padded_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nested_to_padded_tensor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nested_to_padded_tensor, schema_str, "nested_to_padded_tensor(Tensor self, float padding, int[]? output_size=None) -> Tensor")

// aten::nested_to_padded_tensor(Tensor self, float padding, int[]? output_size=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<nested_to_padded_tensor::schema> create_nested_to_padded_tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nested_to_padded_tensor::name, nested_to_padded_tensor::overload_name)
      .typed<nested_to_padded_tensor::schema>();
}

// aten::nested_to_padded_tensor(Tensor self, float padding, int[]? output_size=None) -> Tensor
at::Tensor nested_to_padded_tensor::call(const at::Tensor & self, double padding, at::OptionalIntArrayRef output_size) {
    
    static auto op = create_nested_to_padded_tensor_typed_handle();
    return op.call(self, padding, output_size);
}

// aten::nested_to_padded_tensor(Tensor self, float padding, int[]? output_size=None) -> Tensor
at::Tensor nested_to_padded_tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double padding, at::OptionalIntArrayRef output_size) {
    
    static auto op = create_nested_to_padded_tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, padding, output_size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_warn_in_autograd, name, "aten::_test_warn_in_autograd")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_warn_in_autograd, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_warn_in_autograd, schema_str, "_test_warn_in_autograd(Tensor self) -> Tensor")

// aten::_test_warn_in_autograd(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_test_warn_in_autograd::schema> create__test_warn_in_autograd_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_warn_in_autograd::name, _test_warn_in_autograd::overload_name)
      .typed<_test_warn_in_autograd::schema>();
}

// aten::_test_warn_in_autograd(Tensor self) -> Tensor
at::Tensor _test_warn_in_autograd::call(const at::Tensor & self) {
    
    static auto op = create__test_warn_in_autograd_typed_handle();
    return op.call(self);
}

// aten::_test_warn_in_autograd(Tensor self) -> Tensor
at::Tensor _test_warn_in_autograd::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__test_warn_in_autograd_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_view, name, "aten::_test_autograd_multiple_dispatch_view")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_view, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_view, schema_str, "_test_autograd_multiple_dispatch_view(Tensor(a) self) -> Tensor(a)")

// aten::_test_autograd_multiple_dispatch_view(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<_test_autograd_multiple_dispatch_view::schema> create__test_autograd_multiple_dispatch_view_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_autograd_multiple_dispatch_view::name, _test_autograd_multiple_dispatch_view::overload_name)
      .typed<_test_autograd_multiple_dispatch_view::schema>();
}

// aten::_test_autograd_multiple_dispatch_view(Tensor(a) self) -> Tensor(a)
at::Tensor _test_autograd_multiple_dispatch_view::call(const at::Tensor & self) {
    
    static auto op = create__test_autograd_multiple_dispatch_view_typed_handle();
    return op.call(self);
}

// aten::_test_autograd_multiple_dispatch_view(Tensor(a) self) -> Tensor(a)
at::Tensor _test_autograd_multiple_dispatch_view::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__test_autograd_multiple_dispatch_view_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_copy, name, "aten::diagonal_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_copy, schema_str, "diagonal_copy(Tensor self, int offset=0, int dim1=0, int dim2=1) -> Tensor")

// aten::diagonal_copy(Tensor self, int offset=0, int dim1=0, int dim2=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<diagonal_copy::schema> create_diagonal_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(diagonal_copy::name, diagonal_copy::overload_name)
      .typed<diagonal_copy::schema>();
}

// aten::diagonal_copy(Tensor self, int offset=0, int dim1=0, int dim2=1) -> Tensor
at::Tensor diagonal_copy::call(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2) {
    
    static auto op = create_diagonal_copy_typed_handle();
    return op.call(self, offset, dim1, dim2);
}

// aten::diagonal_copy(Tensor self, int offset=0, int dim1=0, int dim2=1) -> Tensor
at::Tensor diagonal_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2) {
    
    static auto op = create_diagonal_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, offset, dim1, dim2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(permute_copy, name, "aten::permute_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(permute_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(permute_copy, schema_str, "permute_copy(Tensor self, int[] dims) -> Tensor")

// aten::permute_copy(Tensor self, int[] dims) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<permute_copy::schema> create_permute_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(permute_copy::name, permute_copy::overload_name)
      .typed<permute_copy::schema>();
}

// aten::permute_copy(Tensor self, int[] dims) -> Tensor
at::Tensor permute_copy::call(const at::Tensor & self, at::IntArrayRef dims) {
    
    static auto op = create_permute_copy_typed_handle();
    return op.call(self, dims);
}

// aten::permute_copy(Tensor self, int[] dims) -> Tensor
at::Tensor permute_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dims) {
    
    static auto op = create_permute_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, dims);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_copy_int, name, "aten::select_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_copy_int, overload_name, "int")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_copy_int, schema_str, "select_copy.int(Tensor self, int dim, SymInt index) -> Tensor")

// aten::select_copy.int(Tensor self, int dim, SymInt index) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<select_copy_int::schema> create_select_copy_int_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(select_copy_int::name, select_copy_int::overload_name)
      .typed<select_copy_int::schema>();
}

// aten::select_copy.int(Tensor self, int dim, SymInt index) -> Tensor
at::Tensor select_copy_int::call(const at::Tensor & self, int64_t dim, c10::SymInt index) {
    
    static auto op = create_select_copy_int_typed_handle();
    return op.call(self, dim, index);
}

// aten::select_copy.int(Tensor self, int dim, SymInt index) -> Tensor
at::Tensor select_copy_int::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::SymInt index) {
    
    static auto op = create_select_copy_int_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_copy_Tensor, name, "aten::slice_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_copy_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_copy_Tensor, schema_str, "slice_copy.Tensor(Tensor self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor")

// aten::slice_copy.Tensor(Tensor self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<slice_copy_Tensor::schema> create_slice_copy_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(slice_copy_Tensor::name, slice_copy_Tensor::overload_name)
      .typed<slice_copy_Tensor::schema>();
}

// aten::slice_copy.Tensor(Tensor self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor
at::Tensor slice_copy_Tensor::call(const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step) {
    
    static auto op = create_slice_copy_Tensor_typed_handle();
    return op.call(self, dim, start, end, step);
}

// aten::slice_copy.Tensor(Tensor self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1) -> Tensor
at::Tensor slice_copy_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step) {
    
    static auto op = create_slice_copy_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, start, end, step);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_with_sizes_copy, name, "aten::split_with_sizes_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_with_sizes_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_with_sizes_copy, schema_str, "split_with_sizes_copy(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]")

// aten::split_with_sizes_copy(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<split_with_sizes_copy::schema> create_split_with_sizes_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(split_with_sizes_copy::name, split_with_sizes_copy::overload_name)
      .typed<split_with_sizes_copy::schema>();
}

// aten::split_with_sizes_copy(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]
::std::vector<at::Tensor> split_with_sizes_copy::call(const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim) {
    
    static auto op = create_split_with_sizes_copy_typed_handle();
    return op.call(self, split_sizes, dim);
}

// aten::split_with_sizes_copy(Tensor self, SymInt[] split_sizes, int dim=0) -> Tensor[]
::std::vector<at::Tensor> split_with_sizes_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim) {
    
    static auto op = create_split_with_sizes_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, split_sizes, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(t_copy, name, "aten::t_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(t_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(t_copy, schema_str, "t_copy(Tensor self) -> Tensor")

// aten::t_copy(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<t_copy::schema> create_t_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(t_copy::name, t_copy::overload_name)
      .typed<t_copy::schema>();
}

// aten::t_copy(Tensor self) -> Tensor
at::Tensor t_copy::call(const at::Tensor & self) {
    
    static auto op = create_t_copy_typed_handle();
    return op.call(self);
}

// aten::t_copy(Tensor self) -> Tensor
at::Tensor t_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_t_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(col_indices_copy, name, "aten::col_indices_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(col_indices_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(col_indices_copy, schema_str, "col_indices_copy(Tensor self) -> Tensor")

// aten::col_indices_copy(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<col_indices_copy::schema> create_col_indices_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(col_indices_copy::name, col_indices_copy::overload_name)
      .typed<col_indices_copy::schema>();
}

// aten::col_indices_copy(Tensor self) -> Tensor
at::Tensor col_indices_copy::call(const at::Tensor & self) {
    
    static auto op = create_col_indices_copy_typed_handle();
    return op.call(self);
}

// aten::col_indices_copy(Tensor self) -> Tensor
at::Tensor col_indices_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_col_indices_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_copy_int, name, "aten::unbind_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_copy_int, overload_name, "int")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_copy_int, schema_str, "unbind_copy.int(Tensor self, int dim=0) -> Tensor[]")

// aten::unbind_copy.int(Tensor self, int dim=0) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<unbind_copy_int::schema> create_unbind_copy_int_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unbind_copy_int::name, unbind_copy_int::overload_name)
      .typed<unbind_copy_int::schema>();
}

// aten::unbind_copy.int(Tensor self, int dim=0) -> Tensor[]
::std::vector<at::Tensor> unbind_copy_int::call(const at::Tensor & self, int64_t dim) {
    
    static auto op = create_unbind_copy_int_typed_handle();
    return op.call(self, dim);
}

// aten::unbind_copy.int(Tensor self, int dim=0) -> Tensor[]
::std::vector<at::Tensor> unbind_copy_int::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim) {
    
    static auto op = create_unbind_copy_int_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_copy_int_out, name, "aten::unbind_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_copy_int_out, overload_name, "int_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_copy_int_out, schema_str, "unbind_copy.int_out(Tensor self, int dim=0, *, Tensor(a!)[] out) -> ()")

// aten::unbind_copy.int_out(Tensor self, int dim=0, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<unbind_copy_int_out::schema> create_unbind_copy_int_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unbind_copy_int_out::name, unbind_copy_int_out::overload_name)
      .typed<unbind_copy_int_out::schema>();
}

// aten::unbind_copy.int_out(Tensor self, int dim=0, *, Tensor(a!)[] out) -> ()
void unbind_copy_int_out::call(const at::Tensor & self, int64_t dim, at::TensorList out) {
    
    static auto op = create_unbind_copy_int_out_typed_handle();
    return op.call(self, dim, out);
}

// aten::unbind_copy.int_out(Tensor self, int dim=0, *, Tensor(a!)[] out) -> ()
void unbind_copy_int_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, at::TensorList out) {
    
    static auto op = create_unbind_copy_int_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_with_sizes_copy_out, name, "aten::split_with_sizes_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_with_sizes_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_with_sizes_copy_out, schema_str, "split_with_sizes_copy.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()")

// aten::split_with_sizes_copy.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<split_with_sizes_copy_out::schema> create_split_with_sizes_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(split_with_sizes_copy_out::name, split_with_sizes_copy_out::overload_name)
      .typed<split_with_sizes_copy_out::schema>();
}

// aten::split_with_sizes_copy.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()
void split_with_sizes_copy_out::call(const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim, at::TensorList out) {
    
    static auto op = create_split_with_sizes_copy_out_typed_handle();
    return op.call(self, split_sizes, dim, out);
}

// aten::split_with_sizes_copy.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()
void split_with_sizes_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim, at::TensorList out) {
    
    static auto op = create_split_with_sizes_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, split_sizes, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alias_copy, name, "aten::alias_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alias_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alias_copy, schema_str, "alias_copy(Tensor self) -> Tensor")

// aten::alias_copy(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<alias_copy::schema> create_alias_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(alias_copy::name, alias_copy::overload_name)
      .typed<alias_copy::schema>();
}

// aten::alias_copy(Tensor self) -> Tensor
at::Tensor alias_copy::call(const at::Tensor & self) {
    
    static auto op = create_alias_copy_typed_handle();
    return op.call(self);
}

// aten::alias_copy(Tensor self) -> Tensor
at::Tensor alias_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_alias_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_scaled_dot_product_attention_math, name, "aten::_scaled_dot_product_attention_math")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_scaled_dot_product_attention_math, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_scaled_dot_product_attention_math, schema_str, "_scaled_dot_product_attention_math(Tensor query, Tensor key, Tensor value, Tensor? attn_mask=None, float dropout_p=0.0, bool is_causal=False, Tensor? dropout_mask=None, *, float? scale=None) -> (Tensor, Tensor)")

// aten::_scaled_dot_product_attention_math(Tensor query, Tensor key, Tensor value, Tensor? attn_mask=None, float dropout_p=0.0, bool is_causal=False, Tensor? dropout_mask=None, *, float? scale=None) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_scaled_dot_product_attention_math::schema> create__scaled_dot_product_attention_math_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_scaled_dot_product_attention_math::name, _scaled_dot_product_attention_math::overload_name)
      .typed<_scaled_dot_product_attention_math::schema>();
}

// aten::_scaled_dot_product_attention_math(Tensor query, Tensor key, Tensor value, Tensor? attn_mask=None, float dropout_p=0.0, bool is_causal=False, Tensor? dropout_mask=None, *, float? scale=None) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _scaled_dot_product_attention_math::call(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & attn_mask, double dropout_p, bool is_causal, const c10::optional<at::Tensor> & dropout_mask, c10::optional<double> scale) {
    
    static auto op = create__scaled_dot_product_attention_math_typed_handle();
    return op.call(query, key, value, attn_mask, dropout_p, is_causal, dropout_mask, scale);
}

// aten::_scaled_dot_product_attention_math(Tensor query, Tensor key, Tensor value, Tensor? attn_mask=None, float dropout_p=0.0, bool is_causal=False, Tensor? dropout_mask=None, *, float? scale=None) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _scaled_dot_product_attention_math::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & attn_mask, double dropout_p, bool is_causal, const c10::optional<at::Tensor> & dropout_mask, c10::optional<double> scale) {
    
    static auto op = create__scaled_dot_product_attention_math_typed_handle();
    return op.redispatch(dispatchKeySet, query, key, value, attn_mask, dropout_p, is_causal, dropout_mask, scale);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_scaled_dot_product_flash_attention_backward, name, "aten::_scaled_dot_product_flash_attention_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_scaled_dot_product_flash_attention_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_scaled_dot_product_flash_attention_backward, schema_str, "_scaled_dot_product_flash_attention_backward(Tensor grad_out, Tensor query, Tensor key, Tensor value, Tensor out, Tensor logsumexp, Tensor cum_seq_q, Tensor cum_seq_k, SymInt max_q, SymInt max_k, float dropout_p, bool is_causal, Tensor philox_seed, Tensor philox_offset, *, float? scale=None) -> (Tensor grad_query, Tensor grad_key, Tensor grad_value)")

// aten::_scaled_dot_product_flash_attention_backward(Tensor grad_out, Tensor query, Tensor key, Tensor value, Tensor out, Tensor logsumexp, Tensor cum_seq_q, Tensor cum_seq_k, SymInt max_q, SymInt max_k, float dropout_p, bool is_causal, Tensor philox_seed, Tensor philox_offset, *, float? scale=None) -> (Tensor grad_query, Tensor grad_key, Tensor grad_value)
static C10_NOINLINE c10::TypedOperatorHandle<_scaled_dot_product_flash_attention_backward::schema> create__scaled_dot_product_flash_attention_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_scaled_dot_product_flash_attention_backward::name, _scaled_dot_product_flash_attention_backward::overload_name)
      .typed<_scaled_dot_product_flash_attention_backward::schema>();
}

// aten::_scaled_dot_product_flash_attention_backward(Tensor grad_out, Tensor query, Tensor key, Tensor value, Tensor out, Tensor logsumexp, Tensor cum_seq_q, Tensor cum_seq_k, SymInt max_q, SymInt max_k, float dropout_p, bool is_causal, Tensor philox_seed, Tensor philox_offset, *, float? scale=None) -> (Tensor grad_query, Tensor grad_key, Tensor grad_value)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _scaled_dot_product_flash_attention_backward::call(const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & cum_seq_q, const at::Tensor & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, const at::Tensor & philox_seed, const at::Tensor & philox_offset, c10::optional<double> scale) {
    
    static auto op = create__scaled_dot_product_flash_attention_backward_typed_handle();
    return op.call(grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset, scale);
}

// aten::_scaled_dot_product_flash_attention_backward(Tensor grad_out, Tensor query, Tensor key, Tensor value, Tensor out, Tensor logsumexp, Tensor cum_seq_q, Tensor cum_seq_k, SymInt max_q, SymInt max_k, float dropout_p, bool is_causal, Tensor philox_seed, Tensor philox_offset, *, float? scale=None) -> (Tensor grad_query, Tensor grad_key, Tensor grad_value)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _scaled_dot_product_flash_attention_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & cum_seq_q, const at::Tensor & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, const at::Tensor & philox_seed, const at::Tensor & philox_offset, c10::optional<double> scale) {
    
    static auto op = create__scaled_dot_product_flash_attention_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset, scale);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_triton_scaled_dot_attention, name, "aten::_triton_scaled_dot_attention")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_triton_scaled_dot_attention, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_triton_scaled_dot_attention, schema_str, "_triton_scaled_dot_attention(Tensor q, Tensor k, Tensor v, float dropout_p=0.0) -> Tensor")

// aten::_triton_scaled_dot_attention(Tensor q, Tensor k, Tensor v, float dropout_p=0.0) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_triton_scaled_dot_attention::schema> create__triton_scaled_dot_attention_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_triton_scaled_dot_attention::name, _triton_scaled_dot_attention::overload_name)
      .typed<_triton_scaled_dot_attention::schema>();
}

// aten::_triton_scaled_dot_attention(Tensor q, Tensor k, Tensor v, float dropout_p=0.0) -> Tensor
at::Tensor _triton_scaled_dot_attention::call(const at::Tensor & q, const at::Tensor & k, const at::Tensor & v, double dropout_p) {
    
    static auto op = create__triton_scaled_dot_attention_typed_handle();
    return op.call(q, k, v, dropout_p);
}

// aten::_triton_scaled_dot_attention(Tensor q, Tensor k, Tensor v, float dropout_p=0.0) -> Tensor
at::Tensor _triton_scaled_dot_attention::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & q, const at::Tensor & k, const at::Tensor & v, double dropout_p) {
    
    static auto op = create__triton_scaled_dot_attention_typed_handle();
    return op.redispatch(dispatchKeySet, q, k, v, dropout_p);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t, name, "aten::special_chebyshev_polynomial_t")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t, schema_str, "special_chebyshev_polynomial_t(Tensor x, Tensor n) -> Tensor")

// aten::special_chebyshev_polynomial_t(Tensor x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_t::schema> create_special_chebyshev_polynomial_t_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_t::name, special_chebyshev_polynomial_t::overload_name)
      .typed<special_chebyshev_polynomial_t::schema>();
}

// aten::special_chebyshev_polynomial_t(Tensor x, Tensor n) -> Tensor
at::Tensor special_chebyshev_polynomial_t::call(const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_chebyshev_polynomial_t_typed_handle();
    return op.call(x, n);
}

// aten::special_chebyshev_polynomial_t(Tensor x, Tensor n) -> Tensor
at::Tensor special_chebyshev_polynomial_t::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_chebyshev_polynomial_t_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_x_scalar, name, "aten::special_chebyshev_polynomial_t")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_x_scalar, overload_name, "x_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_x_scalar, schema_str, "special_chebyshev_polynomial_t.x_scalar(Scalar x, Tensor n) -> Tensor")

// aten::special_chebyshev_polynomial_t.x_scalar(Scalar x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_t_x_scalar::schema> create_special_chebyshev_polynomial_t_x_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_t_x_scalar::name, special_chebyshev_polynomial_t_x_scalar::overload_name)
      .typed<special_chebyshev_polynomial_t_x_scalar::schema>();
}

// aten::special_chebyshev_polynomial_t.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_chebyshev_polynomial_t_x_scalar::call(const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_chebyshev_polynomial_t_x_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_chebyshev_polynomial_t.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_chebyshev_polynomial_t_x_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_chebyshev_polynomial_t_x_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_n_scalar, name, "aten::special_chebyshev_polynomial_t")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_n_scalar, overload_name, "n_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_n_scalar, schema_str, "special_chebyshev_polynomial_t.n_scalar(Tensor x, Scalar n) -> Tensor")

// aten::special_chebyshev_polynomial_t.n_scalar(Tensor x, Scalar n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_t_n_scalar::schema> create_special_chebyshev_polynomial_t_n_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_t_n_scalar::name, special_chebyshev_polynomial_t_n_scalar::overload_name)
      .typed<special_chebyshev_polynomial_t_n_scalar::schema>();
}

// aten::special_chebyshev_polynomial_t.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_chebyshev_polynomial_t_n_scalar::call(const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_chebyshev_polynomial_t_n_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_chebyshev_polynomial_t.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_chebyshev_polynomial_t_n_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_chebyshev_polynomial_t_n_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_out, name, "aten::special_chebyshev_polynomial_t")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_out, schema_str, "special_chebyshev_polynomial_t.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_chebyshev_polynomial_t.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_t_out::schema> create_special_chebyshev_polynomial_t_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_t_out::name, special_chebyshev_polynomial_t_out::overload_name)
      .typed<special_chebyshev_polynomial_t_out::schema>();
}

// aten::special_chebyshev_polynomial_t.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_t_out::call(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_t_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_chebyshev_polynomial_t.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_t_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_t_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_x_scalar_out, name, "aten::special_chebyshev_polynomial_t")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_x_scalar_out, overload_name, "x_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_x_scalar_out, schema_str, "special_chebyshev_polynomial_t.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_chebyshev_polynomial_t.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_t_x_scalar_out::schema> create_special_chebyshev_polynomial_t_x_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_t_x_scalar_out::name, special_chebyshev_polynomial_t_x_scalar_out::overload_name)
      .typed<special_chebyshev_polynomial_t_x_scalar_out::schema>();
}

// aten::special_chebyshev_polynomial_t.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_t_x_scalar_out::call(const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_t_x_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_chebyshev_polynomial_t.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_t_x_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_t_x_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_n_scalar_out, name, "aten::special_chebyshev_polynomial_t")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_n_scalar_out, overload_name, "n_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_t_n_scalar_out, schema_str, "special_chebyshev_polynomial_t.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_chebyshev_polynomial_t.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_t_n_scalar_out::schema> create_special_chebyshev_polynomial_t_n_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_t_n_scalar_out::name, special_chebyshev_polynomial_t_n_scalar_out::overload_name)
      .typed<special_chebyshev_polynomial_t_n_scalar_out::schema>();
}

// aten::special_chebyshev_polynomial_t.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_t_n_scalar_out::call(const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_t_n_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_chebyshev_polynomial_t.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_t_n_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_t_n_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_scaled_modified_bessel_k1, name, "aten::special_scaled_modified_bessel_k1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_scaled_modified_bessel_k1, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_scaled_modified_bessel_k1, schema_str, "special_scaled_modified_bessel_k1(Tensor x) -> Tensor")

// aten::special_scaled_modified_bessel_k1(Tensor x) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_scaled_modified_bessel_k1::schema> create_special_scaled_modified_bessel_k1_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_scaled_modified_bessel_k1::name, special_scaled_modified_bessel_k1::overload_name)
      .typed<special_scaled_modified_bessel_k1::schema>();
}

// aten::special_scaled_modified_bessel_k1(Tensor x) -> Tensor
at::Tensor special_scaled_modified_bessel_k1::call(const at::Tensor & x) {
    
    static auto op = create_special_scaled_modified_bessel_k1_typed_handle();
    return op.call(x);
}

// aten::special_scaled_modified_bessel_k1(Tensor x) -> Tensor
at::Tensor special_scaled_modified_bessel_k1::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x) {
    
    static auto op = create_special_scaled_modified_bessel_k1_typed_handle();
    return op.redispatch(dispatchKeySet, x);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_scaled_modified_bessel_k1_out, name, "aten::special_scaled_modified_bessel_k1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_scaled_modified_bessel_k1_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_scaled_modified_bessel_k1_out, schema_str, "special_scaled_modified_bessel_k1.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_scaled_modified_bessel_k1.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_scaled_modified_bessel_k1_out::schema> create_special_scaled_modified_bessel_k1_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_scaled_modified_bessel_k1_out::name, special_scaled_modified_bessel_k1_out::overload_name)
      .typed<special_scaled_modified_bessel_k1_out::schema>();
}

// aten::special_scaled_modified_bessel_k1.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_scaled_modified_bessel_k1_out::call(const at::Tensor & x, at::Tensor & out) {
    
    static auto op = create_special_scaled_modified_bessel_k1_out_typed_handle();
    return op.call(x, out);
}

// aten::special_scaled_modified_bessel_k1.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_scaled_modified_bessel_k1_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, at::Tensor & out) {
    
    static auto op = create_special_scaled_modified_bessel_k1_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foobar, name, "aten::_foobar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foobar, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foobar, schema_str, "_foobar(Tensor self, bool arg1=True, bool arg2=True, *, bool arg3=True) -> Tensor")

// aten::_foobar(Tensor self, bool arg1=True, bool arg2=True, *, bool arg3=True) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_foobar::schema> create__foobar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foobar::name, _foobar::overload_name)
      .typed<_foobar::schema>();
}

// aten::_foobar(Tensor self, bool arg1=True, bool arg2=True, *, bool arg3=True) -> Tensor
at::Tensor _foobar::call(const at::Tensor & self, bool arg1, bool arg2, bool arg3) {
    
    static auto op = create__foobar_typed_handle();
    return op.call(self, arg1, arg2, arg3);
}

// aten::_foobar(Tensor self, bool arg1=True, bool arg2=True, *, bool arg3=True) -> Tensor
at::Tensor _foobar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool arg1, bool arg2, bool arg3) {
    
    static auto op = create__foobar_typed_handle();
    return op.redispatch(dispatchKeySet, self, arg1, arg2, arg3);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_scale_out, name, "aten::_masked_scale")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_scale_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_scale_out, schema_str, "_masked_scale.out(Tensor self, Tensor mask, float scale, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_masked_scale.out(Tensor self, Tensor mask, float scale, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_masked_scale_out::schema> create__masked_scale_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_masked_scale_out::name, _masked_scale_out::overload_name)
      .typed<_masked_scale_out::schema>();
}

// aten::_masked_scale.out(Tensor self, Tensor mask, float scale, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _masked_scale_out::call(const at::Tensor & self, const at::Tensor & mask, double scale, at::Tensor & out) {
    
    static auto op = create__masked_scale_out_typed_handle();
    return op.call(self, mask, scale, out);
}

// aten::_masked_scale.out(Tensor self, Tensor mask, float scale, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _masked_scale_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask, double scale, at::Tensor & out) {
    
    static auto op = create__masked_scale_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, scale, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(constant_pad_nd_out, name, "aten::constant_pad_nd")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(constant_pad_nd_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(constant_pad_nd_out, schema_str, "constant_pad_nd.out(Tensor self, SymInt[] pad, Scalar value=0, *, Tensor(a!) out) -> Tensor(a!)")

// aten::constant_pad_nd.out(Tensor self, SymInt[] pad, Scalar value=0, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<constant_pad_nd_out::schema> create_constant_pad_nd_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(constant_pad_nd_out::name, constant_pad_nd_out::overload_name)
      .typed<constant_pad_nd_out::schema>();
}

// aten::constant_pad_nd.out(Tensor self, SymInt[] pad, Scalar value=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & constant_pad_nd_out::call(const at::Tensor & self, c10::SymIntArrayRef pad, const at::Scalar & value, at::Tensor & out) {
    
    static auto op = create_constant_pad_nd_out_typed_handle();
    return op.call(self, pad, value, out);
}

// aten::constant_pad_nd.out(Tensor self, SymInt[] pad, Scalar value=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & constant_pad_nd_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef pad, const at::Scalar & value, at::Tensor & out) {
    
    static auto op = create_constant_pad_nd_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, pad, value, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward_out, name, "aten::convolution_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward_out, schema_str, "convolution_backward.out(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))")

// aten::convolution_backward.out(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
static C10_NOINLINE c10::TypedOperatorHandle<convolution_backward_out::schema> create_convolution_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(convolution_backward_out::name, convolution_backward_out::overload_name)
      .typed<convolution_backward_out::schema>();
}

// aten::convolution_backward.out(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> convolution_backward_out::call(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalSymIntArrayRef bias_sizes, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_convolution_backward_out_typed_handle();
    return op.call(grad_output, input, weight, bias_sizes, stride, padding, dilation, transposed, output_padding, groups, output_mask, out0, out1, out2);
}

// aten::convolution_backward.out(Tensor grad_output, Tensor input, Tensor weight, SymInt[]? bias_sizes, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> convolution_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalSymIntArrayRef bias_sizes, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_convolution_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, input, weight, bias_sizes, stride, padding, dilation, transposed, output_padding, groups, output_mask, out0, out1, out2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_overrideable_out, name, "aten::convolution_overrideable")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_overrideable_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_overrideable_out, schema_str, "convolution_overrideable.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)")

// aten::convolution_overrideable.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<convolution_overrideable_out::schema> create_convolution_overrideable_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(convolution_overrideable_out::name, convolution_overrideable_out::overload_name)
      .typed<convolution_overrideable_out::schema>();
}

// aten::convolution_overrideable.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & convolution_overrideable_out::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_convolution_overrideable_out_typed_handle();
    return op.call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, out);
}

// aten::convolution_overrideable.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & convolution_overrideable_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_convolution_overrideable_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_copy_from_out, name, "aten::_copy_from")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_copy_from_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_copy_from_out, schema_str, "_copy_from.out(Tensor self, Tensor dst, bool non_blocking=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_copy_from.out(Tensor self, Tensor dst, bool non_blocking=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_copy_from_out::schema> create__copy_from_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_copy_from_out::name, _copy_from_out::overload_name)
      .typed<_copy_from_out::schema>();
}

// aten::_copy_from.out(Tensor self, Tensor dst, bool non_blocking=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _copy_from_out::call(const at::Tensor & self, const at::Tensor & dst, bool non_blocking, at::Tensor & out) {
    
    static auto op = create__copy_from_out_typed_handle();
    return op.call(self, dst, non_blocking, out);
}

// aten::_copy_from.out(Tensor self, Tensor dst, bool non_blocking=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _copy_from_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & dst, bool non_blocking, at::Tensor & out) {
    
    static auto op = create__copy_from_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dst, non_blocking, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm_out, name, "aten::cudnn_batch_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm_out, schema_str, "cudnn_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))")

// aten::cudnn_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_batch_norm_out::schema> create_cudnn_batch_norm_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_batch_norm_out::name, cudnn_batch_norm_out::overload_name)
      .typed<cudnn_batch_norm_out::schema>();
}

// aten::cudnn_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> cudnn_batch_norm_out::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3) {
    
    static auto op = create_cudnn_batch_norm_out_typed_handle();
    return op.call(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon, out0, out1, out2, out3);
}

// aten::cudnn_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> cudnn_batch_norm_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3) {
    
    static auto op = create_cudnn_batch_norm_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon, out0, out1, out2, out3);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_mps_convolution_transpose_out, name, "aten::_mps_convolution_transpose")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_mps_convolution_transpose_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_mps_convolution_transpose_out, schema_str, "_mps_convolution_transpose.out(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_mps_convolution_transpose.out(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_mps_convolution_transpose_out::schema> create__mps_convolution_transpose_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_mps_convolution_transpose_out::name, _mps_convolution_transpose_out::overload_name)
      .typed<_mps_convolution_transpose_out::schema>();
}

// aten::_mps_convolution_transpose.out(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _mps_convolution_transpose_out::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create__mps_convolution_transpose_out_typed_handle();
    return op.call(self, weight, padding, output_padding, stride, dilation, groups, out);
}

// aten::_mps_convolution_transpose.out(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _mps_convolution_transpose_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create__mps_convolution_transpose_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, padding, output_padding, stride, dilation, groups, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mps_convolution_transpose_backward_out, name, "aten::mps_convolution_transpose_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mps_convolution_transpose_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mps_convolution_transpose_backward_out, schema_str, "mps_convolution_transpose_backward.out(Tensor self, Tensor grad_output, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::mps_convolution_transpose_backward.out(Tensor self, Tensor grad_output, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<mps_convolution_transpose_backward_out::schema> create_mps_convolution_transpose_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mps_convolution_transpose_backward_out::name, mps_convolution_transpose_backward_out::overload_name)
      .typed<mps_convolution_transpose_backward_out::schema>();
}

// aten::mps_convolution_transpose_backward.out(Tensor self, Tensor grad_output, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> mps_convolution_transpose_backward_out::call(const at::Tensor & self, const at::Tensor & grad_output, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, ::std::array<bool,2> output_mask, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_mps_convolution_transpose_backward_out_typed_handle();
    return op.call(self, grad_output, weight, padding, output_padding, stride, dilation, groups, output_mask, out0, out1);
}

// aten::mps_convolution_transpose_backward.out(Tensor self, Tensor grad_output, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> mps_convolution_transpose_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & grad_output, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, ::std::array<bool,2> output_mask, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_mps_convolution_transpose_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, grad_output, weight, padding, output_padding, stride, dilation, groups, output_mask, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_out, name, "aten::embedding")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_out, schema_str, "embedding.out(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::embedding.out(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<embedding_out::schema> create_embedding_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(embedding_out::name, embedding_out::overload_name)
      .typed<embedding_out::schema>();
}

// aten::embedding.out(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & embedding_out::call(const at::Tensor & weight, const at::Tensor & indices, c10::SymInt padding_idx, bool scale_grad_by_freq, bool sparse, at::Tensor & out) {
    
    static auto op = create_embedding_out_typed_handle();
    return op.call(weight, indices, padding_idx, scale_grad_by_freq, sparse, out);
}

// aten::embedding.out(Tensor weight, Tensor indices, SymInt padding_idx=-1, bool scale_grad_by_freq=False, bool sparse=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & embedding_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & weight, const at::Tensor & indices, c10::SymInt padding_idx, bool scale_grad_by_freq, bool sparse, at::Tensor & out) {
    
    static auto op = create_embedding_out_typed_handle();
    return op.redispatch(dispatchKeySet, weight, indices, padding_idx, scale_grad_by_freq, sparse, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_dense_backward_out, name, "aten::_embedding_bag_dense_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_dense_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_dense_backward_out, schema_str, "_embedding_bag_dense_backward.out(Tensor grad, Tensor indices, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_embedding_bag_dense_backward.out(Tensor grad, Tensor indices, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_embedding_bag_dense_backward_out::schema> create__embedding_bag_dense_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_embedding_bag_dense_backward_out::name, _embedding_bag_dense_backward_out::overload_name)
      .typed<_embedding_bag_dense_backward_out::schema>();
}

// aten::_embedding_bag_dense_backward.out(Tensor grad, Tensor indices, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _embedding_bag_dense_backward_out::call(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx, at::Tensor & out) {
    
    static auto op = create__embedding_bag_dense_backward_out_typed_handle();
    return op.call(grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx, out);
}

// aten::_embedding_bag_dense_backward.out(Tensor grad, Tensor indices, Tensor offset2bag, Tensor bag_size, Tensor maximum_indices, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _embedding_bag_dense_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx, at::Tensor & out) {
    
    static auto op = create__embedding_bag_dense_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(resize_out, name, "aten::resize")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(resize_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(resize_out, schema_str, "resize.out(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)")

// aten::resize.out(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<resize_out::schema> create_resize_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(resize_out::name, resize_out::overload_name)
      .typed<resize_out::schema>();
}

// aten::resize.out(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)
const at::Tensor & resize_out::call(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format, const at::Tensor & out) {
    
    static auto op = create_resize_out_typed_handle();
    return op.call(self, size, memory_format, out);
}

// aten::resize.out(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)
const at::Tensor & resize_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format, const at::Tensor & out) {
    
    static auto op = create_resize_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, memory_format, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(resize, name, "aten::resize")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(resize, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(resize, schema_str, "resize(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None) -> Tensor")

// aten::resize(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<resize::schema> create_resize_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(resize::name, resize::overload_name)
      .typed<resize::schema>();
}

// aten::resize(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None) -> Tensor
at::Tensor resize::call(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create_resize_typed_handle();
    return op.call(self, size, memory_format);
}

// aten::resize(Tensor self, SymInt[] size, *, MemoryFormat? memory_format=None) -> Tensor
at::Tensor resize::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create_resize_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, memory_format);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide_Scalar_out, name, "aten::floor_divide")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(floor_divide_Scalar_out, schema_str, "floor_divide.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::floor_divide.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<floor_divide_Scalar_out::schema> create_floor_divide_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(floor_divide_Scalar_out::name, floor_divide_Scalar_out::overload_name)
      .typed<floor_divide_Scalar_out::schema>();
}

// aten::floor_divide.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & floor_divide_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_floor_divide_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::floor_divide.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & floor_divide_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_floor_divide_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_names_out, name, "aten::full")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_names_out, overload_name, "names_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_names_out, schema_str, "full.names_out(int[] size, Scalar fill_value, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)")

// aten::full.names_out(int[] size, Scalar fill_value, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<full_names_out::schema> create_full_names_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(full_names_out::name, full_names_out::overload_name)
      .typed<full_names_out::schema>();
}

// aten::full.names_out(int[] size, Scalar fill_value, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
at::Tensor & full_names_out::call(at::IntArrayRef size, const at::Scalar & fill_value, c10::optional<at::DimnameList> names, at::Tensor & out) {
    
    static auto op = create_full_names_out_typed_handle();
    return op.call(size, fill_value, names, out);
}

// aten::full.names_out(int[] size, Scalar fill_value, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
at::Tensor & full_names_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::IntArrayRef size, const at::Scalar & fill_value, c10::optional<at::DimnameList> names, at::Tensor & out) {
    
    static auto op = create_full_names_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, fill_value, names, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_like_out, name, "aten::full_like")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_like_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(full_like_out, schema_str, "full_like.out(Tensor self, Scalar fill_value, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)")

// aten::full_like.out(Tensor self, Scalar fill_value, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<full_like_out::schema> create_full_like_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(full_like_out::name, full_like_out::overload_name)
      .typed<full_like_out::schema>();
}

// aten::full_like.out(Tensor self, Scalar fill_value, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & full_like_out::call(const at::Tensor & self, const at::Scalar & fill_value, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
    
    static auto op = create_full_like_out_typed_handle();
    return op.call(self, fill_value, memory_format, out);
}

// aten::full_like.out(Tensor self, Scalar fill_value, *, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & full_like_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & fill_value, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
    
    static auto op = create_full_like_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, fill_value, memory_format, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d_out, name, "aten::grid_sampler_2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d_out, schema_str, "grid_sampler_2d.out(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, *, Tensor(a!) out) -> Tensor(a!)")

// aten::grid_sampler_2d.out(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<grid_sampler_2d_out::schema> create_grid_sampler_2d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(grid_sampler_2d_out::name, grid_sampler_2d_out::overload_name)
      .typed<grid_sampler_2d_out::schema>();
}

// aten::grid_sampler_2d.out(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & grid_sampler_2d_out::call(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, at::Tensor & out) {
    
    static auto op = create_grid_sampler_2d_out_typed_handle();
    return op.call(input, grid, interpolation_mode, padding_mode, align_corners, out);
}

// aten::grid_sampler_2d.out(Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & grid_sampler_2d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, at::Tensor & out) {
    
    static auto op = create_grid_sampler_2d_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, grid, interpolation_mode, padding_mode, align_corners, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_out, name, "aten::kaiser_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_out, schema_str, "kaiser_window.out(int window_length, *, Tensor(a!) out) -> Tensor(a!)")

// aten::kaiser_window.out(int window_length, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<kaiser_window_out::schema> create_kaiser_window_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(kaiser_window_out::name, kaiser_window_out::overload_name)
      .typed<kaiser_window_out::schema>();
}

// aten::kaiser_window.out(int window_length, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & kaiser_window_out::call(int64_t window_length, at::Tensor & out) {
    
    static auto op = create_kaiser_window_out_typed_handle();
    return op.call(window_length, out);
}

// aten::kaiser_window.out(int window_length, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & kaiser_window_out::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, at::Tensor & out) {
    
    static auto op = create_kaiser_window_out_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_periodic_out, name, "aten::kaiser_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_periodic_out, overload_name, "periodic_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_periodic_out, schema_str, "kaiser_window.periodic_out(int window_length, bool periodic, *, Tensor(a!) out) -> Tensor(a!)")

// aten::kaiser_window.periodic_out(int window_length, bool periodic, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<kaiser_window_periodic_out::schema> create_kaiser_window_periodic_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(kaiser_window_periodic_out::name, kaiser_window_periodic_out::overload_name)
      .typed<kaiser_window_periodic_out::schema>();
}

// aten::kaiser_window.periodic_out(int window_length, bool periodic, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & kaiser_window_periodic_out::call(int64_t window_length, bool periodic, at::Tensor & out) {
    
    static auto op = create_kaiser_window_periodic_out_typed_handle();
    return op.call(window_length, periodic, out);
}

// aten::kaiser_window.periodic_out(int window_length, bool periodic, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & kaiser_window_periodic_out::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, bool periodic, at::Tensor & out) {
    
    static auto op = create_kaiser_window_periodic_out_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, periodic, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_beta_out, name, "aten::kaiser_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_beta_out, overload_name, "beta_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kaiser_window_beta_out, schema_str, "kaiser_window.beta_out(int window_length, bool periodic, float beta, *, Tensor(a!) out) -> Tensor(a!)")

// aten::kaiser_window.beta_out(int window_length, bool periodic, float beta, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<kaiser_window_beta_out::schema> create_kaiser_window_beta_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(kaiser_window_beta_out::name, kaiser_window_beta_out::overload_name)
      .typed<kaiser_window_beta_out::schema>();
}

// aten::kaiser_window.beta_out(int window_length, bool periodic, float beta, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & kaiser_window_beta_out::call(int64_t window_length, bool periodic, double beta, at::Tensor & out) {
    
    static auto op = create_kaiser_window_beta_out_typed_handle();
    return op.call(window_length, periodic, beta, out);
}

// aten::kaiser_window.beta_out(int window_length, bool periodic, float beta, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & kaiser_window_beta_out::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, bool periodic, double beta, at::Tensor & out) {
    
    static auto op = create_kaiser_window_beta_out_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, periodic, beta, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_put_out, name, "aten::index_put")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_put_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_put_out, schema_str, "index_put.out(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::index_put.out(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<index_put_out::schema> create_index_put_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_put_out::name, index_put_out::overload_name)
      .typed<index_put_out::schema>();
}

// aten::index_put.out(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_put_out::call(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, at::Tensor & out) {
    
    static auto op = create_index_put_out_typed_handle();
    return op.call(self, indices, values, accumulate, out);
}

// aten::index_put.out(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_put_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, at::Tensor & out) {
    
    static auto op = create_index_put_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, indices, values, accumulate, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul_backward_out, name, "aten::matmul_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(matmul_backward_out, schema_str, "matmul_backward.out(Tensor grad, Tensor self, Tensor other, bool[2] mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::matmul_backward.out(Tensor grad, Tensor self, Tensor other, bool[2] mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<matmul_backward_out::schema> create_matmul_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(matmul_backward_out::name, matmul_backward_out::overload_name)
      .typed<matmul_backward_out::schema>();
}

// aten::matmul_backward.out(Tensor grad, Tensor self, Tensor other, bool[2] mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> matmul_backward_out::call(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & other, ::std::array<bool,2> mask, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_matmul_backward_out_typed_handle();
    return op.call(grad, self, other, mask, out0, out1);
}

// aten::matmul_backward.out(Tensor grad, Tensor self, Tensor other, bool[2] mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> matmul_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & self, const at::Tensor & other, ::std::array<bool,2> mask, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_matmul_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad, self, other, mask, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_backward_out, name, "aten::max_pool2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_backward_out, schema_str, "max_pool2d_backward.out(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::max_pool2d_backward.out(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<max_pool2d_backward_out::schema> create_max_pool2d_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool2d_backward_out::name, max_pool2d_backward_out::overload_name)
      .typed<max_pool2d_backward_out::schema>();
}

// aten::max_pool2d_backward.out(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & max_pool2d_backward_out::call(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
    
    static auto op = create_max_pool2d_backward_out_typed_handle();
    return op.call(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, out);
}

// aten::max_pool2d_backward.out(Tensor grad_output, Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & max_pool2d_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
    
    static auto op = create_max_pool2d_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool2d_backward_out, name, "aten::mkldnn_max_pool2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool2d_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool2d_backward_out, schema_str, "mkldnn_max_pool2d_backward.out(Tensor grad_output, Tensor output, Tensor input, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mkldnn_max_pool2d_backward.out(Tensor grad_output, Tensor output, Tensor input, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_max_pool2d_backward_out::schema> create_mkldnn_max_pool2d_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_max_pool2d_backward_out::name, mkldnn_max_pool2d_backward_out::overload_name)
      .typed<mkldnn_max_pool2d_backward_out::schema>();
}

// aten::mkldnn_max_pool2d_backward.out(Tensor grad_output, Tensor output, Tensor input, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_max_pool2d_backward_out::call(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
    
    static auto op = create_mkldnn_max_pool2d_backward_out_typed_handle();
    return op.call(grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode, out);
}

// aten::mkldnn_max_pool2d_backward.out(Tensor grad_output, Tensor output, Tensor input, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_max_pool2d_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
    
    static auto op = create_mkldnn_max_pool2d_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_out, name, "aten::median")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(median_out, schema_str, "median.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::median.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<median_out::schema> create_median_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(median_out::name, median_out::overload_name)
      .typed<median_out::schema>();
}

// aten::median.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & median_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_median_out_typed_handle();
    return op.call(self, out);
}

// aten::median.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & median_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_median_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_out, name, "aten::nanmedian")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nanmedian_out, schema_str, "nanmedian.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::nanmedian.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<nanmedian_out::schema> create_nanmedian_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nanmedian_out::name, nanmedian_out::overload_name)
      .typed<nanmedian_out::schema>();
}

// aten::nanmedian.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & nanmedian_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_nanmedian_out_typed_handle();
    return op.call(self, out);
}

// aten::nanmedian.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & nanmedian_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_nanmedian_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm_out, name, "aten::miopen_batch_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm_out, schema_str, "miopen_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))")

// aten::miopen_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
static C10_NOINLINE c10::TypedOperatorHandle<miopen_batch_norm_out::schema> create_miopen_batch_norm_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_batch_norm_out::name, miopen_batch_norm_out::overload_name)
      .typed<miopen_batch_norm_out::schema>();
}

// aten::miopen_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> miopen_batch_norm_out::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_miopen_batch_norm_out_typed_handle();
    return op.call(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon, out0, out1, out2);
}

// aten::miopen_batch_norm.out(Tensor input, Tensor weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float exponential_average_factor, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> miopen_batch_norm_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_miopen_batch_norm_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon, out0, out1, out2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_transpose_out, name, "aten::miopen_convolution_transpose")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_transpose_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_transpose_out, schema_str, "miopen_convolution_transpose.out(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, *, Tensor(a!) out) -> Tensor(a!)")

// aten::miopen_convolution_transpose.out(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<miopen_convolution_transpose_out::schema> create_miopen_convolution_transpose_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_convolution_transpose_out::name, miopen_convolution_transpose_out::overload_name)
      .typed<miopen_convolution_transpose_out::schema>();
}

// aten::miopen_convolution_transpose.out(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & miopen_convolution_transpose_out::call(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, at::Tensor & out) {
    
    static auto op = create_miopen_convolution_transpose_out_typed_handle();
    return op.call(self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic, out);
}

// aten::miopen_convolution_transpose.out(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & miopen_convolution_transpose_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, at::Tensor & out) {
    
    static auto op = create_miopen_convolution_transpose_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_rnn_backward_out, name, "aten::miopen_rnn_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_rnn_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_rnn_backward_out, schema_str, "miopen_rnn_backward.out(Tensor input, Tensor[] weight, int weight_stride0, Tensor weight_buf, Tensor hx, Tensor? cx, Tensor output, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state, Tensor reserve, bool[4] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!)[] out3) -> ()")

// aten::miopen_rnn_backward.out(Tensor input, Tensor[] weight, int weight_stride0, Tensor weight_buf, Tensor hx, Tensor? cx, Tensor output, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state, Tensor reserve, bool[4] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!)[] out3) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<miopen_rnn_backward_out::schema> create_miopen_rnn_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_rnn_backward_out::name, miopen_rnn_backward_out::overload_name)
      .typed<miopen_rnn_backward_out::schema>();
}

// aten::miopen_rnn_backward.out(Tensor input, Tensor[] weight, int weight_stride0, Tensor weight_buf, Tensor hx, Tensor? cx, Tensor output, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state, Tensor reserve, bool[4] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!)[] out3) -> ()
void miopen_rnn_backward_out::call(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::TensorList out3) {
    
    static auto op = create_miopen_rnn_backward_out_typed_handle();
    return op.call(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask, out0, out1, out2, out3);
}

// aten::miopen_rnn_backward.out(Tensor input, Tensor[] weight, int weight_stride0, Tensor weight_buf, Tensor hx, Tensor? cx, Tensor output, Tensor? grad_output, Tensor? grad_hy, Tensor? grad_cy, int mode, int hidden_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, int[] batch_sizes, Tensor? dropout_state, Tensor reserve, bool[4] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!)[] out3) -> ()
void miopen_rnn_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::TensorList out3) {
    
    static auto op = create_miopen_rnn_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask, out0, out1, out2, out3);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(channel_shuffle_out, name, "aten::channel_shuffle")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(channel_shuffle_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(channel_shuffle_out, schema_str, "channel_shuffle.out(Tensor self, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)")

// aten::channel_shuffle.out(Tensor self, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<channel_shuffle_out::schema> create_channel_shuffle_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(channel_shuffle_out::name, channel_shuffle_out::overload_name)
      .typed<channel_shuffle_out::schema>();
}

// aten::channel_shuffle.out(Tensor self, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & channel_shuffle_out::call(const at::Tensor & self, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_channel_shuffle_out_typed_handle();
    return op.call(self, groups, out);
}

// aten::channel_shuffle.out(Tensor self, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & channel_shuffle_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_channel_shuffle_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, groups, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu_out, name, "aten::relu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu_out, schema_str, "relu.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::relu.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<relu_out::schema> create_relu_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(relu_out::name, relu_out::overload_name)
      .typed<relu_out::schema>();
}

// aten::relu.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & relu_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_relu_out_typed_handle();
    return op.call(self, out);
}

// aten::relu.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & relu_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_relu_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_scatter_out, name, "aten::select_scatter")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_scatter_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_scatter_out, schema_str, "select_scatter.out(Tensor self, Tensor src, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)")

// aten::select_scatter.out(Tensor self, Tensor src, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<select_scatter_out::schema> create_select_scatter_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(select_scatter_out::name, select_scatter_out::overload_name)
      .typed<select_scatter_out::schema>();
}

// aten::select_scatter.out(Tensor self, Tensor src, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & select_scatter_out::call(const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::SymInt index, at::Tensor & out) {
    
    static auto op = create_select_scatter_out_typed_handle();
    return op.call(self, src, dim, index, out);
}

// aten::select_scatter.out(Tensor self, Tensor src, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & select_scatter_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::SymInt index, at::Tensor & out) {
    
    static auto op = create_select_scatter_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, dim, index, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsafe_split_with_sizes_out, name, "aten::unsafe_split_with_sizes")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsafe_split_with_sizes_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsafe_split_with_sizes_out, schema_str, "unsafe_split_with_sizes.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()")

// aten::unsafe_split_with_sizes.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<unsafe_split_with_sizes_out::schema> create_unsafe_split_with_sizes_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unsafe_split_with_sizes_out::name, unsafe_split_with_sizes_out::overload_name)
      .typed<unsafe_split_with_sizes_out::schema>();
}

// aten::unsafe_split_with_sizes.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()
void unsafe_split_with_sizes_out::call(const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim, at::TensorList out) {
    
    static auto op = create_unsafe_split_with_sizes_out_typed_handle();
    return op.call(self, split_sizes, dim, out);
}

// aten::unsafe_split_with_sizes.out(Tensor self, SymInt[] split_sizes, int dim=0, *, Tensor(a!)[] out) -> ()
void unsafe_split_with_sizes_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim, at::TensorList out) {
    
    static auto op = create_unsafe_split_with_sizes_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, split_sizes, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_out, name, "aten::prod")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prod_out, schema_str, "prod.out(Tensor self, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)")

// aten::prod.out(Tensor self, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<prod_out::schema> create_prod_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(prod_out::name, prod_out::overload_name)
      .typed<prod_out::schema>();
}

// aten::prod.out(Tensor self, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & prod_out::call(const at::Tensor & self, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_prod_out_typed_handle();
    return op.call(self, dtype, out);
}

// aten::prod.out(Tensor self, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & prod_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_prod_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dtype, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_from_mask_out, name, "aten::_nested_tensor_from_mask")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_from_mask_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_from_mask_out, schema_str, "_nested_tensor_from_mask.out(Tensor t, Tensor mask, bool mask_check=True, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_nested_tensor_from_mask.out(Tensor t, Tensor mask, bool mask_check=True, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_nested_tensor_from_mask_out::schema> create__nested_tensor_from_mask_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_nested_tensor_from_mask_out::name, _nested_tensor_from_mask_out::overload_name)
      .typed<_nested_tensor_from_mask_out::schema>();
}

// aten::_nested_tensor_from_mask.out(Tensor t, Tensor mask, bool mask_check=True, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _nested_tensor_from_mask_out::call(const at::Tensor & t, const at::Tensor & mask, bool mask_check, at::Tensor & out) {
    
    static auto op = create__nested_tensor_from_mask_out_typed_handle();
    return op.call(t, mask, mask_check, out);
}

// aten::_nested_tensor_from_mask.out(Tensor t, Tensor mask, bool mask_check=True, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _nested_tensor_from_mask_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & t, const at::Tensor & mask, bool mask_check, at::Tensor & out) {
    
    static auto op = create__nested_tensor_from_mask_out_typed_handle();
    return op.redispatch(dispatchKeySet, t, mask, mask_check, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_size_out, name, "aten::_nested_tensor_size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_size_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_size_out, schema_str, "_nested_tensor_size.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_nested_tensor_size.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_nested_tensor_size_out::schema> create__nested_tensor_size_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_nested_tensor_size_out::name, _nested_tensor_size_out::overload_name)
      .typed<_nested_tensor_size_out::schema>();
}

// aten::_nested_tensor_size.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _nested_tensor_size_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__nested_tensor_size_out_typed_handle();
    return op.call(self, out);
}

// aten::_nested_tensor_size.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _nested_tensor_size_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__nested_tensor_size_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_view_from_buffer_copy_out, name, "aten::_nested_view_from_buffer_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_view_from_buffer_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_view_from_buffer_copy_out, schema_str, "_nested_view_from_buffer_copy.out(Tensor self, Tensor nested_size, Tensor nested_strides, Tensor offsets, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_nested_view_from_buffer_copy.out(Tensor self, Tensor nested_size, Tensor nested_strides, Tensor offsets, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_nested_view_from_buffer_copy_out::schema> create__nested_view_from_buffer_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_nested_view_from_buffer_copy_out::name, _nested_view_from_buffer_copy_out::overload_name)
      .typed<_nested_view_from_buffer_copy_out::schema>();
}

// aten::_nested_view_from_buffer_copy.out(Tensor self, Tensor nested_size, Tensor nested_strides, Tensor offsets, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _nested_view_from_buffer_copy_out::call(const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets, at::Tensor & out) {
    
    static auto op = create__nested_view_from_buffer_copy_out_typed_handle();
    return op.call(self, nested_size, nested_strides, offsets, out);
}

// aten::_nested_view_from_buffer_copy.out(Tensor self, Tensor nested_size, Tensor nested_strides, Tensor offsets, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _nested_view_from_buffer_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets, at::Tensor & out) {
    
    static auto op = create__nested_view_from_buffer_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, nested_size, nested_strides, offsets, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unique_dim_consecutive_out, name, "aten::unique_dim_consecutive")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unique_dim_consecutive_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unique_dim_consecutive_out, schema_str, "unique_dim_consecutive.out(Tensor self, int dim, bool return_inverse=False, bool return_counts=False, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))")

// aten::unique_dim_consecutive.out(Tensor self, int dim, bool return_inverse=False, bool return_counts=False, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
static C10_NOINLINE c10::TypedOperatorHandle<unique_dim_consecutive_out::schema> create_unique_dim_consecutive_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unique_dim_consecutive_out::name, unique_dim_consecutive_out::overload_name)
      .typed<unique_dim_consecutive_out::schema>();
}

// aten::unique_dim_consecutive.out(Tensor self, int dim, bool return_inverse=False, bool return_counts=False, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> unique_dim_consecutive_out::call(const at::Tensor & self, int64_t dim, bool return_inverse, bool return_counts, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_unique_dim_consecutive_out_typed_handle();
    return op.call(self, dim, return_inverse, return_counts, out0, out1, out2);
}

// aten::unique_dim_consecutive.out(Tensor self, int dim, bool return_inverse=False, bool return_counts=False, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> unique_dim_consecutive_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool return_inverse, bool return_counts, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_unique_dim_consecutive_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, return_inverse, return_counts, out0, out1, out2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unsafe_view_out, name, "aten::_unsafe_view")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unsafe_view_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unsafe_view_out, schema_str, "_unsafe_view.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_unsafe_view.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_unsafe_view_out::schema> create__unsafe_view_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_unsafe_view_out::name, _unsafe_view_out::overload_name)
      .typed<_unsafe_view_out::schema>();
}

// aten::_unsafe_view.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _unsafe_view_out::call(const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create__unsafe_view_out_typed_handle();
    return op.call(self, size, out);
}

// aten::_unsafe_view.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _unsafe_view_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create__unsafe_view_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_efficientzerotensor_out, name, "aten::_efficientzerotensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_efficientzerotensor_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_efficientzerotensor_out, schema_str, "_efficientzerotensor.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_efficientzerotensor.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_efficientzerotensor_out::schema> create__efficientzerotensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_efficientzerotensor_out::name, _efficientzerotensor_out::overload_name)
      .typed<_efficientzerotensor_out::schema>();
}

// aten::_efficientzerotensor.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _efficientzerotensor_out::call(c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create__efficientzerotensor_out_typed_handle();
    return op.call(size, out);
}

// aten::_efficientzerotensor.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _efficientzerotensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create__efficientzerotensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(poisson_out, name, "aten::poisson")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(poisson_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(poisson_out, schema_str, "poisson.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::poisson.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<poisson_out::schema> create_poisson_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(poisson_out::name, poisson_out::overload_name)
      .typed<poisson_out::schema>();
}

// aten::poisson.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & poisson_out::call(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_poisson_out_typed_handle();
    return op.call(self, generator, out);
}

// aten::poisson.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & poisson_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_poisson_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, generator, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_Scalar_out, name, "aten::sub")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sub_Scalar_out, schema_str, "sub.Scalar_out(Tensor self, Scalar other, Scalar alpha=1, *, Tensor(a!) out) -> Tensor(a!)")

// aten::sub.Scalar_out(Tensor self, Scalar other, Scalar alpha=1, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sub_Scalar_out::schema> create_sub_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sub_Scalar_out::name, sub_Scalar_out::overload_name)
      .typed<sub_Scalar_out::schema>();
}

// aten::sub.Scalar_out(Tensor self, Scalar other, Scalar alpha=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sub_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_sub_Scalar_out_typed_handle();
    return op.call(self, other, alpha, out);
}

// aten::sub.Scalar_out(Tensor self, Scalar other, Scalar alpha=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sub_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_sub_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_size_out, name, "aten::sparse_coo_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_size_out, overload_name, "size_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_coo_tensor_size_out, schema_str, "sparse_coo_tensor.size_out(int[] size, *, Tensor(a!) out) -> Tensor(a!)")

// aten::sparse_coo_tensor.size_out(int[] size, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sparse_coo_tensor_size_out::schema> create_sparse_coo_tensor_size_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_coo_tensor_size_out::name, sparse_coo_tensor_size_out::overload_name)
      .typed<sparse_coo_tensor_size_out::schema>();
}

// aten::sparse_coo_tensor.size_out(int[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sparse_coo_tensor_size_out::call(at::IntArrayRef size, at::Tensor & out) {
    
    static auto op = create_sparse_coo_tensor_size_out_typed_handle();
    return op.call(size, out);
}

// aten::sparse_coo_tensor.size_out(int[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sparse_coo_tensor_size_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::IntArrayRef size, at::Tensor & out) {
    
    static auto op = create_sparse_coo_tensor_size_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_and_clear_out, name, "aten::sparse_resize_and_clear")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_and_clear_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_and_clear_out, schema_str, "sparse_resize_and_clear.out(Tensor self, int[] size, int sparse_dim, int dense_dim, *, Tensor(a!) out) -> Tensor(a!)")

// aten::sparse_resize_and_clear.out(Tensor self, int[] size, int sparse_dim, int dense_dim, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sparse_resize_and_clear_out::schema> create_sparse_resize_and_clear_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_resize_and_clear_out::name, sparse_resize_and_clear_out::overload_name)
      .typed<sparse_resize_and_clear_out::schema>();
}

// aten::sparse_resize_and_clear.out(Tensor self, int[] size, int sparse_dim, int dense_dim, *, Tensor(a!) out) -> Tensor(a!)
const at::Tensor & sparse_resize_and_clear_out::call(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim, const at::Tensor & out) {
    
    static auto op = create_sparse_resize_and_clear_out_typed_handle();
    return op.call(self, size, sparse_dim, dense_dim, out);
}

// aten::sparse_resize_and_clear.out(Tensor self, int[] size, int sparse_dim, int dense_dim, *, Tensor(a!) out) -> Tensor(a!)
const at::Tensor & sparse_resize_and_clear_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim, const at::Tensor & out) {
    
    static auto op = create_sparse_resize_and_clear_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, sparse_dim, dense_dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_and_clear, name, "aten::sparse_resize_and_clear")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_and_clear, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_and_clear, schema_str, "sparse_resize_and_clear(Tensor self, int[] size, int sparse_dim, int dense_dim) -> Tensor")

// aten::sparse_resize_and_clear(Tensor self, int[] size, int sparse_dim, int dense_dim) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_resize_and_clear::schema> create_sparse_resize_and_clear_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_resize_and_clear::name, sparse_resize_and_clear::overload_name)
      .typed<sparse_resize_and_clear::schema>();
}

// aten::sparse_resize_and_clear(Tensor self, int[] size, int sparse_dim, int dense_dim) -> Tensor
at::Tensor sparse_resize_and_clear::call(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
    
    static auto op = create_sparse_resize_and_clear_typed_handle();
    return op.call(self, size, sparse_dim, dense_dim);
}

// aten::sparse_resize_and_clear(Tensor self, int[] size, int sparse_dim, int dense_dim) -> Tensor
at::Tensor sparse_resize_and_clear::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
    
    static auto op = create_sparse_resize_and_clear_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, sparse_dim, dense_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_csr_out, name, "aten::_to_sparse_csr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_csr_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_csr_out, schema_str, "_to_sparse_csr.out(Tensor self, int? dense_dim=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_to_sparse_csr.out(Tensor self, int? dense_dim=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_to_sparse_csr_out::schema> create__to_sparse_csr_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_to_sparse_csr_out::name, _to_sparse_csr_out::overload_name)
      .typed<_to_sparse_csr_out::schema>();
}

// aten::_to_sparse_csr.out(Tensor self, int? dense_dim=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _to_sparse_csr_out::call(const at::Tensor & self, c10::optional<int64_t> dense_dim, at::Tensor & out) {
    
    static auto op = create__to_sparse_csr_out_typed_handle();
    return op.call(self, dense_dim, out);
}

// aten::_to_sparse_csr.out(Tensor self, int? dense_dim=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _to_sparse_csr_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<int64_t> dense_dim, at::Tensor & out) {
    
    static auto op = create__to_sparse_csr_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dense_dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_bsr_out, name, "aten::_to_sparse_bsr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_bsr_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_sparse_bsr_out, schema_str, "_to_sparse_bsr.out(Tensor self, int[2] blocksize, int? dense_dim=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_to_sparse_bsr.out(Tensor self, int[2] blocksize, int? dense_dim=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_to_sparse_bsr_out::schema> create__to_sparse_bsr_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_to_sparse_bsr_out::name, _to_sparse_bsr_out::overload_name)
      .typed<_to_sparse_bsr_out::schema>();
}

// aten::_to_sparse_bsr.out(Tensor self, int[2] blocksize, int? dense_dim=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _to_sparse_bsr_out::call(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim, at::Tensor & out) {
    
    static auto op = create__to_sparse_bsr_out_typed_handle();
    return op.call(self, blocksize, dense_dim, out);
}

// aten::_to_sparse_bsr.out(Tensor self, int[2] blocksize, int? dense_dim=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _to_sparse_bsr_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim, at::Tensor & out) {
    
    static auto op = create__to_sparse_bsr_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, blocksize, dense_dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_reorder_conv3d_weight_out, name, "aten::mkldnn_reorder_conv3d_weight")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_reorder_conv3d_weight_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_reorder_conv3d_weight_out, schema_str, "mkldnn_reorder_conv3d_weight.out(Tensor self, SymInt[3] padding=0, SymInt[3] stride=1, SymInt[3] dilation=1, SymInt groups=1, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mkldnn_reorder_conv3d_weight.out(Tensor self, SymInt[3] padding=0, SymInt[3] stride=1, SymInt[3] dilation=1, SymInt groups=1, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_reorder_conv3d_weight_out::schema> create_mkldnn_reorder_conv3d_weight_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_reorder_conv3d_weight_out::name, mkldnn_reorder_conv3d_weight_out::overload_name)
      .typed<mkldnn_reorder_conv3d_weight_out::schema>();
}

// aten::mkldnn_reorder_conv3d_weight.out(Tensor self, SymInt[3] padding=0, SymInt[3] stride=1, SymInt[3] dilation=1, SymInt groups=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_reorder_conv3d_weight_out::call(const at::Tensor & self, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_mkldnn_reorder_conv3d_weight_out_typed_handle();
    return op.call(self, padding, stride, dilation, groups, out);
}

// aten::mkldnn_reorder_conv3d_weight.out(Tensor self, SymInt[3] padding=0, SymInt[3] stride=1, SymInt[3] dilation=1, SymInt groups=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_reorder_conv3d_weight_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_mkldnn_reorder_conv3d_weight_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, padding, stride, dilation, groups, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_tensor_quantized_tensor_out, name, "aten::_make_per_tensor_quantized_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_tensor_quantized_tensor_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_tensor_quantized_tensor_out, schema_str, "_make_per_tensor_quantized_tensor.out(Tensor self, float scale, int zero_point, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_make_per_tensor_quantized_tensor.out(Tensor self, float scale, int zero_point, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_make_per_tensor_quantized_tensor_out::schema> create__make_per_tensor_quantized_tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_make_per_tensor_quantized_tensor_out::name, _make_per_tensor_quantized_tensor_out::overload_name)
      .typed<_make_per_tensor_quantized_tensor_out::schema>();
}

// aten::_make_per_tensor_quantized_tensor.out(Tensor self, float scale, int zero_point, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _make_per_tensor_quantized_tensor_out::call(const at::Tensor & self, double scale, int64_t zero_point, at::Tensor & out) {
    
    static auto op = create__make_per_tensor_quantized_tensor_out_typed_handle();
    return op.call(self, scale, zero_point, out);
}

// aten::_make_per_tensor_quantized_tensor.out(Tensor self, float scale, int zero_point, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _make_per_tensor_quantized_tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double scale, int64_t zero_point, at::Tensor & out) {
    
    static auto op = create__make_per_tensor_quantized_tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scale, zero_point, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_channel_quantized_tensor_out, name, "aten::_make_per_channel_quantized_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_channel_quantized_tensor_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_per_channel_quantized_tensor_out, schema_str, "_make_per_channel_quantized_tensor.out(Tensor self, Tensor scale, Tensor zero_point, int axis, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_make_per_channel_quantized_tensor.out(Tensor self, Tensor scale, Tensor zero_point, int axis, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_make_per_channel_quantized_tensor_out::schema> create__make_per_channel_quantized_tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_make_per_channel_quantized_tensor_out::name, _make_per_channel_quantized_tensor_out::overload_name)
      .typed<_make_per_channel_quantized_tensor_out::schema>();
}

// aten::_make_per_channel_quantized_tensor.out(Tensor self, Tensor scale, Tensor zero_point, int axis, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _make_per_channel_quantized_tensor_out::call(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, at::Tensor & out) {
    
    static auto op = create__make_per_channel_quantized_tensor_out_typed_handle();
    return op.call(self, scale, zero_point, axis, out);
}

// aten::_make_per_channel_quantized_tensor.out(Tensor self, Tensor scale, Tensor zero_point, int axis, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _make_per_channel_quantized_tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, at::Tensor & out) {
    
    static auto op = create__make_per_channel_quantized_tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scale, zero_point, axis, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Scalar_out, name, "aten::masked_fill")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Scalar_out, schema_str, "masked_fill.Scalar_out(Tensor self, Tensor mask, Scalar value, *, Tensor(a!) out) -> Tensor(a!)")

// aten::masked_fill.Scalar_out(Tensor self, Tensor mask, Scalar value, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<masked_fill_Scalar_out::schema> create_masked_fill_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_fill_Scalar_out::name, masked_fill_Scalar_out::overload_name)
      .typed<masked_fill_Scalar_out::schema>();
}

// aten::masked_fill.Scalar_out(Tensor self, Tensor mask, Scalar value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & masked_fill_Scalar_out::call(const at::Tensor & self, const at::Tensor & mask, const at::Scalar & value, at::Tensor & out) {
    
    static auto op = create_masked_fill_Scalar_out_typed_handle();
    return op.call(self, mask, value, out);
}

// aten::masked_fill.Scalar_out(Tensor self, Tensor mask, Scalar value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & masked_fill_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask, const at::Scalar & value, at::Tensor & out) {
    
    static auto op = create_masked_fill_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, value, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Tensor_out, name, "aten::masked_fill")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_fill_Tensor_out, schema_str, "masked_fill.Tensor_out(Tensor self, Tensor mask, Tensor value, *, Tensor(a!) out) -> Tensor(a!)")

// aten::masked_fill.Tensor_out(Tensor self, Tensor mask, Tensor value, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<masked_fill_Tensor_out::schema> create_masked_fill_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_fill_Tensor_out::name, masked_fill_Tensor_out::overload_name)
      .typed<masked_fill_Tensor_out::schema>();
}

// aten::masked_fill.Tensor_out(Tensor self, Tensor mask, Tensor value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & masked_fill_Tensor_out::call(const at::Tensor & self, const at::Tensor & mask, const at::Tensor & value, at::Tensor & out) {
    
    static auto op = create_masked_fill_Tensor_out_typed_handle();
    return op.call(self, mask, value, out);
}

// aten::masked_fill.Tensor_out(Tensor self, Tensor mask, Tensor value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & masked_fill_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask, const at::Tensor & value, at::Tensor & out) {
    
    static auto op = create_masked_fill_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, value, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_scatter_out, name, "aten::masked_scatter")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_scatter_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_scatter_out, schema_str, "masked_scatter.out(Tensor self, Tensor mask, Tensor source, *, Tensor(a!) out) -> Tensor(a!)")

// aten::masked_scatter.out(Tensor self, Tensor mask, Tensor source, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<masked_scatter_out::schema> create_masked_scatter_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_scatter_out::name, masked_scatter_out::overload_name)
      .typed<masked_scatter_out::schema>();
}

// aten::masked_scatter.out(Tensor self, Tensor mask, Tensor source, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & masked_scatter_out::call(const at::Tensor & self, const at::Tensor & mask, const at::Tensor & source, at::Tensor & out) {
    
    static auto op = create_masked_scatter_out_typed_handle();
    return op.call(self, mask, source, out);
}

// aten::masked_scatter.out(Tensor self, Tensor mask, Tensor source, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & masked_scatter_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask, const at::Tensor & source, at::Tensor & out) {
    
    static auto op = create_masked_scatter_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, source, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_softmax_backward_out, name, "aten::_masked_softmax_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_softmax_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_masked_softmax_backward_out, schema_str, "_masked_softmax_backward.out(Tensor grad_output, Tensor output, Tensor mask, int? dim=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_masked_softmax_backward.out(Tensor grad_output, Tensor output, Tensor mask, int? dim=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_masked_softmax_backward_out::schema> create__masked_softmax_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_masked_softmax_backward_out::name, _masked_softmax_backward_out::overload_name)
      .typed<_masked_softmax_backward_out::schema>();
}

// aten::_masked_softmax_backward.out(Tensor grad_output, Tensor output, Tensor mask, int? dim=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _masked_softmax_backward_out::call(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & mask, c10::optional<int64_t> dim, at::Tensor & out) {
    
    static auto op = create__masked_softmax_backward_out_typed_handle();
    return op.call(grad_output, output, mask, dim, out);
}

// aten::_masked_softmax_backward.out(Tensor grad_output, Tensor output, Tensor mask, int? dim=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _masked_softmax_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & mask, c10::optional<int64_t> dim, at::Tensor & out) {
    
    static auto op = create__masked_softmax_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output, mask, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar_Tensor_out, name, "aten::bitwise_or")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar_Tensor_out, overload_name, "Scalar_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_or_Scalar_Tensor_out, schema_str, "bitwise_or.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_or.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_or_Scalar_Tensor_out::schema> create_bitwise_or_Scalar_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_or_Scalar_Tensor_out::name, bitwise_or_Scalar_Tensor_out::overload_name)
      .typed<bitwise_or_Scalar_Tensor_out::schema>();
}

// aten::bitwise_or.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_or_Scalar_Tensor_out::call(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_or_Scalar_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_or.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_or_Scalar_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_or_Scalar_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(triu_indices_out, name, "aten::triu_indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(triu_indices_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(triu_indices_out, schema_str, "triu_indices.out(int row, int col, int offset=0, *, Tensor(a!) out) -> Tensor(a!)")

// aten::triu_indices.out(int row, int col, int offset=0, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<triu_indices_out::schema> create_triu_indices_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(triu_indices_out::name, triu_indices_out::overload_name)
      .typed<triu_indices_out::schema>();
}

// aten::triu_indices.out(int row, int col, int offset=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & triu_indices_out::call(int64_t row, int64_t col, int64_t offset, at::Tensor & out) {
    
    static auto op = create_triu_indices_out_typed_handle();
    return op.call(row, col, offset, out);
}

// aten::triu_indices.out(int row, int col, int offset=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & triu_indices_out::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t row, int64_t col, int64_t offset, at::Tensor & out) {
    
    static auto op = create_triu_indices_out_typed_handle();
    return op.redispatch(dispatchKeySet, row, col, offset, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trace_out, name, "aten::trace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trace_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trace_out, schema_str, "trace.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::trace.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<trace_out::schema> create_trace_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(trace_out::name, trace_out::overload_name)
      .typed<trace_out::schema>();
}

// aten::trace.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & trace_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_trace_out_typed_handle();
    return op.call(self, out);
}

// aten::trace.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & trace_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_trace_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dist_out, name, "aten::dist")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dist_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dist_out, schema_str, "dist.out(Tensor self, Tensor other, Scalar p=2, *, Tensor(a!) out) -> Tensor(a!)")

// aten::dist.out(Tensor self, Tensor other, Scalar p=2, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<dist_out::schema> create_dist_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(dist_out::name, dist_out::overload_name)
      .typed<dist_out::schema>();
}

// aten::dist.out(Tensor self, Tensor other, Scalar p=2, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & dist_out::call(const at::Tensor & self, const at::Tensor & other, const at::Scalar & p, at::Tensor & out) {
    
    static auto op = create_dist_out_typed_handle();
    return op.call(self, other, p, out);
}

// aten::dist.out(Tensor self, Tensor other, Scalar p=2, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & dist_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, const at::Scalar & p, at::Tensor & out) {
    
    static auto op = create_dist_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, p, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_histogramdd_from_bin_cts_out, name, "aten::_histogramdd_from_bin_cts")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_histogramdd_from_bin_cts_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_histogramdd_from_bin_cts_out, schema_str, "_histogramdd_from_bin_cts.out(Tensor self, int[] bins, *, float[]? range=None, Tensor? weight=None, bool density=False, Tensor(a!) out) -> Tensor(a!)")

// aten::_histogramdd_from_bin_cts.out(Tensor self, int[] bins, *, float[]? range=None, Tensor? weight=None, bool density=False, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_histogramdd_from_bin_cts_out::schema> create__histogramdd_from_bin_cts_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_histogramdd_from_bin_cts_out::name, _histogramdd_from_bin_cts_out::overload_name)
      .typed<_histogramdd_from_bin_cts_out::schema>();
}

// aten::_histogramdd_from_bin_cts.out(Tensor self, int[] bins, *, float[]? range=None, Tensor? weight=None, bool density=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _histogramdd_from_bin_cts_out::call(const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & out) {
    
    static auto op = create__histogramdd_from_bin_cts_out_typed_handle();
    return op.call(self, bins, range, weight, density, out);
}

// aten::_histogramdd_from_bin_cts.out(Tensor self, int[] bins, *, float[]? range=None, Tensor? weight=None, bool density=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _histogramdd_from_bin_cts_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & out) {
    
    static auto op = create__histogramdd_from_bin_cts_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, bins, range, weight, density, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar_Tensor_out, name, "aten::remainder")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar_Tensor_out, overload_name, "Scalar_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(remainder_Scalar_Tensor_out, schema_str, "remainder.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::remainder.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<remainder_Scalar_Tensor_out::schema> create_remainder_Scalar_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(remainder_Scalar_Tensor_out::name, remainder_Scalar_Tensor_out::overload_name)
      .typed<remainder_Scalar_Tensor_out::schema>();
}

// aten::remainder.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & remainder_Scalar_Tensor_out::call(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_remainder_Scalar_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::remainder.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & remainder_Scalar_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_remainder_Scalar_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_Scalar_out, name, "aten::_foreach_clamp_max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_Scalar_out, schema_str, "_foreach_clamp_max.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_clamp_max.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_max_Scalar_out::schema> create__foreach_clamp_max_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_max_Scalar_out::name, _foreach_clamp_max_Scalar_out::overload_name)
      .typed<_foreach_clamp_max_Scalar_out::schema>();
}

// aten::_foreach_clamp_max.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_max_Scalar_out::call(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
    
    static auto op = create__foreach_clamp_max_Scalar_out_typed_handle();
    return op.call(self, scalar, out);
}

// aten::_foreach_clamp_max.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_max_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
    
    static auto op = create__foreach_clamp_max_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_List_out, name, "aten::_foreach_clamp_max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_List_out, overload_name, "List_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_List_out, schema_str, "_foreach_clamp_max.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_clamp_max.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_max_List_out::schema> create__foreach_clamp_max_List_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_max_List_out::name, _foreach_clamp_max_List_out::overload_name)
      .typed<_foreach_clamp_max_List_out::schema>();
}

// aten::_foreach_clamp_max.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_max_List_out::call(at::TensorList self, at::TensorList other, at::TensorList out) {
    
    static auto op = create__foreach_clamp_max_List_out_typed_handle();
    return op.call(self, other, out);
}

// aten::_foreach_clamp_max.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_max_List_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other, at::TensorList out) {
    
    static auto op = create__foreach_clamp_max_List_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_ScalarList_out, name, "aten::_foreach_clamp_max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_ScalarList_out, overload_name, "ScalarList_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_max_ScalarList_out, schema_str, "_foreach_clamp_max.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_clamp_max.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_max_ScalarList_out::schema> create__foreach_clamp_max_ScalarList_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_max_ScalarList_out::name, _foreach_clamp_max_ScalarList_out::overload_name)
      .typed<_foreach_clamp_max_ScalarList_out::schema>();
}

// aten::_foreach_clamp_max.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_max_ScalarList_out::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
    
    static auto op = create__foreach_clamp_max_ScalarList_out_typed_handle();
    return op.call(self, scalars, out);
}

// aten::_foreach_clamp_max.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_max_ScalarList_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
    
    static auto op = create__foreach_clamp_max_ScalarList_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_abs_out, name, "aten::_foreach_abs")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_abs_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_abs_out, schema_str, "_foreach_abs.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_abs.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_abs_out::schema> create__foreach_abs_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_abs_out::name, _foreach_abs_out::overload_name)
      .typed<_foreach_abs_out::schema>();
}

// aten::_foreach_abs.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_abs_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_abs_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_abs.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_abs_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_abs_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_expm1_out, name, "aten::_foreach_expm1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_expm1_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_expm1_out, schema_str, "_foreach_expm1.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_expm1.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_expm1_out::schema> create__foreach_expm1_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_expm1_out::name, _foreach_expm1_out::overload_name)
      .typed<_foreach_expm1_out::schema>();
}

// aten::_foreach_expm1.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_expm1_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_expm1_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_expm1.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_expm1_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_expm1_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_log10_out, name, "aten::_foreach_log10")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_log10_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_log10_out, schema_str, "_foreach_log10.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_log10.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_log10_out::schema> create__foreach_log10_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_log10_out::name, _foreach_log10_out::overload_name)
      .typed<_foreach_log10_out::schema>();
}

// aten::_foreach_log10.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_log10_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_log10_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_log10.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_log10_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_log10_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sign_out, name, "aten::_foreach_sign")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sign_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sign_out, schema_str, "_foreach_sign.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_sign.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_sign_out::schema> create__foreach_sign_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_sign_out::name, _foreach_sign_out::overload_name)
      .typed<_foreach_sign_out::schema>();
}

// aten::_foreach_sign.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_sign_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_sign_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_sign.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_sign_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_sign_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sinh_out, name, "aten::_foreach_sinh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sinh_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_sinh_out, schema_str, "_foreach_sinh.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_sinh.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_sinh_out::schema> create__foreach_sinh_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_sinh_out::name, _foreach_sinh_out::overload_name)
      .typed<_foreach_sinh_out::schema>();
}

// aten::_foreach_sinh.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_sinh_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_sinh_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_sinh.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_sinh_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_sinh_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_tan_out, name, "aten::_foreach_tan")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_tan_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_tan_out, schema_str, "_foreach_tan.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_tan.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_tan_out::schema> create__foreach_tan_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_tan_out::name, _foreach_tan_out::overload_name)
      .typed<_foreach_tan_out::schema>();
}

// aten::_foreach_tan.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_tan_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_tan_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_tan.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_tan_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_tan_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_copy_out, name, "aten::_foreach_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_copy_out, schema_str, "_foreach_copy.out(Tensor[] self, Tensor[] src, bool non_blocking=False, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_copy.out(Tensor[] self, Tensor[] src, bool non_blocking=False, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_copy_out::schema> create__foreach_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_copy_out::name, _foreach_copy_out::overload_name)
      .typed<_foreach_copy_out::schema>();
}

// aten::_foreach_copy.out(Tensor[] self, Tensor[] src, bool non_blocking=False, *, Tensor(a!)[] out) -> ()
void _foreach_copy_out::call(at::TensorList self, at::TensorList src, bool non_blocking, at::TensorList out) {
    
    static auto op = create__foreach_copy_out_typed_handle();
    return op.call(self, src, non_blocking, out);
}

// aten::_foreach_copy.out(Tensor[] self, Tensor[] src, bool non_blocking=False, *, Tensor(a!)[] out) -> ()
void _foreach_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList src, bool non_blocking, at::TensorList out) {
    
    static auto op = create__foreach_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, non_blocking, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_copy, name, "aten::_foreach_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_copy, schema_str, "_foreach_copy(Tensor[] self, Tensor[] src, bool non_blocking=False) -> Tensor[] self_out")

// aten::_foreach_copy(Tensor[] self, Tensor[] src, bool non_blocking=False) -> Tensor[] self_out
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_copy::schema> create__foreach_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_copy::name, _foreach_copy::overload_name)
      .typed<_foreach_copy::schema>();
}

// aten::_foreach_copy(Tensor[] self, Tensor[] src, bool non_blocking=False) -> Tensor[] self_out
::std::vector<at::Tensor> _foreach_copy::call(at::TensorList self, at::TensorList src, bool non_blocking) {
    
    static auto op = create__foreach_copy_typed_handle();
    return op.call(self, src, non_blocking);
}

// aten::_foreach_copy(Tensor[] self, Tensor[] src, bool non_blocking=False) -> Tensor[] self_out
::std::vector<at::Tensor> _foreach_copy::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList src, bool non_blocking) {
    
    static auto op = create__foreach_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, non_blocking);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_adaptive_avg_pool2d_out, name, "aten::_adaptive_avg_pool2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_adaptive_avg_pool2d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_adaptive_avg_pool2d_out, schema_str, "_adaptive_avg_pool2d.out(Tensor self, SymInt[2] output_size, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_adaptive_avg_pool2d.out(Tensor self, SymInt[2] output_size, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_adaptive_avg_pool2d_out::schema> create__adaptive_avg_pool2d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_adaptive_avg_pool2d_out::name, _adaptive_avg_pool2d_out::overload_name)
      .typed<_adaptive_avg_pool2d_out::schema>();
}

// aten::_adaptive_avg_pool2d.out(Tensor self, SymInt[2] output_size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _adaptive_avg_pool2d_out::call(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
    
    static auto op = create__adaptive_avg_pool2d_out_typed_handle();
    return op.call(self, output_size, out);
}

// aten::_adaptive_avg_pool2d.out(Tensor self, SymInt[2] output_size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _adaptive_avg_pool2d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
    
    static auto op = create__adaptive_avg_pool2d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_warn_in_autograd_out, name, "aten::_test_warn_in_autograd")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_warn_in_autograd_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_warn_in_autograd_out, schema_str, "_test_warn_in_autograd.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_test_warn_in_autograd.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_test_warn_in_autograd_out::schema> create__test_warn_in_autograd_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_warn_in_autograd_out::name, _test_warn_in_autograd_out::overload_name)
      .typed<_test_warn_in_autograd_out::schema>();
}

// aten::_test_warn_in_autograd.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _test_warn_in_autograd_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__test_warn_in_autograd_out_typed_handle();
    return op.call(self, out);
}

// aten::_test_warn_in_autograd.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _test_warn_in_autograd_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__test_warn_in_autograd_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_copy_out, name, "aten::diagonal_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_copy_out, schema_str, "diagonal_copy.out(Tensor self, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)")

// aten::diagonal_copy.out(Tensor self, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<diagonal_copy_out::schema> create_diagonal_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(diagonal_copy_out::name, diagonal_copy_out::overload_name)
      .typed<diagonal_copy_out::schema>();
}

// aten::diagonal_copy.out(Tensor self, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & diagonal_copy_out::call(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
    
    static auto op = create_diagonal_copy_out_typed_handle();
    return op.call(self, offset, dim1, dim2, out);
}

// aten::diagonal_copy.out(Tensor self, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & diagonal_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
    
    static auto op = create_diagonal_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, offset, dim1, dim2, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(permute_copy_out, name, "aten::permute_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(permute_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(permute_copy_out, schema_str, "permute_copy.out(Tensor self, int[] dims, *, Tensor(a!) out) -> Tensor(a!)")

// aten::permute_copy.out(Tensor self, int[] dims, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<permute_copy_out::schema> create_permute_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(permute_copy_out::name, permute_copy_out::overload_name)
      .typed<permute_copy_out::schema>();
}

// aten::permute_copy.out(Tensor self, int[] dims, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & permute_copy_out::call(const at::Tensor & self, at::IntArrayRef dims, at::Tensor & out) {
    
    static auto op = create_permute_copy_out_typed_handle();
    return op.call(self, dims, out);
}

// aten::permute_copy.out(Tensor self, int[] dims, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & permute_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dims, at::Tensor & out) {
    
    static auto op = create_permute_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dims, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_copy_int_out, name, "aten::select_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_copy_int_out, overload_name, "int_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(select_copy_int_out, schema_str, "select_copy.int_out(Tensor self, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)")

// aten::select_copy.int_out(Tensor self, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<select_copy_int_out::schema> create_select_copy_int_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(select_copy_int_out::name, select_copy_int_out::overload_name)
      .typed<select_copy_int_out::schema>();
}

// aten::select_copy.int_out(Tensor self, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & select_copy_int_out::call(const at::Tensor & self, int64_t dim, c10::SymInt index, at::Tensor & out) {
    
    static auto op = create_select_copy_int_out_typed_handle();
    return op.call(self, dim, index, out);
}

// aten::select_copy.int_out(Tensor self, int dim, SymInt index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & select_copy_int_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::SymInt index, at::Tensor & out) {
    
    static auto op = create_select_copy_int_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_copy_Tensor_out, name, "aten::slice_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_copy_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(slice_copy_Tensor_out, schema_str, "slice_copy.Tensor_out(Tensor self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1, *, Tensor(a!) out) -> Tensor(a!)")

// aten::slice_copy.Tensor_out(Tensor self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<slice_copy_Tensor_out::schema> create_slice_copy_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(slice_copy_Tensor_out::name, slice_copy_Tensor_out::overload_name)
      .typed<slice_copy_Tensor_out::schema>();
}

// aten::slice_copy.Tensor_out(Tensor self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & slice_copy_Tensor_out::call(const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step, at::Tensor & out) {
    
    static auto op = create_slice_copy_Tensor_out_typed_handle();
    return op.call(self, dim, start, end, step, out);
}

// aten::slice_copy.Tensor_out(Tensor self, int dim=0, SymInt? start=None, SymInt? end=None, SymInt step=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & slice_copy_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step, at::Tensor & out) {
    
    static auto op = create_slice_copy_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, start, end, step, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(t_copy_out, name, "aten::t_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(t_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(t_copy_out, schema_str, "t_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::t_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<t_copy_out::schema> create_t_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(t_copy_out::name, t_copy_out::overload_name)
      .typed<t_copy_out::schema>();
}

// aten::t_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & t_copy_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_t_copy_out_typed_handle();
    return op.call(self, out);
}

// aten::t_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & t_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_t_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(col_indices_copy_out, name, "aten::col_indices_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(col_indices_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(col_indices_copy_out, schema_str, "col_indices_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::col_indices_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<col_indices_copy_out::schema> create_col_indices_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(col_indices_copy_out::name, col_indices_copy_out::overload_name)
      .typed<col_indices_copy_out::schema>();
}

// aten::col_indices_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & col_indices_copy_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_col_indices_copy_out_typed_handle();
    return op.call(self, out);
}

// aten::col_indices_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & col_indices_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_col_indices_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alias_copy_out, name, "aten::alias_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alias_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(alias_copy_out, schema_str, "alias_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::alias_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<alias_copy_out::schema> create_alias_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(alias_copy_out::name, alias_copy_out::overload_name)
      .typed<alias_copy_out::schema>();
}

// aten::alias_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & alias_copy_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_alias_copy_out_typed_handle();
    return op.call(self, out);
}

// aten::alias_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & alias_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_alias_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_triton_scaled_dot_attention_out, name, "aten::_triton_scaled_dot_attention")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_triton_scaled_dot_attention_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_triton_scaled_dot_attention_out, schema_str, "_triton_scaled_dot_attention.out(Tensor q, Tensor k, Tensor v, float dropout_p=0.0, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_triton_scaled_dot_attention.out(Tensor q, Tensor k, Tensor v, float dropout_p=0.0, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_triton_scaled_dot_attention_out::schema> create__triton_scaled_dot_attention_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_triton_scaled_dot_attention_out::name, _triton_scaled_dot_attention_out::overload_name)
      .typed<_triton_scaled_dot_attention_out::schema>();
}

// aten::_triton_scaled_dot_attention.out(Tensor q, Tensor k, Tensor v, float dropout_p=0.0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _triton_scaled_dot_attention_out::call(const at::Tensor & q, const at::Tensor & k, const at::Tensor & v, double dropout_p, at::Tensor & out) {
    
    static auto op = create__triton_scaled_dot_attention_out_typed_handle();
    return op.call(q, k, v, dropout_p, out);
}

// aten::_triton_scaled_dot_attention.out(Tensor q, Tensor k, Tensor v, float dropout_p=0.0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _triton_scaled_dot_attention_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & q, const at::Tensor & k, const at::Tensor & v, double dropout_p, at::Tensor & out) {
    
    static auto op = create__triton_scaled_dot_attention_out_typed_handle();
    return op.redispatch(dispatchKeySet, q, k, v, dropout_p, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foobar_out, name, "aten::_foobar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foobar_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foobar_out, schema_str, "_foobar.out(Tensor self, bool arg1=True, bool arg2=True, *, bool arg3=True, Tensor(a!) out) -> Tensor(a!)")

// aten::_foobar.out(Tensor self, bool arg1=True, bool arg2=True, *, bool arg3=True, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_foobar_out::schema> create__foobar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foobar_out::name, _foobar_out::overload_name)
      .typed<_foobar_out::schema>();
}

// aten::_foobar.out(Tensor self, bool arg1=True, bool arg2=True, *, bool arg3=True, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _foobar_out::call(const at::Tensor & self, bool arg1, bool arg2, bool arg3, at::Tensor & out) {
    
    static auto op = create__foobar_out_typed_handle();
    return op.call(self, arg1, arg2, arg3, out);
}

// aten::_foobar.out(Tensor self, bool arg1=True, bool arg2=True, *, bool arg3=True, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _foobar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool arg1, bool arg2, bool arg3, at::Tensor & out) {
    
    static auto op = create__foobar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, arg1, arg2, arg3, out);
}

}} // namespace at::_ops
