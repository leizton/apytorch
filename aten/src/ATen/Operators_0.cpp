#include <ATen/Tensor.h>
#include <ATen/core/dispatch/Dispatcher.h>

// @generated by torchgen/gen.py from Operators.cpp
// NOTE See [Sharded File] comment in VariableType

#ifndef AT_PER_OPERATOR_HEADERS
#include <ATen/Operators.h>
#else
#include <ATen/ops/_cast_Byte.h>
#include <ATen/ops/_cast_Char.h>
#include <ATen/ops/is_leaf.h>
#include <ATen/ops/requires_grad.h>
#include <ATen/ops/retains_grad.h>
#include <ATen/ops/_unpack_dual.h>
#include <ATen/ops/_has_same_storage_numel.h>
#include <ATen/ops/align_to.h>
#include <ATen/ops/align_to.h>
#include <ATen/ops/_use_cudnn_ctc_loss.h>
#include <ATen/ops/_use_cudnn_ctc_loss.h>
#include <ATen/ops/_cudnn_ctc_loss.h>
#include <ATen/ops/_cudnn_ctc_loss.h>
#include <ATen/ops/_cudnn_rnn.h>
#include <ATen/ops/_debug_has_internal_overlap.h>
#include <ATen/ops/_fused_dropout.h>
#include <ATen/ops/_sobol_engine_initialize_state.h>
#include <ATen/ops/_shape_as_tensor.h>
#include <ATen/ops/dropout.h>
#include <ATen/ops/dropout.h>
#include <ATen/ops/sgn.h>
#include <ATen/ops/sgn.h>
#include <ATen/ops/sgn.h>
#include <ATen/ops/real.h>
#include <ATen/ops/_conj.h>
#include <ATen/ops/_conj_physical.h>
#include <ATen/ops/_neg_view.h>
#include <ATen/ops/avg_pool1d.h>
#include <ATen/ops/adaptive_avg_pool1d.h>
#include <ATen/ops/_is_all_true.h>
#include <ATen/ops/_test_check_tensor.h>
#include <ATen/ops/allclose.h>
#include <ATen/ops/argmax.h>
#include <ATen/ops/argmax.h>
#include <ATen/ops/acosh.h>
#include <ATen/ops/acosh.h>
#include <ATen/ops/acosh.h>
#include <ATen/ops/arctanh.h>
#include <ATen/ops/arctanh.h>
#include <ATen/ops/arctanh.h>
#include <ATen/ops/as_strided.h>
#include <ATen/ops/as_strided.h>
#include <ATen/ops/atleast_3d.h>
#include <ATen/ops/atleast_3d.h>
#include <ATen/ops/_batch_norm_impl_index.h>
#include <ATen/ops/_batch_norm_impl_index_backward.h>
#include <ATen/ops/logical_or.h>
#include <ATen/ops/logical_or.h>
#include <ATen/ops/logical_or.h>
#include <ATen/ops/blackman_window.h>
#include <ATen/ops/blackman_window.h>
#include <ATen/ops/broadcast_tensors.h>
#include <ATen/ops/cat.h>
#include <ATen/ops/cat.h>
#include <ATen/ops/cat.h>
#include <ATen/ops/cat.h>
#include <ATen/ops/convolution.h>
#include <ATen/ops/convolution_backward_overrideable.h>
#include <ATen/ops/_convolution.h>
#include <ATen/ops/_convolution.h>
#include <ATen/ops/conv_transpose1d.h>
#include <ATen/ops/cos.h>
#include <ATen/ops/cos.h>
#include <ATen/ops/cos.h>
#include <ATen/ops/cudnn_affine_grid_generator.h>
#include <ATen/ops/cudnn_batch_norm_backward.h>
#include <ATen/ops/cudnn_convolution_transpose.h>
#include <ATen/ops/cudnn_grid_sampler_backward.h>
#include <ATen/ops/cumsum.h>
#include <ATen/ops/cumsum.h>
#include <ATen/ops/cumsum.h>
#include <ATen/ops/cumsum.h>
#include <ATen/ops/cumsum.h>
#include <ATen/ops/cumsum.h>
#include <ATen/ops/_ctc_loss.h>
#include <ATen/ops/_ctc_loss.h>
#include <ATen/ops/diagflat.h>
#include <ATen/ops/linalg_diagonal.h>
#include <ATen/ops/true_divide.h>
#include <ATen/ops/true_divide.h>
#include <ATen/ops/true_divide.h>
#include <ATen/ops/true_divide.h>
#include <ATen/ops/true_divide.h>
#include <ATen/ops/vdot.h>
#include <ATen/ops/vdot.h>
#include <ATen/ops/embedding_backward.h>
#include <ATen/ops/embedding_dense_backward.h>
#include <ATen/ops/_embedding_bag.h>
#include <ATen/ops/_embedding_bag_sparse_backward.h>
#include <ATen/ops/new_empty.h>
#include <ATen/ops/expm1.h>
#include <ATen/ops/expm1.h>
#include <ATen/ops/expm1.h>
#include <ATen/ops/expand_as.h>
#include <ATen/ops/unflatten.h>
#include <ATen/ops/unflatten.h>
#include <ATen/ops/fill.h>
#include <ATen/ops/fill.h>
#include <ATen/ops/fill.h>
#include <ATen/ops/fill.h>
#include <ATen/ops/lcm.h>
#include <ATen/ops/lcm.h>
#include <ATen/ops/lcm.h>
#include <ATen/ops/grid_sampler_2d_backward.h>
#include <ATen/ops/group_norm.h>
#include <ATen/ops/index_copy.h>
#include <ATen/ops/index_copy.h>
#include <ATen/ops/index_copy.h>
#include <ATen/ops/index_copy.h>
#include <ATen/ops/index_copy.h>
#include <ATen/ops/_unsafe_index_put.h>
#include <ATen/ops/_index_put_impl.h>
#include <ATen/ops/is_distributed.h>
#include <ATen/ops/is_inference.h>
#include <ATen/ops/kron.h>
#include <ATen/ops/kron.h>
#include <ATen/ops/linear.h>
#include <ATen/ops/linear.h>
#include <ATen/ops/mkldnn_linear.h>
#include <ATen/ops/mkldnn_linear_backward_weights.h>
#include <ATen/ops/_cslt_sparse_mm.h>
#include <ATen/ops/_mixed_dtypes_linear.h>
#include <ATen/ops/fbgemm_linear_quantize_weight.h>
#include <ATen/ops/linspace.h>
#include <ATen/ops/linspace.h>
#include <ATen/ops/linspace.h>
#include <ATen/ops/linspace.h>
#include <ATen/ops/linspace.h>
#include <ATen/ops/linspace.h>
#include <ATen/ops/linspace.h>
#include <ATen/ops/linspace.h>
#include <ATen/ops/log10.h>
#include <ATen/ops/log10.h>
#include <ATen/ops/log10.h>
#include <ATen/ops/log1p.h>
#include <ATen/ops/log1p.h>
#include <ATen/ops/log1p.h>
#include <ATen/ops/logaddexp2.h>
#include <ATen/ops/logaddexp2.h>
#include <ATen/ops/_log_softmax.h>
#include <ATen/ops/_log_softmax.h>
#include <ATen/ops/logsumexp.h>
#include <ATen/ops/logsumexp.h>
#include <ATen/ops/logsumexp.h>
#include <ATen/ops/logsumexp.h>
#include <ATen/ops/_aminmax.h>
#include <ATen/ops/_aminmax.h>
#include <ATen/ops/aminmax.h>
#include <ATen/ops/aminmax.h>
#include <ATen/ops/max.h>
#include <ATen/ops/max.h>
#include <ATen/ops/max.h>
#include <ATen/ops/max.h>
#include <ATen/ops/max_pool1d_with_indices.h>
#include <ATen/ops/mkldnn_max_pool3d_backward.h>
#include <ATen/ops/quantized_max_pool1d.h>
#include <ATen/ops/mkldnn_convolution.h>
#include <ATen/ops/miopen_batch_norm_backward.h>
#include <ATen/ops/miopen_convolution_relu.h>
#include <ATen/ops/mode.h>
#include <ATen/ops/mode.h>
#include <ATen/ops/mode.h>
#include <ATen/ops/mode.h>
#include <ATen/ops/mul.h>
#include <ATen/ops/mul.h>
#include <ATen/ops/mul.h>
#include <ATen/ops/mul.h>
#include <ATen/ops/mul.h>
#include <ATen/ops/mvlgamma.h>
#include <ATen/ops/mvlgamma.h>
#include <ATen/ops/mvlgamma.h>
#include <ATen/ops/narrow.h>
#include <ATen/ops/narrow.h>
#include <ATen/ops/batch_norm_backward_elemt.h>
#include <ATen/ops/pdist.h>
#include <ATen/ops/moveaxis.h>
#include <ATen/ops/moveaxis.h>
#include <ATen/ops/pixel_unshuffle.h>
#include <ATen/ops/is_pinned.h>
#include <ATen/ops/pin_memory.h>
#include <ATen/ops/_pin_memory.h>
#include <ATen/ops/randn.h>
#include <ATen/ops/randn.h>
#include <ATen/ops/randn.h>
#include <ATen/ops/randn.h>
#include <ATen/ops/randn.h>
#include <ATen/ops/randn.h>
#include <ATen/ops/range.h>
#include <ATen/ops/range.h>
#include <ATen/ops/range.h>
#include <ATen/ops/range.h>
#include <ATen/ops/ravel.h>
#include <ATen/ops/reciprocal.h>
#include <ATen/ops/reciprocal.h>
#include <ATen/ops/reciprocal.h>
#include <ATen/ops/neg.h>
#include <ATen/ops/neg.h>
#include <ATen/ops/neg.h>
#include <ATen/ops/reshape_as.h>
#include <ATen/ops/rrelu.h>
#include <ATen/ops/rrelu.h>
#include <ATen/ops/relu6.h>
#include <ATen/ops/relu6.h>
#include <ATen/ops/prelu.h>
#include <ATen/ops/_prelu_kernel_backward.h>
#include <ATen/ops/gelu_backward.h>
#include <ATen/ops/gelu_backward.h>
#include <ATen/ops/selu.h>
#include <ATen/ops/selu.h>
#include <ATen/ops/silu_backward.h>
#include <ATen/ops/silu_backward.h>
#include <ATen/ops/sin.h>
#include <ATen/ops/sin.h>
#include <ATen/ops/sin.h>
#include <ATen/ops/sym_storage_offset.h>
#include <ATen/ops/diagonal_scatter.h>
#include <ATen/ops/as_strided_scatter.h>
#include <ATen/ops/split.h>
#include <ATen/ops/split.h>
#include <ATen/ops/squeeze.h>
#include <ATen/ops/squeeze.h>
#include <ATen/ops/squeeze.h>
#include <ATen/ops/squeeze.h>
#include <ATen/ops/squeeze.h>
#include <ATen/ops/squeeze.h>
#include <ATen/ops/squeeze.h>
#include <ATen/ops/squeeze.h>
#include <ATen/ops/sspaddmm.h>
#include <ATen/ops/sspaddmm.h>
#include <ATen/ops/stride.h>
#include <ATen/ops/stride.h>
#include <ATen/ops/threshold_backward.h>
#include <ATen/ops/threshold_backward.h>
#include <ATen/ops/one_hot.h>
#include <ATen/ops/_transform_bias_rescale_qkv.h>
#include <ATen/ops/_unique.h>
#include <ATen/ops/where.h>
#include <ATen/ops/where.h>
#include <ATen/ops/where.h>
#include <ATen/ops/where.h>
#include <ATen/ops/where.h>
#include <ATen/ops/where.h>
#include <ATen/ops/_weight_norm.h>
#include <ATen/ops/_weight_norm_interface.h>
#include <ATen/ops/_weight_norm_differentiable_backward.h>
#include <ATen/ops/zeros.h>
#include <ATen/ops/zeros.h>
#include <ATen/ops/zeros.h>
#include <ATen/ops/_standard_gamma.h>
#include <ATen/ops/_sample_dirichlet.h>
#include <ATen/ops/binomial.h>
#include <ATen/ops/_sparse_sum.h>
#include <ATen/ops/_sparse_sum.h>
#include <ATen/ops/_sparse_sum.h>
#include <ATen/ops/_sparse_sum.h>
#include <ATen/ops/_sparse_addmm.h>
#include <ATen/ops/_sparse_mm_reduce_impl_backward.h>
#include <ATen/ops/addmm.h>
#include <ATen/ops/addmm.h>
#include <ATen/ops/addmm.h>
#include <ATen/ops/sparse_csc_tensor.h>
#include <ATen/ops/sparse_bsc_tensor.h>
#include <ATen/ops/sparse_csc_tensor.h>
#include <ATen/ops/sparse_bsc_tensor.h>
#include <ATen/ops/_sparse_compressed_tensor_unsafe.h>
#include <ATen/ops/_sparse_csr_tensor_unsafe.h>
#include <ATen/ops/_sparse_coo_tensor_unsafe.h>
#include <ATen/ops/_validate_sparse_csr_tensor_args.h>
#include <ATen/ops/_validate_sparse_bsr_tensor_args.h>
#include <ATen/ops/_validate_sparse_bsc_tensor_args.h>
#include <ATen/ops/sparse_resize.h>
#include <ATen/ops/sparse_mask.h>
#include <ATen/ops/_to_cpu.h>
#include <ATen/ops/values.h>
#include <ATen/ops/row_indices.h>
#include <ATen/ops/copy_sparse_to_sparse.h>
#include <ATen/ops/unbind.h>
#include <ATen/ops/unbind.h>
#include <ATen/ops/to_sparse.h>
#include <ATen/ops/to_sparse.h>
#include <ATen/ops/to_mkldnn.h>
#include <ATen/ops/to_mkldnn_backward.h>
#include <ATen/ops/int_repr.h>
#include <ATen/ops/qscheme.h>
#include <ATen/ops/fake_quantize_per_channel_affine.h>
#include <ATen/ops/fake_quantize_per_channel_affine_cachemask.h>
#include <ATen/ops/_fused_moving_avg_obs_fq_helper.h>
#include <ATen/ops/_to_copy.h>
#include <ATen/ops/_thnn_differentiable_lstm_cell_backward.h>
#include <ATen/ops/_thnn_differentiable_gru_cell_backward.h>
#include <ATen/ops/rnn_tanh_cell.h>
#include <ATen/ops/quantized_gru_cell.h>
#include <ATen/ops/_pack_padded_sequence_backward.h>
#include <ATen/ops/lift.h>
#include <ATen/ops/lift_fresh.h>
#include <ATen/ops/eq.h>
#include <ATen/ops/eq.h>
#include <ATen/ops/bitwise_and.h>
#include <ATen/ops/bitwise_and.h>
#include <ATen/ops/bitwise_and.h>
#include <ATen/ops/bitwise_and.h>
#include <ATen/ops/bitwise_and.h>
#include <ATen/ops/bitwise_and.h>
#include <ATen/ops/bitwise_and.h>
#include <ATen/ops/or.h>
#include <ATen/ops/or.h>
#include <ATen/ops/or.h>
#include <ATen/ops/or.h>
#include <ATen/ops/bitwise_xor.h>
#include <ATen/ops/bitwise_xor.h>
#include <ATen/ops/bitwise_xor.h>
#include <ATen/ops/bitwise_xor.h>
#include <ATen/ops/bitwise_xor.h>
#include <ATen/ops/bitwise_xor.h>
#include <ATen/ops/bitwise_xor.h>
#include <ATen/ops/lshift.h>
#include <ATen/ops/lshift.h>
#include <ATen/ops/lshift.h>
#include <ATen/ops/lshift.h>
#include <ATen/ops/bitwise_left_shift.h>
#include <ATen/ops/bitwise_left_shift.h>
#include <ATen/ops/bitwise_left_shift.h>
#include <ATen/ops/bitwise_left_shift.h>
#include <ATen/ops/bitwise_left_shift.h>
#include <ATen/ops/bitwise_left_shift.h>
#include <ATen/ops/bitwise_left_shift.h>
#include <ATen/ops/rshift.h>
#include <ATen/ops/rshift.h>
#include <ATen/ops/rshift.h>
#include <ATen/ops/rshift.h>
#include <ATen/ops/bitwise_right_shift.h>
#include <ATen/ops/bitwise_right_shift.h>
#include <ATen/ops/bitwise_right_shift.h>
#include <ATen/ops/bitwise_right_shift.h>
#include <ATen/ops/bitwise_right_shift.h>
#include <ATen/ops/bitwise_right_shift.h>
#include <ATen/ops/bitwise_right_shift.h>
#include <ATen/ops/exponential.h>
#include <ATen/ops/geometric.h>
#include <ATen/ops/trace_backward.h>
#include <ATen/ops/eq.h>
#include <ATen/ops/eq.h>
#include <ATen/ops/eq.h>
#include <ATen/ops/eq.h>
#include <ATen/ops/le.h>
#include <ATen/ops/le.h>
#include <ATen/ops/le.h>
#include <ATen/ops/le.h>
#include <ATen/ops/le.h>
#include <ATen/ops/le.h>
#include <ATen/ops/take_along_dim.h>
#include <ATen/ops/take_along_dim.h>
#include <ATen/ops/index_select.h>
#include <ATen/ops/index_select.h>
#include <ATen/ops/index_select.h>
#include <ATen/ops/index_select.h>
#include <ATen/ops/masked_select_backward.h>
#include <ATen/ops/nonzero.h>
#include <ATen/ops/nonzero.h>
#include <ATen/ops/nonzero_numpy.h>
#include <ATen/ops/addcmul.h>
#include <ATen/ops/addcmul.h>
#include <ATen/ops/addcmul.h>
#include <ATen/ops/swapdims.h>
#include <ATen/ops/swapdims.h>
#include <ATen/ops/cholesky.h>
#include <ATen/ops/cholesky.h>
#include <ATen/ops/lu_solve.h>
#include <ATen/ops/lu_solve.h>
#include <ATen/ops/lu_unpack.h>
#include <ATen/ops/lu_unpack.h>
#include <ATen/ops/multinomial.h>
#include <ATen/ops/multinomial.h>
#include <ATen/ops/lgamma.h>
#include <ATen/ops/lgamma.h>
#include <ATen/ops/lgamma.h>
#include <ATen/ops/arctan2.h>
#include <ATen/ops/arctan2.h>
#include <ATen/ops/arctan2.h>
#include <ATen/ops/histogram.h>
#include <ATen/ops/histogram.h>
#include <ATen/ops/histogram.h>
#include <ATen/ops/histogram.h>
#include <ATen/ops/igamma.h>
#include <ATen/ops/igamma.h>
#include <ATen/ops/igamma.h>
#include <ATen/ops/max.h>
#include <ATen/ops/max.h>
#include <ATen/ops/max.h>
#include <ATen/ops/max.h>
#include <ATen/ops/pow.h>
#include <ATen/ops/pow.h>
#include <ATen/ops/pow.h>
#include <ATen/ops/pow.h>
#include <ATen/ops/pow.h>
#include <ATen/ops/pow.h>
#include <ATen/ops/pow.h>
#include <ATen/ops/pow.h>
#include <ATen/ops/_amp_foreach_non_finite_check_and_unscale.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_clamp_min.h>
#include <ATen/ops/_foreach_clamp_min.h>
#include <ATen/ops/_foreach_clamp_min.h>
#include <ATen/ops/_foreach_clamp_min.h>
#include <ATen/ops/_foreach_clamp_min.h>
#include <ATen/ops/_foreach_clamp_min.h>
#include <ATen/ops/_foreach_minimum.h>
#include <ATen/ops/_foreach_minimum.h>
#include <ATen/ops/_foreach_minimum.h>
#include <ATen/ops/_foreach_minimum.h>
#include <ATen/ops/_foreach_minimum.h>
#include <ATen/ops/_foreach_minimum.h>
#include <ATen/ops/_foreach_cosh.h>
#include <ATen/ops/_foreach_cosh.h>
#include <ATen/ops/_foreach_erfc.h>
#include <ATen/ops/_foreach_erfc.h>
#include <ATen/ops/_foreach_frac.h>
#include <ATen/ops/_foreach_frac.h>
#include <ATen/ops/_foreach_lerp.h>
#include <ATen/ops/_foreach_lerp.h>
#include <ATen/ops/_foreach_lerp.h>
#include <ATen/ops/_foreach_lerp.h>
#include <ATen/ops/_foreach_lgamma.h>
#include <ATen/ops/_foreach_lgamma.h>
#include <ATen/ops/_foreach_round.h>
#include <ATen/ops/_foreach_round.h>
#include <ATen/ops/_foreach_trunc.h>
#include <ATen/ops/_foreach_trunc.h>
#include <ATen/ops/mse_loss_backward.h>
#include <ATen/ops/mse_loss_backward.h>
#include <ATen/ops/multi_margin_loss_backward.h>
#include <ATen/ops/multi_margin_loss_backward.h>
#include <ATen/ops/multilabel_margin_loss_backward.h>
#include <ATen/ops/multilabel_margin_loss_backward.h>
#include <ATen/ops/elu_backward.h>
#include <ATen/ops/elu_backward.h>
#include <ATen/ops/hardsigmoid_backward.h>
#include <ATen/ops/hardsigmoid_backward.h>
#include <ATen/ops/rrelu_with_noise_backward.h>
#include <ATen/ops/softplus_backward.h>
#include <ATen/ops/softplus_backward.h>
#include <ATen/ops/mkldnn_adaptive_avg_pool2d_backward.h>
#include <ATen/ops/fractional_max_pool3d_backward.h>
#include <ATen/ops/fractional_max_pool3d_backward.h>
#include <ATen/ops/max_pool2d_with_indices.h>
#include <ATen/ops/max_pool2d_with_indices.h>
#include <ATen/ops/reflection_pad1d.h>
#include <ATen/ops/reflection_pad1d.h>
#include <ATen/ops/_pad_enum.h>
#include <ATen/ops/upsample_trilinear3d.h>
#include <ATen/ops/_upsample_bicubic2d_aa.h>
#include <ATen/ops/upsample_nearest3d.h>
#include <ATen/ops/_upsample_bilinear2d_aa_backward.h>
#include <ATen/ops/_upsample_bilinear2d_aa_backward.h>
#include <ATen/ops/_upsample_bicubic2d_aa.h>
#include <ATen/ops/_upsample_bicubic2d_aa.h>
#include <ATen/ops/upsample_trilinear3d.h>
#include <ATen/ops/upsample_trilinear3d.h>
#include <ATen/ops/upsample_nearest3d.h>
#include <ATen/ops/upsample_nearest3d.h>
#include <ATen/ops/sigmoid_backward.h>
#include <ATen/ops/sigmoid_backward.h>
#include <ATen/ops/tanh_backward.h>
#include <ATen/ops/tanh_backward.h>
#include <ATen/ops/thnn_conv2d.h>
#include <ATen/ops/thnn_conv2d.h>
#include <ATen/ops/_slow_conv2d_forward.h>
#include <ATen/ops/_slow_conv2d_forward.h>
#include <ATen/ops/column_stack.h>
#include <ATen/ops/column_stack.h>
#include <ATen/ops/special_entr.h>
#include <ATen/ops/special_entr.h>
#include <ATen/ops/special_ndtri.h>
#include <ATen/ops/special_ndtri.h>
#include <ATen/ops/special_erfc.h>
#include <ATen/ops/special_erfc.h>
#include <ATen/ops/special_i1e.h>
#include <ATen/ops/special_i1e.h>
#include <ATen/ops/special_logsumexp.h>
#include <ATen/ops/special_logsumexp.h>
#include <ATen/ops/special_gammainc.h>
#include <ATen/ops/special_gammainc.h>
#include <ATen/ops/fft_rfft2.h>
#include <ATen/ops/fft_rfft2.h>
#include <ATen/ops/fft_hfftn.h>
#include <ATen/ops/fft_hfftn.h>
#include <ATen/ops/linalg_lu.h>
#include <ATen/ops/linalg_lu.h>
#include <ATen/ops/linalg_ldl_factor_ex.h>
#include <ATen/ops/linalg_ldl_factor_ex.h>
#include <ATen/ops/linalg_ldl_solve.h>
#include <ATen/ops/linalg_ldl_solve.h>
#include <ATen/ops/linalg_lstsq.h>
#include <ATen/ops/linalg_lstsq.h>
#include <ATen/ops/linalg_vecdot.h>
#include <ATen/ops/linalg_vecdot.h>
#include <ATen/ops/linalg_matrix_exp.h>
#include <ATen/ops/_linalg_eigh.h>
#include <ATen/ops/_linalg_eigh.h>
#include <ATen/ops/linalg_norm.h>
#include <ATen/ops/linalg_norm.h>
#include <ATen/ops/linalg_norm.h>
#include <ATen/ops/linalg_norm.h>
#include <ATen/ops/linalg_svdvals.h>
#include <ATen/ops/linalg_svdvals.h>
#include <ATen/ops/linalg_matrix_power.h>
#include <ATen/ops/linalg_matrix_power.h>
#include <ATen/ops/_test_serialization_subcmul.h>
#include <ATen/ops/_test_optional_intlist.h>
#include <ATen/ops/_test_ambiguous_defaults.h>
#include <ATen/ops/_test_ambiguous_defaults.h>
#include <ATen/ops/_test_autograd_multiple_dispatch.h>
#include <ATen/ops/_test_autograd_multiple_dispatch.h>
#include <ATen/ops/segment_reduce.h>
#include <ATen/ops/_segment_reduce_backward.h>
#include <ATen/ops/_make_dual_copy.h>
#include <ATen/ops/view_as_complex_copy.h>
#include <ATen/ops/_neg_view_copy.h>
#include <ATen/ops/expand_copy.h>
#include <ATen/ops/unsqueeze_copy.h>
#include <ATen/ops/crow_indices_copy.h>
#include <ATen/ops/to_padded_tensor.h>
#include <ATen/ops/_nested_tensor_softmax_with_shape.h>
#include <ATen/ops/_flash_attention_forward.h>
#include <ATen/ops/special_bessel_j0.h>
#include <ATen/ops/special_bessel_j0.h>
#include <ATen/ops/special_bessel_y0.h>
#include <ATen/ops/special_bessel_y0.h>
#include <ATen/ops/special_chebyshev_polynomial_u.h>
#include <ATen/ops/special_chebyshev_polynomial_u.h>
#include <ATen/ops/special_chebyshev_polynomial_u.h>
#include <ATen/ops/special_chebyshev_polynomial_u.h>
#include <ATen/ops/special_chebyshev_polynomial_u.h>
#include <ATen/ops/special_chebyshev_polynomial_u.h>
#include <ATen/ops/special_hermite_polynomial_he.h>
#include <ATen/ops/special_hermite_polynomial_he.h>
#include <ATen/ops/special_hermite_polynomial_he.h>
#include <ATen/ops/special_hermite_polynomial_he.h>
#include <ATen/ops/special_hermite_polynomial_he.h>
#include <ATen/ops/special_hermite_polynomial_he.h>
#include <ATen/ops/special_modified_bessel_i1.h>
#include <ATen/ops/special_modified_bessel_i1.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_v.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_v.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_v.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_v.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_v.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_v.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_w.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_w.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_w.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_w.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_w.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_w.h>
#include <ATen/ops/special_spherical_bessel_j0.h>
#include <ATen/ops/special_spherical_bessel_j0.h>
#include <ATen/ops/_cudnn_ctc_loss.h>
#include <ATen/ops/_cudnn_rnn.h>
#include <ATen/ops/_fused_dropout.h>
#include <ATen/ops/_conj_physical.h>
#include <ATen/ops/blackman_window.h>
#include <ATen/ops/blackman_window.h>
#include <ATen/ops/convolution.h>
#include <ATen/ops/convolution_backward_overrideable.h>
#include <ATen/ops/_convolution.h>
#include <ATen/ops/cudnn_affine_grid_generator.h>
#include <ATen/ops/cudnn_batch_norm_backward.h>
#include <ATen/ops/cudnn_convolution_transpose.h>
#include <ATen/ops/cudnn_grid_sampler_backward.h>
#include <ATen/ops/_ctc_loss.h>
#include <ATen/ops/_ctc_loss.h>
#include <ATen/ops/embedding_dense_backward.h>
#include <ATen/ops/_embedding_bag.h>
#include <ATen/ops/new_empty.h>
#include <ATen/ops/fill.h>
#include <ATen/ops/fill.h>
#include <ATen/ops/grid_sampler_2d_backward.h>
#include <ATen/ops/_index_put_impl.h>
#include <ATen/ops/_index_put_impl.h>
#include <ATen/ops/mkldnn_linear.h>
#include <ATen/ops/mkldnn_linear_backward_weights.h>
#include <ATen/ops/_aminmax.h>
#include <ATen/ops/_aminmax.h>
#include <ATen/ops/mkldnn_max_pool3d_backward.h>
#include <ATen/ops/quantized_max_pool1d.h>
#include <ATen/ops/mkldnn_convolution.h>
#include <ATen/ops/miopen_batch_norm_backward.h>
#include <ATen/ops/mul.h>
#include <ATen/ops/batch_norm_backward_elemt.h>
#include <ATen/ops/pixel_unshuffle.h>
#include <ATen/ops/_pin_memory.h>
#include <ATen/ops/randn.h>
#include <ATen/ops/randn.h>
#include <ATen/ops/diagonal_scatter.h>
#include <ATen/ops/as_strided_scatter.h>
#include <ATen/ops/_transform_bias_rescale_qkv.h>
#include <ATen/ops/_unique.h>
#include <ATen/ops/_weight_norm_interface.h>
#include <ATen/ops/zeros.h>
#include <ATen/ops/_standard_gamma.h>
#include <ATen/ops/_sample_dirichlet.h>
#include <ATen/ops/binomial.h>
#include <ATen/ops/_sparse_sum.h>
#include <ATen/ops/_sparse_addmm.h>
#include <ATen/ops/sparse_resize.h>
#include <ATen/ops/sparse_resize.h>
#include <ATen/ops/sparse_mask.h>
#include <ATen/ops/copy_sparse_to_sparse.h>
#include <ATen/ops/copy_sparse_to_sparse.h>
#include <ATen/ops/to_mkldnn.h>
#include <ATen/ops/int_repr.h>
#include <ATen/ops/fake_quantize_per_channel_affine_cachemask.h>
#include <ATen/ops/_fused_moving_avg_obs_fq_helper.h>
#include <ATen/ops/_fused_moving_avg_obs_fq_helper.h>
#include <ATen/ops/_to_copy.h>
#include <ATen/ops/lift.h>
#include <ATen/ops/bitwise_and.h>
#include <ATen/ops/bitwise_xor.h>
#include <ATen/ops/lshift.h>
#include <ATen/ops/lshift.h>
#include <ATen/ops/bitwise_left_shift.h>
#include <ATen/ops/rshift.h>
#include <ATen/ops/rshift.h>
#include <ATen/ops/bitwise_right_shift.h>
#include <ATen/ops/exponential.h>
#include <ATen/ops/exponential.h>
#include <ATen/ops/geometric.h>
#include <ATen/ops/geometric.h>
#include <ATen/ops/_amp_foreach_non_finite_check_and_unscale.h>
#include <ATen/ops/_amp_foreach_non_finite_check_and_unscale.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_add.h>
#include <ATen/ops/_foreach_clamp_min.h>
#include <ATen/ops/_foreach_clamp_min.h>
#include <ATen/ops/_foreach_clamp_min.h>
#include <ATen/ops/_foreach_minimum.h>
#include <ATen/ops/_foreach_minimum.h>
#include <ATen/ops/_foreach_minimum.h>
#include <ATen/ops/_foreach_cosh.h>
#include <ATen/ops/_foreach_erfc.h>
#include <ATen/ops/_foreach_frac.h>
#include <ATen/ops/_foreach_lerp.h>
#include <ATen/ops/_foreach_lerp.h>
#include <ATen/ops/_foreach_lgamma.h>
#include <ATen/ops/_foreach_round.h>
#include <ATen/ops/_foreach_trunc.h>
#include <ATen/ops/rrelu_with_noise_backward.h>
#include <ATen/ops/mkldnn_adaptive_avg_pool2d_backward.h>
#include <ATen/ops/linalg_matrix_exp.h>
#include <ATen/ops/_test_optional_intlist.h>
#include <ATen/ops/_test_autograd_multiple_dispatch.h>
#include <ATen/ops/segment_reduce.h>
#include <ATen/ops/_segment_reduce_backward.h>
#include <ATen/ops/_make_dual_copy.h>
#include <ATen/ops/view_as_complex_copy.h>
#include <ATen/ops/_neg_view_copy.h>
#include <ATen/ops/expand_copy.h>
#include <ATen/ops/unsqueeze_copy.h>
#include <ATen/ops/crow_indices_copy.h>
#include <ATen/ops/to_padded_tensor.h>
#endif



namespace at { namespace _ops {


STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cast_Byte, name, "aten::_cast_Byte")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cast_Byte, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cast_Byte, schema_str, "_cast_Byte(Tensor self, bool non_blocking=False) -> Tensor")

// aten::_cast_Byte(Tensor self, bool non_blocking=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_cast_Byte::schema> create__cast_Byte_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cast_Byte::name, _cast_Byte::overload_name)
      .typed<_cast_Byte::schema>();
}

// aten::_cast_Byte(Tensor self, bool non_blocking=False) -> Tensor
at::Tensor _cast_Byte::call(const at::Tensor & self, bool non_blocking) {
    
    static auto op = create__cast_Byte_typed_handle();
    return op.call(self, non_blocking);
}

// aten::_cast_Byte(Tensor self, bool non_blocking=False) -> Tensor
at::Tensor _cast_Byte::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool non_blocking) {
    
    static auto op = create__cast_Byte_typed_handle();
    return op.redispatch(dispatchKeySet, self, non_blocking);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cast_Char, name, "aten::_cast_Char")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cast_Char, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cast_Char, schema_str, "_cast_Char(Tensor self, bool non_blocking=False) -> Tensor")

// aten::_cast_Char(Tensor self, bool non_blocking=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_cast_Char::schema> create__cast_Char_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cast_Char::name, _cast_Char::overload_name)
      .typed<_cast_Char::schema>();
}

// aten::_cast_Char(Tensor self, bool non_blocking=False) -> Tensor
at::Tensor _cast_Char::call(const at::Tensor & self, bool non_blocking) {
    
    static auto op = create__cast_Char_typed_handle();
    return op.call(self, non_blocking);
}

// aten::_cast_Char(Tensor self, bool non_blocking=False) -> Tensor
at::Tensor _cast_Char::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool non_blocking) {
    
    static auto op = create__cast_Char_typed_handle();
    return op.redispatch(dispatchKeySet, self, non_blocking);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_leaf, name, "aten::is_leaf")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_leaf, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_leaf, schema_str, "is_leaf(Tensor self) -> bool")

// aten::is_leaf(Tensor self) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<is_leaf::schema> create_is_leaf_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(is_leaf::name, is_leaf::overload_name)
      .typed<is_leaf::schema>();
}

// aten::is_leaf(Tensor self) -> bool
bool is_leaf::call(const at::Tensor & self) {
    
    static auto op = create_is_leaf_typed_handle();
    return op.call(self);
}

// aten::is_leaf(Tensor self) -> bool
bool is_leaf::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_is_leaf_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(requires_grad_, name, "aten::requires_grad_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(requires_grad_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(requires_grad_, schema_str, "requires_grad_(Tensor(a!) self, bool requires_grad=True) -> Tensor(a!)")

// aten::requires_grad_(Tensor(a!) self, bool requires_grad=True) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<requires_grad_::schema> create_requires_grad__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(requires_grad_::name, requires_grad_::overload_name)
      .typed<requires_grad_::schema>();
}

// aten::requires_grad_(Tensor(a!) self, bool requires_grad=True) -> Tensor(a!)
at::Tensor & requires_grad_::call(at::Tensor & self, bool requires_grad) {
    
    static auto op = create_requires_grad__typed_handle();
    return op.call(self, requires_grad);
}

// aten::requires_grad_(Tensor(a!) self, bool requires_grad=True) -> Tensor(a!)
at::Tensor & requires_grad_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, bool requires_grad) {
    
    static auto op = create_requires_grad__typed_handle();
    return op.redispatch(dispatchKeySet, self, requires_grad);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(retains_grad, name, "aten::retains_grad")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(retains_grad, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(retains_grad, schema_str, "retains_grad(Tensor self) -> bool")

// aten::retains_grad(Tensor self) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<retains_grad::schema> create_retains_grad_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(retains_grad::name, retains_grad::overload_name)
      .typed<retains_grad::schema>();
}

// aten::retains_grad(Tensor self) -> bool
bool retains_grad::call(const at::Tensor & self) {
    
    static auto op = create_retains_grad_typed_handle();
    return op.call(self);
}

// aten::retains_grad(Tensor self) -> bool
bool retains_grad::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_retains_grad_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unpack_dual, name, "aten::_unpack_dual")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unpack_dual, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unpack_dual, schema_str, "_unpack_dual(Tensor(a) dual, int level) -> (Tensor(a) primal, Tensor tangent)")

// aten::_unpack_dual(Tensor(a) dual, int level) -> (Tensor(a) primal, Tensor tangent)
static C10_NOINLINE c10::TypedOperatorHandle<_unpack_dual::schema> create__unpack_dual_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_unpack_dual::name, _unpack_dual::overload_name)
      .typed<_unpack_dual::schema>();
}

// aten::_unpack_dual(Tensor(a) dual, int level) -> (Tensor(a) primal, Tensor tangent)
::std::tuple<at::Tensor,at::Tensor> _unpack_dual::call(const at::Tensor & dual, int64_t level) {
    
    static auto op = create__unpack_dual_typed_handle();
    return op.call(dual, level);
}

// aten::_unpack_dual(Tensor(a) dual, int level) -> (Tensor(a) primal, Tensor tangent)
::std::tuple<at::Tensor,at::Tensor> _unpack_dual::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & dual, int64_t level) {
    
    static auto op = create__unpack_dual_typed_handle();
    return op.redispatch(dispatchKeySet, dual, level);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_has_same_storage_numel, name, "aten::_has_same_storage_numel")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_has_same_storage_numel, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_has_same_storage_numel, schema_str, "_has_same_storage_numel(Tensor self, Tensor other) -> bool")

// aten::_has_same_storage_numel(Tensor self, Tensor other) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<_has_same_storage_numel::schema> create__has_same_storage_numel_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_has_same_storage_numel::name, _has_same_storage_numel::overload_name)
      .typed<_has_same_storage_numel::schema>();
}

// aten::_has_same_storage_numel(Tensor self, Tensor other) -> bool
bool _has_same_storage_numel::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create__has_same_storage_numel_typed_handle();
    return op.call(self, other);
}

// aten::_has_same_storage_numel(Tensor self, Tensor other) -> bool
bool _has_same_storage_numel::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create__has_same_storage_numel_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(align_to, name, "aten::align_to")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(align_to, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(align_to, schema_str, "align_to(Tensor(a) self, Dimname[] names) -> Tensor(a)")

// aten::align_to(Tensor(a) self, Dimname[] names) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<align_to::schema> create_align_to_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(align_to::name, align_to::overload_name)
      .typed<align_to::schema>();
}

// aten::align_to(Tensor(a) self, Dimname[] names) -> Tensor(a)
at::Tensor align_to::call(const at::Tensor & self, at::DimnameList names) {
    
    static auto op = create_align_to_typed_handle();
    return op.call(self, names);
}

// aten::align_to(Tensor(a) self, Dimname[] names) -> Tensor(a)
at::Tensor align_to::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::DimnameList names) {
    
    static auto op = create_align_to_typed_handle();
    return op.redispatch(dispatchKeySet, self, names);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(align_to_ellipsis_idx, name, "aten::align_to")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(align_to_ellipsis_idx, overload_name, "ellipsis_idx")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(align_to_ellipsis_idx, schema_str, "align_to.ellipsis_idx(Tensor(a) self, Dimname[] order, int ellipsis_idx) -> Tensor(a)")

// aten::align_to.ellipsis_idx(Tensor(a) self, Dimname[] order, int ellipsis_idx) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<align_to_ellipsis_idx::schema> create_align_to_ellipsis_idx_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(align_to_ellipsis_idx::name, align_to_ellipsis_idx::overload_name)
      .typed<align_to_ellipsis_idx::schema>();
}

// aten::align_to.ellipsis_idx(Tensor(a) self, Dimname[] order, int ellipsis_idx) -> Tensor(a)
at::Tensor align_to_ellipsis_idx::call(const at::Tensor & self, at::DimnameList order, int64_t ellipsis_idx) {
    
    static auto op = create_align_to_ellipsis_idx_typed_handle();
    return op.call(self, order, ellipsis_idx);
}

// aten::align_to.ellipsis_idx(Tensor(a) self, Dimname[] order, int ellipsis_idx) -> Tensor(a)
at::Tensor align_to_ellipsis_idx::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::DimnameList order, int64_t ellipsis_idx) {
    
    static auto op = create_align_to_ellipsis_idx_typed_handle();
    return op.redispatch(dispatchKeySet, self, order, ellipsis_idx);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_use_cudnn_ctc_loss, name, "aten::_use_cudnn_ctc_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_use_cudnn_ctc_loss, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_use_cudnn_ctc_loss, schema_str, "_use_cudnn_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank) -> bool")

// aten::_use_cudnn_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<_use_cudnn_ctc_loss::schema> create__use_cudnn_ctc_loss_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_use_cudnn_ctc_loss::name, _use_cudnn_ctc_loss::overload_name)
      .typed<_use_cudnn_ctc_loss::schema>();
}

// aten::_use_cudnn_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank) -> bool
bool _use_cudnn_ctc_loss::call(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank) {
    
    static auto op = create__use_cudnn_ctc_loss_typed_handle();
    return op.call(log_probs, targets, input_lengths, target_lengths, blank);
}

// aten::_use_cudnn_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank) -> bool
bool _use_cudnn_ctc_loss::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank) {
    
    static auto op = create__use_cudnn_ctc_loss_typed_handle();
    return op.redispatch(dispatchKeySet, log_probs, targets, input_lengths, target_lengths, blank);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_use_cudnn_ctc_loss_Tensor, name, "aten::_use_cudnn_ctc_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_use_cudnn_ctc_loss_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_use_cudnn_ctc_loss_Tensor, schema_str, "_use_cudnn_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank) -> bool")

// aten::_use_cudnn_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<_use_cudnn_ctc_loss_Tensor::schema> create__use_cudnn_ctc_loss_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_use_cudnn_ctc_loss_Tensor::name, _use_cudnn_ctc_loss_Tensor::overload_name)
      .typed<_use_cudnn_ctc_loss_Tensor::schema>();
}

// aten::_use_cudnn_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank) -> bool
bool _use_cudnn_ctc_loss_Tensor::call(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank) {
    
    static auto op = create__use_cudnn_ctc_loss_Tensor_typed_handle();
    return op.call(log_probs, targets, input_lengths, target_lengths, blank);
}

// aten::_use_cudnn_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank) -> bool
bool _use_cudnn_ctc_loss_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank) {
    
    static auto op = create__use_cudnn_ctc_loss_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, log_probs, targets, input_lengths, target_lengths, blank);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_ctc_loss, name, "aten::_cudnn_ctc_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_ctc_loss, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_ctc_loss, schema_str, "_cudnn_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank, bool deterministic, bool zero_infinity) -> (Tensor, Tensor)")

// aten::_cudnn_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank, bool deterministic, bool zero_infinity) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_cudnn_ctc_loss::schema> create__cudnn_ctc_loss_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cudnn_ctc_loss::name, _cudnn_ctc_loss::overload_name)
      .typed<_cudnn_ctc_loss::schema>();
}

// aten::_cudnn_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank, bool deterministic, bool zero_infinity) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _cudnn_ctc_loss::call(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool deterministic, bool zero_infinity) {
    
    static auto op = create__cudnn_ctc_loss_typed_handle();
    return op.call(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity);
}

// aten::_cudnn_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank, bool deterministic, bool zero_infinity) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _cudnn_ctc_loss::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool deterministic, bool zero_infinity) {
    
    static auto op = create__cudnn_ctc_loss_typed_handle();
    return op.redispatch(dispatchKeySet, log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_ctc_loss_Tensor, name, "aten::_cudnn_ctc_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_ctc_loss_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_ctc_loss_Tensor, schema_str, "_cudnn_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank, bool deterministic, bool zero_infinity) -> (Tensor, Tensor)")

// aten::_cudnn_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank, bool deterministic, bool zero_infinity) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_cudnn_ctc_loss_Tensor::schema> create__cudnn_ctc_loss_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cudnn_ctc_loss_Tensor::name, _cudnn_ctc_loss_Tensor::overload_name)
      .typed<_cudnn_ctc_loss_Tensor::schema>();
}

// aten::_cudnn_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank, bool deterministic, bool zero_infinity) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _cudnn_ctc_loss_Tensor::call(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool deterministic, bool zero_infinity) {
    
    static auto op = create__cudnn_ctc_loss_Tensor_typed_handle();
    return op.call(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity);
}

// aten::_cudnn_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank, bool deterministic, bool zero_infinity) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _cudnn_ctc_loss_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool deterministic, bool zero_infinity) {
    
    static auto op = create__cudnn_ctc_loss_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_rnn, name, "aten::_cudnn_rnn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_rnn, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_rnn, schema_str, "_cudnn_rnn(Tensor input, Tensor[] weight, int weight_stride0, Tensor? weight_buf, Tensor hx, Tensor? cx, int mode, SymInt hidden_size, SymInt proj_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, SymInt[] batch_sizes, Tensor? dropout_state) -> (Tensor, Tensor, Tensor, Tensor, Tensor)")

// aten::_cudnn_rnn(Tensor input, Tensor[] weight, int weight_stride0, Tensor? weight_buf, Tensor hx, Tensor? cx, int mode, SymInt hidden_size, SymInt proj_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, SymInt[] batch_sizes, Tensor? dropout_state) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_cudnn_rnn::schema> create__cudnn_rnn_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cudnn_rnn::name, _cudnn_rnn::overload_name)
      .typed<_cudnn_rnn::schema>();
}

// aten::_cudnn_rnn(Tensor input, Tensor[] weight, int weight_stride0, Tensor? weight_buf, Tensor hx, Tensor? cx, int mode, SymInt hidden_size, SymInt proj_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, SymInt[] batch_sizes, Tensor? dropout_state) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _cudnn_rnn::call(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const c10::optional<at::Tensor> & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state) {
    
    static auto op = create__cudnn_rnn_typed_handle();
    return op.call(input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state);
}

// aten::_cudnn_rnn(Tensor input, Tensor[] weight, int weight_stride0, Tensor? weight_buf, Tensor hx, Tensor? cx, int mode, SymInt hidden_size, SymInt proj_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, SymInt[] batch_sizes, Tensor? dropout_state) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _cudnn_rnn::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const c10::optional<at::Tensor> & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state) {
    
    static auto op = create__cudnn_rnn_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_debug_has_internal_overlap, name, "aten::_debug_has_internal_overlap")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_debug_has_internal_overlap, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_debug_has_internal_overlap, schema_str, "_debug_has_internal_overlap(Tensor self) -> int")

// aten::_debug_has_internal_overlap(Tensor self) -> int
static C10_NOINLINE c10::TypedOperatorHandle<_debug_has_internal_overlap::schema> create__debug_has_internal_overlap_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_debug_has_internal_overlap::name, _debug_has_internal_overlap::overload_name)
      .typed<_debug_has_internal_overlap::schema>();
}

// aten::_debug_has_internal_overlap(Tensor self) -> int
int64_t _debug_has_internal_overlap::call(const at::Tensor & self) {
    
    static auto op = create__debug_has_internal_overlap_typed_handle();
    return op.call(self);
}

// aten::_debug_has_internal_overlap(Tensor self) -> int
int64_t _debug_has_internal_overlap::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__debug_has_internal_overlap_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_dropout, name, "aten::_fused_dropout")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_dropout, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_dropout, schema_str, "_fused_dropout(Tensor self, float p, Generator? generator=None) -> (Tensor, Tensor)")

// aten::_fused_dropout(Tensor self, float p, Generator? generator=None) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_fused_dropout::schema> create__fused_dropout_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_fused_dropout::name, _fused_dropout::overload_name)
      .typed<_fused_dropout::schema>();
}

// aten::_fused_dropout(Tensor self, float p, Generator? generator=None) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _fused_dropout::call(const at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    
    static auto op = create__fused_dropout_typed_handle();
    return op.call(self, p, generator);
}

// aten::_fused_dropout(Tensor self, float p, Generator? generator=None) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _fused_dropout::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    
    static auto op = create__fused_dropout_typed_handle();
    return op.redispatch(dispatchKeySet, self, p, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sobol_engine_initialize_state_, name, "aten::_sobol_engine_initialize_state_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sobol_engine_initialize_state_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sobol_engine_initialize_state_, schema_str, "_sobol_engine_initialize_state_(Tensor(a!) self, int dimension) -> Tensor(a!)")

// aten::_sobol_engine_initialize_state_(Tensor(a!) self, int dimension) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_sobol_engine_initialize_state_::schema> create__sobol_engine_initialize_state__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sobol_engine_initialize_state_::name, _sobol_engine_initialize_state_::overload_name)
      .typed<_sobol_engine_initialize_state_::schema>();
}

// aten::_sobol_engine_initialize_state_(Tensor(a!) self, int dimension) -> Tensor(a!)
at::Tensor & _sobol_engine_initialize_state_::call(at::Tensor & self, int64_t dimension) {
    
    static auto op = create__sobol_engine_initialize_state__typed_handle();
    return op.call(self, dimension);
}

// aten::_sobol_engine_initialize_state_(Tensor(a!) self, int dimension) -> Tensor(a!)
at::Tensor & _sobol_engine_initialize_state_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, int64_t dimension) {
    
    static auto op = create__sobol_engine_initialize_state__typed_handle();
    return op.redispatch(dispatchKeySet, self, dimension);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_shape_as_tensor, name, "aten::_shape_as_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_shape_as_tensor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_shape_as_tensor, schema_str, "_shape_as_tensor(Tensor self) -> Tensor")

// aten::_shape_as_tensor(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_shape_as_tensor::schema> create__shape_as_tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_shape_as_tensor::name, _shape_as_tensor::overload_name)
      .typed<_shape_as_tensor::schema>();
}

// aten::_shape_as_tensor(Tensor self) -> Tensor
at::Tensor _shape_as_tensor::call(const at::Tensor & self) {
    
    static auto op = create__shape_as_tensor_typed_handle();
    return op.call(self);
}

// aten::_shape_as_tensor(Tensor self) -> Tensor
at::Tensor _shape_as_tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__shape_as_tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dropout, name, "aten::dropout")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dropout, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dropout, schema_str, "dropout(Tensor input, float p, bool train) -> Tensor")

// aten::dropout(Tensor input, float p, bool train) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<dropout::schema> create_dropout_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(dropout::name, dropout::overload_name)
      .typed<dropout::schema>();
}

// aten::dropout(Tensor input, float p, bool train) -> Tensor
at::Tensor dropout::call(const at::Tensor & input, double p, bool train) {
    
    static auto op = create_dropout_typed_handle();
    return op.call(input, p, train);
}

// aten::dropout(Tensor input, float p, bool train) -> Tensor
at::Tensor dropout::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, double p, bool train) {
    
    static auto op = create_dropout_typed_handle();
    return op.redispatch(dispatchKeySet, input, p, train);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dropout_, name, "aten::dropout_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dropout_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(dropout_, schema_str, "dropout_(Tensor(a!) self, float p, bool train) -> Tensor(a!)")

// aten::dropout_(Tensor(a!) self, float p, bool train) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<dropout_::schema> create_dropout__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(dropout_::name, dropout_::overload_name)
      .typed<dropout_::schema>();
}

// aten::dropout_(Tensor(a!) self, float p, bool train) -> Tensor(a!)
at::Tensor & dropout_::call(at::Tensor & self, double p, bool train) {
    
    static auto op = create_dropout__typed_handle();
    return op.call(self, p, train);
}

// aten::dropout_(Tensor(a!) self, float p, bool train) -> Tensor(a!)
at::Tensor & dropout_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, double p, bool train) {
    
    static auto op = create_dropout__typed_handle();
    return op.redispatch(dispatchKeySet, self, p, train);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sgn, name, "aten::sgn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sgn, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sgn, schema_str, "sgn(Tensor self) -> Tensor")

// aten::sgn(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sgn::schema> create_sgn_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sgn::name, sgn::overload_name)
      .typed<sgn::schema>();
}

// aten::sgn(Tensor self) -> Tensor
at::Tensor sgn::call(const at::Tensor & self) {
    
    static auto op = create_sgn_typed_handle();
    return op.call(self);
}

// aten::sgn(Tensor self) -> Tensor
at::Tensor sgn::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_sgn_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sgn_, name, "aten::sgn_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sgn_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sgn_, schema_str, "sgn_(Tensor(a!) self) -> Tensor(a!)")

// aten::sgn_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sgn_::schema> create_sgn__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sgn_::name, sgn_::overload_name)
      .typed<sgn_::schema>();
}

// aten::sgn_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & sgn_::call(at::Tensor & self) {
    
    static auto op = create_sgn__typed_handle();
    return op.call(self);
}

// aten::sgn_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & sgn_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_sgn__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sgn_out, name, "aten::sgn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sgn_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sgn_out, schema_str, "sgn.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::sgn.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sgn_out::schema> create_sgn_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sgn_out::name, sgn_out::overload_name)
      .typed<sgn_out::schema>();
}

// aten::sgn.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sgn_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_sgn_out_typed_handle();
    return op.call(self, out);
}

// aten::sgn.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sgn_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_sgn_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(real, name, "aten::real")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(real, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(real, schema_str, "real(Tensor(a) self) -> Tensor(a)")

// aten::real(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<real::schema> create_real_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(real::name, real::overload_name)
      .typed<real::schema>();
}

// aten::real(Tensor(a) self) -> Tensor(a)
at::Tensor real::call(const at::Tensor & self) {
    
    static auto op = create_real_typed_handle();
    return op.call(self);
}

// aten::real(Tensor(a) self) -> Tensor(a)
at::Tensor real::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_real_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_conj, name, "aten::_conj")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_conj, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_conj, schema_str, "_conj(Tensor(a) self) -> Tensor(a)")

// aten::_conj(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<_conj::schema> create__conj_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_conj::name, _conj::overload_name)
      .typed<_conj::schema>();
}

// aten::_conj(Tensor(a) self) -> Tensor(a)
at::Tensor _conj::call(const at::Tensor& self) {
    static auto op = create__conj_typed_handle();
    return op.call(self);
}

// aten::_conj(Tensor(a) self) -> Tensor(a)
at::Tensor _conj::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__conj_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_conj_physical, name, "aten::_conj_physical")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_conj_physical, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_conj_physical, schema_str, "_conj_physical(Tensor self) -> Tensor")

// aten::_conj_physical(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_conj_physical::schema> create__conj_physical_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_conj_physical::name, _conj_physical::overload_name)
      .typed<_conj_physical::schema>();
}

// aten::_conj_physical(Tensor self) -> Tensor
at::Tensor _conj_physical::call(const at::Tensor & self) {
    
    static auto op = create__conj_physical_typed_handle();
    return op.call(self);
}

// aten::_conj_physical(Tensor self) -> Tensor
at::Tensor _conj_physical::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__conj_physical_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_neg_view, name, "aten::_neg_view")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_neg_view, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_neg_view, schema_str, "_neg_view(Tensor(a) self) -> Tensor(a)")

// aten::_neg_view(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<_neg_view::schema> create__neg_view_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_neg_view::name, _neg_view::overload_name)
      .typed<_neg_view::schema>();
}

// aten::_neg_view(Tensor(a) self) -> Tensor(a)
at::Tensor _neg_view::call(const at::Tensor & self) {
    
    static auto op = create__neg_view_typed_handle();
    return op.call(self);
}

// aten::_neg_view(Tensor(a) self) -> Tensor(a)
at::Tensor _neg_view::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__neg_view_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool1d, name, "aten::avg_pool1d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool1d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(avg_pool1d, schema_str, "avg_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, bool ceil_mode=False, bool count_include_pad=True) -> Tensor")

// aten::avg_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, bool ceil_mode=False, bool count_include_pad=True) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<avg_pool1d::schema> create_avg_pool1d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(avg_pool1d::name, avg_pool1d::overload_name)
      .typed<avg_pool1d::schema>();
}

// aten::avg_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, bool ceil_mode=False, bool count_include_pad=True) -> Tensor
at::Tensor avg_pool1d::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad) {
    
    static auto op = create_avg_pool1d_typed_handle();
    return op.call(self, kernel_size, stride, padding, ceil_mode, count_include_pad);
}

// aten::avg_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, bool ceil_mode=False, bool count_include_pad=True) -> Tensor
at::Tensor avg_pool1d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad) {
    
    static auto op = create_avg_pool1d_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, ceil_mode, count_include_pad);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(adaptive_avg_pool1d, name, "aten::adaptive_avg_pool1d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(adaptive_avg_pool1d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(adaptive_avg_pool1d, schema_str, "adaptive_avg_pool1d(Tensor self, int[1] output_size) -> Tensor")

// aten::adaptive_avg_pool1d(Tensor self, int[1] output_size) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<adaptive_avg_pool1d::schema> create_adaptive_avg_pool1d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(adaptive_avg_pool1d::name, adaptive_avg_pool1d::overload_name)
      .typed<adaptive_avg_pool1d::schema>();
}

// aten::adaptive_avg_pool1d(Tensor self, int[1] output_size) -> Tensor
at::Tensor adaptive_avg_pool1d::call(const at::Tensor & self, at::IntArrayRef output_size) {
    
    static auto op = create_adaptive_avg_pool1d_typed_handle();
    return op.call(self, output_size);
}

// aten::adaptive_avg_pool1d(Tensor self, int[1] output_size) -> Tensor
at::Tensor adaptive_avg_pool1d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef output_size) {
    
    static auto op = create_adaptive_avg_pool1d_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_is_all_true, name, "aten::_is_all_true")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_is_all_true, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_is_all_true, schema_str, "_is_all_true(Tensor self) -> Tensor")

// aten::_is_all_true(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_is_all_true::schema> create__is_all_true_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_is_all_true::name, _is_all_true::overload_name)
      .typed<_is_all_true::schema>();
}

// aten::_is_all_true(Tensor self) -> Tensor
at::Tensor _is_all_true::call(const at::Tensor & self) {
    
    static auto op = create__is_all_true_typed_handle();
    return op.call(self);
}

// aten::_is_all_true(Tensor self) -> Tensor
at::Tensor _is_all_true::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__is_all_true_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_check_tensor, name, "aten::_test_check_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_check_tensor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_check_tensor, schema_str, "_test_check_tensor(Tensor self) -> Tensor")

// aten::_test_check_tensor(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_test_check_tensor::schema> create__test_check_tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_check_tensor::name, _test_check_tensor::overload_name)
      .typed<_test_check_tensor::schema>();
}

// aten::_test_check_tensor(Tensor self) -> Tensor
at::Tensor _test_check_tensor::call(const at::Tensor & self) {
    
    static auto op = create__test_check_tensor_typed_handle();
    return op.call(self);
}

// aten::_test_check_tensor(Tensor self) -> Tensor
at::Tensor _test_check_tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__test_check_tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(allclose, name, "aten::allclose")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(allclose, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(allclose, schema_str, "allclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -> bool")

// aten::allclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<allclose::schema> create_allclose_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(allclose::name, allclose::overload_name)
      .typed<allclose::schema>();
}

// aten::allclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -> bool
bool allclose::call(const at::Tensor & self, const at::Tensor & other, double rtol, double atol, bool equal_nan) {
    
    static auto op = create_allclose_typed_handle();
    return op.call(self, other, rtol, atol, equal_nan);
}

// aten::allclose(Tensor self, Tensor other, float rtol=1e-05, float atol=1e-08, bool equal_nan=False) -> bool
bool allclose::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, double rtol, double atol, bool equal_nan) {
    
    static auto op = create_allclose_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, rtol, atol, equal_nan);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(argmax, name, "aten::argmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(argmax, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(argmax, schema_str, "argmax(Tensor self, int? dim=None, bool keepdim=False) -> Tensor")

// aten::argmax(Tensor self, int? dim=None, bool keepdim=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<argmax::schema> create_argmax_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(argmax::name, argmax::overload_name)
      .typed<argmax::schema>();
}

// aten::argmax(Tensor self, int? dim=None, bool keepdim=False) -> Tensor
at::Tensor argmax::call(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
    
    static auto op = create_argmax_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::argmax(Tensor self, int? dim=None, bool keepdim=False) -> Tensor
at::Tensor argmax::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
    
    static auto op = create_argmax_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(argmax_out, name, "aten::argmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(argmax_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(argmax_out, schema_str, "argmax.out(Tensor self, int? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::argmax.out(Tensor self, int? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<argmax_out::schema> create_argmax_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(argmax_out::name, argmax_out::overload_name)
      .typed<argmax_out::schema>();
}

// aten::argmax.out(Tensor self, int? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & argmax_out::call(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_argmax_out_typed_handle();
    return op.call(self, dim, keepdim, out);
}

// aten::argmax.out(Tensor self, int? dim=None, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & argmax_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_argmax_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acosh, name, "aten::acosh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acosh, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acosh, schema_str, "acosh(Tensor self) -> Tensor")

// aten::acosh(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<acosh::schema> create_acosh_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(acosh::name, acosh::overload_name)
      .typed<acosh::schema>();
}

// aten::acosh(Tensor self) -> Tensor
at::Tensor acosh::call(const at::Tensor & self) {
    
    static auto op = create_acosh_typed_handle();
    return op.call(self);
}

// aten::acosh(Tensor self) -> Tensor
at::Tensor acosh::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_acosh_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acosh_, name, "aten::acosh_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acosh_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acosh_, schema_str, "acosh_(Tensor(a!) self) -> Tensor(a!)")

// aten::acosh_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<acosh_::schema> create_acosh__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(acosh_::name, acosh_::overload_name)
      .typed<acosh_::schema>();
}

// aten::acosh_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & acosh_::call(at::Tensor & self) {
    
    static auto op = create_acosh__typed_handle();
    return op.call(self);
}

// aten::acosh_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & acosh_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_acosh__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acosh_out, name, "aten::acosh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acosh_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(acosh_out, schema_str, "acosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::acosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<acosh_out::schema> create_acosh_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(acosh_out::name, acosh_out::overload_name)
      .typed<acosh_out::schema>();
}

// aten::acosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & acosh_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_acosh_out_typed_handle();
    return op.call(self, out);
}

// aten::acosh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & acosh_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_acosh_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctanh, name, "aten::arctanh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctanh, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctanh, schema_str, "arctanh(Tensor self) -> Tensor")

// aten::arctanh(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<arctanh::schema> create_arctanh_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arctanh::name, arctanh::overload_name)
      .typed<arctanh::schema>();
}

// aten::arctanh(Tensor self) -> Tensor
at::Tensor arctanh::call(const at::Tensor & self) {
    
    static auto op = create_arctanh_typed_handle();
    return op.call(self);
}

// aten::arctanh(Tensor self) -> Tensor
at::Tensor arctanh::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_arctanh_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctanh_, name, "aten::arctanh_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctanh_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctanh_, schema_str, "arctanh_(Tensor(a!) self) -> Tensor(a!)")

// aten::arctanh_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<arctanh_::schema> create_arctanh__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arctanh_::name, arctanh_::overload_name)
      .typed<arctanh_::schema>();
}

// aten::arctanh_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & arctanh_::call(at::Tensor & self) {
    
    static auto op = create_arctanh__typed_handle();
    return op.call(self);
}

// aten::arctanh_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & arctanh_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_arctanh__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctanh_out, name, "aten::arctanh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctanh_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctanh_out, schema_str, "arctanh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::arctanh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<arctanh_out::schema> create_arctanh_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arctanh_out::name, arctanh_out::overload_name)
      .typed<arctanh_out::schema>();
}

// aten::arctanh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & arctanh_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_arctanh_out_typed_handle();
    return op.call(self, out);
}

// aten::arctanh.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & arctanh_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_arctanh_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided, name, "aten::as_strided")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided, schema_str, "as_strided(Tensor(a) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a)")

// aten::as_strided(Tensor(a) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<as_strided::schema> create_as_strided_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(as_strided::name, as_strided::overload_name)
      .typed<as_strided::schema>();
}

// aten::as_strided(Tensor(a) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a)
at::Tensor as_strided::call(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    
    static auto op = create_as_strided_typed_handle();
    return op.call(self, size, stride, storage_offset);
}

// aten::as_strided(Tensor(a) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a)
at::Tensor as_strided::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    
    static auto op = create_as_strided_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, stride, storage_offset);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided_, name, "aten::as_strided_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided_, schema_str, "as_strided_(Tensor(a!) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a!)")

// aten::as_strided_(Tensor(a!) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<as_strided_::schema> create_as_strided__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(as_strided_::name, as_strided_::overload_name)
      .typed<as_strided_::schema>();
}

// aten::as_strided_(Tensor(a!) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a!)
const at::Tensor & as_strided_::call(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    
    static auto op = create_as_strided__typed_handle();
    return op.call(self, size, stride, storage_offset);
}

// aten::as_strided_(Tensor(a!) self, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor(a!)
const at::Tensor & as_strided_::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    
    static auto op = create_as_strided__typed_handle();
    return op.redispatch(dispatchKeySet, self, size, stride, storage_offset);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_3d, name, "aten::atleast_3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_3d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_3d, schema_str, "atleast_3d(Tensor self) -> Tensor")

// aten::atleast_3d(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<atleast_3d::schema> create_atleast_3d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(atleast_3d::name, atleast_3d::overload_name)
      .typed<atleast_3d::schema>();
}

// aten::atleast_3d(Tensor self) -> Tensor
at::Tensor atleast_3d::call(const at::Tensor & self) {
    
    static auto op = create_atleast_3d_typed_handle();
    return op.call(self);
}

// aten::atleast_3d(Tensor self) -> Tensor
at::Tensor atleast_3d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_atleast_3d_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_3d_Sequence, name, "aten::atleast_3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_3d_Sequence, overload_name, "Sequence")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(atleast_3d_Sequence, schema_str, "atleast_3d.Sequence(Tensor[] tensors) -> Tensor[]")

// aten::atleast_3d.Sequence(Tensor[] tensors) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<atleast_3d_Sequence::schema> create_atleast_3d_Sequence_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(atleast_3d_Sequence::name, atleast_3d_Sequence::overload_name)
      .typed<atleast_3d_Sequence::schema>();
}

// aten::atleast_3d.Sequence(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> atleast_3d_Sequence::call(at::TensorList tensors) {
    
    static auto op = create_atleast_3d_Sequence_typed_handle();
    return op.call(tensors);
}

// aten::atleast_3d.Sequence(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> atleast_3d_Sequence::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors) {
    
    static auto op = create_atleast_3d_Sequence_typed_handle();
    return op.redispatch(dispatchKeySet, tensors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_batch_norm_impl_index, name, "aten::_batch_norm_impl_index")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_batch_norm_impl_index, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_batch_norm_impl_index, schema_str, "_batch_norm_impl_index(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps, bool cudnn_enabled) -> (Tensor, Tensor, Tensor, Tensor, int)")

// aten::_batch_norm_impl_index(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps, bool cudnn_enabled) -> (Tensor, Tensor, Tensor, Tensor, int)
static C10_NOINLINE c10::TypedOperatorHandle<_batch_norm_impl_index::schema> create__batch_norm_impl_index_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_batch_norm_impl_index::name, _batch_norm_impl_index::overload_name)
      .typed<_batch_norm_impl_index::schema>();
}

// aten::_batch_norm_impl_index(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps, bool cudnn_enabled) -> (Tensor, Tensor, Tensor, Tensor, int)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,int64_t> _batch_norm_impl_index::call(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps, bool cudnn_enabled) {
    
    static auto op = create__batch_norm_impl_index_typed_handle();
    return op.call(input, weight, bias, running_mean, running_var, training, momentum, eps, cudnn_enabled);
}

// aten::_batch_norm_impl_index(Tensor input, Tensor? weight, Tensor? bias, Tensor? running_mean, Tensor? running_var, bool training, float momentum, float eps, bool cudnn_enabled) -> (Tensor, Tensor, Tensor, Tensor, int)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,int64_t> _batch_norm_impl_index::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps, bool cudnn_enabled) {
    
    static auto op = create__batch_norm_impl_index_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, running_mean, running_var, training, momentum, eps, cudnn_enabled);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_batch_norm_impl_index_backward, name, "aten::_batch_norm_impl_index_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_batch_norm_impl_index_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_batch_norm_impl_index_backward, schema_str, "_batch_norm_impl_index_backward(int impl_index, Tensor input, Tensor grad_output, Tensor? weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var_transform, bool train, float eps, bool[3] output_mask, Tensor reservedSpace) -> (Tensor, Tensor, Tensor)")

// aten::_batch_norm_impl_index_backward(int impl_index, Tensor input, Tensor grad_output, Tensor? weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var_transform, bool train, float eps, bool[3] output_mask, Tensor reservedSpace) -> (Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_batch_norm_impl_index_backward::schema> create__batch_norm_impl_index_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_batch_norm_impl_index_backward::name, _batch_norm_impl_index_backward::overload_name)
      .typed<_batch_norm_impl_index_backward::schema>();
}

// aten::_batch_norm_impl_index_backward(int impl_index, Tensor input, Tensor grad_output, Tensor? weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var_transform, bool train, float eps, bool[3] output_mask, Tensor reservedSpace) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _batch_norm_impl_index_backward::call(int64_t impl_index, const at::Tensor & input, const at::Tensor & grad_output, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var_transform, bool train, double eps, ::std::array<bool,3> output_mask, const at::Tensor & reservedSpace) {
    
    static auto op = create__batch_norm_impl_index_backward_typed_handle();
    return op.call(impl_index, input, grad_output, weight, running_mean, running_var, save_mean, save_var_transform, train, eps, output_mask, reservedSpace);
}

// aten::_batch_norm_impl_index_backward(int impl_index, Tensor input, Tensor grad_output, Tensor? weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var_transform, bool train, float eps, bool[3] output_mask, Tensor reservedSpace) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _batch_norm_impl_index_backward::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t impl_index, const at::Tensor & input, const at::Tensor & grad_output, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var_transform, bool train, double eps, ::std::array<bool,3> output_mask, const at::Tensor & reservedSpace) {
    
    static auto op = create__batch_norm_impl_index_backward_typed_handle();
    return op.redispatch(dispatchKeySet, impl_index, input, grad_output, weight, running_mean, running_var, save_mean, save_var_transform, train, eps, output_mask, reservedSpace);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_or, name, "aten::logical_or")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_or, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_or, schema_str, "logical_or(Tensor self, Tensor other) -> Tensor")

// aten::logical_or(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<logical_or::schema> create_logical_or_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logical_or::name, logical_or::overload_name)
      .typed<logical_or::schema>();
}

// aten::logical_or(Tensor self, Tensor other) -> Tensor
at::Tensor logical_or::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logical_or_typed_handle();
    return op.call(self, other);
}

// aten::logical_or(Tensor self, Tensor other) -> Tensor
at::Tensor logical_or::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logical_or_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_or_, name, "aten::logical_or_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_or_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_or_, schema_str, "logical_or_(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::logical_or_(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<logical_or_::schema> create_logical_or__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logical_or_::name, logical_or_::overload_name)
      .typed<logical_or_::schema>();
}

// aten::logical_or_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & logical_or_::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logical_or__typed_handle();
    return op.call(self, other);
}

// aten::logical_or_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & logical_or_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logical_or__typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_or_out, name, "aten::logical_or")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_or_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logical_or_out, schema_str, "logical_or.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::logical_or.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<logical_or_out::schema> create_logical_or_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logical_or_out::name, logical_or_out::overload_name)
      .typed<logical_or_out::schema>();
}

// aten::logical_or.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logical_or_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_logical_or_out_typed_handle();
    return op.call(self, other, out);
}

// aten::logical_or.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logical_or_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_logical_or_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window, name, "aten::blackman_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window, schema_str, "blackman_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::blackman_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<blackman_window::schema> create_blackman_window_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(blackman_window::name, blackman_window::overload_name)
      .typed<blackman_window::schema>();
}

// aten::blackman_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor blackman_window::call(int64_t window_length, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_blackman_window_typed_handle();
    return op.call(window_length, dtype, layout, device, pin_memory);
}

// aten::blackman_window(int window_length, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor blackman_window::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_blackman_window_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window_periodic, name, "aten::blackman_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window_periodic, overload_name, "periodic")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window_periodic, schema_str, "blackman_window.periodic(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::blackman_window.periodic(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<blackman_window_periodic::schema> create_blackman_window_periodic_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(blackman_window_periodic::name, blackman_window_periodic::overload_name)
      .typed<blackman_window_periodic::schema>();
}

// aten::blackman_window.periodic(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor blackman_window_periodic::call(int64_t window_length, bool periodic, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_blackman_window_periodic_typed_handle();
    return op.call(window_length, periodic, dtype, layout, device, pin_memory);
}

// aten::blackman_window.periodic(int window_length, bool periodic, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor blackman_window_periodic::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, bool periodic, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_blackman_window_periodic_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, periodic, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(broadcast_tensors, name, "aten::broadcast_tensors")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(broadcast_tensors, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(broadcast_tensors, schema_str, "broadcast_tensors(Tensor[] tensors) -> Tensor[]")

// aten::broadcast_tensors(Tensor[] tensors) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<broadcast_tensors::schema> create_broadcast_tensors_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(broadcast_tensors::name, broadcast_tensors::overload_name)
      .typed<broadcast_tensors::schema>();
}

// aten::broadcast_tensors(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> broadcast_tensors::call(at::TensorList tensors) {
    
    static auto op = create_broadcast_tensors_typed_handle();
    return op.call(tensors);
}

// aten::broadcast_tensors(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> broadcast_tensors::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors) {
    
    static auto op = create_broadcast_tensors_typed_handle();
    return op.redispatch(dispatchKeySet, tensors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat, name, "aten::cat")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat, schema_str, "cat(Tensor[] tensors, int dim=0) -> Tensor")

// aten::cat(Tensor[] tensors, int dim=0) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cat::schema> create_cat_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cat::name, cat::overload_name)
      .typed<cat::schema>();
}

// aten::cat(Tensor[] tensors, int dim=0) -> Tensor
at::Tensor cat::call(const at::ITensorListRef & tensors, int64_t dim) {
    
    static auto op = create_cat_typed_handle();
    return op.call(tensors, dim);
}

// aten::cat(Tensor[] tensors, int dim=0) -> Tensor
at::Tensor cat::redispatch(c10::DispatchKeySet dispatchKeySet, const at::ITensorListRef & tensors, int64_t dim) {
    
    static auto op = create_cat_typed_handle();
    return op.redispatch(dispatchKeySet, tensors, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat_out, name, "aten::cat")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat_out, schema_str, "cat.out(Tensor[] tensors, int dim=0, *, Tensor(a!) out) -> Tensor(a!)")

// aten::cat.out(Tensor[] tensors, int dim=0, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cat_out::schema> create_cat_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cat_out::name, cat_out::overload_name)
      .typed<cat_out::schema>();
}

// aten::cat.out(Tensor[] tensors, int dim=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cat_out::call(const at::ITensorListRef & tensors, int64_t dim, at::Tensor & out) {
    
    static auto op = create_cat_out_typed_handle();
    return op.call(tensors, dim, out);
}

// aten::cat.out(Tensor[] tensors, int dim=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cat_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::ITensorListRef & tensors, int64_t dim, at::Tensor & out) {
    
    static auto op = create_cat_out_typed_handle();
    return op.redispatch(dispatchKeySet, tensors, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat_names, name, "aten::cat")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat_names, overload_name, "names")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat_names, schema_str, "cat.names(Tensor[] tensors, Dimname dim) -> Tensor")

// aten::cat.names(Tensor[] tensors, Dimname dim) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cat_names::schema> create_cat_names_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cat_names::name, cat_names::overload_name)
      .typed<cat_names::schema>();
}

// aten::cat.names(Tensor[] tensors, Dimname dim) -> Tensor
at::Tensor cat_names::call(at::TensorList tensors, at::Dimname dim) {
    
    static auto op = create_cat_names_typed_handle();
    return op.call(tensors, dim);
}

// aten::cat.names(Tensor[] tensors, Dimname dim) -> Tensor
at::Tensor cat_names::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors, at::Dimname dim) {
    
    static auto op = create_cat_names_typed_handle();
    return op.redispatch(dispatchKeySet, tensors, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat_names_out, name, "aten::cat")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat_names_out, overload_name, "names_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cat_names_out, schema_str, "cat.names_out(Tensor[] tensors, Dimname dim, *, Tensor(a!) out) -> Tensor(a!)")

// aten::cat.names_out(Tensor[] tensors, Dimname dim, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cat_names_out::schema> create_cat_names_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cat_names_out::name, cat_names_out::overload_name)
      .typed<cat_names_out::schema>();
}

// aten::cat.names_out(Tensor[] tensors, Dimname dim, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cat_names_out::call(at::TensorList tensors, at::Dimname dim, at::Tensor & out) {
    
    static auto op = create_cat_names_out_typed_handle();
    return op.call(tensors, dim, out);
}

// aten::cat.names_out(Tensor[] tensors, Dimname dim, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cat_names_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors, at::Dimname dim, at::Tensor & out) {
    
    static auto op = create_cat_names_out_typed_handle();
    return op.redispatch(dispatchKeySet, tensors, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution, name, "aten::convolution")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution, schema_str, "convolution(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups) -> Tensor")

// aten::convolution(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<convolution::schema> create_convolution_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(convolution::name, convolution::overload_name)
      .typed<convolution::schema>();
}

// aten::convolution(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups) -> Tensor
at::Tensor convolution::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups) {
    
    static auto op = create_convolution_typed_handle();
    return op.call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups);
}

// aten::convolution(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups) -> Tensor
at::Tensor convolution::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups) {
    
    static auto op = create_convolution_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward_overrideable, name, "aten::convolution_backward_overrideable")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward_overrideable, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward_overrideable, schema_str, "convolution_backward_overrideable(Tensor grad_output, Tensor input, Tensor weight, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)")

// aten::convolution_backward_overrideable(Tensor grad_output, Tensor input, Tensor weight, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)
static C10_NOINLINE c10::TypedOperatorHandle<convolution_backward_overrideable::schema> create_convolution_backward_overrideable_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(convolution_backward_overrideable::name, convolution_backward_overrideable::overload_name)
      .typed<convolution_backward_overrideable::schema>();
}

// aten::convolution_backward_overrideable(Tensor grad_output, Tensor input, Tensor weight, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> convolution_backward_overrideable::call(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask) {
    
    static auto op = create_convolution_backward_overrideable_typed_handle();
    return op.call(grad_output, input, weight, stride, padding, dilation, transposed, output_padding, groups, output_mask);
}

// aten::convolution_backward_overrideable(Tensor grad_output, Tensor input, Tensor weight, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask) -> (Tensor grad_input, Tensor grad_weight, Tensor grad_bias)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> convolution_backward_overrideable::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask) {
    
    static auto op = create_convolution_backward_overrideable_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, input, weight, stride, padding, dilation, transposed, output_padding, groups, output_mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution, name, "aten::_convolution")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution, schema_str, "_convolution(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32) -> Tensor")

// aten::_convolution(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_convolution::schema> create__convolution_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_convolution::name, _convolution::overload_name)
      .typed<_convolution::schema>();
}

// aten::_convolution(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32) -> Tensor
at::Tensor _convolution::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32) {
    
    static auto op = create__convolution_typed_handle();
    return op.call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32);
}

// aten::_convolution(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32) -> Tensor
at::Tensor _convolution::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32) {
    
    static auto op = create__convolution_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution_deprecated, name, "aten::_convolution")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution_deprecated, overload_name, "deprecated")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution_deprecated, schema_str, "_convolution.deprecated(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, int[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled) -> Tensor")

// aten::_convolution.deprecated(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, int[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_convolution_deprecated::schema> create__convolution_deprecated_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_convolution_deprecated::name, _convolution_deprecated::overload_name)
      .typed<_convolution_deprecated::schema>();
}

// aten::_convolution.deprecated(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, int[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled) -> Tensor
at::Tensor _convolution_deprecated::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, at::IntArrayRef output_padding, c10::SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled) {
    
    static auto op = create__convolution_deprecated_typed_handle();
    return op.call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled);
}

// aten::_convolution.deprecated(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, int[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled) -> Tensor
at::Tensor _convolution_deprecated::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, at::IntArrayRef output_padding, c10::SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled) {
    
    static auto op = create__convolution_deprecated_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conv_transpose1d, name, "aten::conv_transpose1d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conv_transpose1d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(conv_transpose1d, schema_str, "conv_transpose1d(Tensor input, Tensor weight, Tensor? bias=None, SymInt[1] stride=1, SymInt[1] padding=0, SymInt[1] output_padding=0, SymInt groups=1, SymInt[1] dilation=1) -> Tensor")

// aten::conv_transpose1d(Tensor input, Tensor weight, Tensor? bias=None, SymInt[1] stride=1, SymInt[1] padding=0, SymInt[1] output_padding=0, SymInt groups=1, SymInt[1] dilation=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<conv_transpose1d::schema> create_conv_transpose1d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(conv_transpose1d::name, conv_transpose1d::overload_name)
      .typed<conv_transpose1d::schema>();
}

// aten::conv_transpose1d(Tensor input, Tensor weight, Tensor? bias=None, SymInt[1] stride=1, SymInt[1] padding=0, SymInt[1] output_padding=0, SymInt groups=1, SymInt[1] dilation=1) -> Tensor
at::Tensor conv_transpose1d::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymInt groups, c10::SymIntArrayRef dilation) {
    
    static auto op = create_conv_transpose1d_typed_handle();
    return op.call(input, weight, bias, stride, padding, output_padding, groups, dilation);
}

// aten::conv_transpose1d(Tensor input, Tensor weight, Tensor? bias=None, SymInt[1] stride=1, SymInt[1] padding=0, SymInt[1] output_padding=0, SymInt groups=1, SymInt[1] dilation=1) -> Tensor
at::Tensor conv_transpose1d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymInt groups, c10::SymIntArrayRef dilation) {
    
    static auto op = create_conv_transpose1d_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, output_padding, groups, dilation);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cos, name, "aten::cos")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cos, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cos, schema_str, "cos(Tensor self) -> Tensor")

// aten::cos(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cos::schema> create_cos_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cos::name, cos::overload_name)
      .typed<cos::schema>();
}

// aten::cos(Tensor self) -> Tensor
at::Tensor cos::call(const at::Tensor & self) {
    
    static auto op = create_cos_typed_handle();
    return op.call(self);
}

// aten::cos(Tensor self) -> Tensor
at::Tensor cos::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_cos_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cos_, name, "aten::cos_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cos_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cos_, schema_str, "cos_(Tensor(a!) self) -> Tensor(a!)")

// aten::cos_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cos_::schema> create_cos__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cos_::name, cos_::overload_name)
      .typed<cos_::schema>();
}

// aten::cos_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & cos_::call(at::Tensor & self) {
    
    static auto op = create_cos__typed_handle();
    return op.call(self);
}

// aten::cos_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & cos_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_cos__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cos_out, name, "aten::cos")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cos_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cos_out, schema_str, "cos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::cos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cos_out::schema> create_cos_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cos_out::name, cos_out::overload_name)
      .typed<cos_out::schema>();
}

// aten::cos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cos_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_cos_out_typed_handle();
    return op.call(self, out);
}

// aten::cos.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cos_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_cos_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_affine_grid_generator, name, "aten::cudnn_affine_grid_generator")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_affine_grid_generator, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_affine_grid_generator, schema_str, "cudnn_affine_grid_generator(Tensor theta, int N, int C, int H, int W) -> Tensor grid")

// aten::cudnn_affine_grid_generator(Tensor theta, int N, int C, int H, int W) -> Tensor grid
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_affine_grid_generator::schema> create_cudnn_affine_grid_generator_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_affine_grid_generator::name, cudnn_affine_grid_generator::overload_name)
      .typed<cudnn_affine_grid_generator::schema>();
}

// aten::cudnn_affine_grid_generator(Tensor theta, int N, int C, int H, int W) -> Tensor grid
at::Tensor cudnn_affine_grid_generator::call(const at::Tensor & theta, int64_t N, int64_t C, int64_t H, int64_t W) {
    
    static auto op = create_cudnn_affine_grid_generator_typed_handle();
    return op.call(theta, N, C, H, W);
}

// aten::cudnn_affine_grid_generator(Tensor theta, int N, int C, int H, int W) -> Tensor grid
at::Tensor cudnn_affine_grid_generator::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & theta, int64_t N, int64_t C, int64_t H, int64_t W) {
    
    static auto op = create_cudnn_affine_grid_generator_typed_handle();
    return op.redispatch(dispatchKeySet, theta, N, C, H, W);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm_backward, name, "aten::cudnn_batch_norm_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm_backward, schema_str, "cudnn_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace) -> (Tensor, Tensor, Tensor)")

// aten::cudnn_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace) -> (Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_batch_norm_backward::schema> create_cudnn_batch_norm_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_batch_norm_backward::name, cudnn_batch_norm_backward::overload_name)
      .typed<cudnn_batch_norm_backward::schema>();
}

// aten::cudnn_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> cudnn_batch_norm_backward::call(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, const at::Tensor & reserveSpace) {
    
    static auto op = create_cudnn_batch_norm_backward_typed_handle();
    return op.call(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace);
}

// aten::cudnn_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> cudnn_batch_norm_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, const at::Tensor & reserveSpace) {
    
    static auto op = create_cudnn_batch_norm_backward_typed_handle();
    return op.redispatch(dispatchKeySet, input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_convolution_transpose, name, "aten::cudnn_convolution_transpose")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_convolution_transpose, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_convolution_transpose, schema_str, "cudnn_convolution_transpose(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) -> Tensor")

// aten::cudnn_convolution_transpose(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_convolution_transpose::schema> create_cudnn_convolution_transpose_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_convolution_transpose::name, cudnn_convolution_transpose::overload_name)
      .typed<cudnn_convolution_transpose::schema>();
}

// aten::cudnn_convolution_transpose(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) -> Tensor
at::Tensor cudnn_convolution_transpose::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) {
    
    static auto op = create_cudnn_convolution_transpose_typed_handle();
    return op.call(self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32);
}

// aten::cudnn_convolution_transpose(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) -> Tensor
at::Tensor cudnn_convolution_transpose::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) {
    
    static auto op = create_cudnn_convolution_transpose_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_grid_sampler_backward, name, "aten::cudnn_grid_sampler_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_grid_sampler_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_grid_sampler_backward, schema_str, "cudnn_grid_sampler_backward(Tensor self, Tensor grid, Tensor grad_output) -> (Tensor grad_self, Tensor grad_grid)")

// aten::cudnn_grid_sampler_backward(Tensor self, Tensor grid, Tensor grad_output) -> (Tensor grad_self, Tensor grad_grid)
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_grid_sampler_backward::schema> create_cudnn_grid_sampler_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_grid_sampler_backward::name, cudnn_grid_sampler_backward::overload_name)
      .typed<cudnn_grid_sampler_backward::schema>();
}

// aten::cudnn_grid_sampler_backward(Tensor self, Tensor grid, Tensor grad_output) -> (Tensor grad_self, Tensor grad_grid)
::std::tuple<at::Tensor,at::Tensor> cudnn_grid_sampler_backward::call(const at::Tensor & self, const at::Tensor & grid, const at::Tensor & grad_output) {
    
    static auto op = create_cudnn_grid_sampler_backward_typed_handle();
    return op.call(self, grid, grad_output);
}

// aten::cudnn_grid_sampler_backward(Tensor self, Tensor grid, Tensor grad_output) -> (Tensor grad_self, Tensor grad_grid)
::std::tuple<at::Tensor,at::Tensor> cudnn_grid_sampler_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & grid, const at::Tensor & grad_output) {
    
    static auto op = create_cudnn_grid_sampler_backward_typed_handle();
    return op.redispatch(dispatchKeySet, self, grid, grad_output);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum, name, "aten::cumsum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum, schema_str, "cumsum(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor")

// aten::cumsum(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cumsum::schema> create_cumsum_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cumsum::name, cumsum::overload_name)
      .typed<cumsum::schema>();
}

// aten::cumsum(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor
at::Tensor cumsum::call(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_cumsum_typed_handle();
    return op.call(self, dim, dtype);
}

// aten::cumsum(Tensor self, int dim, *, ScalarType? dtype=None) -> Tensor
at::Tensor cumsum::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_cumsum_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_, name, "aten::cumsum_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_, schema_str, "cumsum_(Tensor(a!) self, int dim, *, ScalarType? dtype=None) -> Tensor(a!)")

// aten::cumsum_(Tensor(a!) self, int dim, *, ScalarType? dtype=None) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cumsum_::schema> create_cumsum__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cumsum_::name, cumsum_::overload_name)
      .typed<cumsum_::schema>();
}

// aten::cumsum_(Tensor(a!) self, int dim, *, ScalarType? dtype=None) -> Tensor(a!)
at::Tensor & cumsum_::call(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_cumsum__typed_handle();
    return op.call(self, dim, dtype);
}

// aten::cumsum_(Tensor(a!) self, int dim, *, ScalarType? dtype=None) -> Tensor(a!)
at::Tensor & cumsum_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_cumsum__typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_out, name, "aten::cumsum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_out, schema_str, "cumsum.out(Tensor self, int dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)")

// aten::cumsum.out(Tensor self, int dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cumsum_out::schema> create_cumsum_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cumsum_out::name, cumsum_out::overload_name)
      .typed<cumsum_out::schema>();
}

// aten::cumsum.out(Tensor self, int dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cumsum_out::call(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_cumsum_out_typed_handle();
    return op.call(self, dim, dtype, out);
}

// aten::cumsum.out(Tensor self, int dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cumsum_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_cumsum_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, dtype, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_dimname, name, "aten::cumsum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_dimname, schema_str, "cumsum.dimname(Tensor self, Dimname dim, *, ScalarType? dtype=None) -> Tensor")

// aten::cumsum.dimname(Tensor self, Dimname dim, *, ScalarType? dtype=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cumsum_dimname::schema> create_cumsum_dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cumsum_dimname::name, cumsum_dimname::overload_name)
      .typed<cumsum_dimname::schema>();
}

// aten::cumsum.dimname(Tensor self, Dimname dim, *, ScalarType? dtype=None) -> Tensor
at::Tensor cumsum_dimname::call(const at::Tensor & self, at::Dimname dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_cumsum_dimname_typed_handle();
    return op.call(self, dim, dtype);
}

// aten::cumsum.dimname(Tensor self, Dimname dim, *, ScalarType? dtype=None) -> Tensor
at::Tensor cumsum_dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_cumsum_dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum__dimname, name, "aten::cumsum_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum__dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum__dimname, schema_str, "cumsum_.dimname(Tensor(a!) self, Dimname dim, *, ScalarType? dtype=None) -> Tensor(a!)")

// aten::cumsum_.dimname(Tensor(a!) self, Dimname dim, *, ScalarType? dtype=None) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cumsum__dimname::schema> create_cumsum__dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cumsum__dimname::name, cumsum__dimname::overload_name)
      .typed<cumsum__dimname::schema>();
}

// aten::cumsum_.dimname(Tensor(a!) self, Dimname dim, *, ScalarType? dtype=None) -> Tensor(a!)
at::Tensor & cumsum__dimname::call(at::Tensor & self, at::Dimname dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_cumsum__dimname_typed_handle();
    return op.call(self, dim, dtype);
}

// aten::cumsum_.dimname(Tensor(a!) self, Dimname dim, *, ScalarType? dtype=None) -> Tensor(a!)
at::Tensor & cumsum__dimname::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, at::Dimname dim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_cumsum__dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_dimname_out, name, "aten::cumsum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_dimname_out, overload_name, "dimname_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cumsum_dimname_out, schema_str, "cumsum.dimname_out(Tensor self, Dimname dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)")

// aten::cumsum.dimname_out(Tensor self, Dimname dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cumsum_dimname_out::schema> create_cumsum_dimname_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cumsum_dimname_out::name, cumsum_dimname_out::overload_name)
      .typed<cumsum_dimname_out::schema>();
}

// aten::cumsum.dimname_out(Tensor self, Dimname dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cumsum_dimname_out::call(const at::Tensor & self, at::Dimname dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_cumsum_dimname_out_typed_handle();
    return op.call(self, dim, dtype, out);
}

// aten::cumsum.dimname_out(Tensor self, Dimname dim, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cumsum_dimname_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_cumsum_dimname_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, dtype, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss, name, "aten::_ctc_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss, schema_str, "_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, bool zero_infinity=False) -> (Tensor, Tensor)")

// aten::_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, bool zero_infinity=False) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_ctc_loss::schema> create__ctc_loss_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_ctc_loss::name, _ctc_loss::overload_name)
      .typed<_ctc_loss::schema>();
}

// aten::_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, bool zero_infinity=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _ctc_loss::call(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool zero_infinity) {
    
    static auto op = create__ctc_loss_typed_handle();
    return op.call(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}

// aten::_ctc_loss(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, bool zero_infinity=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _ctc_loss::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool zero_infinity) {
    
    static auto op = create__ctc_loss_typed_handle();
    return op.redispatch(dispatchKeySet, log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss_Tensor, name, "aten::_ctc_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss_Tensor, schema_str, "_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank=0, bool zero_infinity=False) -> (Tensor, Tensor)")

// aten::_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank=0, bool zero_infinity=False) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_ctc_loss_Tensor::schema> create__ctc_loss_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_ctc_loss_Tensor::name, _ctc_loss_Tensor::overload_name)
      .typed<_ctc_loss_Tensor::schema>();
}

// aten::_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank=0, bool zero_infinity=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _ctc_loss_Tensor::call(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool zero_infinity) {
    
    static auto op = create__ctc_loss_Tensor_typed_handle();
    return op.call(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}

// aten::_ctc_loss.Tensor(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank=0, bool zero_infinity=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _ctc_loss_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool zero_infinity) {
    
    static auto op = create__ctc_loss_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagflat, name, "aten::diagflat")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagflat, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagflat, schema_str, "diagflat(Tensor self, int offset=0) -> Tensor")

// aten::diagflat(Tensor self, int offset=0) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<diagflat::schema> create_diagflat_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(diagflat::name, diagflat::overload_name)
      .typed<diagflat::schema>();
}

// aten::diagflat(Tensor self, int offset=0) -> Tensor
at::Tensor diagflat::call(const at::Tensor & self, int64_t offset) {
    
    static auto op = create_diagflat_typed_handle();
    return op.call(self, offset);
}

// aten::diagflat(Tensor self, int offset=0) -> Tensor
at::Tensor diagflat::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t offset) {
    
    static auto op = create_diagflat_typed_handle();
    return op.redispatch(dispatchKeySet, self, offset);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_diagonal, name, "aten::linalg_diagonal")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_diagonal, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_diagonal, schema_str, "linalg_diagonal(Tensor(a) A, *, int offset=0, int dim1=-2, int dim2=-1) -> Tensor(a)")

// aten::linalg_diagonal(Tensor(a) A, *, int offset=0, int dim1=-2, int dim2=-1) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_diagonal::schema> create_linalg_diagonal_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_diagonal::name, linalg_diagonal::overload_name)
      .typed<linalg_diagonal::schema>();
}

// aten::linalg_diagonal(Tensor(a) A, *, int offset=0, int dim1=-2, int dim2=-1) -> Tensor(a)
at::Tensor linalg_diagonal::call(const at::Tensor & A, int64_t offset, int64_t dim1, int64_t dim2) {
    
    static auto op = create_linalg_diagonal_typed_handle();
    return op.call(A, offset, dim1, dim2);
}

// aten::linalg_diagonal(Tensor(a) A, *, int offset=0, int dim1=-2, int dim2=-1) -> Tensor(a)
at::Tensor linalg_diagonal::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, int64_t offset, int64_t dim1, int64_t dim2) {
    
    static auto op = create_linalg_diagonal_typed_handle();
    return op.redispatch(dispatchKeySet, A, offset, dim1, dim2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide_Tensor, name, "aten::true_divide")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide_Tensor, schema_str, "true_divide.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::true_divide.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<true_divide_Tensor::schema> create_true_divide_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(true_divide_Tensor::name, true_divide_Tensor::overload_name)
      .typed<true_divide_Tensor::schema>();
}

// aten::true_divide.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor true_divide_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_true_divide_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::true_divide.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor true_divide_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_true_divide_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide__Tensor, name, "aten::true_divide_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide__Tensor, schema_str, "true_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::true_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<true_divide__Tensor::schema> create_true_divide__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(true_divide__Tensor::name, true_divide__Tensor::overload_name)
      .typed<true_divide__Tensor::schema>();
}

// aten::true_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & true_divide__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_true_divide__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::true_divide_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & true_divide__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_true_divide__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide_out, name, "aten::true_divide")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide_out, schema_str, "true_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::true_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<true_divide_out::schema> create_true_divide_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(true_divide_out::name, true_divide_out::overload_name)
      .typed<true_divide_out::schema>();
}

// aten::true_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & true_divide_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_true_divide_out_typed_handle();
    return op.call(self, other, out);
}

// aten::true_divide.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & true_divide_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_true_divide_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide_Scalar, name, "aten::true_divide")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide_Scalar, schema_str, "true_divide.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::true_divide.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<true_divide_Scalar::schema> create_true_divide_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(true_divide_Scalar::name, true_divide_Scalar::overload_name)
      .typed<true_divide_Scalar::schema>();
}

// aten::true_divide.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor true_divide_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_true_divide_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::true_divide.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor true_divide_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_true_divide_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide__Scalar, name, "aten::true_divide_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(true_divide__Scalar, schema_str, "true_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::true_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<true_divide__Scalar::schema> create_true_divide__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(true_divide__Scalar::name, true_divide__Scalar::overload_name)
      .typed<true_divide__Scalar::schema>();
}

// aten::true_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & true_divide__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_true_divide__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::true_divide_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & true_divide__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_true_divide__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(vdot, name, "aten::vdot")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(vdot, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(vdot, schema_str, "vdot(Tensor self, Tensor other) -> Tensor")

// aten::vdot(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<vdot::schema> create_vdot_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(vdot::name, vdot::overload_name)
      .typed<vdot::schema>();
}

// aten::vdot(Tensor self, Tensor other) -> Tensor
at::Tensor vdot::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_vdot_typed_handle();
    return op.call(self, other);
}

// aten::vdot(Tensor self, Tensor other) -> Tensor
at::Tensor vdot::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_vdot_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(vdot_out, name, "aten::vdot")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(vdot_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(vdot_out, schema_str, "vdot.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::vdot.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<vdot_out::schema> create_vdot_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(vdot_out::name, vdot_out::overload_name)
      .typed<vdot_out::schema>();
}

// aten::vdot.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & vdot_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_vdot_out_typed_handle();
    return op.call(self, other, out);
}

// aten::vdot.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & vdot_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_vdot_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_backward, name, "aten::embedding_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_backward, schema_str, "embedding_backward(Tensor grad, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq, bool sparse) -> Tensor")

// aten::embedding_backward(Tensor grad, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq, bool sparse) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<embedding_backward::schema> create_embedding_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(embedding_backward::name, embedding_backward::overload_name)
      .typed<embedding_backward::schema>();
}

// aten::embedding_backward(Tensor grad, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq, bool sparse) -> Tensor
at::Tensor embedding_backward::call(const at::Tensor & grad, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq, bool sparse) {
    
    static auto op = create_embedding_backward_typed_handle();
    return op.call(grad, indices, num_weights, padding_idx, scale_grad_by_freq, sparse);
}

// aten::embedding_backward(Tensor grad, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq, bool sparse) -> Tensor
at::Tensor embedding_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq, bool sparse) {
    
    static auto op = create_embedding_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, indices, num_weights, padding_idx, scale_grad_by_freq, sparse);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_dense_backward, name, "aten::embedding_dense_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_dense_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_dense_backward, schema_str, "embedding_dense_backward(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq) -> Tensor")

// aten::embedding_dense_backward(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<embedding_dense_backward::schema> create_embedding_dense_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(embedding_dense_backward::name, embedding_dense_backward::overload_name)
      .typed<embedding_dense_backward::schema>();
}

// aten::embedding_dense_backward(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq) -> Tensor
at::Tensor embedding_dense_backward::call(const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq) {
    
    static auto op = create_embedding_dense_backward_typed_handle();
    return op.call(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq);
}

// aten::embedding_dense_backward(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq) -> Tensor
at::Tensor embedding_dense_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq) {
    
    static auto op = create_embedding_dense_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, indices, num_weights, padding_idx, scale_grad_by_freq);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag, name, "aten::_embedding_bag")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag, schema_str, "_embedding_bag(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None, bool include_last_offset=False, int padding_idx=-1) -> (Tensor, Tensor, Tensor, Tensor)")

// aten::_embedding_bag(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None, bool include_last_offset=False, int padding_idx=-1) -> (Tensor, Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_embedding_bag::schema> create__embedding_bag_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_embedding_bag::name, _embedding_bag::overload_name)
      .typed<_embedding_bag::schema>();
}

// aten::_embedding_bag(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None, bool include_last_offset=False, int padding_idx=-1) -> (Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _embedding_bag::call(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
    
    static auto op = create__embedding_bag_typed_handle();
    return op.call(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}

// aten::_embedding_bag(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None, bool include_last_offset=False, int padding_idx=-1) -> (Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _embedding_bag::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
    
    static auto op = create__embedding_bag_typed_handle();
    return op.redispatch(dispatchKeySet, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_sparse_backward, name, "aten::_embedding_bag_sparse_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_sparse_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_sparse_backward, schema_str, "_embedding_bag_sparse_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor")

// aten::_embedding_bag_sparse_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_embedding_bag_sparse_backward::schema> create__embedding_bag_sparse_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_embedding_bag_sparse_backward::name, _embedding_bag_sparse_backward::overload_name)
      .typed<_embedding_bag_sparse_backward::schema>();
}

// aten::_embedding_bag_sparse_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor
at::Tensor _embedding_bag_sparse_backward::call(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offsets, const at::Tensor & offset2bag, const at::Tensor & bag_size, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
    
    static auto op = create__embedding_bag_sparse_backward_typed_handle();
    return op.call(grad, indices, offsets, offset2bag, bag_size, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}

// aten::_embedding_bag_sparse_backward(Tensor grad, Tensor indices, Tensor offsets, Tensor offset2bag, Tensor bag_size, SymInt num_weights, bool scale_grad_by_freq, int mode, Tensor? per_sample_weights, int padding_idx=-1) -> Tensor
at::Tensor _embedding_bag_sparse_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offsets, const at::Tensor & offset2bag, const at::Tensor & bag_size, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
    
    static auto op = create__embedding_bag_sparse_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, indices, offsets, offset2bag, bag_size, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(new_empty, name, "aten::new_empty")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(new_empty, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(new_empty, schema_str, "new_empty(Tensor self, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::new_empty(Tensor self, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<new_empty::schema> create_new_empty_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(new_empty::name, new_empty::overload_name)
      .typed<new_empty::schema>();
}

// aten::new_empty(Tensor self, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor new_empty::call(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_new_empty_typed_handle();
    return op.call(self, size, dtype, layout, device, pin_memory);
}

// aten::new_empty(Tensor self, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor new_empty::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_new_empty_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expm1, name, "aten::expm1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expm1, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expm1, schema_str, "expm1(Tensor self) -> Tensor")

// aten::expm1(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<expm1::schema> create_expm1_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(expm1::name, expm1::overload_name)
      .typed<expm1::schema>();
}

// aten::expm1(Tensor self) -> Tensor
at::Tensor expm1::call(const at::Tensor & self) {
    
    static auto op = create_expm1_typed_handle();
    return op.call(self);
}

// aten::expm1(Tensor self) -> Tensor
at::Tensor expm1::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_expm1_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expm1_, name, "aten::expm1_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expm1_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expm1_, schema_str, "expm1_(Tensor(a!) self) -> Tensor(a!)")

// aten::expm1_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<expm1_::schema> create_expm1__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(expm1_::name, expm1_::overload_name)
      .typed<expm1_::schema>();
}

// aten::expm1_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & expm1_::call(at::Tensor & self) {
    
    static auto op = create_expm1__typed_handle();
    return op.call(self);
}

// aten::expm1_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & expm1_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_expm1__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expm1_out, name, "aten::expm1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expm1_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expm1_out, schema_str, "expm1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::expm1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<expm1_out::schema> create_expm1_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(expm1_out::name, expm1_out::overload_name)
      .typed<expm1_out::schema>();
}

// aten::expm1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & expm1_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_expm1_out_typed_handle();
    return op.call(self, out);
}

// aten::expm1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & expm1_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_expm1_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expand_as, name, "aten::expand_as")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expand_as, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expand_as, schema_str, "expand_as(Tensor(a) self, Tensor other) -> Tensor(a)")

// aten::expand_as(Tensor(a) self, Tensor other) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<expand_as::schema> create_expand_as_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(expand_as::name, expand_as::overload_name)
      .typed<expand_as::schema>();
}

// aten::expand_as(Tensor(a) self, Tensor other) -> Tensor(a)
at::Tensor expand_as::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_expand_as_typed_handle();
    return op.call(self, other);
}

// aten::expand_as(Tensor(a) self, Tensor other) -> Tensor(a)
at::Tensor expand_as::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_expand_as_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unflatten_int, name, "aten::unflatten")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unflatten_int, overload_name, "int")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unflatten_int, schema_str, "unflatten.int(Tensor(a) self, int dim, SymInt[] sizes) -> Tensor(a)")

// aten::unflatten.int(Tensor(a) self, int dim, SymInt[] sizes) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<unflatten_int::schema> create_unflatten_int_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unflatten_int::name, unflatten_int::overload_name)
      .typed<unflatten_int::schema>();
}

// aten::unflatten.int(Tensor(a) self, int dim, SymInt[] sizes) -> Tensor(a)
at::Tensor unflatten_int::call(const at::Tensor & self, int64_t dim, c10::SymIntArrayRef sizes) {
    
    static auto op = create_unflatten_int_typed_handle();
    return op.call(self, dim, sizes);
}

// aten::unflatten.int(Tensor(a) self, int dim, SymInt[] sizes) -> Tensor(a)
at::Tensor unflatten_int::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::SymIntArrayRef sizes) {
    
    static auto op = create_unflatten_int_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, sizes);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unflatten_Dimname, name, "aten::unflatten")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unflatten_Dimname, overload_name, "Dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unflatten_Dimname, schema_str, "unflatten.Dimname(Tensor(a) self, Dimname dim, SymInt[] sizes, Dimname[] names) -> Tensor(a)")

// aten::unflatten.Dimname(Tensor(a) self, Dimname dim, SymInt[] sizes, Dimname[] names) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<unflatten_Dimname::schema> create_unflatten_Dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unflatten_Dimname::name, unflatten_Dimname::overload_name)
      .typed<unflatten_Dimname::schema>();
}

// aten::unflatten.Dimname(Tensor(a) self, Dimname dim, SymInt[] sizes, Dimname[] names) -> Tensor(a)
at::Tensor unflatten_Dimname::call(const at::Tensor & self, at::Dimname dim, c10::SymIntArrayRef sizes, at::DimnameList names) {
    
    static auto op = create_unflatten_Dimname_typed_handle();
    return op.call(self, dim, sizes, names);
}

// aten::unflatten.Dimname(Tensor(a) self, Dimname dim, SymInt[] sizes, Dimname[] names) -> Tensor(a)
at::Tensor unflatten_Dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, c10::SymIntArrayRef sizes, at::DimnameList names) {
    
    static auto op = create_unflatten_Dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, sizes, names);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Scalar, name, "aten::fill")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Scalar, schema_str, "fill.Scalar(Tensor self, Scalar value) -> Tensor")

// aten::fill.Scalar(Tensor self, Scalar value) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fill_Scalar::schema> create_fill_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fill_Scalar::name, fill_Scalar::overload_name)
      .typed<fill_Scalar::schema>();
}

// aten::fill.Scalar(Tensor self, Scalar value) -> Tensor
at::Tensor fill_Scalar::call(const at::Tensor & self, const at::Scalar & value) {
    
    static auto op = create_fill_Scalar_typed_handle();
    return op.call(self, value);
}

// aten::fill.Scalar(Tensor self, Scalar value) -> Tensor
at::Tensor fill_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & value) {
    
    static auto op = create_fill_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Tensor, name, "aten::fill")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Tensor, schema_str, "fill.Tensor(Tensor self, Tensor value) -> Tensor")

// aten::fill.Tensor(Tensor self, Tensor value) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fill_Tensor::schema> create_fill_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fill_Tensor::name, fill_Tensor::overload_name)
      .typed<fill_Tensor::schema>();
}

// aten::fill.Tensor(Tensor self, Tensor value) -> Tensor
at::Tensor fill_Tensor::call(const at::Tensor & self, const at::Tensor & value) {
    
    static auto op = create_fill_Tensor_typed_handle();
    return op.call(self, value);
}

// aten::fill.Tensor(Tensor self, Tensor value) -> Tensor
at::Tensor fill_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & value) {
    
    static auto op = create_fill_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill__Scalar, name, "aten::fill_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill__Scalar, schema_str, "fill_.Scalar(Tensor(a!) self, Scalar value) -> Tensor(a!)")

// aten::fill_.Scalar(Tensor(a!) self, Scalar value) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fill__Scalar::schema> create_fill__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fill__Scalar::name, fill__Scalar::overload_name)
      .typed<fill__Scalar::schema>();
}

// aten::fill_.Scalar(Tensor(a!) self, Scalar value) -> Tensor(a!)
at::Tensor & fill__Scalar::call(at::Tensor & self, const at::Scalar & value) {
    
    static auto op = create_fill__Scalar_typed_handle();
    return op.call(self, value);
}

// aten::fill_.Scalar(Tensor(a!) self, Scalar value) -> Tensor(a!)
at::Tensor & fill__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & value) {
    
    static auto op = create_fill__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill__Tensor, name, "aten::fill_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill__Tensor, schema_str, "fill_.Tensor(Tensor(a!) self, Tensor value) -> Tensor(a!)")

// aten::fill_.Tensor(Tensor(a!) self, Tensor value) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fill__Tensor::schema> create_fill__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fill__Tensor::name, fill__Tensor::overload_name)
      .typed<fill__Tensor::schema>();
}

// aten::fill_.Tensor(Tensor(a!) self, Tensor value) -> Tensor(a!)
at::Tensor & fill__Tensor::call(at::Tensor & self, const at::Tensor & value) {
    
    static auto op = create_fill__Tensor_typed_handle();
    return op.call(self, value);
}

// aten::fill_.Tensor(Tensor(a!) self, Tensor value) -> Tensor(a!)
at::Tensor & fill__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & value) {
    
    static auto op = create_fill__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lcm_out, name, "aten::lcm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lcm_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lcm_out, schema_str, "lcm.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::lcm.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<lcm_out::schema> create_lcm_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lcm_out::name, lcm_out::overload_name)
      .typed<lcm_out::schema>();
}

// aten::lcm.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & lcm_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_lcm_out_typed_handle();
    return op.call(self, other, out);
}

// aten::lcm.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & lcm_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_lcm_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lcm, name, "aten::lcm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lcm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lcm, schema_str, "lcm(Tensor self, Tensor other) -> Tensor")

// aten::lcm(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<lcm::schema> create_lcm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lcm::name, lcm::overload_name)
      .typed<lcm::schema>();
}

// aten::lcm(Tensor self, Tensor other) -> Tensor
at::Tensor lcm::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_lcm_typed_handle();
    return op.call(self, other);
}

// aten::lcm(Tensor self, Tensor other) -> Tensor
at::Tensor lcm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_lcm_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lcm_, name, "aten::lcm_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lcm_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lcm_, schema_str, "lcm_(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::lcm_(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<lcm_::schema> create_lcm__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lcm_::name, lcm_::overload_name)
      .typed<lcm_::schema>();
}

// aten::lcm_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & lcm_::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_lcm__typed_handle();
    return op.call(self, other);
}

// aten::lcm_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & lcm_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_lcm__typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d_backward, name, "aten::grid_sampler_2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d_backward, schema_str, "grid_sampler_2d_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask) -> (Tensor, Tensor)")

// aten::grid_sampler_2d_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<grid_sampler_2d_backward::schema> create_grid_sampler_2d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(grid_sampler_2d_backward::name, grid_sampler_2d_backward::overload_name)
      .typed<grid_sampler_2d_backward::schema>();
}

// aten::grid_sampler_2d_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> grid_sampler_2d_backward::call(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
    
    static auto op = create_grid_sampler_2d_backward_typed_handle();
    return op.call(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}

// aten::grid_sampler_2d_backward(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> grid_sampler_2d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
    
    static auto op = create_grid_sampler_2d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(group_norm, name, "aten::group_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(group_norm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(group_norm, schema_str, "group_norm(Tensor input, int num_groups, Tensor? weight=None, Tensor? bias=None, float eps=1e-05, bool cudnn_enabled=True) -> Tensor")

// aten::group_norm(Tensor input, int num_groups, Tensor? weight=None, Tensor? bias=None, float eps=1e-05, bool cudnn_enabled=True) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<group_norm::schema> create_group_norm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(group_norm::name, group_norm::overload_name)
      .typed<group_norm::schema>();
}

// aten::group_norm(Tensor input, int num_groups, Tensor? weight=None, Tensor? bias=None, float eps=1e-05, bool cudnn_enabled=True) -> Tensor
at::Tensor group_norm::call(const at::Tensor & input, int64_t num_groups, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps, bool cudnn_enabled) {
    
    static auto op = create_group_norm_typed_handle();
    return op.call(input, num_groups, weight, bias, eps, cudnn_enabled);
}

// aten::group_norm(Tensor input, int num_groups, Tensor? weight=None, Tensor? bias=None, float eps=1e-05, bool cudnn_enabled=True) -> Tensor
at::Tensor group_norm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, int64_t num_groups, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps, bool cudnn_enabled) {
    
    static auto op = create_group_norm_typed_handle();
    return op.redispatch(dispatchKeySet, input, num_groups, weight, bias, eps, cudnn_enabled);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy_out, name, "aten::index_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy_out, schema_str, "index_copy.out(Tensor self, int dim, Tensor index, Tensor source, *, Tensor(a!) out) -> Tensor(a!)")

// aten::index_copy.out(Tensor self, int dim, Tensor index, Tensor source, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<index_copy_out::schema> create_index_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_copy_out::name, index_copy_out::overload_name)
      .typed<index_copy_out::schema>();
}

// aten::index_copy.out(Tensor self, int dim, Tensor index, Tensor source, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_copy_out::call(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, at::Tensor & out) {
    
    static auto op = create_index_copy_out_typed_handle();
    return op.call(self, dim, index, source, out);
}

// aten::index_copy.out(Tensor self, int dim, Tensor index, Tensor source, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, at::Tensor & out) {
    
    static auto op = create_index_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, source, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy_, name, "aten::index_copy_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy_, schema_str, "index_copy_(Tensor(a!) self, int dim, Tensor index, Tensor source) -> Tensor(a!)")

// aten::index_copy_(Tensor(a!) self, int dim, Tensor index, Tensor source) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<index_copy_::schema> create_index_copy__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_copy_::name, index_copy_::overload_name)
      .typed<index_copy_::schema>();
}

// aten::index_copy_(Tensor(a!) self, int dim, Tensor index, Tensor source) -> Tensor(a!)
at::Tensor & index_copy_::call(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
    
    static auto op = create_index_copy__typed_handle();
    return op.call(self, dim, index, source);
}

// aten::index_copy_(Tensor(a!) self, int dim, Tensor index, Tensor source) -> Tensor(a!)
at::Tensor & index_copy_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
    
    static auto op = create_index_copy__typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, source);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy, name, "aten::index_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy, schema_str, "index_copy(Tensor self, int dim, Tensor index, Tensor source) -> Tensor")

// aten::index_copy(Tensor self, int dim, Tensor index, Tensor source) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<index_copy::schema> create_index_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_copy::name, index_copy::overload_name)
      .typed<index_copy::schema>();
}

// aten::index_copy(Tensor self, int dim, Tensor index, Tensor source) -> Tensor
at::Tensor index_copy::call(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
    
    static auto op = create_index_copy_typed_handle();
    return op.call(self, dim, index, source);
}

// aten::index_copy(Tensor self, int dim, Tensor index, Tensor source) -> Tensor
at::Tensor index_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
    
    static auto op = create_index_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, source);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy__dimname, name, "aten::index_copy_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy__dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy__dimname, schema_str, "index_copy_.dimname(Tensor(a!) self, Dimname dim, Tensor index, Tensor source) -> Tensor(a!)")

// aten::index_copy_.dimname(Tensor(a!) self, Dimname dim, Tensor index, Tensor source) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<index_copy__dimname::schema> create_index_copy__dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_copy__dimname::name, index_copy__dimname::overload_name)
      .typed<index_copy__dimname::schema>();
}

// aten::index_copy_.dimname(Tensor(a!) self, Dimname dim, Tensor index, Tensor source) -> Tensor(a!)
at::Tensor & index_copy__dimname::call(at::Tensor & self, at::Dimname dim, const at::Tensor & index, const at::Tensor & source) {
    
    static auto op = create_index_copy__dimname_typed_handle();
    return op.call(self, dim, index, source);
}

// aten::index_copy_.dimname(Tensor(a!) self, Dimname dim, Tensor index, Tensor source) -> Tensor(a!)
at::Tensor & index_copy__dimname::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, at::Dimname dim, const at::Tensor & index, const at::Tensor & source) {
    
    static auto op = create_index_copy__dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, source);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy_dimname, name, "aten::index_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy_dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_copy_dimname, schema_str, "index_copy.dimname(Tensor self, Dimname dim, Tensor index, Tensor source) -> Tensor")

// aten::index_copy.dimname(Tensor self, Dimname dim, Tensor index, Tensor source) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<index_copy_dimname::schema> create_index_copy_dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_copy_dimname::name, index_copy_dimname::overload_name)
      .typed<index_copy_dimname::schema>();
}

// aten::index_copy.dimname(Tensor self, Dimname dim, Tensor index, Tensor source) -> Tensor
at::Tensor index_copy_dimname::call(const at::Tensor & self, at::Dimname dim, const at::Tensor & index, const at::Tensor & source) {
    
    static auto op = create_index_copy_dimname_typed_handle();
    return op.call(self, dim, index, source);
}

// aten::index_copy.dimname(Tensor self, Dimname dim, Tensor index, Tensor source) -> Tensor
at::Tensor index_copy_dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, const at::Tensor & index, const at::Tensor & source) {
    
    static auto op = create_index_copy_dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, source);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unsafe_index_put, name, "aten::_unsafe_index_put")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unsafe_index_put, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unsafe_index_put, schema_str, "_unsafe_index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor")

// aten::_unsafe_index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_unsafe_index_put::schema> create__unsafe_index_put_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_unsafe_index_put::name, _unsafe_index_put::overload_name)
      .typed<_unsafe_index_put::schema>();
}

// aten::_unsafe_index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor
at::Tensor _unsafe_index_put::call(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate) {
    
    static auto op = create__unsafe_index_put_typed_handle();
    return op.call(self, indices, values, accumulate);
}

// aten::_unsafe_index_put(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False) -> Tensor
at::Tensor _unsafe_index_put::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate) {
    
    static auto op = create__unsafe_index_put_typed_handle();
    return op.redispatch(dispatchKeySet, self, indices, values, accumulate);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_index_put_impl_, name, "aten::_index_put_impl_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_index_put_impl_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_index_put_impl_, schema_str, "_index_put_impl_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False) -> Tensor(a!)")

// aten::_index_put_impl_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_index_put_impl_::schema> create__index_put_impl__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_index_put_impl_::name, _index_put_impl_::overload_name)
      .typed<_index_put_impl_::schema>();
}

// aten::_index_put_impl_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False) -> Tensor(a!)
at::Tensor & _index_put_impl_::call(at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
    
    static auto op = create__index_put_impl__typed_handle();
    return op.call(self, indices, values, accumulate, unsafe);
}

// aten::_index_put_impl_(Tensor(a!) self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False) -> Tensor(a!)
at::Tensor & _index_put_impl_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
    
    static auto op = create__index_put_impl__typed_handle();
    return op.redispatch(dispatchKeySet, self, indices, values, accumulate, unsafe);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_distributed, name, "aten::is_distributed")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_distributed, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_distributed, schema_str, "is_distributed(Tensor self) -> bool")

// aten::is_distributed(Tensor self) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<is_distributed::schema> create_is_distributed_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(is_distributed::name, is_distributed::overload_name)
      .typed<is_distributed::schema>();
}

// aten::is_distributed(Tensor self) -> bool
bool is_distributed::call(const at::Tensor & self) {
    
    static auto op = create_is_distributed_typed_handle();
    return op.call(self);
}

// aten::is_distributed(Tensor self) -> bool
bool is_distributed::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_is_distributed_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_inference, name, "aten::is_inference")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_inference, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_inference, schema_str, "is_inference(Tensor self) -> bool")

// aten::is_inference(Tensor self) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<is_inference::schema> create_is_inference_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(is_inference::name, is_inference::overload_name)
      .typed<is_inference::schema>();
}

// aten::is_inference(Tensor self) -> bool
bool is_inference::call(const at::Tensor & self) {
    
    static auto op = create_is_inference_typed_handle();
    return op.call(self);
}

// aten::is_inference(Tensor self) -> bool
bool is_inference::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_is_inference_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kron, name, "aten::kron")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kron, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kron, schema_str, "kron(Tensor self, Tensor other) -> Tensor")

// aten::kron(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<kron::schema> create_kron_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(kron::name, kron::overload_name)
      .typed<kron::schema>();
}

// aten::kron(Tensor self, Tensor other) -> Tensor
at::Tensor kron::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_kron_typed_handle();
    return op.call(self, other);
}

// aten::kron(Tensor self, Tensor other) -> Tensor
at::Tensor kron::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_kron_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kron_out, name, "aten::kron")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kron_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(kron_out, schema_str, "kron.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::kron.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<kron_out::schema> create_kron_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(kron_out::name, kron_out::overload_name)
      .typed<kron_out::schema>();
}

// aten::kron.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & kron_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_kron_out_typed_handle();
    return op.call(self, other, out);
}

// aten::kron.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & kron_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_kron_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linear, name, "aten::linear")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linear, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linear, schema_str, "linear(Tensor input, Tensor weight, Tensor? bias=None) -> Tensor")

// aten::linear(Tensor input, Tensor weight, Tensor? bias=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linear::schema> create_linear_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linear::name, linear::overload_name)
      .typed<linear::schema>();
}

// aten::linear(Tensor input, Tensor weight, Tensor? bias=None) -> Tensor
at::Tensor linear::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias) {
    
    static auto op = create_linear_typed_handle();
    return op.call(input, weight, bias);
}

// aten::linear(Tensor input, Tensor weight, Tensor? bias=None) -> Tensor
at::Tensor linear::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias) {
    
    static auto op = create_linear_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linear_out, name, "aten::linear")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linear_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linear_out, schema_str, "linear.out(Tensor input, Tensor weight, Tensor? bias=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::linear.out(Tensor input, Tensor weight, Tensor? bias=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linear_out::schema> create_linear_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linear_out::name, linear_out::overload_name)
      .typed<linear_out::schema>();
}

// aten::linear.out(Tensor input, Tensor weight, Tensor? bias=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linear_out::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::Tensor & out) {
    
    static auto op = create_linear_out_typed_handle();
    return op.call(input, weight, bias, out);
}

// aten::linear.out(Tensor input, Tensor weight, Tensor? bias=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linear_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::Tensor & out) {
    
    static auto op = create_linear_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear, name, "aten::mkldnn_linear")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear, schema_str, "mkldnn_linear(Tensor self, Tensor weight, Tensor? bias=None) -> Tensor")

// aten::mkldnn_linear(Tensor self, Tensor weight, Tensor? bias=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_linear::schema> create_mkldnn_linear_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_linear::name, mkldnn_linear::overload_name)
      .typed<mkldnn_linear::schema>();
}

// aten::mkldnn_linear(Tensor self, Tensor weight, Tensor? bias=None) -> Tensor
at::Tensor mkldnn_linear::call(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias) {
    
    static auto op = create_mkldnn_linear_typed_handle();
    return op.call(self, weight, bias);
}

// aten::mkldnn_linear(Tensor self, Tensor weight, Tensor? bias=None) -> Tensor
at::Tensor mkldnn_linear::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias) {
    
    static auto op = create_mkldnn_linear_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, bias);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear_backward_weights, name, "aten::mkldnn_linear_backward_weights")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear_backward_weights, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear_backward_weights, schema_str, "mkldnn_linear_backward_weights(Tensor grad_output, Tensor input, Tensor weight, bool bias_defined) -> (Tensor, Tensor)")

// aten::mkldnn_linear_backward_weights(Tensor grad_output, Tensor input, Tensor weight, bool bias_defined) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_linear_backward_weights::schema> create_mkldnn_linear_backward_weights_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_linear_backward_weights::name, mkldnn_linear_backward_weights::overload_name)
      .typed<mkldnn_linear_backward_weights::schema>();
}

// aten::mkldnn_linear_backward_weights(Tensor grad_output, Tensor input, Tensor weight, bool bias_defined) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> mkldnn_linear_backward_weights::call(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, bool bias_defined) {
    
    static auto op = create_mkldnn_linear_backward_weights_typed_handle();
    return op.call(grad_output, input, weight, bias_defined);
}

// aten::mkldnn_linear_backward_weights(Tensor grad_output, Tensor input, Tensor weight, bool bias_defined) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> mkldnn_linear_backward_weights::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, bool bias_defined) {
    
    static auto op = create_mkldnn_linear_backward_weights_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, input, weight, bias_defined);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cslt_sparse_mm, name, "aten::_cslt_sparse_mm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cslt_sparse_mm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cslt_sparse_mm, schema_str, "_cslt_sparse_mm(Tensor compressed_A, Tensor dense_B, Tensor? bias=None, Tensor? alpha=None, ScalarType? out_dtype=None, bool transpose_result=False, int alg_id=0) -> Tensor")

// aten::_cslt_sparse_mm(Tensor compressed_A, Tensor dense_B, Tensor? bias=None, Tensor? alpha=None, ScalarType? out_dtype=None, bool transpose_result=False, int alg_id=0) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_cslt_sparse_mm::schema> create__cslt_sparse_mm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cslt_sparse_mm::name, _cslt_sparse_mm::overload_name)
      .typed<_cslt_sparse_mm::schema>();
}

// aten::_cslt_sparse_mm(Tensor compressed_A, Tensor dense_B, Tensor? bias=None, Tensor? alpha=None, ScalarType? out_dtype=None, bool transpose_result=False, int alg_id=0) -> Tensor
at::Tensor _cslt_sparse_mm::call(const at::Tensor & compressed_A, const at::Tensor & dense_B, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & alpha, c10::optional<at::ScalarType> out_dtype, bool transpose_result, int64_t alg_id) {
    
    static auto op = create__cslt_sparse_mm_typed_handle();
    return op.call(compressed_A, dense_B, bias, alpha, out_dtype, transpose_result, alg_id);
}

// aten::_cslt_sparse_mm(Tensor compressed_A, Tensor dense_B, Tensor? bias=None, Tensor? alpha=None, ScalarType? out_dtype=None, bool transpose_result=False, int alg_id=0) -> Tensor
at::Tensor _cslt_sparse_mm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & compressed_A, const at::Tensor & dense_B, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & alpha, c10::optional<at::ScalarType> out_dtype, bool transpose_result, int64_t alg_id) {
    
    static auto op = create__cslt_sparse_mm_typed_handle();
    return op.redispatch(dispatchKeySet, compressed_A, dense_B, bias, alpha, out_dtype, transpose_result, alg_id);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_mixed_dtypes_linear, name, "aten::_mixed_dtypes_linear")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_mixed_dtypes_linear, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_mixed_dtypes_linear, schema_str, "_mixed_dtypes_linear(Tensor input, Tensor weight, Tensor scale, *, Tensor? bias=None, str? activation=None) -> Tensor")

// aten::_mixed_dtypes_linear(Tensor input, Tensor weight, Tensor scale, *, Tensor? bias=None, str? activation=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_mixed_dtypes_linear::schema> create__mixed_dtypes_linear_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_mixed_dtypes_linear::name, _mixed_dtypes_linear::overload_name)
      .typed<_mixed_dtypes_linear::schema>();
}

// aten::_mixed_dtypes_linear(Tensor input, Tensor weight, Tensor scale, *, Tensor? bias=None, str? activation=None) -> Tensor
at::Tensor _mixed_dtypes_linear::call(const at::Tensor & input, const at::Tensor & weight, const at::Tensor & scale, const c10::optional<at::Tensor> & bias, c10::optional<c10::string_view> activation) {
    
    static auto op = create__mixed_dtypes_linear_typed_handle();
    return op.call(input, weight, scale, bias, activation);
}

// aten::_mixed_dtypes_linear(Tensor input, Tensor weight, Tensor scale, *, Tensor? bias=None, str? activation=None) -> Tensor
at::Tensor _mixed_dtypes_linear::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const at::Tensor & scale, const c10::optional<at::Tensor> & bias, c10::optional<c10::string_view> activation) {
    
    static auto op = create__mixed_dtypes_linear_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, scale, bias, activation);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fbgemm_linear_quantize_weight, name, "aten::fbgemm_linear_quantize_weight")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fbgemm_linear_quantize_weight, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fbgemm_linear_quantize_weight, schema_str, "fbgemm_linear_quantize_weight(Tensor input) -> (Tensor, Tensor, float, int)")

// aten::fbgemm_linear_quantize_weight(Tensor input) -> (Tensor, Tensor, float, int)
static C10_NOINLINE c10::TypedOperatorHandle<fbgemm_linear_quantize_weight::schema> create_fbgemm_linear_quantize_weight_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fbgemm_linear_quantize_weight::name, fbgemm_linear_quantize_weight::overload_name)
      .typed<fbgemm_linear_quantize_weight::schema>();
}

// aten::fbgemm_linear_quantize_weight(Tensor input) -> (Tensor, Tensor, float, int)
::std::tuple<at::Tensor,at::Tensor,double,int64_t> fbgemm_linear_quantize_weight::call(const at::Tensor & input) {
    
    static auto op = create_fbgemm_linear_quantize_weight_typed_handle();
    return op.call(input);
}

// aten::fbgemm_linear_quantize_weight(Tensor input) -> (Tensor, Tensor, float, int)
::std::tuple<at::Tensor,at::Tensor,double,int64_t> fbgemm_linear_quantize_weight::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input) {
    
    static auto op = create_fbgemm_linear_quantize_weight_typed_handle();
    return op.redispatch(dispatchKeySet, input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace, name, "aten::linspace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace, schema_str, "linspace(Scalar start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::linspace(Scalar start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linspace::schema> create_linspace_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linspace::name, linspace::overload_name)
      .typed<linspace::schema>();
}

// aten::linspace(Scalar start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor linspace::call(const at::Scalar & start, const at::Scalar & end, int64_t steps, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_linspace_typed_handle();
    return op.call(start, end, steps, dtype, layout, device, pin_memory);
}

// aten::linspace(Scalar start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor linspace::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & start, const at::Scalar & end, int64_t steps, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_linspace_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, steps, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Tensor, name, "aten::linspace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Tensor, overload_name, "Tensor_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Tensor, schema_str, "linspace.Tensor_Tensor(Tensor start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::linspace.Tensor_Tensor(Tensor start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linspace_Tensor_Tensor::schema> create_linspace_Tensor_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linspace_Tensor_Tensor::name, linspace_Tensor_Tensor::overload_name)
      .typed<linspace_Tensor_Tensor::schema>();
}

// aten::linspace.Tensor_Tensor(Tensor start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor linspace_Tensor_Tensor::call(const at::Tensor & start, const at::Tensor & end, int64_t steps, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_linspace_Tensor_Tensor_typed_handle();
    return op.call(start, end, steps, dtype, layout, device, pin_memory);
}

// aten::linspace.Tensor_Tensor(Tensor start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor linspace_Tensor_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & start, const at::Tensor & end, int64_t steps, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_linspace_Tensor_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, steps, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Scalar, name, "aten::linspace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Scalar, overload_name, "Tensor_Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Scalar, schema_str, "linspace.Tensor_Scalar(Tensor start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::linspace.Tensor_Scalar(Tensor start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linspace_Tensor_Scalar::schema> create_linspace_Tensor_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linspace_Tensor_Scalar::name, linspace_Tensor_Scalar::overload_name)
      .typed<linspace_Tensor_Scalar::schema>();
}

// aten::linspace.Tensor_Scalar(Tensor start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor linspace_Tensor_Scalar::call(const at::Tensor & start, const at::Scalar & end, int64_t steps, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_linspace_Tensor_Scalar_typed_handle();
    return op.call(start, end, steps, dtype, layout, device, pin_memory);
}

// aten::linspace.Tensor_Scalar(Tensor start, Scalar end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor linspace_Tensor_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & start, const at::Scalar & end, int64_t steps, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_linspace_Tensor_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, steps, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Scalar_Tensor, name, "aten::linspace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Scalar_Tensor, overload_name, "Scalar_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Scalar_Tensor, schema_str, "linspace.Scalar_Tensor(Scalar start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::linspace.Scalar_Tensor(Scalar start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linspace_Scalar_Tensor::schema> create_linspace_Scalar_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linspace_Scalar_Tensor::name, linspace_Scalar_Tensor::overload_name)
      .typed<linspace_Scalar_Tensor::schema>();
}

// aten::linspace.Scalar_Tensor(Scalar start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor linspace_Scalar_Tensor::call(const at::Scalar & start, const at::Tensor & end, int64_t steps, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_linspace_Scalar_Tensor_typed_handle();
    return op.call(start, end, steps, dtype, layout, device, pin_memory);
}

// aten::linspace.Scalar_Tensor(Scalar start, Tensor end, int steps, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor linspace_Scalar_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & start, const at::Tensor & end, int64_t steps, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_linspace_Scalar_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, steps, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_out, name, "aten::linspace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_out, schema_str, "linspace.out(Scalar start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)")

// aten::linspace.out(Scalar start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linspace_out::schema> create_linspace_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linspace_out::name, linspace_out::overload_name)
      .typed<linspace_out::schema>();
}

// aten::linspace.out(Scalar start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linspace_out::call(const at::Scalar & start, const at::Scalar & end, int64_t steps, at::Tensor & out) {
    
    static auto op = create_linspace_out_typed_handle();
    return op.call(start, end, steps, out);
}

// aten::linspace.out(Scalar start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linspace_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & start, const at::Scalar & end, int64_t steps, at::Tensor & out) {
    
    static auto op = create_linspace_out_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, steps, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Tensor_out, name, "aten::linspace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Tensor_out, overload_name, "Tensor_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Tensor_out, schema_str, "linspace.Tensor_Tensor_out(Tensor start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)")

// aten::linspace.Tensor_Tensor_out(Tensor start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linspace_Tensor_Tensor_out::schema> create_linspace_Tensor_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linspace_Tensor_Tensor_out::name, linspace_Tensor_Tensor_out::overload_name)
      .typed<linspace_Tensor_Tensor_out::schema>();
}

// aten::linspace.Tensor_Tensor_out(Tensor start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linspace_Tensor_Tensor_out::call(const at::Tensor & start, const at::Tensor & end, int64_t steps, at::Tensor & out) {
    
    static auto op = create_linspace_Tensor_Tensor_out_typed_handle();
    return op.call(start, end, steps, out);
}

// aten::linspace.Tensor_Tensor_out(Tensor start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linspace_Tensor_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & start, const at::Tensor & end, int64_t steps, at::Tensor & out) {
    
    static auto op = create_linspace_Tensor_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, steps, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Scalar_out, name, "aten::linspace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Scalar_out, overload_name, "Tensor_Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Tensor_Scalar_out, schema_str, "linspace.Tensor_Scalar_out(Tensor start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)")

// aten::linspace.Tensor_Scalar_out(Tensor start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linspace_Tensor_Scalar_out::schema> create_linspace_Tensor_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linspace_Tensor_Scalar_out::name, linspace_Tensor_Scalar_out::overload_name)
      .typed<linspace_Tensor_Scalar_out::schema>();
}

// aten::linspace.Tensor_Scalar_out(Tensor start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linspace_Tensor_Scalar_out::call(const at::Tensor & start, const at::Scalar & end, int64_t steps, at::Tensor & out) {
    
    static auto op = create_linspace_Tensor_Scalar_out_typed_handle();
    return op.call(start, end, steps, out);
}

// aten::linspace.Tensor_Scalar_out(Tensor start, Scalar end, int steps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linspace_Tensor_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & start, const at::Scalar & end, int64_t steps, at::Tensor & out) {
    
    static auto op = create_linspace_Tensor_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, steps, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Scalar_Tensor_out, name, "aten::linspace")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Scalar_Tensor_out, overload_name, "Scalar_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linspace_Scalar_Tensor_out, schema_str, "linspace.Scalar_Tensor_out(Scalar start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)")

// aten::linspace.Scalar_Tensor_out(Scalar start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linspace_Scalar_Tensor_out::schema> create_linspace_Scalar_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linspace_Scalar_Tensor_out::name, linspace_Scalar_Tensor_out::overload_name)
      .typed<linspace_Scalar_Tensor_out::schema>();
}

// aten::linspace.Scalar_Tensor_out(Scalar start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linspace_Scalar_Tensor_out::call(const at::Scalar & start, const at::Tensor & end, int64_t steps, at::Tensor & out) {
    
    static auto op = create_linspace_Scalar_Tensor_out_typed_handle();
    return op.call(start, end, steps, out);
}

// aten::linspace.Scalar_Tensor_out(Scalar start, Tensor end, int steps, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linspace_Scalar_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & start, const at::Tensor & end, int64_t steps, at::Tensor & out) {
    
    static auto op = create_linspace_Scalar_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, steps, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log10, name, "aten::log10")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log10, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log10, schema_str, "log10(Tensor self) -> Tensor")

// aten::log10(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<log10::schema> create_log10_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(log10::name, log10::overload_name)
      .typed<log10::schema>();
}

// aten::log10(Tensor self) -> Tensor
at::Tensor log10::call(const at::Tensor & self) {
    
    static auto op = create_log10_typed_handle();
    return op.call(self);
}

// aten::log10(Tensor self) -> Tensor
at::Tensor log10::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_log10_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log10_, name, "aten::log10_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log10_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log10_, schema_str, "log10_(Tensor(a!) self) -> Tensor(a!)")

// aten::log10_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<log10_::schema> create_log10__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(log10_::name, log10_::overload_name)
      .typed<log10_::schema>();
}

// aten::log10_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & log10_::call(at::Tensor & self) {
    
    static auto op = create_log10__typed_handle();
    return op.call(self);
}

// aten::log10_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & log10_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_log10__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log10_out, name, "aten::log10")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log10_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log10_out, schema_str, "log10.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::log10.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<log10_out::schema> create_log10_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(log10_out::name, log10_out::overload_name)
      .typed<log10_out::schema>();
}

// aten::log10.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & log10_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_log10_out_typed_handle();
    return op.call(self, out);
}

// aten::log10.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & log10_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_log10_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log1p, name, "aten::log1p")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log1p, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log1p, schema_str, "log1p(Tensor self) -> Tensor")

// aten::log1p(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<log1p::schema> create_log1p_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(log1p::name, log1p::overload_name)
      .typed<log1p::schema>();
}

// aten::log1p(Tensor self) -> Tensor
at::Tensor log1p::call(const at::Tensor & self) {
    
    static auto op = create_log1p_typed_handle();
    return op.call(self);
}

// aten::log1p(Tensor self) -> Tensor
at::Tensor log1p::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_log1p_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log1p_, name, "aten::log1p_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log1p_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log1p_, schema_str, "log1p_(Tensor(a!) self) -> Tensor(a!)")

// aten::log1p_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<log1p_::schema> create_log1p__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(log1p_::name, log1p_::overload_name)
      .typed<log1p_::schema>();
}

// aten::log1p_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & log1p_::call(at::Tensor & self) {
    
    static auto op = create_log1p__typed_handle();
    return op.call(self);
}

// aten::log1p_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & log1p_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_log1p__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log1p_out, name, "aten::log1p")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log1p_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(log1p_out, schema_str, "log1p.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::log1p.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<log1p_out::schema> create_log1p_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(log1p_out::name, log1p_out::overload_name)
      .typed<log1p_out::schema>();
}

// aten::log1p.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & log1p_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_log1p_out_typed_handle();
    return op.call(self, out);
}

// aten::log1p.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & log1p_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_log1p_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logaddexp2_out, name, "aten::logaddexp2")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logaddexp2_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logaddexp2_out, schema_str, "logaddexp2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::logaddexp2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<logaddexp2_out::schema> create_logaddexp2_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logaddexp2_out::name, logaddexp2_out::overload_name)
      .typed<logaddexp2_out::schema>();
}

// aten::logaddexp2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logaddexp2_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_logaddexp2_out_typed_handle();
    return op.call(self, other, out);
}

// aten::logaddexp2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logaddexp2_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_logaddexp2_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logaddexp2, name, "aten::logaddexp2")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logaddexp2, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logaddexp2, schema_str, "logaddexp2(Tensor self, Tensor other) -> Tensor")

// aten::logaddexp2(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<logaddexp2::schema> create_logaddexp2_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logaddexp2::name, logaddexp2::overload_name)
      .typed<logaddexp2::schema>();
}

// aten::logaddexp2(Tensor self, Tensor other) -> Tensor
at::Tensor logaddexp2::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logaddexp2_typed_handle();
    return op.call(self, other);
}

// aten::logaddexp2(Tensor self, Tensor other) -> Tensor
at::Tensor logaddexp2::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_logaddexp2_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_log_softmax, name, "aten::_log_softmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_log_softmax, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_log_softmax, schema_str, "_log_softmax(Tensor self, int dim, bool half_to_float) -> Tensor")

// aten::_log_softmax(Tensor self, int dim, bool half_to_float) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_log_softmax::schema> create__log_softmax_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_log_softmax::name, _log_softmax::overload_name)
      .typed<_log_softmax::schema>();
}

// aten::_log_softmax(Tensor self, int dim, bool half_to_float) -> Tensor
at::Tensor _log_softmax::call(const at::Tensor & self, int64_t dim, bool half_to_float) {
    
    static auto op = create__log_softmax_typed_handle();
    return op.call(self, dim, half_to_float);
}

// aten::_log_softmax(Tensor self, int dim, bool half_to_float) -> Tensor
at::Tensor _log_softmax::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool half_to_float) {
    
    static auto op = create__log_softmax_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, half_to_float);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_log_softmax_out, name, "aten::_log_softmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_log_softmax_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_log_softmax_out, schema_str, "_log_softmax.out(Tensor self, int dim, bool half_to_float, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_log_softmax.out(Tensor self, int dim, bool half_to_float, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_log_softmax_out::schema> create__log_softmax_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_log_softmax_out::name, _log_softmax_out::overload_name)
      .typed<_log_softmax_out::schema>();
}

// aten::_log_softmax.out(Tensor self, int dim, bool half_to_float, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _log_softmax_out::call(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
    
    static auto op = create__log_softmax_out_typed_handle();
    return op.call(self, dim, half_to_float, out);
}

// aten::_log_softmax.out(Tensor self, int dim, bool half_to_float, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _log_softmax_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
    
    static auto op = create__log_softmax_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, half_to_float, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp, name, "aten::logsumexp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp, schema_str, "logsumexp(Tensor self, int[1] dim, bool keepdim=False) -> Tensor")

// aten::logsumexp(Tensor self, int[1] dim, bool keepdim=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<logsumexp::schema> create_logsumexp_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logsumexp::name, logsumexp::overload_name)
      .typed<logsumexp::schema>();
}

// aten::logsumexp(Tensor self, int[1] dim, bool keepdim=False) -> Tensor
at::Tensor logsumexp::call(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
    
    static auto op = create_logsumexp_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::logsumexp(Tensor self, int[1] dim, bool keepdim=False) -> Tensor
at::Tensor logsumexp::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
    
    static auto op = create_logsumexp_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp_out, name, "aten::logsumexp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp_out, schema_str, "logsumexp.out(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::logsumexp.out(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<logsumexp_out::schema> create_logsumexp_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logsumexp_out::name, logsumexp_out::overload_name)
      .typed<logsumexp_out::schema>();
}

// aten::logsumexp.out(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logsumexp_out::call(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_logsumexp_out_typed_handle();
    return op.call(self, dim, keepdim, out);
}

// aten::logsumexp.out(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logsumexp_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_logsumexp_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp_names, name, "aten::logsumexp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp_names, overload_name, "names")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp_names, schema_str, "logsumexp.names(Tensor self, Dimname[1] dim, bool keepdim=False) -> Tensor")

// aten::logsumexp.names(Tensor self, Dimname[1] dim, bool keepdim=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<logsumexp_names::schema> create_logsumexp_names_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logsumexp_names::name, logsumexp_names::overload_name)
      .typed<logsumexp_names::schema>();
}

// aten::logsumexp.names(Tensor self, Dimname[1] dim, bool keepdim=False) -> Tensor
at::Tensor logsumexp_names::call(const at::Tensor & self, at::DimnameList dim, bool keepdim) {
    
    static auto op = create_logsumexp_names_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::logsumexp.names(Tensor self, Dimname[1] dim, bool keepdim=False) -> Tensor
at::Tensor logsumexp_names::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::DimnameList dim, bool keepdim) {
    
    static auto op = create_logsumexp_names_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp_names_out, name, "aten::logsumexp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp_names_out, overload_name, "names_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(logsumexp_names_out, schema_str, "logsumexp.names_out(Tensor self, Dimname[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::logsumexp.names_out(Tensor self, Dimname[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<logsumexp_names_out::schema> create_logsumexp_names_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(logsumexp_names_out::name, logsumexp_names_out::overload_name)
      .typed<logsumexp_names_out::schema>();
}

// aten::logsumexp.names_out(Tensor self, Dimname[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logsumexp_names_out::call(const at::Tensor & self, at::DimnameList dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_logsumexp_names_out_typed_handle();
    return op.call(self, dim, keepdim, out);
}

// aten::logsumexp.names_out(Tensor self, Dimname[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & logsumexp_names_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::DimnameList dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_logsumexp_names_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax, name, "aten::_aminmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax, schema_str, "_aminmax(Tensor self) -> (Tensor, Tensor)")

// aten::_aminmax(Tensor self) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_aminmax::schema> create__aminmax_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_aminmax::name, _aminmax::overload_name)
      .typed<_aminmax::schema>();
}

// aten::_aminmax(Tensor self) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _aminmax::call(const at::Tensor & self) {
    
    static auto op = create__aminmax_typed_handle();
    return op.call(self);
}

// aten::_aminmax(Tensor self) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _aminmax::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__aminmax_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax_dim, name, "aten::_aminmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax_dim, overload_name, "dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax_dim, schema_str, "_aminmax.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor, Tensor)")

// aten::_aminmax.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_aminmax_dim::schema> create__aminmax_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_aminmax_dim::name, _aminmax_dim::overload_name)
      .typed<_aminmax_dim::schema>();
}

// aten::_aminmax.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _aminmax_dim::call(const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create__aminmax_dim_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::_aminmax.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _aminmax_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create__aminmax_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(aminmax, name, "aten::aminmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(aminmax, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(aminmax, schema_str, "aminmax(Tensor self, *, int? dim=None, bool keepdim=False) -> (Tensor min, Tensor max)")

// aten::aminmax(Tensor self, *, int? dim=None, bool keepdim=False) -> (Tensor min, Tensor max)
static C10_NOINLINE c10::TypedOperatorHandle<aminmax::schema> create_aminmax_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(aminmax::name, aminmax::overload_name)
      .typed<aminmax::schema>();
}

// aten::aminmax(Tensor self, *, int? dim=None, bool keepdim=False) -> (Tensor min, Tensor max)
::std::tuple<at::Tensor,at::Tensor> aminmax::call(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
    
    static auto op = create_aminmax_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::aminmax(Tensor self, *, int? dim=None, bool keepdim=False) -> (Tensor min, Tensor max)
::std::tuple<at::Tensor,at::Tensor> aminmax::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
    
    static auto op = create_aminmax_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(aminmax_out, name, "aten::aminmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(aminmax_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(aminmax_out, schema_str, "aminmax.out(Tensor self, *, int? dim=None, bool keepdim=False, Tensor(a!) min, Tensor(b!) max) -> (Tensor(a!) min, Tensor(b!) max)")

// aten::aminmax.out(Tensor self, *, int? dim=None, bool keepdim=False, Tensor(a!) min, Tensor(b!) max) -> (Tensor(a!) min, Tensor(b!) max)
static C10_NOINLINE c10::TypedOperatorHandle<aminmax_out::schema> create_aminmax_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(aminmax_out::name, aminmax_out::overload_name)
      .typed<aminmax_out::schema>();
}

// aten::aminmax.out(Tensor self, *, int? dim=None, bool keepdim=False, Tensor(a!) min, Tensor(b!) max) -> (Tensor(a!) min, Tensor(b!) max)
::std::tuple<at::Tensor &,at::Tensor &> aminmax_out::call(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & min, at::Tensor & max) {
    
    static auto op = create_aminmax_out_typed_handle();
    return op.call(self, dim, keepdim, min, max);
}

// aten::aminmax.out(Tensor self, *, int? dim=None, bool keepdim=False, Tensor(a!) min, Tensor(b!) max) -> (Tensor(a!) min, Tensor(b!) max)
::std::tuple<at::Tensor &,at::Tensor &> aminmax_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & min, at::Tensor & max) {
    
    static auto op = create_aminmax_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, min, max);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_dim, name, "aten::max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_dim, overload_name, "dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_dim, schema_str, "max.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)")

// aten::max.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)
static C10_NOINLINE c10::TypedOperatorHandle<max_dim::schema> create_max_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_dim::name, max_dim::overload_name)
      .typed<max_dim::schema>();
}

// aten::max.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> max_dim::call(const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_max_dim_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::max.dim(Tensor self, int dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> max_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_max_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_dim_max, name, "aten::max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_dim_max, overload_name, "dim_max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_dim_max, schema_str, "max.dim_max(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)")

// aten::max.dim_max(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)
static C10_NOINLINE c10::TypedOperatorHandle<max_dim_max::schema> create_max_dim_max_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_dim_max::name, max_dim_max::overload_name)
      .typed<max_dim_max::schema>();
}

// aten::max.dim_max(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> max_dim_max::call(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
    
    static auto op = create_max_dim_max_typed_handle();
    return op.call(self, dim, keepdim, max, max_values);
}

// aten::max.dim_max(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> max_dim_max::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
    
    static auto op = create_max_dim_max_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, max, max_values);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_names_dim, name, "aten::max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_names_dim, overload_name, "names_dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_names_dim, schema_str, "max.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)")

// aten::max.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
static C10_NOINLINE c10::TypedOperatorHandle<max_names_dim::schema> create_max_names_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_names_dim::name, max_names_dim::overload_name)
      .typed<max_names_dim::schema>();
}

// aten::max.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> max_names_dim::call(const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_max_names_dim_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::max.names_dim(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> max_names_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_max_names_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_names_dim_max, name, "aten::max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_names_dim_max, overload_name, "names_dim_max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_names_dim_max, schema_str, "max.names_dim_max(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)")

// aten::max.names_dim_max(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)
static C10_NOINLINE c10::TypedOperatorHandle<max_names_dim_max::schema> create_max_names_dim_max_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_names_dim_max::name, max_names_dim_max::overload_name)
      .typed<max_names_dim_max::schema>();
}

// aten::max.names_dim_max(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> max_names_dim_max::call(const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
    
    static auto op = create_max_names_dim_max_typed_handle();
    return op.call(self, dim, keepdim, max, max_values);
}

// aten::max.names_dim_max(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) max, Tensor(b!) max_values) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> max_names_dim_max::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
    
    static auto op = create_max_names_dim_max_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, max, max_values);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool1d_with_indices, name, "aten::max_pool1d_with_indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool1d_with_indices, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool1d_with_indices, schema_str, "max_pool1d_with_indices(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)")

// aten::max_pool1d_with_indices(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<max_pool1d_with_indices::schema> create_max_pool1d_with_indices_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool1d_with_indices::name, max_pool1d_with_indices::overload_name)
      .typed<max_pool1d_with_indices::schema>();
}

// aten::max_pool1d_with_indices(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> max_pool1d_with_indices::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool1d_with_indices_typed_handle();
    return op.call(self, kernel_size, stride, padding, dilation, ceil_mode);
}

// aten::max_pool1d_with_indices(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> max_pool1d_with_indices::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool1d_with_indices_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, dilation, ceil_mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool3d_backward, name, "aten::mkldnn_max_pool3d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool3d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool3d_backward, schema_str, "mkldnn_max_pool3d_backward(Tensor grad_output, Tensor output, Tensor input, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> Tensor")

// aten::mkldnn_max_pool3d_backward(Tensor grad_output, Tensor output, Tensor input, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_max_pool3d_backward::schema> create_mkldnn_max_pool3d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_max_pool3d_backward::name, mkldnn_max_pool3d_backward::overload_name)
      .typed<mkldnn_max_pool3d_backward::schema>();
}

// aten::mkldnn_max_pool3d_backward(Tensor grad_output, Tensor output, Tensor input, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor mkldnn_max_pool3d_backward::call(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_mkldnn_max_pool3d_backward_typed_handle();
    return op.call(grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode);
}

// aten::mkldnn_max_pool3d_backward(Tensor grad_output, Tensor output, Tensor input, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor mkldnn_max_pool3d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_mkldnn_max_pool3d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_max_pool1d, name, "aten::quantized_max_pool1d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_max_pool1d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_max_pool1d, schema_str, "quantized_max_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -> Tensor")

// aten::quantized_max_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<quantized_max_pool1d::schema> create_quantized_max_pool1d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(quantized_max_pool1d::name, quantized_max_pool1d::overload_name)
      .typed<quantized_max_pool1d::schema>();
}

// aten::quantized_max_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor quantized_max_pool1d::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_quantized_max_pool1d_typed_handle();
    return op.call(self, kernel_size, stride, padding, dilation, ceil_mode);
}

// aten::quantized_max_pool1d(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False) -> Tensor
at::Tensor quantized_max_pool1d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_quantized_max_pool1d_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, dilation, ceil_mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_convolution, name, "aten::mkldnn_convolution")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_convolution, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_convolution, schema_str, "mkldnn_convolution(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] stride, SymInt[] dilation, SymInt groups) -> Tensor")

// aten::mkldnn_convolution(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] stride, SymInt[] dilation, SymInt groups) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_convolution::schema> create_mkldnn_convolution_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_convolution::name, mkldnn_convolution::overload_name)
      .typed<mkldnn_convolution::schema>();
}

// aten::mkldnn_convolution(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] stride, SymInt[] dilation, SymInt groups) -> Tensor
at::Tensor mkldnn_convolution::call(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_mkldnn_convolution_typed_handle();
    return op.call(self, weight, bias, padding, stride, dilation, groups);
}

// aten::mkldnn_convolution(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] stride, SymInt[] dilation, SymInt groups) -> Tensor
at::Tensor mkldnn_convolution::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_mkldnn_convolution_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, bias, padding, stride, dilation, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm_backward, name, "aten::miopen_batch_norm_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm_backward, schema_str, "miopen_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon) -> (Tensor, Tensor, Tensor)")

// aten::miopen_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon) -> (Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<miopen_batch_norm_backward::schema> create_miopen_batch_norm_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_batch_norm_backward::name, miopen_batch_norm_backward::overload_name)
      .typed<miopen_batch_norm_backward::schema>();
}

// aten::miopen_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> miopen_batch_norm_backward::call(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon) {
    
    static auto op = create_miopen_batch_norm_backward_typed_handle();
    return op.call(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon);
}

// aten::miopen_batch_norm_backward(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> miopen_batch_norm_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon) {
    
    static auto op = create_miopen_batch_norm_backward_typed_handle();
    return op.redispatch(dispatchKeySet, input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_relu, name, "aten::miopen_convolution_relu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_relu, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_convolution_relu, schema_str, "miopen_convolution_relu(Tensor self, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, SymInt groups) -> Tensor")

// aten::miopen_convolution_relu(Tensor self, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, SymInt groups) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<miopen_convolution_relu::schema> create_miopen_convolution_relu_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_convolution_relu::name, miopen_convolution_relu::overload_name)
      .typed<miopen_convolution_relu::schema>();
}

// aten::miopen_convolution_relu(Tensor self, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, SymInt groups) -> Tensor
at::Tensor miopen_convolution_relu::call(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_miopen_convolution_relu_typed_handle();
    return op.call(self, weight, bias, stride, padding, dilation, groups);
}

// aten::miopen_convolution_relu(Tensor self, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, SymInt groups) -> Tensor
at::Tensor miopen_convolution_relu::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
    
    static auto op = create_miopen_convolution_relu_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, bias, stride, padding, dilation, groups);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode, name, "aten::mode")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode, schema_str, "mode(Tensor self, int dim=-1, bool keepdim=False) -> (Tensor values, Tensor indices)")

// aten::mode(Tensor self, int dim=-1, bool keepdim=False) -> (Tensor values, Tensor indices)
static C10_NOINLINE c10::TypedOperatorHandle<mode::schema> create_mode_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mode::name, mode::overload_name)
      .typed<mode::schema>();
}

// aten::mode(Tensor self, int dim=-1, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> mode::call(const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_mode_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::mode(Tensor self, int dim=-1, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> mode::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim) {
    
    static auto op = create_mode_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode_values, name, "aten::mode")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode_values, overload_name, "values")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode_values, schema_str, "mode.values(Tensor self, int dim=-1, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)")

// aten::mode.values(Tensor self, int dim=-1, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
static C10_NOINLINE c10::TypedOperatorHandle<mode_values::schema> create_mode_values_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mode_values::name, mode_values::overload_name)
      .typed<mode_values::schema>();
}

// aten::mode.values(Tensor self, int dim=-1, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> mode_values::call(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_mode_values_typed_handle();
    return op.call(self, dim, keepdim, values, indices);
}

// aten::mode.values(Tensor self, int dim=-1, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> mode_values::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_mode_values_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, values, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode_dimname, name, "aten::mode")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode_dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode_dimname, schema_str, "mode.dimname(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)")

// aten::mode.dimname(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
static C10_NOINLINE c10::TypedOperatorHandle<mode_dimname::schema> create_mode_dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mode_dimname::name, mode_dimname::overload_name)
      .typed<mode_dimname::schema>();
}

// aten::mode.dimname(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> mode_dimname::call(const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_mode_dimname_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::mode.dimname(Tensor self, Dimname dim, bool keepdim=False) -> (Tensor values, Tensor indices)
::std::tuple<at::Tensor,at::Tensor> mode_dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim) {
    
    static auto op = create_mode_dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode_dimname_out, name, "aten::mode")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode_dimname_out, overload_name, "dimname_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mode_dimname_out, schema_str, "mode.dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)")

// aten::mode.dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
static C10_NOINLINE c10::TypedOperatorHandle<mode_dimname_out::schema> create_mode_dimname_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mode_dimname_out::name, mode_dimname_out::overload_name)
      .typed<mode_dimname_out::schema>();
}

// aten::mode.dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> mode_dimname_out::call(const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_mode_dimname_out_typed_handle();
    return op.call(self, dim, keepdim, values, indices);
}

// aten::mode.dimname_out(Tensor self, Dimname dim, bool keepdim=False, *, Tensor(a!) values, Tensor(b!) indices) -> (Tensor(a!) values, Tensor(b!) indices)
::std::tuple<at::Tensor &,at::Tensor &> mode_dimname_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    
    static auto op = create_mode_dimname_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, values, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_Tensor, name, "aten::mul")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_Tensor, schema_str, "mul.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::mul.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mul_Tensor::schema> create_mul_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mul_Tensor::name, mul_Tensor::overload_name)
      .typed<mul_Tensor::schema>();
}

// aten::mul.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor mul_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_mul_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::mul.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor mul_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_mul_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul__Tensor, name, "aten::mul_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul__Tensor, schema_str, "mul_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::mul_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mul__Tensor::schema> create_mul__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mul__Tensor::name, mul__Tensor::overload_name)
      .typed<mul__Tensor::schema>();
}

// aten::mul_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & mul__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_mul__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::mul_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & mul__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_mul__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_out, name, "aten::mul")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_out, schema_str, "mul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mul_out::schema> create_mul_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mul_out::name, mul_out::overload_name)
      .typed<mul_out::schema>();
}

// aten::mul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mul_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_mul_out_typed_handle();
    return op.call(self, other, out);
}

// aten::mul.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mul_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_mul_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_Scalar, name, "aten::mul")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_Scalar, schema_str, "mul.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::mul.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mul_Scalar::schema> create_mul_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mul_Scalar::name, mul_Scalar::overload_name)
      .typed<mul_Scalar::schema>();
}

// aten::mul.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor mul_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_mul_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::mul.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor mul_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_mul_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul__Scalar, name, "aten::mul_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul__Scalar, schema_str, "mul_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::mul_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mul__Scalar::schema> create_mul__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mul__Scalar::name, mul__Scalar::overload_name)
      .typed<mul__Scalar::schema>();
}

// aten::mul_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & mul__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_mul__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::mul_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & mul__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_mul__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mvlgamma_out, name, "aten::mvlgamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mvlgamma_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mvlgamma_out, schema_str, "mvlgamma.out(Tensor self, int p, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mvlgamma.out(Tensor self, int p, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mvlgamma_out::schema> create_mvlgamma_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mvlgamma_out::name, mvlgamma_out::overload_name)
      .typed<mvlgamma_out::schema>();
}

// aten::mvlgamma.out(Tensor self, int p, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mvlgamma_out::call(const at::Tensor & self, int64_t p, at::Tensor & out) {
    
    static auto op = create_mvlgamma_out_typed_handle();
    return op.call(self, p, out);
}

// aten::mvlgamma.out(Tensor self, int p, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mvlgamma_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t p, at::Tensor & out) {
    
    static auto op = create_mvlgamma_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, p, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mvlgamma, name, "aten::mvlgamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mvlgamma, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mvlgamma, schema_str, "mvlgamma(Tensor self, int p) -> Tensor")

// aten::mvlgamma(Tensor self, int p) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mvlgamma::schema> create_mvlgamma_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mvlgamma::name, mvlgamma::overload_name)
      .typed<mvlgamma::schema>();
}

// aten::mvlgamma(Tensor self, int p) -> Tensor
at::Tensor mvlgamma::call(const at::Tensor & self, int64_t p) {
    
    static auto op = create_mvlgamma_typed_handle();
    return op.call(self, p);
}

// aten::mvlgamma(Tensor self, int p) -> Tensor
at::Tensor mvlgamma::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t p) {
    
    static auto op = create_mvlgamma_typed_handle();
    return op.redispatch(dispatchKeySet, self, p);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mvlgamma_, name, "aten::mvlgamma_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mvlgamma_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mvlgamma_, schema_str, "mvlgamma_(Tensor(a!) self, int p) -> Tensor(a!)")

// aten::mvlgamma_(Tensor(a!) self, int p) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mvlgamma_::schema> create_mvlgamma__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mvlgamma_::name, mvlgamma_::overload_name)
      .typed<mvlgamma_::schema>();
}

// aten::mvlgamma_(Tensor(a!) self, int p) -> Tensor(a!)
at::Tensor & mvlgamma_::call(at::Tensor & self, int64_t p) {
    
    static auto op = create_mvlgamma__typed_handle();
    return op.call(self, p);
}

// aten::mvlgamma_(Tensor(a!) self, int p) -> Tensor(a!)
at::Tensor & mvlgamma_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, int64_t p) {
    
    static auto op = create_mvlgamma__typed_handle();
    return op.redispatch(dispatchKeySet, self, p);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(narrow, name, "aten::narrow")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(narrow, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(narrow, schema_str, "narrow(Tensor(a) self, int dim, SymInt start, SymInt length) -> Tensor(a)")

// aten::narrow(Tensor(a) self, int dim, SymInt start, SymInt length) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<narrow::schema> create_narrow_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(narrow::name, narrow::overload_name)
      .typed<narrow::schema>();
}

// aten::narrow(Tensor(a) self, int dim, SymInt start, SymInt length) -> Tensor(a)
at::Tensor narrow::call(const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length) {
    
    static auto op = create_narrow_typed_handle();
    return op.call(self, dim, start, length);
}

// aten::narrow(Tensor(a) self, int dim, SymInt start, SymInt length) -> Tensor(a)
at::Tensor narrow::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length) {
    
    static auto op = create_narrow_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, start, length);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(narrow_Tensor, name, "aten::narrow")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(narrow_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(narrow_Tensor, schema_str, "narrow.Tensor(Tensor(a) self, int dim, Tensor start, SymInt length) -> Tensor(a)")

// aten::narrow.Tensor(Tensor(a) self, int dim, Tensor start, SymInt length) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<narrow_Tensor::schema> create_narrow_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(narrow_Tensor::name, narrow_Tensor::overload_name)
      .typed<narrow_Tensor::schema>();
}

// aten::narrow.Tensor(Tensor(a) self, int dim, Tensor start, SymInt length) -> Tensor(a)
at::Tensor narrow_Tensor::call(const at::Tensor & self, int64_t dim, const at::Tensor & start, c10::SymInt length) {
    
    static auto op = create_narrow_Tensor_typed_handle();
    return op.call(self, dim, start, length);
}

// aten::narrow.Tensor(Tensor(a) self, int dim, Tensor start, SymInt length) -> Tensor(a)
at::Tensor narrow_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, const at::Tensor & start, c10::SymInt length) {
    
    static auto op = create_narrow_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, start, length);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_backward_elemt, name, "aten::batch_norm_backward_elemt")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_backward_elemt, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_backward_elemt, schema_str, "batch_norm_backward_elemt(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, Tensor? weight, Tensor sum_dy, Tensor sum_dy_xmu, Tensor count) -> Tensor")

// aten::batch_norm_backward_elemt(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, Tensor? weight, Tensor sum_dy, Tensor sum_dy_xmu, Tensor count) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<batch_norm_backward_elemt::schema> create_batch_norm_backward_elemt_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(batch_norm_backward_elemt::name, batch_norm_backward_elemt::overload_name)
      .typed<batch_norm_backward_elemt::schema>();
}

// aten::batch_norm_backward_elemt(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, Tensor? weight, Tensor sum_dy, Tensor sum_dy_xmu, Tensor count) -> Tensor
at::Tensor batch_norm_backward_elemt::call(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, const at::Tensor & sum_dy, const at::Tensor & sum_dy_xmu, const at::Tensor & count) {
    
    static auto op = create_batch_norm_backward_elemt_typed_handle();
    return op.call(grad_out, input, mean, invstd, weight, sum_dy, sum_dy_xmu, count);
}

// aten::batch_norm_backward_elemt(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, Tensor? weight, Tensor sum_dy, Tensor sum_dy_xmu, Tensor count) -> Tensor
at::Tensor batch_norm_backward_elemt::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, const at::Tensor & sum_dy, const at::Tensor & sum_dy_xmu, const at::Tensor & count) {
    
    static auto op = create_batch_norm_backward_elemt_typed_handle();
    return op.redispatch(dispatchKeySet, grad_out, input, mean, invstd, weight, sum_dy, sum_dy_xmu, count);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pdist, name, "aten::pdist")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pdist, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pdist, schema_str, "pdist(Tensor self, float p=2) -> Tensor")

// aten::pdist(Tensor self, float p=2) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<pdist::schema> create_pdist_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pdist::name, pdist::overload_name)
      .typed<pdist::schema>();
}

// aten::pdist(Tensor self, float p=2) -> Tensor
at::Tensor pdist::call(const at::Tensor & self, double p) {
    
    static auto op = create_pdist_typed_handle();
    return op.call(self, p);
}

// aten::pdist(Tensor self, float p=2) -> Tensor
at::Tensor pdist::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double p) {
    
    static auto op = create_pdist_typed_handle();
    return op.redispatch(dispatchKeySet, self, p);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(moveaxis_intlist, name, "aten::moveaxis")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(moveaxis_intlist, overload_name, "intlist")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(moveaxis_intlist, schema_str, "moveaxis.intlist(Tensor(a) self, int[] source, int[] destination) -> Tensor(a)")

// aten::moveaxis.intlist(Tensor(a) self, int[] source, int[] destination) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<moveaxis_intlist::schema> create_moveaxis_intlist_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(moveaxis_intlist::name, moveaxis_intlist::overload_name)
      .typed<moveaxis_intlist::schema>();
}

// aten::moveaxis.intlist(Tensor(a) self, int[] source, int[] destination) -> Tensor(a)
at::Tensor moveaxis_intlist::call(const at::Tensor & self, at::IntArrayRef source, at::IntArrayRef destination) {
    
    static auto op = create_moveaxis_intlist_typed_handle();
    return op.call(self, source, destination);
}

// aten::moveaxis.intlist(Tensor(a) self, int[] source, int[] destination) -> Tensor(a)
at::Tensor moveaxis_intlist::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef source, at::IntArrayRef destination) {
    
    static auto op = create_moveaxis_intlist_typed_handle();
    return op.redispatch(dispatchKeySet, self, source, destination);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(moveaxis_int, name, "aten::moveaxis")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(moveaxis_int, overload_name, "int")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(moveaxis_int, schema_str, "moveaxis.int(Tensor(a) self, int source, int destination) -> Tensor(a)")

// aten::moveaxis.int(Tensor(a) self, int source, int destination) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<moveaxis_int::schema> create_moveaxis_int_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(moveaxis_int::name, moveaxis_int::overload_name)
      .typed<moveaxis_int::schema>();
}

// aten::moveaxis.int(Tensor(a) self, int source, int destination) -> Tensor(a)
at::Tensor moveaxis_int::call(const at::Tensor & self, int64_t source, int64_t destination) {
    
    static auto op = create_moveaxis_int_typed_handle();
    return op.call(self, source, destination);
}

// aten::moveaxis.int(Tensor(a) self, int source, int destination) -> Tensor(a)
at::Tensor moveaxis_int::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t source, int64_t destination) {
    
    static auto op = create_moveaxis_int_typed_handle();
    return op.redispatch(dispatchKeySet, self, source, destination);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pixel_unshuffle, name, "aten::pixel_unshuffle")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pixel_unshuffle, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pixel_unshuffle, schema_str, "pixel_unshuffle(Tensor self, int downscale_factor) -> Tensor")

// aten::pixel_unshuffle(Tensor self, int downscale_factor) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<pixel_unshuffle::schema> create_pixel_unshuffle_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pixel_unshuffle::name, pixel_unshuffle::overload_name)
      .typed<pixel_unshuffle::schema>();
}

// aten::pixel_unshuffle(Tensor self, int downscale_factor) -> Tensor
at::Tensor pixel_unshuffle::call(const at::Tensor & self, int64_t downscale_factor) {
    
    static auto op = create_pixel_unshuffle_typed_handle();
    return op.call(self, downscale_factor);
}

// aten::pixel_unshuffle(Tensor self, int downscale_factor) -> Tensor
at::Tensor pixel_unshuffle::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t downscale_factor) {
    
    static auto op = create_pixel_unshuffle_typed_handle();
    return op.redispatch(dispatchKeySet, self, downscale_factor);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_pinned, name, "aten::is_pinned")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_pinned, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(is_pinned, schema_str, "is_pinned(Tensor self, Device? device=None) -> bool")

// aten::is_pinned(Tensor self, Device? device=None) -> bool
static C10_NOINLINE c10::TypedOperatorHandle<is_pinned::schema> create_is_pinned_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(is_pinned::name, is_pinned::overload_name)
      .typed<is_pinned::schema>();
}

// aten::is_pinned(Tensor self, Device? device=None) -> bool
bool is_pinned::call(const at::Tensor & self, c10::optional<at::Device> device) {
    
    static auto op = create_is_pinned_typed_handle();
    return op.call(self, device);
}

// aten::is_pinned(Tensor self, Device? device=None) -> bool
bool is_pinned::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Device> device) {
    
    static auto op = create_is_pinned_typed_handle();
    return op.redispatch(dispatchKeySet, self, device);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pin_memory, name, "aten::pin_memory")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pin_memory, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pin_memory, schema_str, "pin_memory(Tensor(a) self, Device? device=None) -> Tensor(a)")

// aten::pin_memory(Tensor(a) self, Device? device=None) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<pin_memory::schema> create_pin_memory_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pin_memory::name, pin_memory::overload_name)
      .typed<pin_memory::schema>();
}

// aten::pin_memory(Tensor(a) self, Device? device=None) -> Tensor(a)
at::Tensor pin_memory::call(const at::Tensor & self, c10::optional<at::Device> device) {
    
    static auto op = create_pin_memory_typed_handle();
    return op.call(self, device);
}

// aten::pin_memory(Tensor(a) self, Device? device=None) -> Tensor(a)
at::Tensor pin_memory::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Device> device) {
    
    static auto op = create_pin_memory_typed_handle();
    return op.redispatch(dispatchKeySet, self, device);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pin_memory, name, "aten::_pin_memory")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pin_memory, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pin_memory, schema_str, "_pin_memory(Tensor self, Device? device=None) -> Tensor")

// aten::_pin_memory(Tensor self, Device? device=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_pin_memory::schema> create__pin_memory_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_pin_memory::name, _pin_memory::overload_name)
      .typed<_pin_memory::schema>();
}

// aten::_pin_memory(Tensor self, Device? device=None) -> Tensor
at::Tensor _pin_memory::call(const at::Tensor & self, c10::optional<at::Device> device) {
    
    static auto op = create__pin_memory_typed_handle();
    return op.call(self, device);
}

// aten::_pin_memory(Tensor self, Device? device=None) -> Tensor
at::Tensor _pin_memory::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Device> device) {
    
    static auto op = create__pin_memory_typed_handle();
    return op.redispatch(dispatchKeySet, self, device);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn, name, "aten::randn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn, schema_str, "randn(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::randn(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<randn::schema> create_randn_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randn::name, randn::overload_name)
      .typed<randn::schema>();
}

// aten::randn(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randn::call(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randn_typed_handle();
    return op.call(size, dtype, layout, device, pin_memory);
}

// aten::randn(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randn::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randn_typed_handle();
    return op.redispatch(dispatchKeySet, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator, name, "aten::randn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator, overload_name, "generator")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator, schema_str, "randn.generator(SymInt[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::randn.generator(SymInt[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<randn_generator::schema> create_randn_generator_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randn_generator::name, randn_generator::overload_name)
      .typed<randn_generator::schema>();
}

// aten::randn.generator(SymInt[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randn_generator::call(c10::SymIntArrayRef size, c10::optional<at::Generator> generator, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randn_generator_typed_handle();
    return op.call(size, generator, dtype, layout, device, pin_memory);
}

// aten::randn.generator(SymInt[] size, *, Generator? generator, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randn_generator::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, c10::optional<at::Generator> generator, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randn_generator_typed_handle();
    return op.redispatch(dispatchKeySet, size, generator, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_names, name, "aten::randn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_names, overload_name, "names")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_names, schema_str, "randn.names(SymInt[] size, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::randn.names(SymInt[] size, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<randn_names::schema> create_randn_names_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randn_names::name, randn_names::overload_name)
      .typed<randn_names::schema>();
}

// aten::randn.names(SymInt[] size, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randn_names::call(c10::SymIntArrayRef size, c10::optional<at::DimnameList> names, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randn_names_typed_handle();
    return op.call(size, names, dtype, layout, device, pin_memory);
}

// aten::randn.names(SymInt[] size, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randn_names::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, c10::optional<at::DimnameList> names, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randn_names_typed_handle();
    return op.redispatch(dispatchKeySet, size, names, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator_with_names, name, "aten::randn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator_with_names, overload_name, "generator_with_names")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator_with_names, schema_str, "randn.generator_with_names(SymInt[] size, *, Generator? generator, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::randn.generator_with_names(SymInt[] size, *, Generator? generator, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<randn_generator_with_names::schema> create_randn_generator_with_names_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randn_generator_with_names::name, randn_generator_with_names::overload_name)
      .typed<randn_generator_with_names::schema>();
}

// aten::randn.generator_with_names(SymInt[] size, *, Generator? generator, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randn_generator_with_names::call(c10::SymIntArrayRef size, c10::optional<at::Generator> generator, c10::optional<at::DimnameList> names, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randn_generator_with_names_typed_handle();
    return op.call(size, generator, names, dtype, layout, device, pin_memory);
}

// aten::randn.generator_with_names(SymInt[] size, *, Generator? generator, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor randn_generator_with_names::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, c10::optional<at::Generator> generator, c10::optional<at::DimnameList> names, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_randn_generator_with_names_typed_handle();
    return op.redispatch(dispatchKeySet, size, generator, names, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_out, name, "aten::randn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_out, schema_str, "randn.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)")

// aten::randn.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<randn_out::schema> create_randn_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randn_out::name, randn_out::overload_name)
      .typed<randn_out::schema>();
}

// aten::randn.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randn_out::call(c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create_randn_out_typed_handle();
    return op.call(size, out);
}

// aten::randn.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randn_out::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create_randn_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator_out, name, "aten::randn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator_out, overload_name, "generator_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator_out, schema_str, "randn.generator_out(SymInt[] size, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)")

// aten::randn.generator_out(SymInt[] size, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<randn_generator_out::schema> create_randn_generator_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randn_generator_out::name, randn_generator_out::overload_name)
      .typed<randn_generator_out::schema>();
}

// aten::randn.generator_out(SymInt[] size, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randn_generator_out::call(c10::SymIntArrayRef size, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_randn_generator_out_typed_handle();
    return op.call(size, generator, out);
}

// aten::randn.generator_out(SymInt[] size, *, Generator? generator, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randn_generator_out::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_randn_generator_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, generator, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range_step, name, "aten::range")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range_step, overload_name, "step")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range_step, schema_str, "range.step(Scalar start, Scalar end, Scalar step=1, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::range.step(Scalar start, Scalar end, Scalar step=1, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<range_step::schema> create_range_step_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(range_step::name, range_step::overload_name)
      .typed<range_step::schema>();
}

// aten::range.step(Scalar start, Scalar end, Scalar step=1, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor range_step::call(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_range_step_typed_handle();
    return op.call(start, end, step, dtype, layout, device, pin_memory);
}

// aten::range.step(Scalar start, Scalar end, Scalar step=1, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor range_step::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_range_step_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, step, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range, name, "aten::range")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range, schema_str, "range(Scalar start, Scalar end, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::range(Scalar start, Scalar end, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<range::schema> create_range_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(range::name, range::overload_name)
      .typed<range::schema>();
}

// aten::range(Scalar start, Scalar end, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor range::call(const at::Scalar & start, const at::Scalar & end, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_range_typed_handle();
    return op.call(start, end, dtype, layout, device, pin_memory);
}

// aten::range(Scalar start, Scalar end, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor range::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & start, const at::Scalar & end, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_range_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range_out_, name, "aten::range")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range_out_, overload_name, "out_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range_out_, schema_str, "range.out_(Scalar start, Scalar end, *, Tensor(a!) out) -> Tensor(a!)")

// aten::range.out_(Scalar start, Scalar end, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<range_out_::schema> create_range_out__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(range_out_::name, range_out_::overload_name)
      .typed<range_out_::schema>();
}

// aten::range.out_(Scalar start, Scalar end, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & range_out_::call(const at::Scalar & start, const at::Scalar & end, at::Tensor & out) {
    
    static auto op = create_range_out__typed_handle();
    return op.call(start, end, out);
}

// aten::range.out_(Scalar start, Scalar end, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & range_out_::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & start, const at::Scalar & end, at::Tensor & out) {
    
    static auto op = create_range_out__typed_handle();
    return op.redispatch(dispatchKeySet, start, end, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range_out, name, "aten::range")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(range_out, schema_str, "range.out(Scalar start, Scalar end, Scalar step=1, *, Tensor(a!) out) -> Tensor(a!)")

// aten::range.out(Scalar start, Scalar end, Scalar step=1, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<range_out::schema> create_range_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(range_out::name, range_out::overload_name)
      .typed<range_out::schema>();
}

// aten::range.out(Scalar start, Scalar end, Scalar step=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & range_out::call(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
    
    static auto op = create_range_out_typed_handle();
    return op.call(start, end, step, out);
}

// aten::range.out(Scalar start, Scalar end, Scalar step=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & range_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
    
    static auto op = create_range_out_typed_handle();
    return op.redispatch(dispatchKeySet, start, end, step, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ravel, name, "aten::ravel")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ravel, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(ravel, schema_str, "ravel(Tensor(a) self) -> Tensor(a)")

// aten::ravel(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<ravel::schema> create_ravel_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(ravel::name, ravel::overload_name)
      .typed<ravel::schema>();
}

// aten::ravel(Tensor(a) self) -> Tensor(a)
at::Tensor ravel::call(const at::Tensor & self) {
    
    static auto op = create_ravel_typed_handle();
    return op.call(self);
}

// aten::ravel(Tensor(a) self) -> Tensor(a)
at::Tensor ravel::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_ravel_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reciprocal, name, "aten::reciprocal")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reciprocal, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reciprocal, schema_str, "reciprocal(Tensor self) -> Tensor")

// aten::reciprocal(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<reciprocal::schema> create_reciprocal_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(reciprocal::name, reciprocal::overload_name)
      .typed<reciprocal::schema>();
}

// aten::reciprocal(Tensor self) -> Tensor
at::Tensor reciprocal::call(const at::Tensor & self) {
    
    static auto op = create_reciprocal_typed_handle();
    return op.call(self);
}

// aten::reciprocal(Tensor self) -> Tensor
at::Tensor reciprocal::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_reciprocal_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reciprocal_, name, "aten::reciprocal_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reciprocal_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reciprocal_, schema_str, "reciprocal_(Tensor(a!) self) -> Tensor(a!)")

// aten::reciprocal_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<reciprocal_::schema> create_reciprocal__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(reciprocal_::name, reciprocal_::overload_name)
      .typed<reciprocal_::schema>();
}

// aten::reciprocal_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & reciprocal_::call(at::Tensor & self) {
    
    static auto op = create_reciprocal__typed_handle();
    return op.call(self);
}

// aten::reciprocal_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & reciprocal_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_reciprocal__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reciprocal_out, name, "aten::reciprocal")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reciprocal_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reciprocal_out, schema_str, "reciprocal.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::reciprocal.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<reciprocal_out::schema> create_reciprocal_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(reciprocal_out::name, reciprocal_out::overload_name)
      .typed<reciprocal_out::schema>();
}

// aten::reciprocal.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & reciprocal_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_reciprocal_out_typed_handle();
    return op.call(self, out);
}

// aten::reciprocal.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & reciprocal_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_reciprocal_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(neg, name, "aten::neg")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(neg, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(neg, schema_str, "neg(Tensor self) -> Tensor")

// aten::neg(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<neg::schema> create_neg_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(neg::name, neg::overload_name)
      .typed<neg::schema>();
}

// aten::neg(Tensor self) -> Tensor
at::Tensor neg::call(const at::Tensor & self) {
    
    static auto op = create_neg_typed_handle();
    return op.call(self);
}

// aten::neg(Tensor self) -> Tensor
at::Tensor neg::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_neg_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(neg_, name, "aten::neg_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(neg_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(neg_, schema_str, "neg_(Tensor(a!) self) -> Tensor(a!)")

// aten::neg_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<neg_::schema> create_neg__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(neg_::name, neg_::overload_name)
      .typed<neg_::schema>();
}

// aten::neg_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & neg_::call(at::Tensor & self) {
    
    static auto op = create_neg__typed_handle();
    return op.call(self);
}

// aten::neg_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & neg_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_neg__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(neg_out, name, "aten::neg")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(neg_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(neg_out, schema_str, "neg.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::neg.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<neg_out::schema> create_neg_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(neg_out::name, neg_out::overload_name)
      .typed<neg_out::schema>();
}

// aten::neg.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & neg_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_neg_out_typed_handle();
    return op.call(self, out);
}

// aten::neg.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & neg_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_neg_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reshape_as, name, "aten::reshape_as")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reshape_as, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reshape_as, schema_str, "reshape_as(Tensor(a) self, Tensor other) -> Tensor(a)")

// aten::reshape_as(Tensor(a) self, Tensor other) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<reshape_as::schema> create_reshape_as_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(reshape_as::name, reshape_as::overload_name)
      .typed<reshape_as::schema>();
}

// aten::reshape_as(Tensor(a) self, Tensor other) -> Tensor(a)
at::Tensor reshape_as::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_reshape_as_typed_handle();
    return op.call(self, other);
}

// aten::reshape_as(Tensor(a) self, Tensor other) -> Tensor(a)
at::Tensor reshape_as::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_reshape_as_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu, name, "aten::rrelu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu, schema_str, "rrelu(Tensor self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -> Tensor")

// aten::rrelu(Tensor self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<rrelu::schema> create_rrelu_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(rrelu::name, rrelu::overload_name)
      .typed<rrelu::schema>();
}

// aten::rrelu(Tensor self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -> Tensor
at::Tensor rrelu::call(const at::Tensor & self, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
    
    static auto op = create_rrelu_typed_handle();
    return op.call(self, lower, upper, training, generator);
}

// aten::rrelu(Tensor self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -> Tensor
at::Tensor rrelu::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
    
    static auto op = create_rrelu_typed_handle();
    return op.redispatch(dispatchKeySet, self, lower, upper, training, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu_, name, "aten::rrelu_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu_, schema_str, "rrelu_(Tensor(a!) self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -> Tensor(a!)")

// aten::rrelu_(Tensor(a!) self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<rrelu_::schema> create_rrelu__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(rrelu_::name, rrelu_::overload_name)
      .typed<rrelu_::schema>();
}

// aten::rrelu_(Tensor(a!) self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -> Tensor(a!)
at::Tensor & rrelu_::call(at::Tensor & self, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
    
    static auto op = create_rrelu__typed_handle();
    return op.call(self, lower, upper, training, generator);
}

// aten::rrelu_(Tensor(a!) self, Scalar lower=0.125, Scalar upper=0.3333333333333333, bool training=False, Generator? generator=None) -> Tensor(a!)
at::Tensor & rrelu_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
    
    static auto op = create_rrelu__typed_handle();
    return op.redispatch(dispatchKeySet, self, lower, upper, training, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu6, name, "aten::relu6")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu6, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu6, schema_str, "relu6(Tensor self) -> Tensor")

// aten::relu6(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<relu6::schema> create_relu6_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(relu6::name, relu6::overload_name)
      .typed<relu6::schema>();
}

// aten::relu6(Tensor self) -> Tensor
at::Tensor relu6::call(const at::Tensor & self) {
    
    static auto op = create_relu6_typed_handle();
    return op.call(self);
}

// aten::relu6(Tensor self) -> Tensor
at::Tensor relu6::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_relu6_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu6_, name, "aten::relu6_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu6_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(relu6_, schema_str, "relu6_(Tensor(a!) self) -> Tensor(a!)")

// aten::relu6_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<relu6_::schema> create_relu6__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(relu6_::name, relu6_::overload_name)
      .typed<relu6_::schema>();
}

// aten::relu6_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & relu6_::call(at::Tensor & self) {
    
    static auto op = create_relu6__typed_handle();
    return op.call(self);
}

// aten::relu6_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & relu6_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_relu6__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prelu, name, "aten::prelu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prelu, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(prelu, schema_str, "prelu(Tensor self, Tensor weight) -> Tensor")

// aten::prelu(Tensor self, Tensor weight) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<prelu::schema> create_prelu_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(prelu::name, prelu::overload_name)
      .typed<prelu::schema>();
}

// aten::prelu(Tensor self, Tensor weight) -> Tensor
at::Tensor prelu::call(const at::Tensor & self, const at::Tensor & weight) {
    
    static auto op = create_prelu_typed_handle();
    return op.call(self, weight);
}

// aten::prelu(Tensor self, Tensor weight) -> Tensor
at::Tensor prelu::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight) {
    
    static auto op = create_prelu_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_prelu_kernel_backward, name, "aten::_prelu_kernel_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_prelu_kernel_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_prelu_kernel_backward, schema_str, "_prelu_kernel_backward(Tensor grad_output, Tensor self, Tensor weight) -> (Tensor, Tensor)")

// aten::_prelu_kernel_backward(Tensor grad_output, Tensor self, Tensor weight) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_prelu_kernel_backward::schema> create__prelu_kernel_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_prelu_kernel_backward::name, _prelu_kernel_backward::overload_name)
      .typed<_prelu_kernel_backward::schema>();
}

// aten::_prelu_kernel_backward(Tensor grad_output, Tensor self, Tensor weight) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _prelu_kernel_backward::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight) {
    
    static auto op = create__prelu_kernel_backward_typed_handle();
    return op.call(grad_output, self, weight);
}

// aten::_prelu_kernel_backward(Tensor grad_output, Tensor self, Tensor weight) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _prelu_kernel_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight) {
    
    static auto op = create__prelu_kernel_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, weight);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(gelu_backward_grad_input, name, "aten::gelu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(gelu_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(gelu_backward_grad_input, schema_str, "gelu_backward.grad_input(Tensor grad_output, Tensor self, *, str approximate='none', Tensor(a!) grad_input) -> Tensor(a!)")

// aten::gelu_backward.grad_input(Tensor grad_output, Tensor self, *, str approximate='none', Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<gelu_backward_grad_input::schema> create_gelu_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(gelu_backward_grad_input::name, gelu_backward_grad_input::overload_name)
      .typed<gelu_backward_grad_input::schema>();
}

// aten::gelu_backward.grad_input(Tensor grad_output, Tensor self, *, str approximate='none', Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & gelu_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate, at::Tensor & grad_input) {
    
    static auto op = create_gelu_backward_grad_input_typed_handle();
    return op.call(grad_output, self, approximate, grad_input);
}

// aten::gelu_backward.grad_input(Tensor grad_output, Tensor self, *, str approximate='none', Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & gelu_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate, at::Tensor & grad_input) {
    
    static auto op = create_gelu_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, approximate, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(gelu_backward, name, "aten::gelu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(gelu_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(gelu_backward, schema_str, "gelu_backward(Tensor grad_output, Tensor self, *, str approximate='none') -> Tensor")

// aten::gelu_backward(Tensor grad_output, Tensor self, *, str approximate='none') -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<gelu_backward::schema> create_gelu_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(gelu_backward::name, gelu_backward::overload_name)
      .typed<gelu_backward::schema>();
}

// aten::gelu_backward(Tensor grad_output, Tensor self, *, str approximate='none') -> Tensor
at::Tensor gelu_backward::call(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
    
    static auto op = create_gelu_backward_typed_handle();
    return op.call(grad_output, self, approximate);
}

// aten::gelu_backward(Tensor grad_output, Tensor self, *, str approximate='none') -> Tensor
at::Tensor gelu_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
    
    static auto op = create_gelu_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, approximate);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(selu, name, "aten::selu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(selu, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(selu, schema_str, "selu(Tensor self) -> Tensor")

// aten::selu(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<selu::schema> create_selu_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(selu::name, selu::overload_name)
      .typed<selu::schema>();
}

// aten::selu(Tensor self) -> Tensor
at::Tensor selu::call(const at::Tensor & self) {
    
    static auto op = create_selu_typed_handle();
    return op.call(self);
}

// aten::selu(Tensor self) -> Tensor
at::Tensor selu::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_selu_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(selu_, name, "aten::selu_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(selu_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(selu_, schema_str, "selu_(Tensor(a!) self) -> Tensor(a!)")

// aten::selu_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<selu_::schema> create_selu__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(selu_::name, selu_::overload_name)
      .typed<selu_::schema>();
}

// aten::selu_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & selu_::call(at::Tensor & self) {
    
    static auto op = create_selu__typed_handle();
    return op.call(self);
}

// aten::selu_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & selu_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_selu__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(silu_backward_grad_input, name, "aten::silu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(silu_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(silu_backward_grad_input, schema_str, "silu_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::silu_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<silu_backward_grad_input::schema> create_silu_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(silu_backward_grad_input::name, silu_backward_grad_input::overload_name)
      .typed<silu_backward_grad_input::schema>();
}

// aten::silu_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & silu_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
    
    static auto op = create_silu_backward_grad_input_typed_handle();
    return op.call(grad_output, self, grad_input);
}

// aten::silu_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & silu_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
    
    static auto op = create_silu_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(silu_backward, name, "aten::silu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(silu_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(silu_backward, schema_str, "silu_backward(Tensor grad_output, Tensor self) -> Tensor")

// aten::silu_backward(Tensor grad_output, Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<silu_backward::schema> create_silu_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(silu_backward::name, silu_backward::overload_name)
      .typed<silu_backward::schema>();
}

// aten::silu_backward(Tensor grad_output, Tensor self) -> Tensor
at::Tensor silu_backward::call(const at::Tensor & grad_output, const at::Tensor & self) {
    
    static auto op = create_silu_backward_typed_handle();
    return op.call(grad_output, self);
}

// aten::silu_backward(Tensor grad_output, Tensor self) -> Tensor
at::Tensor silu_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self) {
    
    static auto op = create_silu_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sin, name, "aten::sin")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sin, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sin, schema_str, "sin(Tensor self) -> Tensor")

// aten::sin(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sin::schema> create_sin_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sin::name, sin::overload_name)
      .typed<sin::schema>();
}

// aten::sin(Tensor self) -> Tensor
at::Tensor sin::call(const at::Tensor & self) {
    
    static auto op = create_sin_typed_handle();
    return op.call(self);
}

// aten::sin(Tensor self) -> Tensor
at::Tensor sin::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_sin_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sin_, name, "aten::sin_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sin_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sin_, schema_str, "sin_(Tensor(a!) self) -> Tensor(a!)")

// aten::sin_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sin_::schema> create_sin__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sin_::name, sin_::overload_name)
      .typed<sin_::schema>();
}

// aten::sin_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & sin_::call(at::Tensor & self) {
    
    static auto op = create_sin__typed_handle();
    return op.call(self);
}

// aten::sin_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & sin_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_sin__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sin_out, name, "aten::sin")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sin_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sin_out, schema_str, "sin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::sin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sin_out::schema> create_sin_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sin_out::name, sin_out::overload_name)
      .typed<sin_out::schema>();
}

// aten::sin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sin_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_sin_out_typed_handle();
    return op.call(self, out);
}

// aten::sin.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sin_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_sin_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sym_storage_offset, name, "aten::sym_storage_offset")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sym_storage_offset, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sym_storage_offset, schema_str, "sym_storage_offset(Tensor self) -> SymInt")

// aten::sym_storage_offset(Tensor self) -> SymInt
static C10_NOINLINE c10::TypedOperatorHandle<sym_storage_offset::schema> create_sym_storage_offset_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sym_storage_offset::name, sym_storage_offset::overload_name)
      .typed<sym_storage_offset::schema>();
}

// aten::sym_storage_offset(Tensor self) -> SymInt
c10::SymInt sym_storage_offset::call(const at::Tensor & self) {
    
    static auto op = create_sym_storage_offset_typed_handle();
    return op.call(self);
}

// aten::sym_storage_offset(Tensor self) -> SymInt
c10::SymInt sym_storage_offset::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_sym_storage_offset_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_scatter, name, "aten::diagonal_scatter")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_scatter, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_scatter, schema_str, "diagonal_scatter(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1) -> Tensor")

// aten::diagonal_scatter(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<diagonal_scatter::schema> create_diagonal_scatter_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(diagonal_scatter::name, diagonal_scatter::overload_name)
      .typed<diagonal_scatter::schema>();
}

// aten::diagonal_scatter(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1) -> Tensor
at::Tensor diagonal_scatter::call(const at::Tensor & self, const at::Tensor & src, int64_t offset, int64_t dim1, int64_t dim2) {
    
    static auto op = create_diagonal_scatter_typed_handle();
    return op.call(self, src, offset, dim1, dim2);
}

// aten::diagonal_scatter(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1) -> Tensor
at::Tensor diagonal_scatter::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & src, int64_t offset, int64_t dim1, int64_t dim2) {
    
    static auto op = create_diagonal_scatter_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, offset, dim1, dim2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided_scatter, name, "aten::as_strided_scatter")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided_scatter, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided_scatter, schema_str, "as_strided_scatter(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor")

// aten::as_strided_scatter(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<as_strided_scatter::schema> create_as_strided_scatter_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(as_strided_scatter::name, as_strided_scatter::overload_name)
      .typed<as_strided_scatter::schema>();
}

// aten::as_strided_scatter(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor
at::Tensor as_strided_scatter::call(const at::Tensor & self, const at::Tensor & src, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    
    static auto op = create_as_strided_scatter_typed_handle();
    return op.call(self, src, size, stride, storage_offset);
}

// aten::as_strided_scatter(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None) -> Tensor
at::Tensor as_strided_scatter::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & src, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    
    static auto op = create_as_strided_scatter_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, size, stride, storage_offset);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_Tensor, name, "aten::split")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_Tensor, schema_str, "split.Tensor(Tensor(a -> *) self, SymInt split_size, int dim=0) -> Tensor(a)[]")

// aten::split.Tensor(Tensor(a -> *) self, SymInt split_size, int dim=0) -> Tensor(a)[]
static C10_NOINLINE c10::TypedOperatorHandle<split_Tensor::schema> create_split_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(split_Tensor::name, split_Tensor::overload_name)
      .typed<split_Tensor::schema>();
}

// aten::split.Tensor(Tensor(a -> *) self, SymInt split_size, int dim=0) -> Tensor(a)[]
::std::vector<at::Tensor> split_Tensor::call(const at::Tensor & self, c10::SymInt split_size, int64_t dim) {
    
    static auto op = create_split_Tensor_typed_handle();
    return op.call(self, split_size, dim);
}

// aten::split.Tensor(Tensor(a -> *) self, SymInt split_size, int dim=0) -> Tensor(a)[]
::std::vector<at::Tensor> split_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymInt split_size, int64_t dim) {
    
    static auto op = create_split_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, split_size, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_sizes, name, "aten::split")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_sizes, overload_name, "sizes")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(split_sizes, schema_str, "split.sizes(Tensor(a -> *) self, SymInt[] split_size, int dim=0) -> Tensor(a)[]")

// aten::split.sizes(Tensor(a -> *) self, SymInt[] split_size, int dim=0) -> Tensor(a)[]
static C10_NOINLINE c10::TypedOperatorHandle<split_sizes::schema> create_split_sizes_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(split_sizes::name, split_sizes::overload_name)
      .typed<split_sizes::schema>();
}

// aten::split.sizes(Tensor(a -> *) self, SymInt[] split_size, int dim=0) -> Tensor(a)[]
::std::vector<at::Tensor> split_sizes::call(const at::Tensor & self, c10::SymIntArrayRef split_size, int64_t dim) {
    
    static auto op = create_split_sizes_typed_handle();
    return op.call(self, split_size, dim);
}

// aten::split.sizes(Tensor(a -> *) self, SymInt[] split_size, int dim=0) -> Tensor(a)[]
::std::vector<at::Tensor> split_sizes::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef split_size, int64_t dim) {
    
    static auto op = create_split_sizes_typed_handle();
    return op.redispatch(dispatchKeySet, self, split_size, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze, name, "aten::squeeze")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze, schema_str, "squeeze(Tensor(a) self) -> Tensor(a)")

// aten::squeeze(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<squeeze::schema> create_squeeze_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(squeeze::name, squeeze::overload_name)
      .typed<squeeze::schema>();
}

// aten::squeeze(Tensor(a) self) -> Tensor(a)
at::Tensor squeeze::call(const at::Tensor & self) {
    
    static auto op = create_squeeze_typed_handle();
    return op.call(self);
}

// aten::squeeze(Tensor(a) self) -> Tensor(a)
at::Tensor squeeze::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_squeeze_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_dim, name, "aten::squeeze")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_dim, overload_name, "dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_dim, schema_str, "squeeze.dim(Tensor(a) self, int dim) -> Tensor(a)")

// aten::squeeze.dim(Tensor(a) self, int dim) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<squeeze_dim::schema> create_squeeze_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(squeeze_dim::name, squeeze_dim::overload_name)
      .typed<squeeze_dim::schema>();
}

// aten::squeeze.dim(Tensor(a) self, int dim) -> Tensor(a)
at::Tensor squeeze_dim::call(const at::Tensor & self, int64_t dim) {
    
    static auto op = create_squeeze_dim_typed_handle();
    return op.call(self, dim);
}

// aten::squeeze.dim(Tensor(a) self, int dim) -> Tensor(a)
at::Tensor squeeze_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim) {
    
    static auto op = create_squeeze_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_dimname, name, "aten::squeeze")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_dimname, schema_str, "squeeze.dimname(Tensor(a) self, Dimname dim) -> Tensor(a)")

// aten::squeeze.dimname(Tensor(a) self, Dimname dim) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<squeeze_dimname::schema> create_squeeze_dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(squeeze_dimname::name, squeeze_dimname::overload_name)
      .typed<squeeze_dimname::schema>();
}

// aten::squeeze.dimname(Tensor(a) self, Dimname dim) -> Tensor(a)
at::Tensor squeeze_dimname::call(const at::Tensor & self, at::Dimname dim) {
    
    static auto op = create_squeeze_dimname_typed_handle();
    return op.call(self, dim);
}

// aten::squeeze.dimname(Tensor(a) self, Dimname dim) -> Tensor(a)
at::Tensor squeeze_dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim) {
    
    static auto op = create_squeeze_dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_dims, name, "aten::squeeze")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_dims, overload_name, "dims")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_dims, schema_str, "squeeze.dims(Tensor(a) self, int[] dim) -> Tensor(a)")

// aten::squeeze.dims(Tensor(a) self, int[] dim) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<squeeze_dims::schema> create_squeeze_dims_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(squeeze_dims::name, squeeze_dims::overload_name)
      .typed<squeeze_dims::schema>();
}

// aten::squeeze.dims(Tensor(a) self, int[] dim) -> Tensor(a)
at::Tensor squeeze_dims::call(const at::Tensor & self, at::IntArrayRef dim) {
    
    static auto op = create_squeeze_dims_typed_handle();
    return op.call(self, dim);
}

// aten::squeeze.dims(Tensor(a) self, int[] dim) -> Tensor(a)
at::Tensor squeeze_dims::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim) {
    
    static auto op = create_squeeze_dims_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_, name, "aten::squeeze_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze_, schema_str, "squeeze_(Tensor(a!) self) -> Tensor(a!)")

// aten::squeeze_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<squeeze_::schema> create_squeeze__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(squeeze_::name, squeeze_::overload_name)
      .typed<squeeze_::schema>();
}

// aten::squeeze_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & squeeze_::call(at::Tensor & self) {
    
    static auto op = create_squeeze__typed_handle();
    return op.call(self);
}

// aten::squeeze_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & squeeze_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_squeeze__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze__dim, name, "aten::squeeze_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze__dim, overload_name, "dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze__dim, schema_str, "squeeze_.dim(Tensor(a!) self, int dim) -> Tensor(a!)")

// aten::squeeze_.dim(Tensor(a!) self, int dim) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<squeeze__dim::schema> create_squeeze__dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(squeeze__dim::name, squeeze__dim::overload_name)
      .typed<squeeze__dim::schema>();
}

// aten::squeeze_.dim(Tensor(a!) self, int dim) -> Tensor(a!)
at::Tensor & squeeze__dim::call(at::Tensor & self, int64_t dim) {
    
    static auto op = create_squeeze__dim_typed_handle();
    return op.call(self, dim);
}

// aten::squeeze_.dim(Tensor(a!) self, int dim) -> Tensor(a!)
at::Tensor & squeeze__dim::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, int64_t dim) {
    
    static auto op = create_squeeze__dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze__dims, name, "aten::squeeze_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze__dims, overload_name, "dims")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze__dims, schema_str, "squeeze_.dims(Tensor(a!) self, int[] dim) -> Tensor(a!)")

// aten::squeeze_.dims(Tensor(a!) self, int[] dim) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<squeeze__dims::schema> create_squeeze__dims_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(squeeze__dims::name, squeeze__dims::overload_name)
      .typed<squeeze__dims::schema>();
}

// aten::squeeze_.dims(Tensor(a!) self, int[] dim) -> Tensor(a!)
at::Tensor & squeeze__dims::call(at::Tensor & self, at::IntArrayRef dim) {
    
    static auto op = create_squeeze__dims_typed_handle();
    return op.call(self, dim);
}

// aten::squeeze_.dims(Tensor(a!) self, int[] dim) -> Tensor(a!)
at::Tensor & squeeze__dims::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, at::IntArrayRef dim) {
    
    static auto op = create_squeeze__dims_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze__dimname, name, "aten::squeeze_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze__dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(squeeze__dimname, schema_str, "squeeze_.dimname(Tensor(a!) self, Dimname dim) -> Tensor(a!)")

// aten::squeeze_.dimname(Tensor(a!) self, Dimname dim) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<squeeze__dimname::schema> create_squeeze__dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(squeeze__dimname::name, squeeze__dimname::overload_name)
      .typed<squeeze__dimname::schema>();
}

// aten::squeeze_.dimname(Tensor(a!) self, Dimname dim) -> Tensor(a!)
at::Tensor & squeeze__dimname::call(at::Tensor & self, at::Dimname dim) {
    
    static auto op = create_squeeze__dimname_typed_handle();
    return op.call(self, dim);
}

// aten::squeeze_.dimname(Tensor(a!) self, Dimname dim) -> Tensor(a!)
at::Tensor & squeeze__dimname::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, at::Dimname dim) {
    
    static auto op = create_squeeze__dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sspaddmm, name, "aten::sspaddmm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sspaddmm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sspaddmm, schema_str, "sspaddmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor")

// aten::sspaddmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sspaddmm::schema> create_sspaddmm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sspaddmm::name, sspaddmm::overload_name)
      .typed<sspaddmm::schema>();
}

// aten::sspaddmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor
at::Tensor sspaddmm::call(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    
    static auto op = create_sspaddmm_typed_handle();
    return op.call(self, mat1, mat2, beta, alpha);
}

// aten::sspaddmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor
at::Tensor sspaddmm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    
    static auto op = create_sspaddmm_typed_handle();
    return op.redispatch(dispatchKeySet, self, mat1, mat2, beta, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sspaddmm_out, name, "aten::sspaddmm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sspaddmm_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sspaddmm_out, schema_str, "sspaddmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")

// aten::sspaddmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sspaddmm_out::schema> create_sspaddmm_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sspaddmm_out::name, sspaddmm_out::overload_name)
      .typed<sspaddmm_out::schema>();
}

// aten::sspaddmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sspaddmm_out::call(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_sspaddmm_out_typed_handle();
    return op.call(self, mat1, mat2, beta, alpha, out);
}

// aten::sspaddmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sspaddmm_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_sspaddmm_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, mat1, mat2, beta, alpha, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(stride_int, name, "aten::stride")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(stride_int, overload_name, "int")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(stride_int, schema_str, "stride.int(Tensor self, int dim) -> int")

// aten::stride.int(Tensor self, int dim) -> int
static C10_NOINLINE c10::TypedOperatorHandle<stride_int::schema> create_stride_int_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(stride_int::name, stride_int::overload_name)
      .typed<stride_int::schema>();
}

// aten::stride.int(Tensor self, int dim) -> int
int64_t stride_int::call(const at::Tensor & self, int64_t dim) {
    
    static auto op = create_stride_int_typed_handle();
    return op.call(self, dim);
}

// aten::stride.int(Tensor self, int dim) -> int
int64_t stride_int::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim) {
    
    static auto op = create_stride_int_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(stride_Dimname, name, "aten::stride")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(stride_Dimname, overload_name, "Dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(stride_Dimname, schema_str, "stride.Dimname(Tensor self, Dimname dim) -> int")

// aten::stride.Dimname(Tensor self, Dimname dim) -> int
static C10_NOINLINE c10::TypedOperatorHandle<stride_Dimname::schema> create_stride_Dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(stride_Dimname::name, stride_Dimname::overload_name)
      .typed<stride_Dimname::schema>();
}

// aten::stride.Dimname(Tensor self, Dimname dim) -> int
int64_t stride_Dimname::call(const at::Tensor & self, at::Dimname dim) {
    
    static auto op = create_stride_Dimname_typed_handle();
    return op.call(self, dim);
}

// aten::stride.Dimname(Tensor self, Dimname dim) -> int
int64_t stride_Dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim) {
    
    static auto op = create_stride_Dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(threshold_backward_grad_input, name, "aten::threshold_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(threshold_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(threshold_backward_grad_input, schema_str, "threshold_backward.grad_input(Tensor grad_output, Tensor self, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::threshold_backward.grad_input(Tensor grad_output, Tensor self, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<threshold_backward_grad_input::schema> create_threshold_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(threshold_backward_grad_input::name, threshold_backward_grad_input::overload_name)
      .typed<threshold_backward_grad_input::schema>();
}

// aten::threshold_backward.grad_input(Tensor grad_output, Tensor self, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & threshold_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold, at::Tensor & grad_input) {
    
    static auto op = create_threshold_backward_grad_input_typed_handle();
    return op.call(grad_output, self, threshold, grad_input);
}

// aten::threshold_backward.grad_input(Tensor grad_output, Tensor self, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & threshold_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold, at::Tensor & grad_input) {
    
    static auto op = create_threshold_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, threshold, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(threshold_backward, name, "aten::threshold_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(threshold_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(threshold_backward, schema_str, "threshold_backward(Tensor grad_output, Tensor self, Scalar threshold) -> Tensor")

// aten::threshold_backward(Tensor grad_output, Tensor self, Scalar threshold) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<threshold_backward::schema> create_threshold_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(threshold_backward::name, threshold_backward::overload_name)
      .typed<threshold_backward::schema>();
}

// aten::threshold_backward(Tensor grad_output, Tensor self, Scalar threshold) -> Tensor
at::Tensor threshold_backward::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
    
    static auto op = create_threshold_backward_typed_handle();
    return op.call(grad_output, self, threshold);
}

// aten::threshold_backward(Tensor grad_output, Tensor self, Scalar threshold) -> Tensor
at::Tensor threshold_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
    
    static auto op = create_threshold_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, threshold);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(one_hot, name, "aten::one_hot")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(one_hot, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(one_hot, schema_str, "one_hot(Tensor self, int num_classes=-1) -> Tensor")

// aten::one_hot(Tensor self, int num_classes=-1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<one_hot::schema> create_one_hot_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(one_hot::name, one_hot::overload_name)
      .typed<one_hot::schema>();
}

// aten::one_hot(Tensor self, int num_classes=-1) -> Tensor
at::Tensor one_hot::call(const at::Tensor & self, int64_t num_classes) {
    
    static auto op = create_one_hot_typed_handle();
    return op.call(self, num_classes);
}

// aten::one_hot(Tensor self, int num_classes=-1) -> Tensor
at::Tensor one_hot::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t num_classes) {
    
    static auto op = create_one_hot_typed_handle();
    return op.redispatch(dispatchKeySet, self, num_classes);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_transform_bias_rescale_qkv, name, "aten::_transform_bias_rescale_qkv")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_transform_bias_rescale_qkv, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_transform_bias_rescale_qkv, schema_str, "_transform_bias_rescale_qkv(Tensor qkv, Tensor qkv_bias, int num_heads) -> (Tensor, Tensor, Tensor)")

// aten::_transform_bias_rescale_qkv(Tensor qkv, Tensor qkv_bias, int num_heads) -> (Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_transform_bias_rescale_qkv::schema> create__transform_bias_rescale_qkv_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_transform_bias_rescale_qkv::name, _transform_bias_rescale_qkv::overload_name)
      .typed<_transform_bias_rescale_qkv::schema>();
}

// aten::_transform_bias_rescale_qkv(Tensor qkv, Tensor qkv_bias, int num_heads) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _transform_bias_rescale_qkv::call(const at::Tensor & qkv, const at::Tensor & qkv_bias, int64_t num_heads) {
    
    static auto op = create__transform_bias_rescale_qkv_typed_handle();
    return op.call(qkv, qkv_bias, num_heads);
}

// aten::_transform_bias_rescale_qkv(Tensor qkv, Tensor qkv_bias, int num_heads) -> (Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _transform_bias_rescale_qkv::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & qkv, const at::Tensor & qkv_bias, int64_t num_heads) {
    
    static auto op = create__transform_bias_rescale_qkv_typed_handle();
    return op.redispatch(dispatchKeySet, qkv, qkv_bias, num_heads);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unique, name, "aten::_unique")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unique, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unique, schema_str, "_unique(Tensor self, bool sorted=True, bool return_inverse=False) -> (Tensor, Tensor)")

// aten::_unique(Tensor self, bool sorted=True, bool return_inverse=False) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_unique::schema> create__unique_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_unique::name, _unique::overload_name)
      .typed<_unique::schema>();
}

// aten::_unique(Tensor self, bool sorted=True, bool return_inverse=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _unique::call(const at::Tensor & self, bool sorted, bool return_inverse) {
    
    static auto op = create__unique_typed_handle();
    return op.call(self, sorted, return_inverse);
}

// aten::_unique(Tensor self, bool sorted=True, bool return_inverse=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _unique::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool sorted, bool return_inverse) {
    
    static auto op = create__unique_typed_handle();
    return op.redispatch(dispatchKeySet, self, sorted, return_inverse);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_self, name, "aten::where")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_self, overload_name, "self")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_self, schema_str, "where.self(Tensor condition, Tensor self, Tensor other) -> Tensor")

// aten::where.self(Tensor condition, Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<where_self::schema> create_where_self_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(where_self::name, where_self::overload_name)
      .typed<where_self::schema>();
}

// aten::where.self(Tensor condition, Tensor self, Tensor other) -> Tensor
at::Tensor where_self::call(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_where_self_typed_handle();
    return op.call(condition, self, other);
}

// aten::where.self(Tensor condition, Tensor self, Tensor other) -> Tensor
at::Tensor where_self::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_where_self_typed_handle();
    return op.redispatch(dispatchKeySet, condition, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_self_out, name, "aten::where")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_self_out, overload_name, "self_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_self_out, schema_str, "where.self_out(Tensor condition, Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::where.self_out(Tensor condition, Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<where_self_out::schema> create_where_self_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(where_self_out::name, where_self_out::overload_name)
      .typed<where_self_out::schema>();
}

// aten::where.self_out(Tensor condition, Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & where_self_out::call(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_where_self_out_typed_handle();
    return op.call(condition, self, other, out);
}

// aten::where.self_out(Tensor condition, Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & where_self_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_where_self_out_typed_handle();
    return op.redispatch(dispatchKeySet, condition, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_ScalarSelf, name, "aten::where")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_ScalarSelf, overload_name, "ScalarSelf")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_ScalarSelf, schema_str, "where.ScalarSelf(Tensor condition, Scalar self, Tensor other) -> Tensor")

// aten::where.ScalarSelf(Tensor condition, Scalar self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<where_ScalarSelf::schema> create_where_ScalarSelf_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(where_ScalarSelf::name, where_ScalarSelf::overload_name)
      .typed<where_ScalarSelf::schema>();
}

// aten::where.ScalarSelf(Tensor condition, Scalar self, Tensor other) -> Tensor
at::Tensor where_ScalarSelf::call(const at::Tensor & condition, const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_where_ScalarSelf_typed_handle();
    return op.call(condition, self, other);
}

// aten::where.ScalarSelf(Tensor condition, Scalar self, Tensor other) -> Tensor
at::Tensor where_ScalarSelf::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & condition, const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_where_ScalarSelf_typed_handle();
    return op.redispatch(dispatchKeySet, condition, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_ScalarOther, name, "aten::where")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_ScalarOther, overload_name, "ScalarOther")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_ScalarOther, schema_str, "where.ScalarOther(Tensor condition, Tensor self, Scalar other) -> Tensor")

// aten::where.ScalarOther(Tensor condition, Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<where_ScalarOther::schema> create_where_ScalarOther_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(where_ScalarOther::name, where_ScalarOther::overload_name)
      .typed<where_ScalarOther::schema>();
}

// aten::where.ScalarOther(Tensor condition, Tensor self, Scalar other) -> Tensor
at::Tensor where_ScalarOther::call(const at::Tensor & condition, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_where_ScalarOther_typed_handle();
    return op.call(condition, self, other);
}

// aten::where.ScalarOther(Tensor condition, Tensor self, Scalar other) -> Tensor
at::Tensor where_ScalarOther::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & condition, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_where_ScalarOther_typed_handle();
    return op.redispatch(dispatchKeySet, condition, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_Scalar, name, "aten::where")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where_Scalar, schema_str, "where.Scalar(Tensor condition, Scalar self, Scalar other) -> Tensor")

// aten::where.Scalar(Tensor condition, Scalar self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<where_Scalar::schema> create_where_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(where_Scalar::name, where_Scalar::overload_name)
      .typed<where_Scalar::schema>();
}

// aten::where.Scalar(Tensor condition, Scalar self, Scalar other) -> Tensor
at::Tensor where_Scalar::call(const at::Tensor & condition, const at::Scalar & self, const at::Scalar & other) {
    
    static auto op = create_where_Scalar_typed_handle();
    return op.call(condition, self, other);
}

// aten::where.Scalar(Tensor condition, Scalar self, Scalar other) -> Tensor
at::Tensor where_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & condition, const at::Scalar & self, const at::Scalar & other) {
    
    static auto op = create_where_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, condition, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where, name, "aten::where")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(where, schema_str, "where(Tensor condition) -> Tensor[]")

// aten::where(Tensor condition) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<where::schema> create_where_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(where::name, where::overload_name)
      .typed<where::schema>();
}

// aten::where(Tensor condition) -> Tensor[]
::std::vector<at::Tensor> where::call(const at::Tensor & condition) {
    
    static auto op = create_where_typed_handle();
    return op.call(condition);
}

// aten::where(Tensor condition) -> Tensor[]
::std::vector<at::Tensor> where::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & condition) {
    
    static auto op = create_where_typed_handle();
    return op.redispatch(dispatchKeySet, condition);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm, name, "aten::_weight_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm, schema_str, "_weight_norm(Tensor v, Tensor g, int dim=0) -> Tensor")

// aten::_weight_norm(Tensor v, Tensor g, int dim=0) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_weight_norm::schema> create__weight_norm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_weight_norm::name, _weight_norm::overload_name)
      .typed<_weight_norm::schema>();
}

// aten::_weight_norm(Tensor v, Tensor g, int dim=0) -> Tensor
at::Tensor _weight_norm::call(const at::Tensor & v, const at::Tensor & g, int64_t dim) {
    
    static auto op = create__weight_norm_typed_handle();
    return op.call(v, g, dim);
}

// aten::_weight_norm(Tensor v, Tensor g, int dim=0) -> Tensor
at::Tensor _weight_norm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & v, const at::Tensor & g, int64_t dim) {
    
    static auto op = create__weight_norm_typed_handle();
    return op.redispatch(dispatchKeySet, v, g, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm_interface, name, "aten::_weight_norm_interface")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm_interface, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm_interface, schema_str, "_weight_norm_interface(Tensor v, Tensor g, int dim=0) -> (Tensor, Tensor)")

// aten::_weight_norm_interface(Tensor v, Tensor g, int dim=0) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_weight_norm_interface::schema> create__weight_norm_interface_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_weight_norm_interface::name, _weight_norm_interface::overload_name)
      .typed<_weight_norm_interface::schema>();
}

// aten::_weight_norm_interface(Tensor v, Tensor g, int dim=0) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _weight_norm_interface::call(const at::Tensor & v, const at::Tensor & g, int64_t dim) {
    
    static auto op = create__weight_norm_interface_typed_handle();
    return op.call(v, g, dim);
}

// aten::_weight_norm_interface(Tensor v, Tensor g, int dim=0) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _weight_norm_interface::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & v, const at::Tensor & g, int64_t dim) {
    
    static auto op = create__weight_norm_interface_typed_handle();
    return op.redispatch(dispatchKeySet, v, g, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm_differentiable_backward, name, "aten::_weight_norm_differentiable_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm_differentiable_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm_differentiable_backward, schema_str, "_weight_norm_differentiable_backward(Tensor grad_w, Tensor saved_v, Tensor saved_g, Tensor saved_norms, int dim) -> (Tensor, Tensor)")

// aten::_weight_norm_differentiable_backward(Tensor grad_w, Tensor saved_v, Tensor saved_g, Tensor saved_norms, int dim) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_weight_norm_differentiable_backward::schema> create__weight_norm_differentiable_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_weight_norm_differentiable_backward::name, _weight_norm_differentiable_backward::overload_name)
      .typed<_weight_norm_differentiable_backward::schema>();
}

// aten::_weight_norm_differentiable_backward(Tensor grad_w, Tensor saved_v, Tensor saved_g, Tensor saved_norms, int dim) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _weight_norm_differentiable_backward::call(const at::Tensor & grad_w, const at::Tensor & saved_v, const at::Tensor & saved_g, const at::Tensor & saved_norms, int64_t dim) {
    
    static auto op = create__weight_norm_differentiable_backward_typed_handle();
    return op.call(grad_w, saved_v, saved_g, saved_norms, dim);
}

// aten::_weight_norm_differentiable_backward(Tensor grad_w, Tensor saved_v, Tensor saved_g, Tensor saved_norms, int dim) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _weight_norm_differentiable_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_w, const at::Tensor & saved_v, const at::Tensor & saved_g, const at::Tensor & saved_norms, int64_t dim) {
    
    static auto op = create__weight_norm_differentiable_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_w, saved_v, saved_g, saved_norms, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros_names, name, "aten::zeros")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros_names, overload_name, "names")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros_names, schema_str, "zeros.names(int[] size, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::zeros.names(int[] size, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<zeros_names::schema> create_zeros_names_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(zeros_names::name, zeros_names::overload_name)
      .typed<zeros_names::schema>();
}

// aten::zeros.names(int[] size, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor zeros_names::call(at::IntArrayRef size, c10::optional<at::DimnameList> names, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_zeros_names_typed_handle();
    return op.call(size, names, dtype, layout, device, pin_memory);
}

// aten::zeros.names(int[] size, *, Dimname[]? names, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor zeros_names::redispatch(c10::DispatchKeySet dispatchKeySet, at::IntArrayRef size, c10::optional<at::DimnameList> names, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_zeros_names_typed_handle();
    return op.redispatch(dispatchKeySet, size, names, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros, name, "aten::zeros")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros, schema_str, "zeros(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::zeros(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<zeros::schema> create_zeros_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(zeros::name, zeros::overload_name)
      .typed<zeros::schema>();
}

// aten::zeros(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor zeros::call(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_zeros_typed_handle();
    return op.call(size, dtype, layout, device, pin_memory);
}

// aten::zeros(SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor zeros::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_zeros_typed_handle();
    return op.redispatch(dispatchKeySet, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros_out, name, "aten::zeros")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros_out, schema_str, "zeros.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)")

// aten::zeros.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<zeros_out::schema> create_zeros_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(zeros_out::name, zeros_out::overload_name)
      .typed<zeros_out::schema>();
}

// aten::zeros.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & zeros_out::call(c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create_zeros_out_typed_handle();
    return op.call(size, out);
}

// aten::zeros.out(SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & zeros_out::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create_zeros_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_standard_gamma, name, "aten::_standard_gamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_standard_gamma, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_standard_gamma, schema_str, "_standard_gamma(Tensor self, Generator? generator=None) -> Tensor")

// aten::_standard_gamma(Tensor self, Generator? generator=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_standard_gamma::schema> create__standard_gamma_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_standard_gamma::name, _standard_gamma::overload_name)
      .typed<_standard_gamma::schema>();
}

// aten::_standard_gamma(Tensor self, Generator? generator=None) -> Tensor
at::Tensor _standard_gamma::call(const at::Tensor & self, c10::optional<at::Generator> generator) {
    
    static auto op = create__standard_gamma_typed_handle();
    return op.call(self, generator);
}

// aten::_standard_gamma(Tensor self, Generator? generator=None) -> Tensor
at::Tensor _standard_gamma::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Generator> generator) {
    
    static auto op = create__standard_gamma_typed_handle();
    return op.redispatch(dispatchKeySet, self, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sample_dirichlet, name, "aten::_sample_dirichlet")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sample_dirichlet, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sample_dirichlet, schema_str, "_sample_dirichlet(Tensor self, Generator? generator=None) -> Tensor")

// aten::_sample_dirichlet(Tensor self, Generator? generator=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_sample_dirichlet::schema> create__sample_dirichlet_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sample_dirichlet::name, _sample_dirichlet::overload_name)
      .typed<_sample_dirichlet::schema>();
}

// aten::_sample_dirichlet(Tensor self, Generator? generator=None) -> Tensor
at::Tensor _sample_dirichlet::call(const at::Tensor & self, c10::optional<at::Generator> generator) {
    
    static auto op = create__sample_dirichlet_typed_handle();
    return op.call(self, generator);
}

// aten::_sample_dirichlet(Tensor self, Generator? generator=None) -> Tensor
at::Tensor _sample_dirichlet::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Generator> generator) {
    
    static auto op = create__sample_dirichlet_typed_handle();
    return op.redispatch(dispatchKeySet, self, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(binomial, name, "aten::binomial")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(binomial, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(binomial, schema_str, "binomial(Tensor count, Tensor prob, Generator? generator=None) -> Tensor")

// aten::binomial(Tensor count, Tensor prob, Generator? generator=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<binomial::schema> create_binomial_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(binomial::name, binomial::overload_name)
      .typed<binomial::schema>();
}

// aten::binomial(Tensor count, Tensor prob, Generator? generator=None) -> Tensor
at::Tensor binomial::call(const at::Tensor & count, const at::Tensor & prob, c10::optional<at::Generator> generator) {
    
    static auto op = create_binomial_typed_handle();
    return op.call(count, prob, generator);
}

// aten::binomial(Tensor count, Tensor prob, Generator? generator=None) -> Tensor
at::Tensor binomial::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & count, const at::Tensor & prob, c10::optional<at::Generator> generator) {
    
    static auto op = create_binomial_typed_handle();
    return op.redispatch(dispatchKeySet, count, prob, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum, name, "aten::_sparse_sum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum, schema_str, "_sparse_sum(Tensor self) -> Tensor")

// aten::_sparse_sum(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_sum::schema> create__sparse_sum_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_sum::name, _sparse_sum::overload_name)
      .typed<_sparse_sum::schema>();
}

// aten::_sparse_sum(Tensor self) -> Tensor
at::Tensor _sparse_sum::call(const at::Tensor & self) {
    
    static auto op = create__sparse_sum_typed_handle();
    return op.call(self);
}

// aten::_sparse_sum(Tensor self) -> Tensor
at::Tensor _sparse_sum::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__sparse_sum_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dtype, name, "aten::_sparse_sum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dtype, overload_name, "dtype")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dtype, schema_str, "_sparse_sum.dtype(Tensor self, *, ScalarType dtype) -> Tensor")

// aten::_sparse_sum.dtype(Tensor self, *, ScalarType dtype) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_sum_dtype::schema> create__sparse_sum_dtype_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_sum_dtype::name, _sparse_sum_dtype::overload_name)
      .typed<_sparse_sum_dtype::schema>();
}

// aten::_sparse_sum.dtype(Tensor self, *, ScalarType dtype) -> Tensor
at::Tensor _sparse_sum_dtype::call(const at::Tensor & self, at::ScalarType dtype) {
    
    static auto op = create__sparse_sum_dtype_typed_handle();
    return op.call(self, dtype);
}

// aten::_sparse_sum.dtype(Tensor self, *, ScalarType dtype) -> Tensor
at::Tensor _sparse_sum_dtype::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::ScalarType dtype) {
    
    static auto op = create__sparse_sum_dtype_typed_handle();
    return op.redispatch(dispatchKeySet, self, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dim, name, "aten::_sparse_sum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dim, overload_name, "dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dim, schema_str, "_sparse_sum.dim(Tensor self, int[1] dim) -> Tensor")

// aten::_sparse_sum.dim(Tensor self, int[1] dim) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_sum_dim::schema> create__sparse_sum_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_sum_dim::name, _sparse_sum_dim::overload_name)
      .typed<_sparse_sum_dim::schema>();
}

// aten::_sparse_sum.dim(Tensor self, int[1] dim) -> Tensor
at::Tensor _sparse_sum_dim::call(const at::Tensor & self, at::IntArrayRef dim) {
    
    static auto op = create__sparse_sum_dim_typed_handle();
    return op.call(self, dim);
}

// aten::_sparse_sum.dim(Tensor self, int[1] dim) -> Tensor
at::Tensor _sparse_sum_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim) {
    
    static auto op = create__sparse_sum_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dim_dtype, name, "aten::_sparse_sum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dim_dtype, overload_name, "dim_dtype")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dim_dtype, schema_str, "_sparse_sum.dim_dtype(Tensor self, int[1] dim, *, ScalarType dtype) -> Tensor")

// aten::_sparse_sum.dim_dtype(Tensor self, int[1] dim, *, ScalarType dtype) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_sum_dim_dtype::schema> create__sparse_sum_dim_dtype_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_sum_dim_dtype::name, _sparse_sum_dim_dtype::overload_name)
      .typed<_sparse_sum_dim_dtype::schema>();
}

// aten::_sparse_sum.dim_dtype(Tensor self, int[1] dim, *, ScalarType dtype) -> Tensor
at::Tensor _sparse_sum_dim_dtype::call(const at::Tensor & self, at::IntArrayRef dim, at::ScalarType dtype) {
    
    static auto op = create__sparse_sum_dim_dtype_typed_handle();
    return op.call(self, dim, dtype);
}

// aten::_sparse_sum.dim_dtype(Tensor self, int[1] dim, *, ScalarType dtype) -> Tensor
at::Tensor _sparse_sum_dim_dtype::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim, at::ScalarType dtype) {
    
    static auto op = create__sparse_sum_dim_dtype_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_addmm, name, "aten::_sparse_addmm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_addmm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_addmm, schema_str, "_sparse_addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor")

// aten::_sparse_addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_addmm::schema> create__sparse_addmm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_addmm::name, _sparse_addmm::overload_name)
      .typed<_sparse_addmm::schema>();
}

// aten::_sparse_addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor
at::Tensor _sparse_addmm::call(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    
    static auto op = create__sparse_addmm_typed_handle();
    return op.call(self, mat1, mat2, beta, alpha);
}

// aten::_sparse_addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor
at::Tensor _sparse_addmm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    
    static auto op = create__sparse_addmm_typed_handle();
    return op.redispatch(dispatchKeySet, self, mat1, mat2, beta, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_mm_reduce_impl_backward, name, "aten::_sparse_mm_reduce_impl_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_mm_reduce_impl_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_mm_reduce_impl_backward, schema_str, "_sparse_mm_reduce_impl_backward(Tensor self, Tensor grad_out, Tensor weight, str reduce, Tensor arg_out, bool[2] output_mask) -> (Tensor, Tensor)")

// aten::_sparse_mm_reduce_impl_backward(Tensor self, Tensor grad_out, Tensor weight, str reduce, Tensor arg_out, bool[2] output_mask) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_mm_reduce_impl_backward::schema> create__sparse_mm_reduce_impl_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_mm_reduce_impl_backward::name, _sparse_mm_reduce_impl_backward::overload_name)
      .typed<_sparse_mm_reduce_impl_backward::schema>();
}

// aten::_sparse_mm_reduce_impl_backward(Tensor self, Tensor grad_out, Tensor weight, str reduce, Tensor arg_out, bool[2] output_mask) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _sparse_mm_reduce_impl_backward::call(const at::Tensor & self, const at::Tensor & grad_out, const at::Tensor & weight, c10::string_view reduce, const at::Tensor & arg_out, ::std::array<bool,2> output_mask) {
    
    static auto op = create__sparse_mm_reduce_impl_backward_typed_handle();
    return op.call(self, grad_out, weight, reduce, arg_out, output_mask);
}

// aten::_sparse_mm_reduce_impl_backward(Tensor self, Tensor grad_out, Tensor weight, str reduce, Tensor arg_out, bool[2] output_mask) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> _sparse_mm_reduce_impl_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & grad_out, const at::Tensor & weight, c10::string_view reduce, const at::Tensor & arg_out, ::std::array<bool,2> output_mask) {
    
    static auto op = create__sparse_mm_reduce_impl_backward_typed_handle();
    return op.redispatch(dispatchKeySet, self, grad_out, weight, reduce, arg_out, output_mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addmm_out, name, "aten::addmm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addmm_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addmm_out, schema_str, "addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")

// aten::addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<addmm_out::schema> create_addmm_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(addmm_out::name, addmm_out::overload_name)
      .typed<addmm_out::schema>();
}

// aten::addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & addmm_out::call(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_addmm_out_typed_handle();
    return op.call(self, mat1, mat2, beta, alpha, out);
}

// aten::addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & addmm_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create_addmm_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, mat1, mat2, beta, alpha, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addmm, name, "aten::addmm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addmm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addmm, schema_str, "addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor")

// aten::addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<addmm::schema> create_addmm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(addmm::name, addmm::overload_name)
      .typed<addmm::schema>();
}

// aten::addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor
at::Tensor addmm::call(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    
    static auto op = create_addmm_typed_handle();
    return op.call(self, mat1, mat2, beta, alpha);
}

// aten::addmm(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor
at::Tensor addmm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    
    static auto op = create_addmm_typed_handle();
    return op.redispatch(dispatchKeySet, self, mat1, mat2, beta, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addmm_, name, "aten::addmm_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addmm_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addmm_, schema_str, "addmm_(Tensor(a!) self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor(a!)")

// aten::addmm_(Tensor(a!) self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<addmm_::schema> create_addmm__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(addmm_::name, addmm_::overload_name)
      .typed<addmm_::schema>();
}

// aten::addmm_(Tensor(a!) self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor(a!)
at::Tensor & addmm_::call(at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    
    static auto op = create_addmm__typed_handle();
    return op.call(self, mat1, mat2, beta, alpha);
}

// aten::addmm_(Tensor(a!) self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1) -> Tensor(a!)
at::Tensor & addmm_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    
    static auto op = create_addmm__typed_handle();
    return op.redispatch(dispatchKeySet, self, mat1, mat2, beta, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_csc_tensor_ccol_row_value_size, name, "aten::sparse_csc_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_csc_tensor_ccol_row_value_size, overload_name, "ccol_row_value_size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_csc_tensor_ccol_row_value_size, schema_str, "sparse_csc_tensor.ccol_row_value_size(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor")

// aten::sparse_csc_tensor.ccol_row_value_size(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_csc_tensor_ccol_row_value_size::schema> create_sparse_csc_tensor_ccol_row_value_size_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_csc_tensor_ccol_row_value_size::name, sparse_csc_tensor_ccol_row_value_size::overload_name)
      .typed<sparse_csc_tensor_ccol_row_value_size::schema>();
}

// aten::sparse_csc_tensor.ccol_row_value_size(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_csc_tensor_ccol_row_value_size::call(const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_csc_tensor_ccol_row_value_size_typed_handle();
    return op.call(ccol_indices, row_indices, values, size, dtype, layout, device, pin_memory);
}

// aten::sparse_csc_tensor.ccol_row_value_size(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_csc_tensor_ccol_row_value_size::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_csc_tensor_ccol_row_value_size_typed_handle();
    return op.redispatch(dispatchKeySet, ccol_indices, row_indices, values, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsc_tensor_ccol_row_value_size, name, "aten::sparse_bsc_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsc_tensor_ccol_row_value_size, overload_name, "ccol_row_value_size")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsc_tensor_ccol_row_value_size, schema_str, "sparse_bsc_tensor.ccol_row_value_size(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor")

// aten::sparse_bsc_tensor.ccol_row_value_size(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_bsc_tensor_ccol_row_value_size::schema> create_sparse_bsc_tensor_ccol_row_value_size_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_bsc_tensor_ccol_row_value_size::name, sparse_bsc_tensor_ccol_row_value_size::overload_name)
      .typed<sparse_bsc_tensor_ccol_row_value_size::schema>();
}

// aten::sparse_bsc_tensor.ccol_row_value_size(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_bsc_tensor_ccol_row_value_size::call(const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_bsc_tensor_ccol_row_value_size_typed_handle();
    return op.call(ccol_indices, row_indices, values, size, dtype, layout, device, pin_memory);
}

// aten::sparse_bsc_tensor.ccol_row_value_size(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_bsc_tensor_ccol_row_value_size::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_bsc_tensor_ccol_row_value_size_typed_handle();
    return op.redispatch(dispatchKeySet, ccol_indices, row_indices, values, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_csc_tensor_ccol_row_value, name, "aten::sparse_csc_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_csc_tensor_ccol_row_value, overload_name, "ccol_row_value")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_csc_tensor_ccol_row_value, schema_str, "sparse_csc_tensor.ccol_row_value(Tensor ccol_indices, Tensor row_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor")

// aten::sparse_csc_tensor.ccol_row_value(Tensor ccol_indices, Tensor row_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_csc_tensor_ccol_row_value::schema> create_sparse_csc_tensor_ccol_row_value_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_csc_tensor_ccol_row_value::name, sparse_csc_tensor_ccol_row_value::overload_name)
      .typed<sparse_csc_tensor_ccol_row_value::schema>();
}

// aten::sparse_csc_tensor.ccol_row_value(Tensor ccol_indices, Tensor row_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_csc_tensor_ccol_row_value::call(const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_csc_tensor_ccol_row_value_typed_handle();
    return op.call(ccol_indices, row_indices, values, dtype, layout, device, pin_memory);
}

// aten::sparse_csc_tensor.ccol_row_value(Tensor ccol_indices, Tensor row_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_csc_tensor_ccol_row_value::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_csc_tensor_ccol_row_value_typed_handle();
    return op.redispatch(dispatchKeySet, ccol_indices, row_indices, values, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsc_tensor_ccol_row_value, name, "aten::sparse_bsc_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsc_tensor_ccol_row_value, overload_name, "ccol_row_value")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_bsc_tensor_ccol_row_value, schema_str, "sparse_bsc_tensor.ccol_row_value(Tensor ccol_indices, Tensor row_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor")

// aten::sparse_bsc_tensor.ccol_row_value(Tensor ccol_indices, Tensor row_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_bsc_tensor_ccol_row_value::schema> create_sparse_bsc_tensor_ccol_row_value_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_bsc_tensor_ccol_row_value::name, sparse_bsc_tensor_ccol_row_value::overload_name)
      .typed<sparse_bsc_tensor_ccol_row_value::schema>();
}

// aten::sparse_bsc_tensor.ccol_row_value(Tensor ccol_indices, Tensor row_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_bsc_tensor_ccol_row_value::call(const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_bsc_tensor_ccol_row_value_typed_handle();
    return op.call(ccol_indices, row_indices, values, dtype, layout, device, pin_memory);
}

// aten::sparse_bsc_tensor.ccol_row_value(Tensor ccol_indices, Tensor row_indices, Tensor values, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=False) -> Tensor
at::Tensor sparse_bsc_tensor_ccol_row_value::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create_sparse_bsc_tensor_ccol_row_value_typed_handle();
    return op.redispatch(dispatchKeySet, ccol_indices, row_indices, values, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_compressed_tensor_unsafe, name, "aten::_sparse_compressed_tensor_unsafe")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_compressed_tensor_unsafe, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_compressed_tensor_unsafe, schema_str, "_sparse_compressed_tensor_unsafe(Tensor compressed_indices, Tensor plain_indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::_sparse_compressed_tensor_unsafe(Tensor compressed_indices, Tensor plain_indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_compressed_tensor_unsafe::schema> create__sparse_compressed_tensor_unsafe_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_compressed_tensor_unsafe::name, _sparse_compressed_tensor_unsafe::overload_name)
      .typed<_sparse_compressed_tensor_unsafe::schema>();
}

// aten::_sparse_compressed_tensor_unsafe(Tensor compressed_indices, Tensor plain_indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor _sparse_compressed_tensor_unsafe::call(const at::Tensor & compressed_indices, const at::Tensor & plain_indices, const at::Tensor & values, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create__sparse_compressed_tensor_unsafe_typed_handle();
    return op.call(compressed_indices, plain_indices, values, size, dtype, layout, device, pin_memory);
}

// aten::_sparse_compressed_tensor_unsafe(Tensor compressed_indices, Tensor plain_indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor _sparse_compressed_tensor_unsafe::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & compressed_indices, const at::Tensor & plain_indices, const at::Tensor & values, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create__sparse_compressed_tensor_unsafe_typed_handle();
    return op.redispatch(dispatchKeySet, compressed_indices, plain_indices, values, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_csr_tensor_unsafe, name, "aten::_sparse_csr_tensor_unsafe")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_csr_tensor_unsafe, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_csr_tensor_unsafe, schema_str, "_sparse_csr_tensor_unsafe(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor")

// aten::_sparse_csr_tensor_unsafe(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_csr_tensor_unsafe::schema> create__sparse_csr_tensor_unsafe_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_csr_tensor_unsafe::name, _sparse_csr_tensor_unsafe::overload_name)
      .typed<_sparse_csr_tensor_unsafe::schema>();
}

// aten::_sparse_csr_tensor_unsafe(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor _sparse_csr_tensor_unsafe::call(const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create__sparse_csr_tensor_unsafe_typed_handle();
    return op.call(crow_indices, col_indices, values, size, dtype, layout, device, pin_memory);
}

// aten::_sparse_csr_tensor_unsafe(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None) -> Tensor
at::Tensor _sparse_csr_tensor_unsafe::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    
    static auto op = create__sparse_csr_tensor_unsafe_typed_handle();
    return op.redispatch(dispatchKeySet, crow_indices, col_indices, values, size, dtype, layout, device, pin_memory);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_coo_tensor_unsafe, name, "aten::_sparse_coo_tensor_unsafe")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_coo_tensor_unsafe, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_coo_tensor_unsafe, schema_str, "_sparse_coo_tensor_unsafe(Tensor indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor")

// aten::_sparse_coo_tensor_unsafe(Tensor indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_coo_tensor_unsafe::schema> create__sparse_coo_tensor_unsafe_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_coo_tensor_unsafe::name, _sparse_coo_tensor_unsafe::overload_name)
      .typed<_sparse_coo_tensor_unsafe::schema>();
}

// aten::_sparse_coo_tensor_unsafe(Tensor indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor
at::Tensor _sparse_coo_tensor_unsafe::call(const at::Tensor & indices, const at::Tensor & values, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<bool> is_coalesced) {
    
    static auto op = create__sparse_coo_tensor_unsafe_typed_handle();
    return op.call(indices, values, size, dtype, layout, device, pin_memory, is_coalesced);
}

// aten::_sparse_coo_tensor_unsafe(Tensor indices, Tensor values, SymInt[] size, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool? is_coalesced=None) -> Tensor
at::Tensor _sparse_coo_tensor_unsafe::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & indices, const at::Tensor & values, c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<bool> is_coalesced) {
    
    static auto op = create__sparse_coo_tensor_unsafe_typed_handle();
    return op.redispatch(dispatchKeySet, indices, values, size, dtype, layout, device, pin_memory, is_coalesced);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_csr_tensor_args, name, "aten::_validate_sparse_csr_tensor_args")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_csr_tensor_args, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_csr_tensor_args, schema_str, "_validate_sparse_csr_tensor_args(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size) -> ()")

// aten::_validate_sparse_csr_tensor_args(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_validate_sparse_csr_tensor_args::schema> create__validate_sparse_csr_tensor_args_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_validate_sparse_csr_tensor_args::name, _validate_sparse_csr_tensor_args::overload_name)
      .typed<_validate_sparse_csr_tensor_args::schema>();
}

// aten::_validate_sparse_csr_tensor_args(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size) -> ()
void _validate_sparse_csr_tensor_args::call(const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, at::IntArrayRef size) {
    
    static auto op = create__validate_sparse_csr_tensor_args_typed_handle();
    return op.call(crow_indices, col_indices, values, size);
}

// aten::_validate_sparse_csr_tensor_args(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size) -> ()
void _validate_sparse_csr_tensor_args::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, at::IntArrayRef size) {
    
    static auto op = create__validate_sparse_csr_tensor_args_typed_handle();
    return op.redispatch(dispatchKeySet, crow_indices, col_indices, values, size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_bsr_tensor_args, name, "aten::_validate_sparse_bsr_tensor_args")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_bsr_tensor_args, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_bsr_tensor_args, schema_str, "_validate_sparse_bsr_tensor_args(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size) -> ()")

// aten::_validate_sparse_bsr_tensor_args(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_validate_sparse_bsr_tensor_args::schema> create__validate_sparse_bsr_tensor_args_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_validate_sparse_bsr_tensor_args::name, _validate_sparse_bsr_tensor_args::overload_name)
      .typed<_validate_sparse_bsr_tensor_args::schema>();
}

// aten::_validate_sparse_bsr_tensor_args(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size) -> ()
void _validate_sparse_bsr_tensor_args::call(const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, at::IntArrayRef size) {
    
    static auto op = create__validate_sparse_bsr_tensor_args_typed_handle();
    return op.call(crow_indices, col_indices, values, size);
}

// aten::_validate_sparse_bsr_tensor_args(Tensor crow_indices, Tensor col_indices, Tensor values, int[] size) -> ()
void _validate_sparse_bsr_tensor_args::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & crow_indices, const at::Tensor & col_indices, const at::Tensor & values, at::IntArrayRef size) {
    
    static auto op = create__validate_sparse_bsr_tensor_args_typed_handle();
    return op.redispatch(dispatchKeySet, crow_indices, col_indices, values, size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_bsc_tensor_args, name, "aten::_validate_sparse_bsc_tensor_args")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_bsc_tensor_args, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_validate_sparse_bsc_tensor_args, schema_str, "_validate_sparse_bsc_tensor_args(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size) -> ()")

// aten::_validate_sparse_bsc_tensor_args(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_validate_sparse_bsc_tensor_args::schema> create__validate_sparse_bsc_tensor_args_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_validate_sparse_bsc_tensor_args::name, _validate_sparse_bsc_tensor_args::overload_name)
      .typed<_validate_sparse_bsc_tensor_args::schema>();
}

// aten::_validate_sparse_bsc_tensor_args(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size) -> ()
void _validate_sparse_bsc_tensor_args::call(const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, at::IntArrayRef size) {
    
    static auto op = create__validate_sparse_bsc_tensor_args_typed_handle();
    return op.call(ccol_indices, row_indices, values, size);
}

// aten::_validate_sparse_bsc_tensor_args(Tensor ccol_indices, Tensor row_indices, Tensor values, int[] size) -> ()
void _validate_sparse_bsc_tensor_args::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & ccol_indices, const at::Tensor & row_indices, const at::Tensor & values, at::IntArrayRef size) {
    
    static auto op = create__validate_sparse_bsc_tensor_args_typed_handle();
    return op.redispatch(dispatchKeySet, ccol_indices, row_indices, values, size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_, name, "aten::sparse_resize_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_, schema_str, "sparse_resize_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)")

// aten::sparse_resize_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sparse_resize_::schema> create_sparse_resize__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_resize_::name, sparse_resize_::overload_name)
      .typed<sparse_resize_::schema>();
}

// aten::sparse_resize_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)
const at::Tensor & sparse_resize_::call(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
    
    static auto op = create_sparse_resize__typed_handle();
    return op.call(self, size, sparse_dim, dense_dim);
}

// aten::sparse_resize_(Tensor(a!) self, int[] size, int sparse_dim, int dense_dim) -> Tensor(a!)
const at::Tensor & sparse_resize_::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
    
    static auto op = create_sparse_resize__typed_handle();
    return op.redispatch(dispatchKeySet, self, size, sparse_dim, dense_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_mask, name, "aten::sparse_mask")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_mask, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_mask, schema_str, "sparse_mask(Tensor self, Tensor mask) -> Tensor")

// aten::sparse_mask(Tensor self, Tensor mask) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_mask::schema> create_sparse_mask_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_mask::name, sparse_mask::overload_name)
      .typed<sparse_mask::schema>();
}

// aten::sparse_mask(Tensor self, Tensor mask) -> Tensor
at::Tensor sparse_mask::call(const at::Tensor & self, const at::Tensor & mask) {
    
    static auto op = create_sparse_mask_typed_handle();
    return op.call(self, mask);
}

// aten::sparse_mask(Tensor self, Tensor mask) -> Tensor
at::Tensor sparse_mask::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask) {
    
    static auto op = create_sparse_mask_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_cpu, name, "aten::_to_cpu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_cpu, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_cpu, schema_str, "_to_cpu(Tensor[] tensors) -> Tensor[]")

// aten::_to_cpu(Tensor[] tensors) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_to_cpu::schema> create__to_cpu_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_to_cpu::name, _to_cpu::overload_name)
      .typed<_to_cpu::schema>();
}

// aten::_to_cpu(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> _to_cpu::call(at::TensorList tensors) {
    
    static auto op = create__to_cpu_typed_handle();
    return op.call(tensors);
}

// aten::_to_cpu(Tensor[] tensors) -> Tensor[]
::std::vector<at::Tensor> _to_cpu::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors) {
    
    static auto op = create__to_cpu_typed_handle();
    return op.redispatch(dispatchKeySet, tensors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(values, name, "aten::values")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(values, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(values, schema_str, "values(Tensor(a) self) -> Tensor(a)")

// aten::values(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<values::schema> create_values_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(values::name, values::overload_name)
      .typed<values::schema>();
}

// aten::values(Tensor(a) self) -> Tensor(a)
at::Tensor values::call(const at::Tensor & self) {
    
    static auto op = create_values_typed_handle();
    return op.call(self);
}

// aten::values(Tensor(a) self) -> Tensor(a)
at::Tensor values::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_values_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(row_indices, name, "aten::row_indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(row_indices, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(row_indices, schema_str, "row_indices(Tensor(a) self) -> Tensor(a)")

// aten::row_indices(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<row_indices::schema> create_row_indices_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(row_indices::name, row_indices::overload_name)
      .typed<row_indices::schema>();
}

// aten::row_indices(Tensor(a) self) -> Tensor(a)
at::Tensor row_indices::call(const at::Tensor & self) {
    
    static auto op = create_row_indices_typed_handle();
    return op.call(self);
}

// aten::row_indices(Tensor(a) self) -> Tensor(a)
at::Tensor row_indices::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_row_indices_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copy_sparse_to_sparse_, name, "aten::copy_sparse_to_sparse_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copy_sparse_to_sparse_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copy_sparse_to_sparse_, schema_str, "copy_sparse_to_sparse_(Tensor(a!) self, Tensor src, bool non_blocking=False) -> Tensor(a!)")

// aten::copy_sparse_to_sparse_(Tensor(a!) self, Tensor src, bool non_blocking=False) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<copy_sparse_to_sparse_::schema> create_copy_sparse_to_sparse__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(copy_sparse_to_sparse_::name, copy_sparse_to_sparse_::overload_name)
      .typed<copy_sparse_to_sparse_::schema>();
}

// aten::copy_sparse_to_sparse_(Tensor(a!) self, Tensor src, bool non_blocking=False) -> Tensor(a!)
at::Tensor & copy_sparse_to_sparse_::call(at::Tensor & self, const at::Tensor & src, bool non_blocking) {
    
    static auto op = create_copy_sparse_to_sparse__typed_handle();
    return op.call(self, src, non_blocking);
}

// aten::copy_sparse_to_sparse_(Tensor(a!) self, Tensor src, bool non_blocking=False) -> Tensor(a!)
at::Tensor & copy_sparse_to_sparse_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & src, bool non_blocking) {
    
    static auto op = create_copy_sparse_to_sparse__typed_handle();
    return op.redispatch(dispatchKeySet, self, src, non_blocking);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_int, name, "aten::unbind")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_int, overload_name, "int")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_int, schema_str, "unbind.int(Tensor(a -> *) self, int dim=0) -> Tensor(a)[]")

// aten::unbind.int(Tensor(a -> *) self, int dim=0) -> Tensor(a)[]
static C10_NOINLINE c10::TypedOperatorHandle<unbind_int::schema> create_unbind_int_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unbind_int::name, unbind_int::overload_name)
      .typed<unbind_int::schema>();
}

// aten::unbind.int(Tensor(a -> *) self, int dim=0) -> Tensor(a)[]
::std::vector<at::Tensor> unbind_int::call(const at::Tensor & self, int64_t dim) {
    
    static auto op = create_unbind_int_typed_handle();
    return op.call(self, dim);
}

// aten::unbind.int(Tensor(a -> *) self, int dim=0) -> Tensor(a)[]
::std::vector<at::Tensor> unbind_int::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim) {
    
    static auto op = create_unbind_int_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_Dimname, name, "aten::unbind")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_Dimname, overload_name, "Dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unbind_Dimname, schema_str, "unbind.Dimname(Tensor(a -> *) self, Dimname dim) -> Tensor(a)[]")

// aten::unbind.Dimname(Tensor(a -> *) self, Dimname dim) -> Tensor(a)[]
static C10_NOINLINE c10::TypedOperatorHandle<unbind_Dimname::schema> create_unbind_Dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unbind_Dimname::name, unbind_Dimname::overload_name)
      .typed<unbind_Dimname::schema>();
}

// aten::unbind.Dimname(Tensor(a -> *) self, Dimname dim) -> Tensor(a)[]
::std::vector<at::Tensor> unbind_Dimname::call(const at::Tensor & self, at::Dimname dim) {
    
    static auto op = create_unbind_Dimname_typed_handle();
    return op.call(self, dim);
}

// aten::unbind.Dimname(Tensor(a -> *) self, Dimname dim) -> Tensor(a)[]
::std::vector<at::Tensor> unbind_Dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim) {
    
    static auto op = create_unbind_Dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse_sparse_dim, name, "aten::to_sparse")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse_sparse_dim, overload_name, "sparse_dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse_sparse_dim, schema_str, "to_sparse.sparse_dim(Tensor self, int sparse_dim) -> Tensor")

// aten::to_sparse.sparse_dim(Tensor self, int sparse_dim) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<to_sparse_sparse_dim::schema> create_to_sparse_sparse_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_sparse_sparse_dim::name, to_sparse_sparse_dim::overload_name)
      .typed<to_sparse_sparse_dim::schema>();
}

// aten::to_sparse.sparse_dim(Tensor self, int sparse_dim) -> Tensor
at::Tensor to_sparse_sparse_dim::call(const at::Tensor & self, int64_t sparse_dim) {
    
    static auto op = create_to_sparse_sparse_dim_typed_handle();
    return op.call(self, sparse_dim);
}

// aten::to_sparse.sparse_dim(Tensor self, int sparse_dim) -> Tensor
at::Tensor to_sparse_sparse_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t sparse_dim) {
    
    static auto op = create_to_sparse_sparse_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, sparse_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse, name, "aten::to_sparse")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_sparse, schema_str, "to_sparse(Tensor self, *, Layout? layout=None, int[2]? blocksize=None, int? dense_dim=None) -> Tensor")

// aten::to_sparse(Tensor self, *, Layout? layout=None, int[2]? blocksize=None, int? dense_dim=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<to_sparse::schema> create_to_sparse_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_sparse::name, to_sparse::overload_name)
      .typed<to_sparse::schema>();
}

// aten::to_sparse(Tensor self, *, Layout? layout=None, int[2]? blocksize=None, int? dense_dim=None) -> Tensor
at::Tensor to_sparse::call(const at::Tensor & self, c10::optional<at::Layout> layout, at::OptionalIntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
    
    static auto op = create_to_sparse_typed_handle();
    return op.call(self, layout, blocksize, dense_dim);
}

// aten::to_sparse(Tensor self, *, Layout? layout=None, int[2]? blocksize=None, int? dense_dim=None) -> Tensor
at::Tensor to_sparse::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Layout> layout, at::OptionalIntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
    
    static auto op = create_to_sparse_typed_handle();
    return op.redispatch(dispatchKeySet, self, layout, blocksize, dense_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_mkldnn, name, "aten::to_mkldnn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_mkldnn, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_mkldnn, schema_str, "to_mkldnn(Tensor self, ScalarType? dtype=None) -> Tensor")

// aten::to_mkldnn(Tensor self, ScalarType? dtype=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<to_mkldnn::schema> create_to_mkldnn_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_mkldnn::name, to_mkldnn::overload_name)
      .typed<to_mkldnn::schema>();
}

// aten::to_mkldnn(Tensor self, ScalarType? dtype=None) -> Tensor
at::Tensor to_mkldnn::call(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_to_mkldnn_typed_handle();
    return op.call(self, dtype);
}

// aten::to_mkldnn(Tensor self, ScalarType? dtype=None) -> Tensor
at::Tensor to_mkldnn::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_to_mkldnn_typed_handle();
    return op.redispatch(dispatchKeySet, self, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_mkldnn_backward, name, "aten::to_mkldnn_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_mkldnn_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_mkldnn_backward, schema_str, "to_mkldnn_backward(Tensor grad, Tensor input) -> Tensor")

// aten::to_mkldnn_backward(Tensor grad, Tensor input) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<to_mkldnn_backward::schema> create_to_mkldnn_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_mkldnn_backward::name, to_mkldnn_backward::overload_name)
      .typed<to_mkldnn_backward::schema>();
}

// aten::to_mkldnn_backward(Tensor grad, Tensor input) -> Tensor
at::Tensor to_mkldnn_backward::call(const at::Tensor & grad, const at::Tensor & input) {
    
    static auto op = create_to_mkldnn_backward_typed_handle();
    return op.call(grad, input);
}

// aten::to_mkldnn_backward(Tensor grad, Tensor input) -> Tensor
at::Tensor to_mkldnn_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & input) {
    
    static auto op = create_to_mkldnn_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(int_repr, name, "aten::int_repr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(int_repr, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(int_repr, schema_str, "int_repr(Tensor self) -> Tensor")

// aten::int_repr(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<int_repr::schema> create_int_repr_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(int_repr::name, int_repr::overload_name)
      .typed<int_repr::schema>();
}

// aten::int_repr(Tensor self) -> Tensor
at::Tensor int_repr::call(const at::Tensor & self) {
    
    static auto op = create_int_repr_typed_handle();
    return op.call(self);
}

// aten::int_repr(Tensor self) -> Tensor
at::Tensor int_repr::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_int_repr_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(qscheme, name, "aten::qscheme")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(qscheme, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(qscheme, schema_str, "qscheme(Tensor self) -> QScheme")

// aten::qscheme(Tensor self) -> QScheme
static C10_NOINLINE c10::TypedOperatorHandle<qscheme::schema> create_qscheme_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(qscheme::name, qscheme::overload_name)
      .typed<qscheme::schema>();
}

// aten::qscheme(Tensor self) -> QScheme
at::QScheme qscheme::call(const at::Tensor & self) {
    
    static auto op = create_qscheme_typed_handle();
    return op.call(self);
}

// aten::qscheme(Tensor self) -> QScheme
at::QScheme qscheme::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_qscheme_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine, name, "aten::fake_quantize_per_channel_affine")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine, schema_str, "fake_quantize_per_channel_affine(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max) -> Tensor")

// aten::fake_quantize_per_channel_affine(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fake_quantize_per_channel_affine::schema> create_fake_quantize_per_channel_affine_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fake_quantize_per_channel_affine::name, fake_quantize_per_channel_affine::overload_name)
      .typed<fake_quantize_per_channel_affine::schema>();
}

// aten::fake_quantize_per_channel_affine(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max) -> Tensor
at::Tensor fake_quantize_per_channel_affine::call(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
    
    static auto op = create_fake_quantize_per_channel_affine_typed_handle();
    return op.call(self, scale, zero_point, axis, quant_min, quant_max);
}

// aten::fake_quantize_per_channel_affine(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max) -> Tensor
at::Tensor fake_quantize_per_channel_affine::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
    
    static auto op = create_fake_quantize_per_channel_affine_typed_handle();
    return op.redispatch(dispatchKeySet, self, scale, zero_point, axis, quant_min, quant_max);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine_cachemask, name, "aten::fake_quantize_per_channel_affine_cachemask")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine_cachemask, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine_cachemask, schema_str, "fake_quantize_per_channel_affine_cachemask(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max) -> (Tensor output, Tensor mask)")

// aten::fake_quantize_per_channel_affine_cachemask(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max) -> (Tensor output, Tensor mask)
static C10_NOINLINE c10::TypedOperatorHandle<fake_quantize_per_channel_affine_cachemask::schema> create_fake_quantize_per_channel_affine_cachemask_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fake_quantize_per_channel_affine_cachemask::name, fake_quantize_per_channel_affine_cachemask::overload_name)
      .typed<fake_quantize_per_channel_affine_cachemask::schema>();
}

// aten::fake_quantize_per_channel_affine_cachemask(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max) -> (Tensor output, Tensor mask)
::std::tuple<at::Tensor,at::Tensor> fake_quantize_per_channel_affine_cachemask::call(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
    
    static auto op = create_fake_quantize_per_channel_affine_cachemask_typed_handle();
    return op.call(self, scale, zero_point, axis, quant_min, quant_max);
}

// aten::fake_quantize_per_channel_affine_cachemask(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max) -> (Tensor output, Tensor mask)
::std::tuple<at::Tensor,at::Tensor> fake_quantize_per_channel_affine_cachemask::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
    
    static auto op = create_fake_quantize_per_channel_affine_cachemask_typed_handle();
    return op.redispatch(dispatchKeySet, self, scale, zero_point, axis, quant_min, quant_max);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_moving_avg_obs_fq_helper, name, "aten::_fused_moving_avg_obs_fq_helper")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_moving_avg_obs_fq_helper, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_moving_avg_obs_fq_helper, schema_str, "_fused_moving_avg_obs_fq_helper(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor(a!) running_min, Tensor(b!) running_max, Tensor(c!) scale, Tensor(d!) zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False) -> (Tensor output, Tensor mask)")

// aten::_fused_moving_avg_obs_fq_helper(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor(a!) running_min, Tensor(b!) running_max, Tensor(c!) scale, Tensor(d!) zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False) -> (Tensor output, Tensor mask)
static C10_NOINLINE c10::TypedOperatorHandle<_fused_moving_avg_obs_fq_helper::schema> create__fused_moving_avg_obs_fq_helper_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_fused_moving_avg_obs_fq_helper::name, _fused_moving_avg_obs_fq_helper::overload_name)
      .typed<_fused_moving_avg_obs_fq_helper::schema>();
}

// aten::_fused_moving_avg_obs_fq_helper(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor(a!) running_min, Tensor(b!) running_max, Tensor(c!) scale, Tensor(d!) zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False) -> (Tensor output, Tensor mask)
::std::tuple<at::Tensor,at::Tensor> _fused_moving_avg_obs_fq_helper::call(const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, at::Tensor & running_min, at::Tensor & running_max, at::Tensor & scale, at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant) {
    
    static auto op = create__fused_moving_avg_obs_fq_helper_typed_handle();
    return op.call(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
}

// aten::_fused_moving_avg_obs_fq_helper(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor(a!) running_min, Tensor(b!) running_max, Tensor(c!) scale, Tensor(d!) zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False) -> (Tensor output, Tensor mask)
::std::tuple<at::Tensor,at::Tensor> _fused_moving_avg_obs_fq_helper::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, at::Tensor & running_min, at::Tensor & running_max, at::Tensor & scale, at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant) {
    
    static auto op = create__fused_moving_avg_obs_fq_helper_typed_handle();
    return op.redispatch(dispatchKeySet, self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_copy, name, "aten::_to_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_copy, schema_str, "_to_copy(Tensor self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool non_blocking=False, MemoryFormat? memory_format=None) -> Tensor")

// aten::_to_copy(Tensor self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool non_blocking=False, MemoryFormat? memory_format=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_to_copy::schema> create__to_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_to_copy::name, _to_copy::overload_name)
      .typed<_to_copy::schema>();
}

// aten::_to_copy(Tensor self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool non_blocking=False, MemoryFormat? memory_format=None) -> Tensor
at::Tensor _to_copy::call(const at::Tensor & self, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, bool non_blocking, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create__to_copy_typed_handle();
    return op.call(self, dtype, layout, device, pin_memory, non_blocking, memory_format);
}

// aten::_to_copy(Tensor self, *, ScalarType? dtype=None, Layout? layout=None, Device? device=None, bool? pin_memory=None, bool non_blocking=False, MemoryFormat? memory_format=None) -> Tensor
at::Tensor _to_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, bool non_blocking, c10::optional<at::MemoryFormat> memory_format) {
    
    static auto op = create__to_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, dtype, layout, device, pin_memory, non_blocking, memory_format);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_thnn_differentiable_lstm_cell_backward, name, "aten::_thnn_differentiable_lstm_cell_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_thnn_differentiable_lstm_cell_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_thnn_differentiable_lstm_cell_backward, schema_str, "_thnn_differentiable_lstm_cell_backward(Tensor? grad_hy, Tensor? grad_cy, Tensor input_gates, Tensor hidden_gates, Tensor? input_bias, Tensor? hidden_bias, Tensor cx, Tensor cy) -> (Tensor, Tensor, Tensor, Tensor, Tensor)")

// aten::_thnn_differentiable_lstm_cell_backward(Tensor? grad_hy, Tensor? grad_cy, Tensor input_gates, Tensor hidden_gates, Tensor? input_bias, Tensor? hidden_bias, Tensor cx, Tensor cy) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_thnn_differentiable_lstm_cell_backward::schema> create__thnn_differentiable_lstm_cell_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_thnn_differentiable_lstm_cell_backward::name, _thnn_differentiable_lstm_cell_backward::overload_name)
      .typed<_thnn_differentiable_lstm_cell_backward::schema>();
}

// aten::_thnn_differentiable_lstm_cell_backward(Tensor? grad_hy, Tensor? grad_cy, Tensor input_gates, Tensor hidden_gates, Tensor? input_bias, Tensor? hidden_bias, Tensor cx, Tensor cy) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _thnn_differentiable_lstm_cell_backward::call(const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, const at::Tensor & input_gates, const at::Tensor & hidden_gates, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias, const at::Tensor & cx, const at::Tensor & cy) {
    
    static auto op = create__thnn_differentiable_lstm_cell_backward_typed_handle();
    return op.call(grad_hy, grad_cy, input_gates, hidden_gates, input_bias, hidden_bias, cx, cy);
}

// aten::_thnn_differentiable_lstm_cell_backward(Tensor? grad_hy, Tensor? grad_cy, Tensor input_gates, Tensor hidden_gates, Tensor? input_bias, Tensor? hidden_bias, Tensor cx, Tensor cy) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _thnn_differentiable_lstm_cell_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, const at::Tensor & input_gates, const at::Tensor & hidden_gates, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias, const at::Tensor & cx, const at::Tensor & cy) {
    
    static auto op = create__thnn_differentiable_lstm_cell_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_hy, grad_cy, input_gates, hidden_gates, input_bias, hidden_bias, cx, cy);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_thnn_differentiable_gru_cell_backward, name, "aten::_thnn_differentiable_gru_cell_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_thnn_differentiable_gru_cell_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_thnn_differentiable_gru_cell_backward, schema_str, "_thnn_differentiable_gru_cell_backward(Tensor grad_hy, Tensor input_gates, Tensor hidden_gates, Tensor hx, Tensor? input_bias, Tensor? hidden_bias) -> (Tensor, Tensor, Tensor, Tensor, Tensor)")

// aten::_thnn_differentiable_gru_cell_backward(Tensor grad_hy, Tensor input_gates, Tensor hidden_gates, Tensor hx, Tensor? input_bias, Tensor? hidden_bias) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<_thnn_differentiable_gru_cell_backward::schema> create__thnn_differentiable_gru_cell_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_thnn_differentiable_gru_cell_backward::name, _thnn_differentiable_gru_cell_backward::overload_name)
      .typed<_thnn_differentiable_gru_cell_backward::schema>();
}

// aten::_thnn_differentiable_gru_cell_backward(Tensor grad_hy, Tensor input_gates, Tensor hidden_gates, Tensor hx, Tensor? input_bias, Tensor? hidden_bias) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _thnn_differentiable_gru_cell_backward::call(const at::Tensor & grad_hy, const at::Tensor & input_gates, const at::Tensor & hidden_gates, const at::Tensor & hx, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias) {
    
    static auto op = create__thnn_differentiable_gru_cell_backward_typed_handle();
    return op.call(grad_hy, input_gates, hidden_gates, hx, input_bias, hidden_bias);
}

// aten::_thnn_differentiable_gru_cell_backward(Tensor grad_hy, Tensor input_gates, Tensor hidden_gates, Tensor hx, Tensor? input_bias, Tensor? hidden_bias) -> (Tensor, Tensor, Tensor, Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _thnn_differentiable_gru_cell_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_hy, const at::Tensor & input_gates, const at::Tensor & hidden_gates, const at::Tensor & hx, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias) {
    
    static auto op = create__thnn_differentiable_gru_cell_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_hy, input_gates, hidden_gates, hx, input_bias, hidden_bias);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rnn_tanh_cell, name, "aten::rnn_tanh_cell")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rnn_tanh_cell, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rnn_tanh_cell, schema_str, "rnn_tanh_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -> Tensor")

// aten::rnn_tanh_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<rnn_tanh_cell::schema> create_rnn_tanh_cell_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(rnn_tanh_cell::name, rnn_tanh_cell::overload_name)
      .typed<rnn_tanh_cell::schema>();
}

// aten::rnn_tanh_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -> Tensor
at::Tensor rnn_tanh_cell::call(const at::Tensor & input, const at::Tensor & hx, const at::Tensor & w_ih, const at::Tensor & w_hh, const c10::optional<at::Tensor> & b_ih, const c10::optional<at::Tensor> & b_hh) {
    
    static auto op = create_rnn_tanh_cell_typed_handle();
    return op.call(input, hx, w_ih, w_hh, b_ih, b_hh);
}

// aten::rnn_tanh_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor? b_ih=None, Tensor? b_hh=None) -> Tensor
at::Tensor rnn_tanh_cell::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & hx, const at::Tensor & w_ih, const at::Tensor & w_hh, const c10::optional<at::Tensor> & b_ih, const c10::optional<at::Tensor> & b_hh) {
    
    static auto op = create_rnn_tanh_cell_typed_handle();
    return op.redispatch(dispatchKeySet, input, hx, w_ih, w_hh, b_ih, b_hh);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_gru_cell, name, "aten::quantized_gru_cell")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_gru_cell, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_gru_cell, schema_str, "quantized_gru_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -> Tensor")

// aten::quantized_gru_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<quantized_gru_cell::schema> create_quantized_gru_cell_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(quantized_gru_cell::name, quantized_gru_cell::overload_name)
      .typed<quantized_gru_cell::schema>();
}

// aten::quantized_gru_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -> Tensor
at::Tensor quantized_gru_cell::call(const at::Tensor & input, const at::Tensor & hx, const at::Tensor & w_ih, const at::Tensor & w_hh, const at::Tensor & b_ih, const at::Tensor & b_hh, const at::Tensor & packed_ih, const at::Tensor & packed_hh, const at::Tensor & col_offsets_ih, const at::Tensor & col_offsets_hh, const at::Scalar & scale_ih, const at::Scalar & scale_hh, const at::Scalar & zero_point_ih, const at::Scalar & zero_point_hh) {
    
    static auto op = create_quantized_gru_cell_typed_handle();
    return op.call(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh);
}

// aten::quantized_gru_cell(Tensor input, Tensor hx, Tensor w_ih, Tensor w_hh, Tensor b_ih, Tensor b_hh, Tensor packed_ih, Tensor packed_hh, Tensor col_offsets_ih, Tensor col_offsets_hh, Scalar scale_ih, Scalar scale_hh, Scalar zero_point_ih, Scalar zero_point_hh) -> Tensor
at::Tensor quantized_gru_cell::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & hx, const at::Tensor & w_ih, const at::Tensor & w_hh, const at::Tensor & b_ih, const at::Tensor & b_hh, const at::Tensor & packed_ih, const at::Tensor & packed_hh, const at::Tensor & col_offsets_ih, const at::Tensor & col_offsets_hh, const at::Scalar & scale_ih, const at::Scalar & scale_hh, const at::Scalar & zero_point_ih, const at::Scalar & zero_point_hh) {
    
    static auto op = create_quantized_gru_cell_typed_handle();
    return op.redispatch(dispatchKeySet, input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pack_padded_sequence_backward, name, "aten::_pack_padded_sequence_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pack_padded_sequence_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pack_padded_sequence_backward, schema_str, "_pack_padded_sequence_backward(Tensor grad, SymInt[] input_size, Tensor batch_sizes, bool batch_first) -> Tensor")

// aten::_pack_padded_sequence_backward(Tensor grad, SymInt[] input_size, Tensor batch_sizes, bool batch_first) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_pack_padded_sequence_backward::schema> create__pack_padded_sequence_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_pack_padded_sequence_backward::name, _pack_padded_sequence_backward::overload_name)
      .typed<_pack_padded_sequence_backward::schema>();
}

// aten::_pack_padded_sequence_backward(Tensor grad, SymInt[] input_size, Tensor batch_sizes, bool batch_first) -> Tensor
at::Tensor _pack_padded_sequence_backward::call(const at::Tensor & grad, c10::SymIntArrayRef input_size, const at::Tensor & batch_sizes, bool batch_first) {
    
    static auto op = create__pack_padded_sequence_backward_typed_handle();
    return op.call(grad, input_size, batch_sizes, batch_first);
}

// aten::_pack_padded_sequence_backward(Tensor grad, SymInt[] input_size, Tensor batch_sizes, bool batch_first) -> Tensor
at::Tensor _pack_padded_sequence_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, c10::SymIntArrayRef input_size, const at::Tensor & batch_sizes, bool batch_first) {
    
    static auto op = create__pack_padded_sequence_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, input_size, batch_sizes, batch_first);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lift, name, "aten::lift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lift, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lift, schema_str, "lift(Tensor self) -> Tensor")

// aten::lift(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<lift::schema> create_lift_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lift::name, lift::overload_name)
      .typed<lift::schema>();
}

// aten::lift(Tensor self) -> Tensor
at::Tensor lift::call(const at::Tensor & self) {
    
    static auto op = create_lift_typed_handle();
    return op.call(self);
}

// aten::lift(Tensor self) -> Tensor
at::Tensor lift::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_lift_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lift_fresh, name, "aten::lift_fresh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lift_fresh, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lift_fresh, schema_str, "lift_fresh(Tensor(a) self) -> Tensor(a)")

// aten::lift_fresh(Tensor(a) self) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<lift_fresh::schema> create_lift_fresh_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lift_fresh::name, lift_fresh::overload_name)
      .typed<lift_fresh::schema>();
}

// aten::lift_fresh(Tensor(a) self) -> Tensor(a)
at::Tensor lift_fresh::call(const at::Tensor & self) {
    
    static auto op = create_lift_fresh_typed_handle();
    return op.call(self);
}

// aten::lift_fresh(Tensor(a) self) -> Tensor(a)
at::Tensor lift_fresh::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_lift_fresh_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq__Scalar, name, "aten::eq_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq__Scalar, schema_str, "eq_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::eq_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<eq__Scalar::schema> create_eq__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(eq__Scalar::name, eq__Scalar::overload_name)
      .typed<eq__Scalar::schema>();
}

// aten::eq_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & eq__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_eq__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::eq_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & eq__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_eq__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq__Tensor, name, "aten::eq_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq__Tensor, schema_str, "eq_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::eq_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<eq__Tensor::schema> create_eq__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(eq__Tensor::name, eq__Tensor::overload_name)
      .typed<eq__Tensor::schema>();
}

// aten::eq_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & eq__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_eq__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::eq_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & eq__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_eq__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Tensor_out, name, "aten::bitwise_and")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Tensor_out, schema_str, "bitwise_and.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_and.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_and_Tensor_out::schema> create_bitwise_and_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_and_Tensor_out::name, bitwise_and_Tensor_out::overload_name)
      .typed<bitwise_and_Tensor_out::schema>();
}

// aten::bitwise_and.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_and_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_and_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_and.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_and_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_and_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar_out, name, "aten::bitwise_and")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar_out, schema_str, "bitwise_and.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_and.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_and_Scalar_out::schema> create_bitwise_and_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_and_Scalar_out::name, bitwise_and_Scalar_out::overload_name)
      .typed<bitwise_and_Scalar_out::schema>();
}

// aten::bitwise_and.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_and_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_and_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_and.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_and_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_and_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar, name, "aten::bitwise_and")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar, schema_str, "bitwise_and.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::bitwise_and.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_and_Scalar::schema> create_bitwise_and_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_and_Scalar::name, bitwise_and_Scalar::overload_name)
      .typed<bitwise_and_Scalar::schema>();
}

// aten::bitwise_and.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_and_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_and_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_and.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_and_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_and_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar_Tensor, name, "aten::bitwise_and")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar_Tensor, overload_name, "Scalar_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar_Tensor, schema_str, "bitwise_and.Scalar_Tensor(Scalar self, Tensor other) -> Tensor")

// aten::bitwise_and.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_and_Scalar_Tensor::schema> create_bitwise_and_Scalar_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_and_Scalar_Tensor::name, bitwise_and_Scalar_Tensor::overload_name)
      .typed<bitwise_and_Scalar_Tensor::schema>();
}

// aten::bitwise_and.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_and_Scalar_Tensor::call(const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_and_Scalar_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_and.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_and_Scalar_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_and_Scalar_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Tensor, name, "aten::bitwise_and")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Tensor, schema_str, "bitwise_and.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::bitwise_and.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_and_Tensor::schema> create_bitwise_and_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_and_Tensor::name, bitwise_and_Tensor::overload_name)
      .typed<bitwise_and_Tensor::schema>();
}

// aten::bitwise_and.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_and_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_and_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_and.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_and_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_and_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and__Scalar, name, "aten::bitwise_and_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and__Scalar, schema_str, "bitwise_and_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::bitwise_and_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_and__Scalar::schema> create_bitwise_and__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_and__Scalar::name, bitwise_and__Scalar::overload_name)
      .typed<bitwise_and__Scalar::schema>();
}

// aten::bitwise_and_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_and__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_and__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_and_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_and__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_and__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and__Tensor, name, "aten::bitwise_and_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and__Tensor, schema_str, "bitwise_and_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::bitwise_and_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_and__Tensor::schema> create_bitwise_and__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_and__Tensor::name, bitwise_and__Tensor::overload_name)
      .typed<bitwise_and__Tensor::schema>();
}

// aten::bitwise_and_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_and__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_and__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_and_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_and__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_and__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__or___Scalar, name, "aten::__or__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__or___Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__or___Scalar, schema_str, "__or__.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::__or__.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<__or___Scalar::schema> create___or___Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__or___Scalar::name, __or___Scalar::overload_name)
      .typed<__or___Scalar::schema>();
}

// aten::__or__.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor __or___Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___or___Scalar_typed_handle();
    return op.call(self, other);
}

// aten::__or__.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor __or___Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___or___Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__or___Tensor, name, "aten::__or__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__or___Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__or___Tensor, schema_str, "__or__.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::__or__.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<__or___Tensor::schema> create___or___Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__or___Tensor::name, __or___Tensor::overload_name)
      .typed<__or___Tensor::schema>();
}

// aten::__or__.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor __or___Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___or___Tensor_typed_handle();
    return op.call(self, other);
}

// aten::__or__.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor __or___Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___or___Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ior___Scalar, name, "aten::__ior__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ior___Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ior___Scalar, schema_str, "__ior__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::__ior__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__ior___Scalar::schema> create___ior___Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__ior___Scalar::name, __ior___Scalar::overload_name)
      .typed<__ior___Scalar::schema>();
}

// aten::__ior__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & __ior___Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___ior___Scalar_typed_handle();
    return op.call(self, other);
}

// aten::__ior__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & __ior___Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___ior___Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ior___Tensor, name, "aten::__ior__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ior___Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ior___Tensor, schema_str, "__ior__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::__ior__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__ior___Tensor::schema> create___ior___Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__ior___Tensor::name, __ior___Tensor::overload_name)
      .typed<__ior___Tensor::schema>();
}

// aten::__ior__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & __ior___Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___ior___Tensor_typed_handle();
    return op.call(self, other);
}

// aten::__ior__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & __ior___Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___ior___Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Tensor_out, name, "aten::bitwise_xor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Tensor_out, schema_str, "bitwise_xor.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_xor.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_xor_Tensor_out::schema> create_bitwise_xor_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_xor_Tensor_out::name, bitwise_xor_Tensor_out::overload_name)
      .typed<bitwise_xor_Tensor_out::schema>();
}

// aten::bitwise_xor.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_xor_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_xor_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_xor.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_xor_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_xor_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar_out, name, "aten::bitwise_xor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar_out, schema_str, "bitwise_xor.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_xor.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_xor_Scalar_out::schema> create_bitwise_xor_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_xor_Scalar_out::name, bitwise_xor_Scalar_out::overload_name)
      .typed<bitwise_xor_Scalar_out::schema>();
}

// aten::bitwise_xor.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_xor_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_xor_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_xor.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_xor_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_xor_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar, name, "aten::bitwise_xor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar, schema_str, "bitwise_xor.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::bitwise_xor.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_xor_Scalar::schema> create_bitwise_xor_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_xor_Scalar::name, bitwise_xor_Scalar::overload_name)
      .typed<bitwise_xor_Scalar::schema>();
}

// aten::bitwise_xor.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_xor_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_xor_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_xor.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_xor_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_xor_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar_Tensor, name, "aten::bitwise_xor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar_Tensor, overload_name, "Scalar_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar_Tensor, schema_str, "bitwise_xor.Scalar_Tensor(Scalar self, Tensor other) -> Tensor")

// aten::bitwise_xor.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_xor_Scalar_Tensor::schema> create_bitwise_xor_Scalar_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_xor_Scalar_Tensor::name, bitwise_xor_Scalar_Tensor::overload_name)
      .typed<bitwise_xor_Scalar_Tensor::schema>();
}

// aten::bitwise_xor.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_xor_Scalar_Tensor::call(const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_xor_Scalar_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_xor.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_xor_Scalar_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_xor_Scalar_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Tensor, name, "aten::bitwise_xor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Tensor, schema_str, "bitwise_xor.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::bitwise_xor.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_xor_Tensor::schema> create_bitwise_xor_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_xor_Tensor::name, bitwise_xor_Tensor::overload_name)
      .typed<bitwise_xor_Tensor::schema>();
}

// aten::bitwise_xor.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_xor_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_xor_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_xor.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_xor_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_xor_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor__Scalar, name, "aten::bitwise_xor_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor__Scalar, schema_str, "bitwise_xor_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::bitwise_xor_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_xor__Scalar::schema> create_bitwise_xor__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_xor__Scalar::name, bitwise_xor__Scalar::overload_name)
      .typed<bitwise_xor__Scalar::schema>();
}

// aten::bitwise_xor_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_xor__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_xor__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_xor_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_xor__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_xor__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor__Tensor, name, "aten::bitwise_xor_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor__Tensor, schema_str, "bitwise_xor_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::bitwise_xor_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_xor__Tensor::schema> create_bitwise_xor__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_xor__Tensor::name, bitwise_xor__Tensor::overload_name)
      .typed<bitwise_xor__Tensor::schema>();
}

// aten::bitwise_xor_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_xor__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_xor__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_xor_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_xor__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_xor__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Scalar, name, "aten::__lshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Scalar, schema_str, "__lshift__.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::__lshift__.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<__lshift___Scalar::schema> create___lshift___Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__lshift___Scalar::name, __lshift___Scalar::overload_name)
      .typed<__lshift___Scalar::schema>();
}

// aten::__lshift__.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor __lshift___Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___lshift___Scalar_typed_handle();
    return op.call(self, other);
}

// aten::__lshift__.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor __lshift___Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___lshift___Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Tensor, name, "aten::__lshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Tensor, schema_str, "__lshift__.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::__lshift__.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<__lshift___Tensor::schema> create___lshift___Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__lshift___Tensor::name, __lshift___Tensor::overload_name)
      .typed<__lshift___Tensor::schema>();
}

// aten::__lshift__.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor __lshift___Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___lshift___Tensor_typed_handle();
    return op.call(self, other);
}

// aten::__lshift__.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor __lshift___Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___lshift___Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ilshift___Scalar, name, "aten::__ilshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ilshift___Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ilshift___Scalar, schema_str, "__ilshift__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::__ilshift__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__ilshift___Scalar::schema> create___ilshift___Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__ilshift___Scalar::name, __ilshift___Scalar::overload_name)
      .typed<__ilshift___Scalar::schema>();
}

// aten::__ilshift__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & __ilshift___Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___ilshift___Scalar_typed_handle();
    return op.call(self, other);
}

// aten::__ilshift__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & __ilshift___Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___ilshift___Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ilshift___Tensor, name, "aten::__ilshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ilshift___Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__ilshift___Tensor, schema_str, "__ilshift__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::__ilshift__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__ilshift___Tensor::schema> create___ilshift___Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__ilshift___Tensor::name, __ilshift___Tensor::overload_name)
      .typed<__ilshift___Tensor::schema>();
}

// aten::__ilshift__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & __ilshift___Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___ilshift___Tensor_typed_handle();
    return op.call(self, other);
}

// aten::__ilshift__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & __ilshift___Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___ilshift___Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor, name, "aten::bitwise_left_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor, schema_str, "bitwise_left_shift.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::bitwise_left_shift.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_left_shift_Tensor::schema> create_bitwise_left_shift_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_left_shift_Tensor::name, bitwise_left_shift_Tensor::overload_name)
      .typed<bitwise_left_shift_Tensor::schema>();
}

// aten::bitwise_left_shift.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_left_shift_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_left_shift_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_left_shift.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_left_shift_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_left_shift_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift__Tensor, name, "aten::bitwise_left_shift_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift__Tensor, schema_str, "bitwise_left_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::bitwise_left_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_left_shift__Tensor::schema> create_bitwise_left_shift__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_left_shift__Tensor::name, bitwise_left_shift__Tensor::overload_name)
      .typed<bitwise_left_shift__Tensor::schema>();
}

// aten::bitwise_left_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_left_shift__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_left_shift__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_left_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_left_shift__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_left_shift__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor_out, name, "aten::bitwise_left_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor_out, schema_str, "bitwise_left_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_left_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_left_shift_Tensor_out::schema> create_bitwise_left_shift_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_left_shift_Tensor_out::name, bitwise_left_shift_Tensor_out::overload_name)
      .typed<bitwise_left_shift_Tensor_out::schema>();
}

// aten::bitwise_left_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_left_shift_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_left_shift_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_left_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_left_shift_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_left_shift_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor_Scalar, name, "aten::bitwise_left_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor_Scalar, overload_name, "Tensor_Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor_Scalar, schema_str, "bitwise_left_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor")

// aten::bitwise_left_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_left_shift_Tensor_Scalar::schema> create_bitwise_left_shift_Tensor_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_left_shift_Tensor_Scalar::name, bitwise_left_shift_Tensor_Scalar::overload_name)
      .typed<bitwise_left_shift_Tensor_Scalar::schema>();
}

// aten::bitwise_left_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_left_shift_Tensor_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_left_shift_Tensor_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_left_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_left_shift_Tensor_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_left_shift_Tensor_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift__Tensor_Scalar, name, "aten::bitwise_left_shift_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift__Tensor_Scalar, overload_name, "Tensor_Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift__Tensor_Scalar, schema_str, "bitwise_left_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::bitwise_left_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_left_shift__Tensor_Scalar::schema> create_bitwise_left_shift__Tensor_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_left_shift__Tensor_Scalar::name, bitwise_left_shift__Tensor_Scalar::overload_name)
      .typed<bitwise_left_shift__Tensor_Scalar::schema>();
}

// aten::bitwise_left_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_left_shift__Tensor_Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_left_shift__Tensor_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_left_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_left_shift__Tensor_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_left_shift__Tensor_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor_Scalar_out, name, "aten::bitwise_left_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor_Scalar_out, overload_name, "Tensor_Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Tensor_Scalar_out, schema_str, "bitwise_left_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_left_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_left_shift_Tensor_Scalar_out::schema> create_bitwise_left_shift_Tensor_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_left_shift_Tensor_Scalar_out::name, bitwise_left_shift_Tensor_Scalar_out::overload_name)
      .typed<bitwise_left_shift_Tensor_Scalar_out::schema>();
}

// aten::bitwise_left_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_left_shift_Tensor_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_left_shift_Tensor_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_left_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_left_shift_Tensor_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_left_shift_Tensor_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Scalar_Tensor, name, "aten::bitwise_left_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Scalar_Tensor, overload_name, "Scalar_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Scalar_Tensor, schema_str, "bitwise_left_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor")

// aten::bitwise_left_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_left_shift_Scalar_Tensor::schema> create_bitwise_left_shift_Scalar_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_left_shift_Scalar_Tensor::name, bitwise_left_shift_Scalar_Tensor::overload_name)
      .typed<bitwise_left_shift_Scalar_Tensor::schema>();
}

// aten::bitwise_left_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_left_shift_Scalar_Tensor::call(const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_left_shift_Scalar_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_left_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_left_shift_Scalar_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_left_shift_Scalar_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Scalar, name, "aten::__rshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Scalar, schema_str, "__rshift__.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::__rshift__.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<__rshift___Scalar::schema> create___rshift___Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__rshift___Scalar::name, __rshift___Scalar::overload_name)
      .typed<__rshift___Scalar::schema>();
}

// aten::__rshift__.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor __rshift___Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___rshift___Scalar_typed_handle();
    return op.call(self, other);
}

// aten::__rshift__.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor __rshift___Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___rshift___Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Tensor, name, "aten::__rshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Tensor, schema_str, "__rshift__.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::__rshift__.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<__rshift___Tensor::schema> create___rshift___Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__rshift___Tensor::name, __rshift___Tensor::overload_name)
      .typed<__rshift___Tensor::schema>();
}

// aten::__rshift__.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor __rshift___Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___rshift___Tensor_typed_handle();
    return op.call(self, other);
}

// aten::__rshift__.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor __rshift___Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___rshift___Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__irshift___Scalar, name, "aten::__irshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__irshift___Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__irshift___Scalar, schema_str, "__irshift__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::__irshift__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__irshift___Scalar::schema> create___irshift___Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__irshift___Scalar::name, __irshift___Scalar::overload_name)
      .typed<__irshift___Scalar::schema>();
}

// aten::__irshift__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & __irshift___Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___irshift___Scalar_typed_handle();
    return op.call(self, other);
}

// aten::__irshift__.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & __irshift___Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create___irshift___Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__irshift___Tensor, name, "aten::__irshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__irshift___Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__irshift___Tensor, schema_str, "__irshift__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::__irshift__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__irshift___Tensor::schema> create___irshift___Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__irshift___Tensor::name, __irshift___Tensor::overload_name)
      .typed<__irshift___Tensor::schema>();
}

// aten::__irshift__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & __irshift___Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___irshift___Tensor_typed_handle();
    return op.call(self, other);
}

// aten::__irshift__.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & __irshift___Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create___irshift___Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor, name, "aten::bitwise_right_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor, schema_str, "bitwise_right_shift.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::bitwise_right_shift.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_right_shift_Tensor::schema> create_bitwise_right_shift_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_right_shift_Tensor::name, bitwise_right_shift_Tensor::overload_name)
      .typed<bitwise_right_shift_Tensor::schema>();
}

// aten::bitwise_right_shift.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_right_shift_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_right_shift_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_right_shift.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor bitwise_right_shift_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_right_shift_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift__Tensor, name, "aten::bitwise_right_shift_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift__Tensor, schema_str, "bitwise_right_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::bitwise_right_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_right_shift__Tensor::schema> create_bitwise_right_shift__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_right_shift__Tensor::name, bitwise_right_shift__Tensor::overload_name)
      .typed<bitwise_right_shift__Tensor::schema>();
}

// aten::bitwise_right_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_right_shift__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_right_shift__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_right_shift_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & bitwise_right_shift__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_right_shift__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor_out, name, "aten::bitwise_right_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor_out, schema_str, "bitwise_right_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_right_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_right_shift_Tensor_out::schema> create_bitwise_right_shift_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_right_shift_Tensor_out::name, bitwise_right_shift_Tensor_out::overload_name)
      .typed<bitwise_right_shift_Tensor_out::schema>();
}

// aten::bitwise_right_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_right_shift_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_right_shift_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_right_shift.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_right_shift_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_right_shift_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor_Scalar, name, "aten::bitwise_right_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor_Scalar, overload_name, "Tensor_Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor_Scalar, schema_str, "bitwise_right_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor")

// aten::bitwise_right_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_right_shift_Tensor_Scalar::schema> create_bitwise_right_shift_Tensor_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_right_shift_Tensor_Scalar::name, bitwise_right_shift_Tensor_Scalar::overload_name)
      .typed<bitwise_right_shift_Tensor_Scalar::schema>();
}

// aten::bitwise_right_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_right_shift_Tensor_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_right_shift_Tensor_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_right_shift.Tensor_Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor bitwise_right_shift_Tensor_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_right_shift_Tensor_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift__Tensor_Scalar, name, "aten::bitwise_right_shift_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift__Tensor_Scalar, overload_name, "Tensor_Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift__Tensor_Scalar, schema_str, "bitwise_right_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::bitwise_right_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_right_shift__Tensor_Scalar::schema> create_bitwise_right_shift__Tensor_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_right_shift__Tensor_Scalar::name, bitwise_right_shift__Tensor_Scalar::overload_name)
      .typed<bitwise_right_shift__Tensor_Scalar::schema>();
}

// aten::bitwise_right_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_right_shift__Tensor_Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_right_shift__Tensor_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_right_shift_.Tensor_Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & bitwise_right_shift__Tensor_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_bitwise_right_shift__Tensor_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor_Scalar_out, name, "aten::bitwise_right_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor_Scalar_out, overload_name, "Tensor_Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Tensor_Scalar_out, schema_str, "bitwise_right_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_right_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_right_shift_Tensor_Scalar_out::schema> create_bitwise_right_shift_Tensor_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_right_shift_Tensor_Scalar_out::name, bitwise_right_shift_Tensor_Scalar_out::overload_name)
      .typed<bitwise_right_shift_Tensor_Scalar_out::schema>();
}

// aten::bitwise_right_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_right_shift_Tensor_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_right_shift_Tensor_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_right_shift.Tensor_Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_right_shift_Tensor_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_bitwise_right_shift_Tensor_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Scalar_Tensor, name, "aten::bitwise_right_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Scalar_Tensor, overload_name, "Scalar_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Scalar_Tensor, schema_str, "bitwise_right_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor")

// aten::bitwise_right_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_right_shift_Scalar_Tensor::schema> create_bitwise_right_shift_Scalar_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_right_shift_Scalar_Tensor::name, bitwise_right_shift_Scalar_Tensor::overload_name)
      .typed<bitwise_right_shift_Scalar_Tensor::schema>();
}

// aten::bitwise_right_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_right_shift_Scalar_Tensor::call(const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_right_shift_Scalar_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::bitwise_right_shift.Scalar_Tensor(Scalar self, Tensor other) -> Tensor
at::Tensor bitwise_right_shift_Scalar_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other) {
    
    static auto op = create_bitwise_right_shift_Scalar_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(exponential_, name, "aten::exponential_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(exponential_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(exponential_, schema_str, "exponential_(Tensor(a!) self, float lambd=1, *, Generator? generator=None) -> Tensor(a!)")

// aten::exponential_(Tensor(a!) self, float lambd=1, *, Generator? generator=None) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<exponential_::schema> create_exponential__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(exponential_::name, exponential_::overload_name)
      .typed<exponential_::schema>();
}

// aten::exponential_(Tensor(a!) self, float lambd=1, *, Generator? generator=None) -> Tensor(a!)
at::Tensor & exponential_::call(at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
    
    static auto op = create_exponential__typed_handle();
    return op.call(self, lambd, generator);
}

// aten::exponential_(Tensor(a!) self, float lambd=1, *, Generator? generator=None) -> Tensor(a!)
at::Tensor & exponential_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
    
    static auto op = create_exponential__typed_handle();
    return op.redispatch(dispatchKeySet, self, lambd, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geometric_, name, "aten::geometric_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geometric_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geometric_, schema_str, "geometric_(Tensor(a!) self, float p, *, Generator? generator=None) -> Tensor(a!)")

// aten::geometric_(Tensor(a!) self, float p, *, Generator? generator=None) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<geometric_::schema> create_geometric__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(geometric_::name, geometric_::overload_name)
      .typed<geometric_::schema>();
}

// aten::geometric_(Tensor(a!) self, float p, *, Generator? generator=None) -> Tensor(a!)
at::Tensor & geometric_::call(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    
    static auto op = create_geometric__typed_handle();
    return op.call(self, p, generator);
}

// aten::geometric_(Tensor(a!) self, float p, *, Generator? generator=None) -> Tensor(a!)
at::Tensor & geometric_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    
    static auto op = create_geometric__typed_handle();
    return op.redispatch(dispatchKeySet, self, p, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trace_backward, name, "aten::trace_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trace_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(trace_backward, schema_str, "trace_backward(Tensor grad, SymInt[] sizes) -> Tensor")

// aten::trace_backward(Tensor grad, SymInt[] sizes) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<trace_backward::schema> create_trace_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(trace_backward::name, trace_backward::overload_name)
      .typed<trace_backward::schema>();
}

// aten::trace_backward(Tensor grad, SymInt[] sizes) -> Tensor
at::Tensor trace_backward::call(const at::Tensor & grad, c10::SymIntArrayRef sizes) {
    
    static auto op = create_trace_backward_typed_handle();
    return op.call(grad, sizes);
}

// aten::trace_backward(Tensor grad, SymInt[] sizes) -> Tensor
at::Tensor trace_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, c10::SymIntArrayRef sizes) {
    
    static auto op = create_trace_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, sizes);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Scalar_out, name, "aten::eq")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Scalar_out, schema_str, "eq.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::eq.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<eq_Scalar_out::schema> create_eq_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(eq_Scalar_out::name, eq_Scalar_out::overload_name)
      .typed<eq_Scalar_out::schema>();
}

// aten::eq.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & eq_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_eq_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::eq.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & eq_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_eq_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Scalar, name, "aten::eq")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Scalar, schema_str, "eq.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::eq.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<eq_Scalar::schema> create_eq_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(eq_Scalar::name, eq_Scalar::overload_name)
      .typed<eq_Scalar::schema>();
}

// aten::eq.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor eq_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_eq_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::eq.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor eq_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_eq_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Tensor_out, name, "aten::eq")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Tensor_out, schema_str, "eq.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::eq.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<eq_Tensor_out::schema> create_eq_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(eq_Tensor_out::name, eq_Tensor_out::overload_name)
      .typed<eq_Tensor_out::schema>();
}

// aten::eq.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & eq_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_eq_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::eq.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & eq_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_eq_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Tensor, name, "aten::eq")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(eq_Tensor, schema_str, "eq.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::eq.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<eq_Tensor::schema> create_eq_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(eq_Tensor::name, eq_Tensor::overload_name)
      .typed<eq_Tensor::schema>();
}

// aten::eq.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor eq_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_eq_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::eq.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor eq_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_eq_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Scalar_out, name, "aten::le")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Scalar_out, schema_str, "le.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::le.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<le_Scalar_out::schema> create_le_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(le_Scalar_out::name, le_Scalar_out::overload_name)
      .typed<le_Scalar_out::schema>();
}

// aten::le.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & le_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_le_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::le.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & le_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_le_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Scalar, name, "aten::le")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Scalar, schema_str, "le.Scalar(Tensor self, Scalar other) -> Tensor")

// aten::le.Scalar(Tensor self, Scalar other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<le_Scalar::schema> create_le_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(le_Scalar::name, le_Scalar::overload_name)
      .typed<le_Scalar::schema>();
}

// aten::le.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor le_Scalar::call(const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_le_Scalar_typed_handle();
    return op.call(self, other);
}

// aten::le.Scalar(Tensor self, Scalar other) -> Tensor
at::Tensor le_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_le_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Tensor_out, name, "aten::le")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Tensor_out, schema_str, "le.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::le.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<le_Tensor_out::schema> create_le_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(le_Tensor_out::name, le_Tensor_out::overload_name)
      .typed<le_Tensor_out::schema>();
}

// aten::le.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & le_Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_le_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::le.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & le_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_le_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Tensor, name, "aten::le")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le_Tensor, schema_str, "le.Tensor(Tensor self, Tensor other) -> Tensor")

// aten::le.Tensor(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<le_Tensor::schema> create_le_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(le_Tensor::name, le_Tensor::overload_name)
      .typed<le_Tensor::schema>();
}

// aten::le.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor le_Tensor::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_le_Tensor_typed_handle();
    return op.call(self, other);
}

// aten::le.Tensor(Tensor self, Tensor other) -> Tensor
at::Tensor le_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_le_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le__Scalar, name, "aten::le_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le__Scalar, schema_str, "le_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)")

// aten::le_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<le__Scalar::schema> create_le__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(le__Scalar::name, le__Scalar::overload_name)
      .typed<le__Scalar::schema>();
}

// aten::le_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & le__Scalar::call(at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_le__Scalar_typed_handle();
    return op.call(self, other);
}

// aten::le_.Scalar(Tensor(a!) self, Scalar other) -> Tensor(a!)
at::Tensor & le__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & other) {
    
    static auto op = create_le__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le__Tensor, name, "aten::le_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(le__Tensor, schema_str, "le_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::le_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<le__Tensor::schema> create_le__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(le__Tensor::name, le__Tensor::overload_name)
      .typed<le__Tensor::schema>();
}

// aten::le_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & le__Tensor::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_le__Tensor_typed_handle();
    return op.call(self, other);
}

// aten::le_.Tensor(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & le__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_le__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take_along_dim_out, name, "aten::take_along_dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take_along_dim_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take_along_dim_out, schema_str, "take_along_dim.out(Tensor self, Tensor indices, int? dim=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::take_along_dim.out(Tensor self, Tensor indices, int? dim=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<take_along_dim_out::schema> create_take_along_dim_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(take_along_dim_out::name, take_along_dim_out::overload_name)
      .typed<take_along_dim_out::schema>();
}

// aten::take_along_dim.out(Tensor self, Tensor indices, int? dim=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & take_along_dim_out::call(const at::Tensor & self, const at::Tensor & indices, c10::optional<int64_t> dim, at::Tensor & out) {
    
    static auto op = create_take_along_dim_out_typed_handle();
    return op.call(self, indices, dim, out);
}

// aten::take_along_dim.out(Tensor self, Tensor indices, int? dim=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & take_along_dim_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & indices, c10::optional<int64_t> dim, at::Tensor & out) {
    
    static auto op = create_take_along_dim_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, indices, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take_along_dim, name, "aten::take_along_dim")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take_along_dim, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(take_along_dim, schema_str, "take_along_dim(Tensor self, Tensor indices, int? dim=None) -> Tensor")

// aten::take_along_dim(Tensor self, Tensor indices, int? dim=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<take_along_dim::schema> create_take_along_dim_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(take_along_dim::name, take_along_dim::overload_name)
      .typed<take_along_dim::schema>();
}

// aten::take_along_dim(Tensor self, Tensor indices, int? dim=None) -> Tensor
at::Tensor take_along_dim::call(const at::Tensor & self, const at::Tensor & indices, c10::optional<int64_t> dim) {
    
    static auto op = create_take_along_dim_typed_handle();
    return op.call(self, indices, dim);
}

// aten::take_along_dim(Tensor self, Tensor indices, int? dim=None) -> Tensor
at::Tensor take_along_dim::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & indices, c10::optional<int64_t> dim) {
    
    static auto op = create_take_along_dim_typed_handle();
    return op.redispatch(dispatchKeySet, self, indices, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_out, name, "aten::index_select")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_out, schema_str, "index_select.out(Tensor self, int dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)")

// aten::index_select.out(Tensor self, int dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<index_select_out::schema> create_index_select_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_select_out::name, index_select_out::overload_name)
      .typed<index_select_out::schema>();
}

// aten::index_select.out(Tensor self, int dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_select_out::call(const at::Tensor & self, int64_t dim, const at::Tensor & index, at::Tensor & out) {
    
    static auto op = create_index_select_out_typed_handle();
    return op.call(self, dim, index, out);
}

// aten::index_select.out(Tensor self, int dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_select_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, const at::Tensor & index, at::Tensor & out) {
    
    static auto op = create_index_select_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select, name, "aten::index_select")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select, schema_str, "index_select(Tensor self, int dim, Tensor index) -> Tensor")

// aten::index_select(Tensor self, int dim, Tensor index) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<index_select::schema> create_index_select_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_select::name, index_select::overload_name)
      .typed<index_select::schema>();
}

// aten::index_select(Tensor self, int dim, Tensor index) -> Tensor
at::Tensor index_select::call(const at::Tensor & self, int64_t dim, const at::Tensor & index) {
    
    static auto op = create_index_select_typed_handle();
    return op.call(self, dim, index);
}

// aten::index_select(Tensor self, int dim, Tensor index) -> Tensor
at::Tensor index_select::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, const at::Tensor & index) {
    
    static auto op = create_index_select_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_dimname_out, name, "aten::index_select")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_dimname_out, overload_name, "dimname_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_dimname_out, schema_str, "index_select.dimname_out(Tensor self, Dimname dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)")

// aten::index_select.dimname_out(Tensor self, Dimname dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<index_select_dimname_out::schema> create_index_select_dimname_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_select_dimname_out::name, index_select_dimname_out::overload_name)
      .typed<index_select_dimname_out::schema>();
}

// aten::index_select.dimname_out(Tensor self, Dimname dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_select_dimname_out::call(const at::Tensor & self, at::Dimname dim, const at::Tensor & index, at::Tensor & out) {
    
    static auto op = create_index_select_dimname_out_typed_handle();
    return op.call(self, dim, index, out);
}

// aten::index_select.dimname_out(Tensor self, Dimname dim, Tensor index, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & index_select_dimname_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, const at::Tensor & index, at::Tensor & out) {
    
    static auto op = create_index_select_dimname_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_dimname, name, "aten::index_select")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_dimname, overload_name, "dimname")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(index_select_dimname, schema_str, "index_select.dimname(Tensor self, Dimname dim, Tensor index) -> Tensor")

// aten::index_select.dimname(Tensor self, Dimname dim, Tensor index) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<index_select_dimname::schema> create_index_select_dimname_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(index_select_dimname::name, index_select_dimname::overload_name)
      .typed<index_select_dimname::schema>();
}

// aten::index_select.dimname(Tensor self, Dimname dim, Tensor index) -> Tensor
at::Tensor index_select_dimname::call(const at::Tensor & self, at::Dimname dim, const at::Tensor & index) {
    
    static auto op = create_index_select_dimname_typed_handle();
    return op.call(self, dim, index);
}

// aten::index_select.dimname(Tensor self, Dimname dim, Tensor index) -> Tensor
at::Tensor index_select_dimname::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Dimname dim, const at::Tensor & index) {
    
    static auto op = create_index_select_dimname_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, index);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_select_backward, name, "aten::masked_select_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_select_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(masked_select_backward, schema_str, "masked_select_backward(Tensor grad, Tensor input, Tensor mask) -> Tensor")

// aten::masked_select_backward(Tensor grad, Tensor input, Tensor mask) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<masked_select_backward::schema> create_masked_select_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(masked_select_backward::name, masked_select_backward::overload_name)
      .typed<masked_select_backward::schema>();
}

// aten::masked_select_backward(Tensor grad, Tensor input, Tensor mask) -> Tensor
at::Tensor masked_select_backward::call(const at::Tensor & grad, const at::Tensor & input, const at::Tensor & mask) {
    
    static auto op = create_masked_select_backward_typed_handle();
    return op.call(grad, input, mask);
}

// aten::masked_select_backward(Tensor grad, Tensor input, Tensor mask) -> Tensor
at::Tensor masked_select_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & input, const at::Tensor & mask) {
    
    static auto op = create_masked_select_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, input, mask);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nonzero_out, name, "aten::nonzero")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nonzero_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nonzero_out, schema_str, "nonzero.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::nonzero.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<nonzero_out::schema> create_nonzero_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nonzero_out::name, nonzero_out::overload_name)
      .typed<nonzero_out::schema>();
}

// aten::nonzero.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & nonzero_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_nonzero_out_typed_handle();
    return op.call(self, out);
}

// aten::nonzero.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & nonzero_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_nonzero_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nonzero, name, "aten::nonzero")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nonzero, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nonzero, schema_str, "nonzero(Tensor self) -> Tensor")

// aten::nonzero(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<nonzero::schema> create_nonzero_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nonzero::name, nonzero::overload_name)
      .typed<nonzero::schema>();
}

// aten::nonzero(Tensor self) -> Tensor
at::Tensor nonzero::call(const at::Tensor & self) {
    
    static auto op = create_nonzero_typed_handle();
    return op.call(self);
}

// aten::nonzero(Tensor self) -> Tensor
at::Tensor nonzero::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_nonzero_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nonzero_numpy, name, "aten::nonzero_numpy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nonzero_numpy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(nonzero_numpy, schema_str, "nonzero_numpy(Tensor self) -> Tensor[]")

// aten::nonzero_numpy(Tensor self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<nonzero_numpy::schema> create_nonzero_numpy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(nonzero_numpy::name, nonzero_numpy::overload_name)
      .typed<nonzero_numpy::schema>();
}

// aten::nonzero_numpy(Tensor self) -> Tensor[]
::std::vector<at::Tensor> nonzero_numpy::call(const at::Tensor & self) {
    
    static auto op = create_nonzero_numpy_typed_handle();
    return op.call(self);
}

// aten::nonzero_numpy(Tensor self) -> Tensor[]
::std::vector<at::Tensor> nonzero_numpy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_nonzero_numpy_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addcmul_out, name, "aten::addcmul")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addcmul_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addcmul_out, schema_str, "addcmul.out(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1, Tensor(a!) out) -> Tensor(a!)")

// aten::addcmul.out(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<addcmul_out::schema> create_addcmul_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(addcmul_out::name, addcmul_out::overload_name)
      .typed<addcmul_out::schema>();
}

// aten::addcmul.out(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & addcmul_out::call(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
    
    static auto op = create_addcmul_out_typed_handle();
    return op.call(self, tensor1, tensor2, value, out);
}

// aten::addcmul.out(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & addcmul_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
    
    static auto op = create_addcmul_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, tensor1, tensor2, value, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addcmul, name, "aten::addcmul")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addcmul, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addcmul, schema_str, "addcmul(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor")

// aten::addcmul(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<addcmul::schema> create_addcmul_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(addcmul::name, addcmul::overload_name)
      .typed<addcmul::schema>();
}

// aten::addcmul(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor
at::Tensor addcmul::call(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
    
    static auto op = create_addcmul_typed_handle();
    return op.call(self, tensor1, tensor2, value);
}

// aten::addcmul(Tensor self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor
at::Tensor addcmul::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
    
    static auto op = create_addcmul_typed_handle();
    return op.redispatch(dispatchKeySet, self, tensor1, tensor2, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addcmul_, name, "aten::addcmul_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addcmul_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(addcmul_, schema_str, "addcmul_(Tensor(a!) self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor(a!)")

// aten::addcmul_(Tensor(a!) self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<addcmul_::schema> create_addcmul__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(addcmul_::name, addcmul_::overload_name)
      .typed<addcmul_::schema>();
}

// aten::addcmul_(Tensor(a!) self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor(a!)
at::Tensor & addcmul_::call(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
    
    static auto op = create_addcmul__typed_handle();
    return op.call(self, tensor1, tensor2, value);
}

// aten::addcmul_(Tensor(a!) self, Tensor tensor1, Tensor tensor2, *, Scalar value=1) -> Tensor(a!)
at::Tensor & addcmul_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
    
    static auto op = create_addcmul__typed_handle();
    return op.redispatch(dispatchKeySet, self, tensor1, tensor2, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(swapdims, name, "aten::swapdims")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(swapdims, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(swapdims, schema_str, "swapdims(Tensor(a) self, int dim0, int dim1) -> Tensor(a)")

// aten::swapdims(Tensor(a) self, int dim0, int dim1) -> Tensor(a)
static C10_NOINLINE c10::TypedOperatorHandle<swapdims::schema> create_swapdims_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(swapdims::name, swapdims::overload_name)
      .typed<swapdims::schema>();
}

// aten::swapdims(Tensor(a) self, int dim0, int dim1) -> Tensor(a)
at::Tensor swapdims::call(const at::Tensor & self, int64_t dim0, int64_t dim1) {
    
    static auto op = create_swapdims_typed_handle();
    return op.call(self, dim0, dim1);
}

// aten::swapdims(Tensor(a) self, int dim0, int dim1) -> Tensor(a)
at::Tensor swapdims::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim0, int64_t dim1) {
    
    static auto op = create_swapdims_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim0, dim1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(swapdims_, name, "aten::swapdims_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(swapdims_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(swapdims_, schema_str, "swapdims_(Tensor(a!) self, int dim0, int dim1) -> Tensor(a!)")

// aten::swapdims_(Tensor(a!) self, int dim0, int dim1) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<swapdims_::schema> create_swapdims__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(swapdims_::name, swapdims_::overload_name)
      .typed<swapdims_::schema>();
}

// aten::swapdims_(Tensor(a!) self, int dim0, int dim1) -> Tensor(a!)
at::Tensor & swapdims_::call(at::Tensor & self, int64_t dim0, int64_t dim1) {
    
    static auto op = create_swapdims__typed_handle();
    return op.call(self, dim0, dim1);
}

// aten::swapdims_(Tensor(a!) self, int dim0, int dim1) -> Tensor(a!)
at::Tensor & swapdims_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, int64_t dim0, int64_t dim1) {
    
    static auto op = create_swapdims__typed_handle();
    return op.redispatch(dispatchKeySet, self, dim0, dim1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cholesky_out, name, "aten::cholesky")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cholesky_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cholesky_out, schema_str, "cholesky.out(Tensor self, bool upper=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::cholesky.out(Tensor self, bool upper=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cholesky_out::schema> create_cholesky_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cholesky_out::name, cholesky_out::overload_name)
      .typed<cholesky_out::schema>();
}

// aten::cholesky.out(Tensor self, bool upper=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cholesky_out::call(const at::Tensor & self, bool upper, at::Tensor & out) {
    
    static auto op = create_cholesky_out_typed_handle();
    return op.call(self, upper, out);
}

// aten::cholesky.out(Tensor self, bool upper=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cholesky_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool upper, at::Tensor & out) {
    
    static auto op = create_cholesky_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, upper, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cholesky, name, "aten::cholesky")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cholesky, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cholesky, schema_str, "cholesky(Tensor self, bool upper=False) -> Tensor")

// aten::cholesky(Tensor self, bool upper=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<cholesky::schema> create_cholesky_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cholesky::name, cholesky::overload_name)
      .typed<cholesky::schema>();
}

// aten::cholesky(Tensor self, bool upper=False) -> Tensor
at::Tensor cholesky::call(const at::Tensor & self, bool upper) {
    
    static auto op = create_cholesky_typed_handle();
    return op.call(self, upper);
}

// aten::cholesky(Tensor self, bool upper=False) -> Tensor
at::Tensor cholesky::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool upper) {
    
    static auto op = create_cholesky_typed_handle();
    return op.redispatch(dispatchKeySet, self, upper);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_solve_out, name, "aten::lu_solve")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_solve_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_solve_out, schema_str, "lu_solve.out(Tensor self, Tensor LU_data, Tensor LU_pivots, *, Tensor(a!) out) -> Tensor(a!)")

// aten::lu_solve.out(Tensor self, Tensor LU_data, Tensor LU_pivots, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<lu_solve_out::schema> create_lu_solve_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lu_solve_out::name, lu_solve_out::overload_name)
      .typed<lu_solve_out::schema>();
}

// aten::lu_solve.out(Tensor self, Tensor LU_data, Tensor LU_pivots, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & lu_solve_out::call(const at::Tensor & self, const at::Tensor & LU_data, const at::Tensor & LU_pivots, at::Tensor & out) {
    
    static auto op = create_lu_solve_out_typed_handle();
    return op.call(self, LU_data, LU_pivots, out);
}

// aten::lu_solve.out(Tensor self, Tensor LU_data, Tensor LU_pivots, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & lu_solve_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & LU_data, const at::Tensor & LU_pivots, at::Tensor & out) {
    
    static auto op = create_lu_solve_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, LU_data, LU_pivots, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_solve, name, "aten::lu_solve")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_solve, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_solve, schema_str, "lu_solve(Tensor self, Tensor LU_data, Tensor LU_pivots) -> Tensor")

// aten::lu_solve(Tensor self, Tensor LU_data, Tensor LU_pivots) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<lu_solve::schema> create_lu_solve_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lu_solve::name, lu_solve::overload_name)
      .typed<lu_solve::schema>();
}

// aten::lu_solve(Tensor self, Tensor LU_data, Tensor LU_pivots) -> Tensor
at::Tensor lu_solve::call(const at::Tensor & self, const at::Tensor & LU_data, const at::Tensor & LU_pivots) {
    
    static auto op = create_lu_solve_typed_handle();
    return op.call(self, LU_data, LU_pivots);
}

// aten::lu_solve(Tensor self, Tensor LU_data, Tensor LU_pivots) -> Tensor
at::Tensor lu_solve::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & LU_data, const at::Tensor & LU_pivots) {
    
    static auto op = create_lu_solve_typed_handle();
    return op.redispatch(dispatchKeySet, self, LU_data, LU_pivots);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_unpack, name, "aten::lu_unpack")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_unpack, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_unpack, schema_str, "lu_unpack(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True) -> (Tensor P, Tensor L, Tensor U)")

// aten::lu_unpack(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True) -> (Tensor P, Tensor L, Tensor U)
static C10_NOINLINE c10::TypedOperatorHandle<lu_unpack::schema> create_lu_unpack_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lu_unpack::name, lu_unpack::overload_name)
      .typed<lu_unpack::schema>();
}

// aten::lu_unpack(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True) -> (Tensor P, Tensor L, Tensor U)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> lu_unpack::call(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots) {
    
    static auto op = create_lu_unpack_typed_handle();
    return op.call(LU_data, LU_pivots, unpack_data, unpack_pivots);
}

// aten::lu_unpack(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True) -> (Tensor P, Tensor L, Tensor U)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> lu_unpack::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots) {
    
    static auto op = create_lu_unpack_typed_handle();
    return op.redispatch(dispatchKeySet, LU_data, LU_pivots, unpack_data, unpack_pivots);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_unpack_out, name, "aten::lu_unpack")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_unpack_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lu_unpack_out, schema_str, "lu_unpack.out(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True, *, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)")

// aten::lu_unpack.out(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True, *, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)
static C10_NOINLINE c10::TypedOperatorHandle<lu_unpack_out::schema> create_lu_unpack_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lu_unpack_out::name, lu_unpack_out::overload_name)
      .typed<lu_unpack_out::schema>();
}

// aten::lu_unpack.out(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True, *, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> lu_unpack_out::call(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
    
    static auto op = create_lu_unpack_out_typed_handle();
    return op.call(LU_data, LU_pivots, unpack_data, unpack_pivots, P, L, U);
}

// aten::lu_unpack.out(Tensor LU_data, Tensor LU_pivots, bool unpack_data=True, bool unpack_pivots=True, *, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> lu_unpack_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
    
    static auto op = create_lu_unpack_out_typed_handle();
    return op.redispatch(dispatchKeySet, LU_data, LU_pivots, unpack_data, unpack_pivots, P, L, U);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multinomial_out, name, "aten::multinomial")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multinomial_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multinomial_out, schema_str, "multinomial.out(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)")

// aten::multinomial.out(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<multinomial_out::schema> create_multinomial_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multinomial_out::name, multinomial_out::overload_name)
      .typed<multinomial_out::schema>();
}

// aten::multinomial.out(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & multinomial_out::call(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_multinomial_out_typed_handle();
    return op.call(self, num_samples, replacement, generator, out);
}

// aten::multinomial.out(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & multinomial_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_multinomial_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, num_samples, replacement, generator, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multinomial, name, "aten::multinomial")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multinomial, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multinomial, schema_str, "multinomial(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None) -> Tensor")

// aten::multinomial(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<multinomial::schema> create_multinomial_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multinomial::name, multinomial::overload_name)
      .typed<multinomial::schema>();
}

// aten::multinomial(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None) -> Tensor
at::Tensor multinomial::call(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator) {
    
    static auto op = create_multinomial_typed_handle();
    return op.call(self, num_samples, replacement, generator);
}

// aten::multinomial(Tensor self, int num_samples, bool replacement=False, *, Generator? generator=None) -> Tensor
at::Tensor multinomial::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator) {
    
    static auto op = create_multinomial_typed_handle();
    return op.redispatch(dispatchKeySet, self, num_samples, replacement, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lgamma_out, name, "aten::lgamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lgamma_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lgamma_out, schema_str, "lgamma.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::lgamma.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<lgamma_out::schema> create_lgamma_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lgamma_out::name, lgamma_out::overload_name)
      .typed<lgamma_out::schema>();
}

// aten::lgamma.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & lgamma_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_lgamma_out_typed_handle();
    return op.call(self, out);
}

// aten::lgamma.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & lgamma_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_lgamma_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lgamma_, name, "aten::lgamma_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lgamma_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lgamma_, schema_str, "lgamma_(Tensor(a!) self) -> Tensor(a!)")

// aten::lgamma_(Tensor(a!) self) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<lgamma_::schema> create_lgamma__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lgamma_::name, lgamma_::overload_name)
      .typed<lgamma_::schema>();
}

// aten::lgamma_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & lgamma_::call(at::Tensor & self) {
    
    static auto op = create_lgamma__typed_handle();
    return op.call(self);
}

// aten::lgamma_(Tensor(a!) self) -> Tensor(a!)
at::Tensor & lgamma_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self) {
    
    static auto op = create_lgamma__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lgamma, name, "aten::lgamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lgamma, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lgamma, schema_str, "lgamma(Tensor self) -> Tensor")

// aten::lgamma(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<lgamma::schema> create_lgamma_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lgamma::name, lgamma::overload_name)
      .typed<lgamma::schema>();
}

// aten::lgamma(Tensor self) -> Tensor
at::Tensor lgamma::call(const at::Tensor & self) {
    
    static auto op = create_lgamma_typed_handle();
    return op.call(self);
}

// aten::lgamma(Tensor self) -> Tensor
at::Tensor lgamma::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_lgamma_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctan2, name, "aten::arctan2")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctan2, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctan2, schema_str, "arctan2(Tensor self, Tensor other) -> Tensor")

// aten::arctan2(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<arctan2::schema> create_arctan2_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arctan2::name, arctan2::overload_name)
      .typed<arctan2::schema>();
}

// aten::arctan2(Tensor self, Tensor other) -> Tensor
at::Tensor arctan2::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_arctan2_typed_handle();
    return op.call(self, other);
}

// aten::arctan2(Tensor self, Tensor other) -> Tensor
at::Tensor arctan2::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_arctan2_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctan2_out, name, "aten::arctan2")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctan2_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctan2_out, schema_str, "arctan2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::arctan2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<arctan2_out::schema> create_arctan2_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arctan2_out::name, arctan2_out::overload_name)
      .typed<arctan2_out::schema>();
}

// aten::arctan2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & arctan2_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_arctan2_out_typed_handle();
    return op.call(self, other, out);
}

// aten::arctan2.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & arctan2_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_arctan2_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctan2_, name, "aten::arctan2_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctan2_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(arctan2_, schema_str, "arctan2_(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::arctan2_(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<arctan2_::schema> create_arctan2__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(arctan2_::name, arctan2_::overload_name)
      .typed<arctan2_::schema>();
}

// aten::arctan2_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & arctan2_::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_arctan2__typed_handle();
    return op.call(self, other);
}

// aten::arctan2_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & arctan2_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_arctan2__typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bins_tensor_out, name, "aten::histogram")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bins_tensor_out, overload_name, "bins_tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bins_tensor_out, schema_str, "histogram.bins_tensor_out(Tensor self, Tensor bins, *, Tensor? weight=None, bool density=False, Tensor(a!) hist, Tensor(b!) bin_edges) -> (Tensor(a!) hist, Tensor(b!) bin_edges)")

// aten::histogram.bins_tensor_out(Tensor self, Tensor bins, *, Tensor? weight=None, bool density=False, Tensor(a!) hist, Tensor(b!) bin_edges) -> (Tensor(a!) hist, Tensor(b!) bin_edges)
static C10_NOINLINE c10::TypedOperatorHandle<histogram_bins_tensor_out::schema> create_histogram_bins_tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(histogram_bins_tensor_out::name, histogram_bins_tensor_out::overload_name)
      .typed<histogram_bins_tensor_out::schema>();
}

// aten::histogram.bins_tensor_out(Tensor self, Tensor bins, *, Tensor? weight=None, bool density=False, Tensor(a!) hist, Tensor(b!) bin_edges) -> (Tensor(a!) hist, Tensor(b!) bin_edges)
::std::tuple<at::Tensor &,at::Tensor &> histogram_bins_tensor_out::call(const at::Tensor & self, const at::Tensor & bins, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & hist, at::Tensor & bin_edges) {
    
    static auto op = create_histogram_bins_tensor_out_typed_handle();
    return op.call(self, bins, weight, density, hist, bin_edges);
}

// aten::histogram.bins_tensor_out(Tensor self, Tensor bins, *, Tensor? weight=None, bool density=False, Tensor(a!) hist, Tensor(b!) bin_edges) -> (Tensor(a!) hist, Tensor(b!) bin_edges)
::std::tuple<at::Tensor &,at::Tensor &> histogram_bins_tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & bins, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & hist, at::Tensor & bin_edges) {
    
    static auto op = create_histogram_bins_tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, bins, weight, density, hist, bin_edges);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bins_tensor, name, "aten::histogram")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bins_tensor, overload_name, "bins_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bins_tensor, schema_str, "histogram.bins_tensor(Tensor self, Tensor bins, *, Tensor? weight=None, bool density=False) -> (Tensor hist, Tensor bin_edges)")

// aten::histogram.bins_tensor(Tensor self, Tensor bins, *, Tensor? weight=None, bool density=False) -> (Tensor hist, Tensor bin_edges)
static C10_NOINLINE c10::TypedOperatorHandle<histogram_bins_tensor::schema> create_histogram_bins_tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(histogram_bins_tensor::name, histogram_bins_tensor::overload_name)
      .typed<histogram_bins_tensor::schema>();
}

// aten::histogram.bins_tensor(Tensor self, Tensor bins, *, Tensor? weight=None, bool density=False) -> (Tensor hist, Tensor bin_edges)
::std::tuple<at::Tensor,at::Tensor> histogram_bins_tensor::call(const at::Tensor & self, const at::Tensor & bins, const c10::optional<at::Tensor> & weight, bool density) {
    
    static auto op = create_histogram_bins_tensor_typed_handle();
    return op.call(self, bins, weight, density);
}

// aten::histogram.bins_tensor(Tensor self, Tensor bins, *, Tensor? weight=None, bool density=False) -> (Tensor hist, Tensor bin_edges)
::std::tuple<at::Tensor,at::Tensor> histogram_bins_tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & bins, const c10::optional<at::Tensor> & weight, bool density) {
    
    static auto op = create_histogram_bins_tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, bins, weight, density);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bin_ct_out, name, "aten::histogram")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bin_ct_out, overload_name, "bin_ct_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bin_ct_out, schema_str, "histogram.bin_ct_out(Tensor self, int bins=100, *, float[]? range=None, Tensor? weight=None, bool density=False, Tensor(a!) hist, Tensor(b!) bin_edges) -> (Tensor(a!) hist, Tensor(b!) bin_edges)")

// aten::histogram.bin_ct_out(Tensor self, int bins=100, *, float[]? range=None, Tensor? weight=None, bool density=False, Tensor(a!) hist, Tensor(b!) bin_edges) -> (Tensor(a!) hist, Tensor(b!) bin_edges)
static C10_NOINLINE c10::TypedOperatorHandle<histogram_bin_ct_out::schema> create_histogram_bin_ct_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(histogram_bin_ct_out::name, histogram_bin_ct_out::overload_name)
      .typed<histogram_bin_ct_out::schema>();
}

// aten::histogram.bin_ct_out(Tensor self, int bins=100, *, float[]? range=None, Tensor? weight=None, bool density=False, Tensor(a!) hist, Tensor(b!) bin_edges) -> (Tensor(a!) hist, Tensor(b!) bin_edges)
::std::tuple<at::Tensor &,at::Tensor &> histogram_bin_ct_out::call(const at::Tensor & self, int64_t bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & hist, at::Tensor & bin_edges) {
    
    static auto op = create_histogram_bin_ct_out_typed_handle();
    return op.call(self, bins, range, weight, density, hist, bin_edges);
}

// aten::histogram.bin_ct_out(Tensor self, int bins=100, *, float[]? range=None, Tensor? weight=None, bool density=False, Tensor(a!) hist, Tensor(b!) bin_edges) -> (Tensor(a!) hist, Tensor(b!) bin_edges)
::std::tuple<at::Tensor &,at::Tensor &> histogram_bin_ct_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & hist, at::Tensor & bin_edges) {
    
    static auto op = create_histogram_bin_ct_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, bins, range, weight, density, hist, bin_edges);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bin_ct, name, "aten::histogram")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bin_ct, overload_name, "bin_ct")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(histogram_bin_ct, schema_str, "histogram.bin_ct(Tensor self, int bins=100, *, float[]? range=None, Tensor? weight=None, bool density=False) -> (Tensor hist, Tensor bin_edges)")

// aten::histogram.bin_ct(Tensor self, int bins=100, *, float[]? range=None, Tensor? weight=None, bool density=False) -> (Tensor hist, Tensor bin_edges)
static C10_NOINLINE c10::TypedOperatorHandle<histogram_bin_ct::schema> create_histogram_bin_ct_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(histogram_bin_ct::name, histogram_bin_ct::overload_name)
      .typed<histogram_bin_ct::schema>();
}

// aten::histogram.bin_ct(Tensor self, int bins=100, *, float[]? range=None, Tensor? weight=None, bool density=False) -> (Tensor hist, Tensor bin_edges)
::std::tuple<at::Tensor,at::Tensor> histogram_bin_ct::call(const at::Tensor & self, int64_t bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
    
    static auto op = create_histogram_bin_ct_typed_handle();
    return op.call(self, bins, range, weight, density);
}

// aten::histogram.bin_ct(Tensor self, int bins=100, *, float[]? range=None, Tensor? weight=None, bool density=False) -> (Tensor hist, Tensor bin_edges)
::std::tuple<at::Tensor,at::Tensor> histogram_bin_ct::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
    
    static auto op = create_histogram_bin_ct_typed_handle();
    return op.redispatch(dispatchKeySet, self, bins, range, weight, density);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(igamma_out, name, "aten::igamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(igamma_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(igamma_out, schema_str, "igamma.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::igamma.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<igamma_out::schema> create_igamma_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(igamma_out::name, igamma_out::overload_name)
      .typed<igamma_out::schema>();
}

// aten::igamma.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & igamma_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_igamma_out_typed_handle();
    return op.call(self, other, out);
}

// aten::igamma.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & igamma_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_igamma_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(igamma, name, "aten::igamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(igamma, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(igamma, schema_str, "igamma(Tensor self, Tensor other) -> Tensor")

// aten::igamma(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<igamma::schema> create_igamma_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(igamma::name, igamma::overload_name)
      .typed<igamma::schema>();
}

// aten::igamma(Tensor self, Tensor other) -> Tensor
at::Tensor igamma::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_igamma_typed_handle();
    return op.call(self, other);
}

// aten::igamma(Tensor self, Tensor other) -> Tensor
at::Tensor igamma::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_igamma_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(igamma_, name, "aten::igamma_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(igamma_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(igamma_, schema_str, "igamma_(Tensor(a!) self, Tensor other) -> Tensor(a!)")

// aten::igamma_(Tensor(a!) self, Tensor other) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<igamma_::schema> create_igamma__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(igamma_::name, igamma_::overload_name)
      .typed<igamma_::schema>();
}

// aten::igamma_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & igamma_::call(at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_igamma__typed_handle();
    return op.call(self, other);
}

// aten::igamma_(Tensor(a!) self, Tensor other) -> Tensor(a!)
at::Tensor & igamma_::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_igamma__typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max, name, "aten::max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max, schema_str, "max(Tensor self) -> Tensor")

// aten::max(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<max::schema> create_max_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max::name, max::overload_name)
      .typed<max::schema>();
}

// aten::max(Tensor self) -> Tensor
at::Tensor max::call(const at::Tensor & self) {
    
    static auto op = create_max_typed_handle();
    return op.call(self);
}

// aten::max(Tensor self) -> Tensor
at::Tensor max::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_max_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_other, name, "aten::max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_other, overload_name, "other")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_other, schema_str, "max.other(Tensor self, Tensor other) -> Tensor")

// aten::max.other(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<max_other::schema> create_max_other_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_other::name, max_other::overload_name)
      .typed<max_other::schema>();
}

// aten::max.other(Tensor self, Tensor other) -> Tensor
at::Tensor max_other::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_max_other_typed_handle();
    return op.call(self, other);
}

// aten::max.other(Tensor self, Tensor other) -> Tensor
at::Tensor max_other::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_max_other_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_out, name, "aten::max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_out, schema_str, "max.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::max.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<max_out::schema> create_max_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_out::name, max_out::overload_name)
      .typed<max_out::schema>();
}

// aten::max.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & max_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_max_out_typed_handle();
    return op.call(self, other, out);
}

// aten::max.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & max_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_max_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_unary_out, name, "aten::max")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_unary_out, overload_name, "unary_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_unary_out, schema_str, "max.unary_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::max.unary_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<max_unary_out::schema> create_max_unary_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_unary_out::name, max_unary_out::overload_name)
      .typed<max_unary_out::schema>();
}

// aten::max.unary_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & max_unary_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_max_unary_out_typed_handle();
    return op.call(self, out);
}

// aten::max.unary_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & max_unary_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_max_unary_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Tensor_out, name, "aten::pow")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Tensor_out, overload_name, "Tensor_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Tensor_out, schema_str, "pow.Tensor_Tensor_out(Tensor self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)")

// aten::pow.Tensor_Tensor_out(Tensor self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<pow_Tensor_Tensor_out::schema> create_pow_Tensor_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pow_Tensor_Tensor_out::name, pow_Tensor_Tensor_out::overload_name)
      .typed<pow_Tensor_Tensor_out::schema>();
}

// aten::pow.Tensor_Tensor_out(Tensor self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & pow_Tensor_Tensor_out::call(const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
    
    static auto op = create_pow_Tensor_Tensor_out_typed_handle();
    return op.call(self, exponent, out);
}

// aten::pow.Tensor_Tensor_out(Tensor self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & pow_Tensor_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
    
    static auto op = create_pow_Tensor_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Tensor, name, "aten::pow")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Tensor, overload_name, "Tensor_Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Tensor, schema_str, "pow.Tensor_Tensor(Tensor self, Tensor exponent) -> Tensor")

// aten::pow.Tensor_Tensor(Tensor self, Tensor exponent) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<pow_Tensor_Tensor::schema> create_pow_Tensor_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pow_Tensor_Tensor::name, pow_Tensor_Tensor::overload_name)
      .typed<pow_Tensor_Tensor::schema>();
}

// aten::pow.Tensor_Tensor(Tensor self, Tensor exponent) -> Tensor
at::Tensor pow_Tensor_Tensor::call(const at::Tensor & self, const at::Tensor & exponent) {
    
    static auto op = create_pow_Tensor_Tensor_typed_handle();
    return op.call(self, exponent);
}

// aten::pow.Tensor_Tensor(Tensor self, Tensor exponent) -> Tensor
at::Tensor pow_Tensor_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & exponent) {
    
    static auto op = create_pow_Tensor_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Scalar_out, name, "aten::pow")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Scalar_out, schema_str, "pow.Scalar_out(Scalar self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)")

// aten::pow.Scalar_out(Scalar self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<pow_Scalar_out::schema> create_pow_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pow_Scalar_out::name, pow_Scalar_out::overload_name)
      .typed<pow_Scalar_out::schema>();
}

// aten::pow.Scalar_out(Scalar self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & pow_Scalar_out::call(const at::Scalar & self, const at::Tensor & exponent, at::Tensor & out) {
    
    static auto op = create_pow_Scalar_out_typed_handle();
    return op.call(self, exponent, out);
}

// aten::pow.Scalar_out(Scalar self, Tensor exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & pow_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & exponent, at::Tensor & out) {
    
    static auto op = create_pow_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Scalar, name, "aten::pow")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Scalar, schema_str, "pow.Scalar(Scalar self, Tensor exponent) -> Tensor")

// aten::pow.Scalar(Scalar self, Tensor exponent) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<pow_Scalar::schema> create_pow_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pow_Scalar::name, pow_Scalar::overload_name)
      .typed<pow_Scalar::schema>();
}

// aten::pow.Scalar(Scalar self, Tensor exponent) -> Tensor
at::Tensor pow_Scalar::call(const at::Scalar & self, const at::Tensor & exponent) {
    
    static auto op = create_pow_Scalar_typed_handle();
    return op.call(self, exponent);
}

// aten::pow.Scalar(Scalar self, Tensor exponent) -> Tensor
at::Tensor pow_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & exponent) {
    
    static auto op = create_pow_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Scalar_out, name, "aten::pow")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Scalar_out, overload_name, "Tensor_Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Scalar_out, schema_str, "pow.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)")

// aten::pow.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<pow_Tensor_Scalar_out::schema> create_pow_Tensor_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pow_Tensor_Scalar_out::name, pow_Tensor_Scalar_out::overload_name)
      .typed<pow_Tensor_Scalar_out::schema>();
}

// aten::pow.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & pow_Tensor_Scalar_out::call(const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
    
    static auto op = create_pow_Tensor_Scalar_out_typed_handle();
    return op.call(self, exponent, out);
}

// aten::pow.Tensor_Scalar_out(Tensor self, Scalar exponent, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & pow_Tensor_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
    
    static auto op = create_pow_Tensor_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Scalar, name, "aten::pow")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Scalar, overload_name, "Tensor_Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow_Tensor_Scalar, schema_str, "pow.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor")

// aten::pow.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<pow_Tensor_Scalar::schema> create_pow_Tensor_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pow_Tensor_Scalar::name, pow_Tensor_Scalar::overload_name)
      .typed<pow_Tensor_Scalar::schema>();
}

// aten::pow.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor
at::Tensor pow_Tensor_Scalar::call(const at::Tensor & self, const at::Scalar & exponent) {
    
    static auto op = create_pow_Tensor_Scalar_typed_handle();
    return op.call(self, exponent);
}

// aten::pow.Tensor_Scalar(Tensor self, Scalar exponent) -> Tensor
at::Tensor pow_Tensor_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & exponent) {
    
    static auto op = create_pow_Tensor_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow__Scalar, name, "aten::pow_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow__Scalar, schema_str, "pow_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)")

// aten::pow_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<pow__Scalar::schema> create_pow__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pow__Scalar::name, pow__Scalar::overload_name)
      .typed<pow__Scalar::schema>();
}

// aten::pow_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)
at::Tensor & pow__Scalar::call(at::Tensor & self, const at::Scalar & exponent) {
    
    static auto op = create_pow__Scalar_typed_handle();
    return op.call(self, exponent);
}

// aten::pow_.Scalar(Tensor(a!) self, Scalar exponent) -> Tensor(a!)
at::Tensor & pow__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Scalar & exponent) {
    
    static auto op = create_pow__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow__Tensor, name, "aten::pow_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pow__Tensor, schema_str, "pow_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)")

// aten::pow_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<pow__Tensor::schema> create_pow__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pow__Tensor::name, pow__Tensor::overload_name)
      .typed<pow__Tensor::schema>();
}

// aten::pow_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)
at::Tensor & pow__Tensor::call(at::Tensor & self, const at::Tensor & exponent) {
    
    static auto op = create_pow__Tensor_typed_handle();
    return op.call(self, exponent);
}

// aten::pow_.Tensor(Tensor(a!) self, Tensor exponent) -> Tensor(a!)
at::Tensor & pow__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::Tensor & self, const at::Tensor & exponent) {
    
    static auto op = create_pow__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, exponent);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_amp_foreach_non_finite_check_and_unscale_, name, "aten::_amp_foreach_non_finite_check_and_unscale_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_amp_foreach_non_finite_check_and_unscale_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_amp_foreach_non_finite_check_and_unscale_, schema_str, "_amp_foreach_non_finite_check_and_unscale_(Tensor(a!)[] self, Tensor(b!) found_inf, Tensor inv_scale) -> ()")

// aten::_amp_foreach_non_finite_check_and_unscale_(Tensor(a!)[] self, Tensor(b!) found_inf, Tensor inv_scale) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_amp_foreach_non_finite_check_and_unscale_::schema> create__amp_foreach_non_finite_check_and_unscale__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_amp_foreach_non_finite_check_and_unscale_::name, _amp_foreach_non_finite_check_and_unscale_::overload_name)
      .typed<_amp_foreach_non_finite_check_and_unscale_::schema>();
}

// aten::_amp_foreach_non_finite_check_and_unscale_(Tensor(a!)[] self, Tensor(b!) found_inf, Tensor inv_scale) -> ()
void _amp_foreach_non_finite_check_and_unscale_::call(at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale) {
    
    static auto op = create__amp_foreach_non_finite_check_and_unscale__typed_handle();
    return op.call(self, found_inf, inv_scale);
}

// aten::_amp_foreach_non_finite_check_and_unscale_(Tensor(a!)[] self, Tensor(b!) found_inf, Tensor inv_scale) -> ()
void _amp_foreach_non_finite_check_and_unscale_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale) {
    
    static auto op = create__amp_foreach_non_finite_check_and_unscale__typed_handle();
    return op.redispatch(dispatchKeySet, self, found_inf, inv_scale);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Scalar, name, "aten::_foreach_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Scalar, schema_str, "_foreach_add.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]")

// aten::_foreach_add.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add_Scalar::schema> create__foreach_add_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add_Scalar::name, _foreach_add_Scalar::overload_name)
      .typed<_foreach_add_Scalar::schema>();
}

// aten::_foreach_add.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
::std::vector<at::Tensor> _foreach_add_Scalar::call(at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_add_Scalar_typed_handle();
    return op.call(self, scalar);
}

// aten::_foreach_add.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
::std::vector<at::Tensor> _foreach_add_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_add_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__Scalar, name, "aten::_foreach_add_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__Scalar, schema_str, "_foreach_add_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()")

// aten::_foreach_add_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add__Scalar::schema> create__foreach_add__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add__Scalar::name, _foreach_add__Scalar::overload_name)
      .typed<_foreach_add__Scalar::schema>();
}

// aten::_foreach_add_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
void _foreach_add__Scalar::call(at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_add__Scalar_typed_handle();
    return op.call(self, scalar);
}

// aten::_foreach_add_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
void _foreach_add__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_add__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_List, name, "aten::_foreach_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_List, schema_str, "_foreach_add.List(Tensor[] self, Tensor[] other, *, Scalar alpha=1) -> Tensor[]")

// aten::_foreach_add.List(Tensor[] self, Tensor[] other, *, Scalar alpha=1) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add_List::schema> create__foreach_add_List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add_List::name, _foreach_add_List::overload_name)
      .typed<_foreach_add_List::schema>();
}

// aten::_foreach_add.List(Tensor[] self, Tensor[] other, *, Scalar alpha=1) -> Tensor[]
::std::vector<at::Tensor> _foreach_add_List::call(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    
    static auto op = create__foreach_add_List_typed_handle();
    return op.call(self, other, alpha);
}

// aten::_foreach_add.List(Tensor[] self, Tensor[] other, *, Scalar alpha=1) -> Tensor[]
::std::vector<at::Tensor> _foreach_add_List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    
    static auto op = create__foreach_add_List_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__List, name, "aten::_foreach_add_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__List, schema_str, "_foreach_add_.List(Tensor(a!)[] self, Tensor[] other, *, Scalar alpha=1) -> ()")

// aten::_foreach_add_.List(Tensor(a!)[] self, Tensor[] other, *, Scalar alpha=1) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add__List::schema> create__foreach_add__List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add__List::name, _foreach_add__List::overload_name)
      .typed<_foreach_add__List::schema>();
}

// aten::_foreach_add_.List(Tensor(a!)[] self, Tensor[] other, *, Scalar alpha=1) -> ()
void _foreach_add__List::call(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    
    static auto op = create__foreach_add__List_typed_handle();
    return op.call(self, other, alpha);
}

// aten::_foreach_add_.List(Tensor(a!)[] self, Tensor[] other, *, Scalar alpha=1) -> ()
void _foreach_add__List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    
    static auto op = create__foreach_add__List_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_ScalarList, name, "aten::_foreach_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_ScalarList, overload_name, "ScalarList")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_ScalarList, schema_str, "_foreach_add.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]")

// aten::_foreach_add.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add_ScalarList::schema> create__foreach_add_ScalarList_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add_ScalarList::name, _foreach_add_ScalarList::overload_name)
      .typed<_foreach_add_ScalarList::schema>();
}

// aten::_foreach_add.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
::std::vector<at::Tensor> _foreach_add_ScalarList::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_add_ScalarList_typed_handle();
    return op.call(self, scalars);
}

// aten::_foreach_add.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
::std::vector<at::Tensor> _foreach_add_ScalarList::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_add_ScalarList_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__ScalarList, name, "aten::_foreach_add_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__ScalarList, overload_name, "ScalarList")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__ScalarList, schema_str, "_foreach_add_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()")

// aten::_foreach_add_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add__ScalarList::schema> create__foreach_add__ScalarList_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add__ScalarList::name, _foreach_add__ScalarList::overload_name)
      .typed<_foreach_add__ScalarList::schema>();
}

// aten::_foreach_add_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
void _foreach_add__ScalarList::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_add__ScalarList_typed_handle();
    return op.call(self, scalars);
}

// aten::_foreach_add_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
void _foreach_add__ScalarList::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_add__ScalarList_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Tensor, name, "aten::_foreach_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Tensor, schema_str, "_foreach_add.Tensor(Tensor[] self, Tensor other, *, Scalar alpha=1) -> Tensor[]")

// aten::_foreach_add.Tensor(Tensor[] self, Tensor other, *, Scalar alpha=1) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add_Tensor::schema> create__foreach_add_Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add_Tensor::name, _foreach_add_Tensor::overload_name)
      .typed<_foreach_add_Tensor::schema>();
}

// aten::_foreach_add.Tensor(Tensor[] self, Tensor other, *, Scalar alpha=1) -> Tensor[]
::std::vector<at::Tensor> _foreach_add_Tensor::call(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create__foreach_add_Tensor_typed_handle();
    return op.call(self, other, alpha);
}

// aten::_foreach_add.Tensor(Tensor[] self, Tensor other, *, Scalar alpha=1) -> Tensor[]
::std::vector<at::Tensor> _foreach_add_Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create__foreach_add_Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__Tensor, name, "aten::_foreach_add_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__Tensor, overload_name, "Tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add__Tensor, schema_str, "_foreach_add_.Tensor(Tensor(a!)[] self, Tensor other, *, Scalar alpha=1) -> ()")

// aten::_foreach_add_.Tensor(Tensor(a!)[] self, Tensor other, *, Scalar alpha=1) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add__Tensor::schema> create__foreach_add__Tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add__Tensor::name, _foreach_add__Tensor::overload_name)
      .typed<_foreach_add__Tensor::schema>();
}

// aten::_foreach_add_.Tensor(Tensor(a!)[] self, Tensor other, *, Scalar alpha=1) -> ()
void _foreach_add__Tensor::call(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create__foreach_add__Tensor_typed_handle();
    return op.call(self, other, alpha);
}

// aten::_foreach_add_.Tensor(Tensor(a!)[] self, Tensor other, *, Scalar alpha=1) -> ()
void _foreach_add__Tensor::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create__foreach_add__Tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_Scalar, name, "aten::_foreach_clamp_min")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_Scalar, schema_str, "_foreach_clamp_min.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]")

// aten::_foreach_clamp_min.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_min_Scalar::schema> create__foreach_clamp_min_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_min_Scalar::name, _foreach_clamp_min_Scalar::overload_name)
      .typed<_foreach_clamp_min_Scalar::schema>();
}

// aten::_foreach_clamp_min.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_min_Scalar::call(at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_clamp_min_Scalar_typed_handle();
    return op.call(self, scalar);
}

// aten::_foreach_clamp_min.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_min_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_clamp_min_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min__Scalar, name, "aten::_foreach_clamp_min_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min__Scalar, schema_str, "_foreach_clamp_min_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()")

// aten::_foreach_clamp_min_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_min__Scalar::schema> create__foreach_clamp_min__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_min__Scalar::name, _foreach_clamp_min__Scalar::overload_name)
      .typed<_foreach_clamp_min__Scalar::schema>();
}

// aten::_foreach_clamp_min_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
void _foreach_clamp_min__Scalar::call(at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_clamp_min__Scalar_typed_handle();
    return op.call(self, scalar);
}

// aten::_foreach_clamp_min_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
void _foreach_clamp_min__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_clamp_min__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_List, name, "aten::_foreach_clamp_min")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_List, schema_str, "_foreach_clamp_min.List(Tensor[] self, Tensor[] other) -> Tensor[]")

// aten::_foreach_clamp_min.List(Tensor[] self, Tensor[] other) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_min_List::schema> create__foreach_clamp_min_List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_min_List::name, _foreach_clamp_min_List::overload_name)
      .typed<_foreach_clamp_min_List::schema>();
}

// aten::_foreach_clamp_min.List(Tensor[] self, Tensor[] other) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_min_List::call(at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_clamp_min_List_typed_handle();
    return op.call(self, other);
}

// aten::_foreach_clamp_min.List(Tensor[] self, Tensor[] other) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_min_List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_clamp_min_List_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min__List, name, "aten::_foreach_clamp_min_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min__List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min__List, schema_str, "_foreach_clamp_min_.List(Tensor(a!)[] self, Tensor[] other) -> ()")

// aten::_foreach_clamp_min_.List(Tensor(a!)[] self, Tensor[] other) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_min__List::schema> create__foreach_clamp_min__List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_min__List::name, _foreach_clamp_min__List::overload_name)
      .typed<_foreach_clamp_min__List::schema>();
}

// aten::_foreach_clamp_min_.List(Tensor(a!)[] self, Tensor[] other) -> ()
void _foreach_clamp_min__List::call(at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_clamp_min__List_typed_handle();
    return op.call(self, other);
}

// aten::_foreach_clamp_min_.List(Tensor(a!)[] self, Tensor[] other) -> ()
void _foreach_clamp_min__List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_clamp_min__List_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_ScalarList, name, "aten::_foreach_clamp_min")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_ScalarList, overload_name, "ScalarList")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_ScalarList, schema_str, "_foreach_clamp_min.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]")

// aten::_foreach_clamp_min.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_min_ScalarList::schema> create__foreach_clamp_min_ScalarList_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_min_ScalarList::name, _foreach_clamp_min_ScalarList::overload_name)
      .typed<_foreach_clamp_min_ScalarList::schema>();
}

// aten::_foreach_clamp_min.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_min_ScalarList::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_clamp_min_ScalarList_typed_handle();
    return op.call(self, scalars);
}

// aten::_foreach_clamp_min.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
::std::vector<at::Tensor> _foreach_clamp_min_ScalarList::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_clamp_min_ScalarList_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min__ScalarList, name, "aten::_foreach_clamp_min_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min__ScalarList, overload_name, "ScalarList")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min__ScalarList, schema_str, "_foreach_clamp_min_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()")

// aten::_foreach_clamp_min_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_min__ScalarList::schema> create__foreach_clamp_min__ScalarList_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_min__ScalarList::name, _foreach_clamp_min__ScalarList::overload_name)
      .typed<_foreach_clamp_min__ScalarList::schema>();
}

// aten::_foreach_clamp_min_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
void _foreach_clamp_min__ScalarList::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_clamp_min__ScalarList_typed_handle();
    return op.call(self, scalars);
}

// aten::_foreach_clamp_min_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
void _foreach_clamp_min__ScalarList::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_clamp_min__ScalarList_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_Scalar, name, "aten::_foreach_minimum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_Scalar, schema_str, "_foreach_minimum.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]")

// aten::_foreach_minimum.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_minimum_Scalar::schema> create__foreach_minimum_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_minimum_Scalar::name, _foreach_minimum_Scalar::overload_name)
      .typed<_foreach_minimum_Scalar::schema>();
}

// aten::_foreach_minimum.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
::std::vector<at::Tensor> _foreach_minimum_Scalar::call(at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_minimum_Scalar_typed_handle();
    return op.call(self, scalar);
}

// aten::_foreach_minimum.Scalar(Tensor[] self, Scalar scalar) -> Tensor[]
::std::vector<at::Tensor> _foreach_minimum_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_minimum_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum__Scalar, name, "aten::_foreach_minimum_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum__Scalar, schema_str, "_foreach_minimum_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()")

// aten::_foreach_minimum_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_minimum__Scalar::schema> create__foreach_minimum__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_minimum__Scalar::name, _foreach_minimum__Scalar::overload_name)
      .typed<_foreach_minimum__Scalar::schema>();
}

// aten::_foreach_minimum_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
void _foreach_minimum__Scalar::call(at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_minimum__Scalar_typed_handle();
    return op.call(self, scalar);
}

// aten::_foreach_minimum_.Scalar(Tensor(a!)[] self, Scalar scalar) -> ()
void _foreach_minimum__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar) {
    
    static auto op = create__foreach_minimum__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_List, name, "aten::_foreach_minimum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_List, schema_str, "_foreach_minimum.List(Tensor[] self, Tensor[] other) -> Tensor[]")

// aten::_foreach_minimum.List(Tensor[] self, Tensor[] other) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_minimum_List::schema> create__foreach_minimum_List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_minimum_List::name, _foreach_minimum_List::overload_name)
      .typed<_foreach_minimum_List::schema>();
}

// aten::_foreach_minimum.List(Tensor[] self, Tensor[] other) -> Tensor[]
::std::vector<at::Tensor> _foreach_minimum_List::call(at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_minimum_List_typed_handle();
    return op.call(self, other);
}

// aten::_foreach_minimum.List(Tensor[] self, Tensor[] other) -> Tensor[]
::std::vector<at::Tensor> _foreach_minimum_List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_minimum_List_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum__List, name, "aten::_foreach_minimum_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum__List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum__List, schema_str, "_foreach_minimum_.List(Tensor(a!)[] self, Tensor[] other) -> ()")

// aten::_foreach_minimum_.List(Tensor(a!)[] self, Tensor[] other) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_minimum__List::schema> create__foreach_minimum__List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_minimum__List::name, _foreach_minimum__List::overload_name)
      .typed<_foreach_minimum__List::schema>();
}

// aten::_foreach_minimum_.List(Tensor(a!)[] self, Tensor[] other) -> ()
void _foreach_minimum__List::call(at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_minimum__List_typed_handle();
    return op.call(self, other);
}

// aten::_foreach_minimum_.List(Tensor(a!)[] self, Tensor[] other) -> ()
void _foreach_minimum__List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other) {
    
    static auto op = create__foreach_minimum__List_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_ScalarList, name, "aten::_foreach_minimum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_ScalarList, overload_name, "ScalarList")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_ScalarList, schema_str, "_foreach_minimum.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]")

// aten::_foreach_minimum.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_minimum_ScalarList::schema> create__foreach_minimum_ScalarList_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_minimum_ScalarList::name, _foreach_minimum_ScalarList::overload_name)
      .typed<_foreach_minimum_ScalarList::schema>();
}

// aten::_foreach_minimum.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
::std::vector<at::Tensor> _foreach_minimum_ScalarList::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_minimum_ScalarList_typed_handle();
    return op.call(self, scalars);
}

// aten::_foreach_minimum.ScalarList(Tensor[] self, Scalar[] scalars) -> Tensor[]
::std::vector<at::Tensor> _foreach_minimum_ScalarList::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_minimum_ScalarList_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum__ScalarList, name, "aten::_foreach_minimum_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum__ScalarList, overload_name, "ScalarList")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum__ScalarList, schema_str, "_foreach_minimum_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()")

// aten::_foreach_minimum_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_minimum__ScalarList::schema> create__foreach_minimum__ScalarList_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_minimum__ScalarList::name, _foreach_minimum__ScalarList::overload_name)
      .typed<_foreach_minimum__ScalarList::schema>();
}

// aten::_foreach_minimum_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
void _foreach_minimum__ScalarList::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_minimum__ScalarList_typed_handle();
    return op.call(self, scalars);
}

// aten::_foreach_minimum_.ScalarList(Tensor(a!)[] self, Scalar[] scalars) -> ()
void _foreach_minimum__ScalarList::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    
    static auto op = create__foreach_minimum__ScalarList_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_cosh, name, "aten::_foreach_cosh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_cosh, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_cosh, schema_str, "_foreach_cosh(Tensor[] self) -> Tensor[]")

// aten::_foreach_cosh(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_cosh::schema> create__foreach_cosh_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_cosh::name, _foreach_cosh::overload_name)
      .typed<_foreach_cosh::schema>();
}

// aten::_foreach_cosh(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_cosh::call(at::TensorList self) {
    
    static auto op = create__foreach_cosh_typed_handle();
    return op.call(self);
}

// aten::_foreach_cosh(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_cosh::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_cosh_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_cosh_, name, "aten::_foreach_cosh_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_cosh_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_cosh_, schema_str, "_foreach_cosh_(Tensor(a!)[] self) -> ()")

// aten::_foreach_cosh_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_cosh_::schema> create__foreach_cosh__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_cosh_::name, _foreach_cosh_::overload_name)
      .typed<_foreach_cosh_::schema>();
}

// aten::_foreach_cosh_(Tensor(a!)[] self) -> ()
void _foreach_cosh_::call(at::TensorList self) {
    
    static auto op = create__foreach_cosh__typed_handle();
    return op.call(self);
}

// aten::_foreach_cosh_(Tensor(a!)[] self) -> ()
void _foreach_cosh_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_cosh__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_erfc, name, "aten::_foreach_erfc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_erfc, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_erfc, schema_str, "_foreach_erfc(Tensor[] self) -> Tensor[]")

// aten::_foreach_erfc(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_erfc::schema> create__foreach_erfc_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_erfc::name, _foreach_erfc::overload_name)
      .typed<_foreach_erfc::schema>();
}

// aten::_foreach_erfc(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_erfc::call(at::TensorList self) {
    
    static auto op = create__foreach_erfc_typed_handle();
    return op.call(self);
}

// aten::_foreach_erfc(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_erfc::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_erfc_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_erfc_, name, "aten::_foreach_erfc_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_erfc_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_erfc_, schema_str, "_foreach_erfc_(Tensor(a!)[] self) -> ()")

// aten::_foreach_erfc_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_erfc_::schema> create__foreach_erfc__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_erfc_::name, _foreach_erfc_::overload_name)
      .typed<_foreach_erfc_::schema>();
}

// aten::_foreach_erfc_(Tensor(a!)[] self) -> ()
void _foreach_erfc_::call(at::TensorList self) {
    
    static auto op = create__foreach_erfc__typed_handle();
    return op.call(self);
}

// aten::_foreach_erfc_(Tensor(a!)[] self) -> ()
void _foreach_erfc_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_erfc__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_frac, name, "aten::_foreach_frac")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_frac, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_frac, schema_str, "_foreach_frac(Tensor[] self) -> Tensor[]")

// aten::_foreach_frac(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_frac::schema> create__foreach_frac_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_frac::name, _foreach_frac::overload_name)
      .typed<_foreach_frac::schema>();
}

// aten::_foreach_frac(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_frac::call(at::TensorList self) {
    
    static auto op = create__foreach_frac_typed_handle();
    return op.call(self);
}

// aten::_foreach_frac(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_frac::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_frac_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_frac_, name, "aten::_foreach_frac_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_frac_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_frac_, schema_str, "_foreach_frac_(Tensor(a!)[] self) -> ()")

// aten::_foreach_frac_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_frac_::schema> create__foreach_frac__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_frac_::name, _foreach_frac_::overload_name)
      .typed<_foreach_frac_::schema>();
}

// aten::_foreach_frac_(Tensor(a!)[] self) -> ()
void _foreach_frac_::call(at::TensorList self) {
    
    static auto op = create__foreach_frac__typed_handle();
    return op.call(self);
}

// aten::_foreach_frac_(Tensor(a!)[] self) -> ()
void _foreach_frac_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_frac__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_List, name, "aten::_foreach_lerp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_List, schema_str, "_foreach_lerp.List(Tensor[] self, Tensor[] tensors1, Tensor[] weights) -> Tensor[]")

// aten::_foreach_lerp.List(Tensor[] self, Tensor[] tensors1, Tensor[] weights) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_lerp_List::schema> create__foreach_lerp_List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_lerp_List::name, _foreach_lerp_List::overload_name)
      .typed<_foreach_lerp_List::schema>();
}

// aten::_foreach_lerp.List(Tensor[] self, Tensor[] tensors1, Tensor[] weights) -> Tensor[]
::std::vector<at::Tensor> _foreach_lerp_List::call(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
    
    static auto op = create__foreach_lerp_List_typed_handle();
    return op.call(self, tensors1, weights);
}

// aten::_foreach_lerp.List(Tensor[] self, Tensor[] tensors1, Tensor[] weights) -> Tensor[]
::std::vector<at::Tensor> _foreach_lerp_List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
    
    static auto op = create__foreach_lerp_List_typed_handle();
    return op.redispatch(dispatchKeySet, self, tensors1, weights);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp__List, name, "aten::_foreach_lerp_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp__List, overload_name, "List")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp__List, schema_str, "_foreach_lerp_.List(Tensor(a!)[] self, Tensor[] tensors1, Tensor[] weights) -> ()")

// aten::_foreach_lerp_.List(Tensor(a!)[] self, Tensor[] tensors1, Tensor[] weights) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_lerp__List::schema> create__foreach_lerp__List_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_lerp__List::name, _foreach_lerp__List::overload_name)
      .typed<_foreach_lerp__List::schema>();
}

// aten::_foreach_lerp_.List(Tensor(a!)[] self, Tensor[] tensors1, Tensor[] weights) -> ()
void _foreach_lerp__List::call(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
    
    static auto op = create__foreach_lerp__List_typed_handle();
    return op.call(self, tensors1, weights);
}

// aten::_foreach_lerp_.List(Tensor(a!)[] self, Tensor[] tensors1, Tensor[] weights) -> ()
void _foreach_lerp__List::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
    
    static auto op = create__foreach_lerp__List_typed_handle();
    return op.redispatch(dispatchKeySet, self, tensors1, weights);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_Scalar, name, "aten::_foreach_lerp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_Scalar, schema_str, "_foreach_lerp.Scalar(Tensor[] self, Tensor[] tensors1, Scalar weight) -> Tensor[]")

// aten::_foreach_lerp.Scalar(Tensor[] self, Tensor[] tensors1, Scalar weight) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_lerp_Scalar::schema> create__foreach_lerp_Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_lerp_Scalar::name, _foreach_lerp_Scalar::overload_name)
      .typed<_foreach_lerp_Scalar::schema>();
}

// aten::_foreach_lerp.Scalar(Tensor[] self, Tensor[] tensors1, Scalar weight) -> Tensor[]
::std::vector<at::Tensor> _foreach_lerp_Scalar::call(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
    
    static auto op = create__foreach_lerp_Scalar_typed_handle();
    return op.call(self, tensors1, weight);
}

// aten::_foreach_lerp.Scalar(Tensor[] self, Tensor[] tensors1, Scalar weight) -> Tensor[]
::std::vector<at::Tensor> _foreach_lerp_Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
    
    static auto op = create__foreach_lerp_Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, tensors1, weight);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp__Scalar, name, "aten::_foreach_lerp_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp__Scalar, overload_name, "Scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp__Scalar, schema_str, "_foreach_lerp_.Scalar(Tensor(a!)[] self, Tensor[] tensors1, Scalar weight) -> ()")

// aten::_foreach_lerp_.Scalar(Tensor(a!)[] self, Tensor[] tensors1, Scalar weight) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_lerp__Scalar::schema> create__foreach_lerp__Scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_lerp__Scalar::name, _foreach_lerp__Scalar::overload_name)
      .typed<_foreach_lerp__Scalar::schema>();
}

// aten::_foreach_lerp_.Scalar(Tensor(a!)[] self, Tensor[] tensors1, Scalar weight) -> ()
void _foreach_lerp__Scalar::call(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
    
    static auto op = create__foreach_lerp__Scalar_typed_handle();
    return op.call(self, tensors1, weight);
}

// aten::_foreach_lerp_.Scalar(Tensor(a!)[] self, Tensor[] tensors1, Scalar weight) -> ()
void _foreach_lerp__Scalar::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
    
    static auto op = create__foreach_lerp__Scalar_typed_handle();
    return op.redispatch(dispatchKeySet, self, tensors1, weight);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lgamma, name, "aten::_foreach_lgamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lgamma, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lgamma, schema_str, "_foreach_lgamma(Tensor[] self) -> Tensor[]")

// aten::_foreach_lgamma(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_lgamma::schema> create__foreach_lgamma_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_lgamma::name, _foreach_lgamma::overload_name)
      .typed<_foreach_lgamma::schema>();
}

// aten::_foreach_lgamma(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_lgamma::call(at::TensorList self) {
    
    static auto op = create__foreach_lgamma_typed_handle();
    return op.call(self);
}

// aten::_foreach_lgamma(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_lgamma::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_lgamma_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lgamma_, name, "aten::_foreach_lgamma_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lgamma_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lgamma_, schema_str, "_foreach_lgamma_(Tensor(a!)[] self) -> ()")

// aten::_foreach_lgamma_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_lgamma_::schema> create__foreach_lgamma__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_lgamma_::name, _foreach_lgamma_::overload_name)
      .typed<_foreach_lgamma_::schema>();
}

// aten::_foreach_lgamma_(Tensor(a!)[] self) -> ()
void _foreach_lgamma_::call(at::TensorList self) {
    
    static auto op = create__foreach_lgamma__typed_handle();
    return op.call(self);
}

// aten::_foreach_lgamma_(Tensor(a!)[] self) -> ()
void _foreach_lgamma_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_lgamma__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_round, name, "aten::_foreach_round")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_round, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_round, schema_str, "_foreach_round(Tensor[] self) -> Tensor[]")

// aten::_foreach_round(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_round::schema> create__foreach_round_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_round::name, _foreach_round::overload_name)
      .typed<_foreach_round::schema>();
}

// aten::_foreach_round(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_round::call(at::TensorList self) {
    
    static auto op = create__foreach_round_typed_handle();
    return op.call(self);
}

// aten::_foreach_round(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_round::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_round_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_round_, name, "aten::_foreach_round_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_round_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_round_, schema_str, "_foreach_round_(Tensor(a!)[] self) -> ()")

// aten::_foreach_round_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_round_::schema> create__foreach_round__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_round_::name, _foreach_round_::overload_name)
      .typed<_foreach_round_::schema>();
}

// aten::_foreach_round_(Tensor(a!)[] self) -> ()
void _foreach_round_::call(at::TensorList self) {
    
    static auto op = create__foreach_round__typed_handle();
    return op.call(self);
}

// aten::_foreach_round_(Tensor(a!)[] self) -> ()
void _foreach_round_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_round__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_trunc, name, "aten::_foreach_trunc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_trunc, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_trunc, schema_str, "_foreach_trunc(Tensor[] self) -> Tensor[]")

// aten::_foreach_trunc(Tensor[] self) -> Tensor[]
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_trunc::schema> create__foreach_trunc_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_trunc::name, _foreach_trunc::overload_name)
      .typed<_foreach_trunc::schema>();
}

// aten::_foreach_trunc(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_trunc::call(at::TensorList self) {
    
    static auto op = create__foreach_trunc_typed_handle();
    return op.call(self);
}

// aten::_foreach_trunc(Tensor[] self) -> Tensor[]
::std::vector<at::Tensor> _foreach_trunc::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_trunc_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_trunc_, name, "aten::_foreach_trunc_")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_trunc_, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_trunc_, schema_str, "_foreach_trunc_(Tensor(a!)[] self) -> ()")

// aten::_foreach_trunc_(Tensor(a!)[] self) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_trunc_::schema> create__foreach_trunc__typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_trunc_::name, _foreach_trunc_::overload_name)
      .typed<_foreach_trunc_::schema>();
}

// aten::_foreach_trunc_(Tensor(a!)[] self) -> ()
void _foreach_trunc_::call(at::TensorList self) {
    
    static auto op = create__foreach_trunc__typed_handle();
    return op.call(self);
}

// aten::_foreach_trunc_(Tensor(a!)[] self) -> ()
void _foreach_trunc_::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self) {
    
    static auto op = create__foreach_trunc__typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mse_loss_backward_grad_input, name, "aten::mse_loss_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mse_loss_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mse_loss_backward_grad_input, schema_str, "mse_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::mse_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mse_loss_backward_grad_input::schema> create_mse_loss_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mse_loss_backward_grad_input::name, mse_loss_backward_grad_input::overload_name)
      .typed<mse_loss_backward_grad_input::schema>();
}

// aten::mse_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & mse_loss_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & grad_input) {
    
    static auto op = create_mse_loss_backward_grad_input_typed_handle();
    return op.call(grad_output, self, target, reduction, grad_input);
}

// aten::mse_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & mse_loss_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & grad_input) {
    
    static auto op = create_mse_loss_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, target, reduction, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mse_loss_backward, name, "aten::mse_loss_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mse_loss_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mse_loss_backward, schema_str, "mse_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -> Tensor")

// aten::mse_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mse_loss_backward::schema> create_mse_loss_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mse_loss_backward::name, mse_loss_backward::overload_name)
      .typed<mse_loss_backward::schema>();
}

// aten::mse_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -> Tensor
at::Tensor mse_loss_backward::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
    
    static auto op = create_mse_loss_backward_typed_handle();
    return op.call(grad_output, self, target, reduction);
}

// aten::mse_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction) -> Tensor
at::Tensor mse_loss_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
    
    static auto op = create_mse_loss_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, target, reduction);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multi_margin_loss_backward_grad_input, name, "aten::multi_margin_loss_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multi_margin_loss_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multi_margin_loss_backward_grad_input, schema_str, "multi_margin_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::multi_margin_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<multi_margin_loss_backward_grad_input::schema> create_multi_margin_loss_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multi_margin_loss_backward_grad_input::name, multi_margin_loss_backward_grad_input::overload_name)
      .typed<multi_margin_loss_backward_grad_input::schema>();
}

// aten::multi_margin_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & multi_margin_loss_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
    
    static auto op = create_multi_margin_loss_backward_grad_input_typed_handle();
    return op.call(grad_output, self, target, p, margin, weight, reduction, grad_input);
}

// aten::multi_margin_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & multi_margin_loss_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
    
    static auto op = create_multi_margin_loss_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, target, p, margin, weight, reduction, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multi_margin_loss_backward, name, "aten::multi_margin_loss_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multi_margin_loss_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multi_margin_loss_backward, schema_str, "multi_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean) -> Tensor")

// aten::multi_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<multi_margin_loss_backward::schema> create_multi_margin_loss_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multi_margin_loss_backward::name, multi_margin_loss_backward::overload_name)
      .typed<multi_margin_loss_backward::schema>();
}

// aten::multi_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean) -> Tensor
at::Tensor multi_margin_loss_backward::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    
    static auto op = create_multi_margin_loss_backward_typed_handle();
    return op.call(grad_output, self, target, p, margin, weight, reduction);
}

// aten::multi_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, Scalar p, Scalar margin, Tensor? weight=None, int reduction=Mean) -> Tensor
at::Tensor multi_margin_loss_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    
    static auto op = create_multi_margin_loss_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, target, p, margin, weight, reduction);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multilabel_margin_loss_backward_grad_input, name, "aten::multilabel_margin_loss_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multilabel_margin_loss_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multilabel_margin_loss_backward_grad_input, schema_str, "multilabel_margin_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::multilabel_margin_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<multilabel_margin_loss_backward_grad_input::schema> create_multilabel_margin_loss_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multilabel_margin_loss_backward_grad_input::name, multilabel_margin_loss_backward_grad_input::overload_name)
      .typed<multilabel_margin_loss_backward_grad_input::schema>();
}

// aten::multilabel_margin_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & multilabel_margin_loss_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target, at::Tensor & grad_input) {
    
    static auto op = create_multilabel_margin_loss_backward_grad_input_typed_handle();
    return op.call(grad_output, self, target, reduction, is_target, grad_input);
}

// aten::multilabel_margin_loss_backward.grad_input(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & multilabel_margin_loss_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target, at::Tensor & grad_input) {
    
    static auto op = create_multilabel_margin_loss_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, target, reduction, is_target, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multilabel_margin_loss_backward, name, "aten::multilabel_margin_loss_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multilabel_margin_loss_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(multilabel_margin_loss_backward, schema_str, "multilabel_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target) -> Tensor")

// aten::multilabel_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<multilabel_margin_loss_backward::schema> create_multilabel_margin_loss_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(multilabel_margin_loss_backward::name, multilabel_margin_loss_backward::overload_name)
      .typed<multilabel_margin_loss_backward::schema>();
}

// aten::multilabel_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target) -> Tensor
at::Tensor multilabel_margin_loss_backward::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target) {
    
    static auto op = create_multilabel_margin_loss_backward_typed_handle();
    return op.call(grad_output, self, target, reduction, is_target);
}

// aten::multilabel_margin_loss_backward(Tensor grad_output, Tensor self, Tensor target, int reduction, Tensor is_target) -> Tensor
at::Tensor multilabel_margin_loss_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target) {
    
    static auto op = create_multilabel_margin_loss_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, target, reduction, is_target);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_backward_grad_input, name, "aten::elu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_backward_grad_input, schema_str, "elu_backward.grad_input(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::elu_backward.grad_input(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<elu_backward_grad_input::schema> create_elu_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(elu_backward_grad_input::name, elu_backward_grad_input::overload_name)
      .typed<elu_backward_grad_input::schema>();
}

// aten::elu_backward.grad_input(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & elu_backward_grad_input::call(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result, at::Tensor & grad_input) {
    
    static auto op = create_elu_backward_grad_input_typed_handle();
    return op.call(grad_output, alpha, scale, input_scale, is_result, self_or_result, grad_input);
}

// aten::elu_backward.grad_input(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & elu_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result, at::Tensor & grad_input) {
    
    static auto op = create_elu_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, alpha, scale, input_scale, is_result, self_or_result, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_backward, name, "aten::elu_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(elu_backward, schema_str, "elu_backward(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result) -> Tensor")

// aten::elu_backward(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<elu_backward::schema> create_elu_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(elu_backward::name, elu_backward::overload_name)
      .typed<elu_backward::schema>();
}

// aten::elu_backward(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result) -> Tensor
at::Tensor elu_backward::call(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
    
    static auto op = create_elu_backward_typed_handle();
    return op.call(grad_output, alpha, scale, input_scale, is_result, self_or_result);
}

// aten::elu_backward(Tensor grad_output, Scalar alpha, Scalar scale, Scalar input_scale, bool is_result, Tensor self_or_result) -> Tensor
at::Tensor elu_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
    
    static auto op = create_elu_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, alpha, scale, input_scale, is_result, self_or_result);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardsigmoid_backward_grad_input, name, "aten::hardsigmoid_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardsigmoid_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardsigmoid_backward_grad_input, schema_str, "hardsigmoid_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::hardsigmoid_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<hardsigmoid_backward_grad_input::schema> create_hardsigmoid_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(hardsigmoid_backward_grad_input::name, hardsigmoid_backward_grad_input::overload_name)
      .typed<hardsigmoid_backward_grad_input::schema>();
}

// aten::hardsigmoid_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & hardsigmoid_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
    
    static auto op = create_hardsigmoid_backward_grad_input_typed_handle();
    return op.call(grad_output, self, grad_input);
}

// aten::hardsigmoid_backward.grad_input(Tensor grad_output, Tensor self, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & hardsigmoid_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
    
    static auto op = create_hardsigmoid_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardsigmoid_backward, name, "aten::hardsigmoid_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardsigmoid_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(hardsigmoid_backward, schema_str, "hardsigmoid_backward(Tensor grad_output, Tensor self) -> Tensor")

// aten::hardsigmoid_backward(Tensor grad_output, Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<hardsigmoid_backward::schema> create_hardsigmoid_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(hardsigmoid_backward::name, hardsigmoid_backward::overload_name)
      .typed<hardsigmoid_backward::schema>();
}

// aten::hardsigmoid_backward(Tensor grad_output, Tensor self) -> Tensor
at::Tensor hardsigmoid_backward::call(const at::Tensor & grad_output, const at::Tensor & self) {
    
    static auto op = create_hardsigmoid_backward_typed_handle();
    return op.call(grad_output, self);
}

// aten::hardsigmoid_backward(Tensor grad_output, Tensor self) -> Tensor
at::Tensor hardsigmoid_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self) {
    
    static auto op = create_hardsigmoid_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu_with_noise_backward, name, "aten::rrelu_with_noise_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu_with_noise_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu_with_noise_backward, schema_str, "rrelu_with_noise_backward(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result) -> Tensor")

// aten::rrelu_with_noise_backward(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<rrelu_with_noise_backward::schema> create_rrelu_with_noise_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(rrelu_with_noise_backward::name, rrelu_with_noise_backward::overload_name)
      .typed<rrelu_with_noise_backward::schema>();
}

// aten::rrelu_with_noise_backward(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result) -> Tensor
at::Tensor rrelu_with_noise_backward::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, bool self_is_result) {
    
    static auto op = create_rrelu_with_noise_backward_typed_handle();
    return op.call(grad_output, self, noise, lower, upper, training, self_is_result);
}

// aten::rrelu_with_noise_backward(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result) -> Tensor
at::Tensor rrelu_with_noise_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, bool self_is_result) {
    
    static auto op = create_rrelu_with_noise_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, noise, lower, upper, training, self_is_result);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus_backward_grad_input, name, "aten::softplus_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus_backward_grad_input, schema_str, "softplus_backward.grad_input(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::softplus_backward.grad_input(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<softplus_backward_grad_input::schema> create_softplus_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(softplus_backward_grad_input::name, softplus_backward_grad_input::overload_name)
      .typed<softplus_backward_grad_input::schema>();
}

// aten::softplus_backward.grad_input(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & softplus_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & grad_input) {
    
    static auto op = create_softplus_backward_grad_input_typed_handle();
    return op.call(grad_output, self, beta, threshold, grad_input);
}

// aten::softplus_backward.grad_input(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & softplus_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & grad_input) {
    
    static auto op = create_softplus_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, beta, threshold, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus_backward, name, "aten::softplus_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(softplus_backward, schema_str, "softplus_backward(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold) -> Tensor")

// aten::softplus_backward(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<softplus_backward::schema> create_softplus_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(softplus_backward::name, softplus_backward::overload_name)
      .typed<softplus_backward::schema>();
}

// aten::softplus_backward(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold) -> Tensor
at::Tensor softplus_backward::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
    
    static auto op = create_softplus_backward_typed_handle();
    return op.call(grad_output, self, beta, threshold);
}

// aten::softplus_backward(Tensor grad_output, Tensor self, Scalar beta, Scalar threshold) -> Tensor
at::Tensor softplus_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
    
    static auto op = create_softplus_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, beta, threshold);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d_backward, name, "aten::mkldnn_adaptive_avg_pool2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d_backward, schema_str, "mkldnn_adaptive_avg_pool2d_backward(Tensor grad_output, Tensor self) -> Tensor")

// aten::mkldnn_adaptive_avg_pool2d_backward(Tensor grad_output, Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_adaptive_avg_pool2d_backward::schema> create_mkldnn_adaptive_avg_pool2d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_adaptive_avg_pool2d_backward::name, mkldnn_adaptive_avg_pool2d_backward::overload_name)
      .typed<mkldnn_adaptive_avg_pool2d_backward::schema>();
}

// aten::mkldnn_adaptive_avg_pool2d_backward(Tensor grad_output, Tensor self) -> Tensor
at::Tensor mkldnn_adaptive_avg_pool2d_backward::call(const at::Tensor & grad_output, const at::Tensor & self) {
    
    static auto op = create_mkldnn_adaptive_avg_pool2d_backward_typed_handle();
    return op.call(grad_output, self);
}

// aten::mkldnn_adaptive_avg_pool2d_backward(Tensor grad_output, Tensor self) -> Tensor
at::Tensor mkldnn_adaptive_avg_pool2d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self) {
    
    static auto op = create_mkldnn_adaptive_avg_pool2d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fractional_max_pool3d_backward_grad_input, name, "aten::fractional_max_pool3d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fractional_max_pool3d_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fractional_max_pool3d_backward_grad_input, schema_str, "fractional_max_pool3d_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::fractional_max_pool3d_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fractional_max_pool3d_backward_grad_input::schema> create_fractional_max_pool3d_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fractional_max_pool3d_backward_grad_input::name, fractional_max_pool3d_backward_grad_input::overload_name)
      .typed<fractional_max_pool3d_backward_grad_input::schema>();
}

// aten::fractional_max_pool3d_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & fractional_max_pool3d_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
    
    static auto op = create_fractional_max_pool3d_backward_grad_input_typed_handle();
    return op.call(grad_output, self, kernel_size, output_size, indices, grad_input);
}

// aten::fractional_max_pool3d_backward.grad_input(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & fractional_max_pool3d_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
    
    static auto op = create_fractional_max_pool3d_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, kernel_size, output_size, indices, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fractional_max_pool3d_backward, name, "aten::fractional_max_pool3d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fractional_max_pool3d_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fractional_max_pool3d_backward, schema_str, "fractional_max_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices) -> Tensor")

// aten::fractional_max_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fractional_max_pool3d_backward::schema> create_fractional_max_pool3d_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fractional_max_pool3d_backward::name, fractional_max_pool3d_backward::overload_name)
      .typed<fractional_max_pool3d_backward::schema>();
}

// aten::fractional_max_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices) -> Tensor
at::Tensor fractional_max_pool3d_backward::call(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
    
    static auto op = create_fractional_max_pool3d_backward_typed_handle();
    return op.call(grad_output, self, kernel_size, output_size, indices);
}

// aten::fractional_max_pool3d_backward(Tensor grad_output, Tensor self, int[3] kernel_size, int[3] output_size, Tensor indices) -> Tensor
at::Tensor fractional_max_pool3d_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
    
    static auto op = create_fractional_max_pool3d_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, kernel_size, output_size, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices_out, name, "aten::max_pool2d_with_indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices_out, schema_str, "max_pool2d_with_indices.out(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))")

// aten::max_pool2d_with_indices.out(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<max_pool2d_with_indices_out::schema> create_max_pool2d_with_indices_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool2d_with_indices_out::name, max_pool2d_with_indices_out::overload_name)
      .typed<max_pool2d_with_indices_out::schema>();
}

// aten::max_pool2d_with_indices.out(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> max_pool2d_with_indices_out::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
    
    static auto op = create_max_pool2d_with_indices_out_typed_handle();
    return op.call(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}

// aten::max_pool2d_with_indices.out(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False, *, Tensor(a!) out, Tensor(b!) indices) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> max_pool2d_with_indices_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
    
    static auto op = create_max_pool2d_with_indices_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices, name, "aten::max_pool2d_with_indices")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(max_pool2d_with_indices, schema_str, "max_pool2d_with_indices(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)")

// aten::max_pool2d_with_indices(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)
static C10_NOINLINE c10::TypedOperatorHandle<max_pool2d_with_indices::schema> create_max_pool2d_with_indices_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(max_pool2d_with_indices::name, max_pool2d_with_indices::overload_name)
      .typed<max_pool2d_with_indices::schema>();
}

// aten::max_pool2d_with_indices(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> max_pool2d_with_indices::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool2d_with_indices_typed_handle();
    return op.call(self, kernel_size, stride, padding, dilation, ceil_mode);
}

// aten::max_pool2d_with_indices(Tensor self, int[2] kernel_size, int[2] stride=[], int[2] padding=0, int[2] dilation=1, bool ceil_mode=False) -> (Tensor, Tensor)
::std::tuple<at::Tensor,at::Tensor> max_pool2d_with_indices::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    
    static auto op = create_max_pool2d_with_indices_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, dilation, ceil_mode);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad1d_out, name, "aten::reflection_pad1d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad1d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad1d_out, schema_str, "reflection_pad1d.out(Tensor self, SymInt[2] padding, *, Tensor(a!) out) -> Tensor(a!)")

// aten::reflection_pad1d.out(Tensor self, SymInt[2] padding, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<reflection_pad1d_out::schema> create_reflection_pad1d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(reflection_pad1d_out::name, reflection_pad1d_out::overload_name)
      .typed<reflection_pad1d_out::schema>();
}

// aten::reflection_pad1d.out(Tensor self, SymInt[2] padding, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & reflection_pad1d_out::call(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
    
    static auto op = create_reflection_pad1d_out_typed_handle();
    return op.call(self, padding, out);
}

// aten::reflection_pad1d.out(Tensor self, SymInt[2] padding, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & reflection_pad1d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
    
    static auto op = create_reflection_pad1d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, padding, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad1d, name, "aten::reflection_pad1d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad1d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(reflection_pad1d, schema_str, "reflection_pad1d(Tensor self, SymInt[2] padding) -> Tensor")

// aten::reflection_pad1d(Tensor self, SymInt[2] padding) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<reflection_pad1d::schema> create_reflection_pad1d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(reflection_pad1d::name, reflection_pad1d::overload_name)
      .typed<reflection_pad1d::schema>();
}

// aten::reflection_pad1d(Tensor self, SymInt[2] padding) -> Tensor
at::Tensor reflection_pad1d::call(const at::Tensor & self, c10::SymIntArrayRef padding) {
    
    static auto op = create_reflection_pad1d_typed_handle();
    return op.call(self, padding);
}

// aten::reflection_pad1d(Tensor self, SymInt[2] padding) -> Tensor
at::Tensor reflection_pad1d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef padding) {
    
    static auto op = create_reflection_pad1d_typed_handle();
    return op.redispatch(dispatchKeySet, self, padding);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pad_enum, name, "aten::_pad_enum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pad_enum, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pad_enum, schema_str, "_pad_enum(Tensor self, SymInt[] pad, int mode, float? value=None) -> Tensor")

// aten::_pad_enum(Tensor self, SymInt[] pad, int mode, float? value=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_pad_enum::schema> create__pad_enum_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_pad_enum::name, _pad_enum::overload_name)
      .typed<_pad_enum::schema>();
}

// aten::_pad_enum(Tensor self, SymInt[] pad, int mode, float? value=None) -> Tensor
at::Tensor _pad_enum::call(const at::Tensor & self, c10::SymIntArrayRef pad, int64_t mode, c10::optional<double> value) {
    
    static auto op = create__pad_enum_typed_handle();
    return op.call(self, pad, mode, value);
}

// aten::_pad_enum(Tensor self, SymInt[] pad, int mode, float? value=None) -> Tensor
at::Tensor _pad_enum::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef pad, int64_t mode, c10::optional<double> value) {
    
    static auto op = create__pad_enum_typed_handle();
    return op.redispatch(dispatchKeySet, self, pad, mode, value);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_trilinear3d_vec, name, "aten::upsample_trilinear3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_trilinear3d_vec, overload_name, "vec")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_trilinear3d_vec, schema_str, "upsample_trilinear3d.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor")

// aten::upsample_trilinear3d.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<upsample_trilinear3d_vec::schema> create_upsample_trilinear3d_vec_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_trilinear3d_vec::name, upsample_trilinear3d_vec::overload_name)
      .typed<upsample_trilinear3d_vec::schema>();
}

// aten::upsample_trilinear3d.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor
at::Tensor upsample_trilinear3d_vec::call(const at::Tensor & input, at::OptionalSymIntArrayRef output_size, bool align_corners, c10::optional<at::ArrayRef<double>> scale_factors) {
    
    static auto op = create_upsample_trilinear3d_vec_typed_handle();
    return op.call(input, output_size, align_corners, scale_factors);
}

// aten::upsample_trilinear3d.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor
at::Tensor upsample_trilinear3d_vec::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, at::OptionalSymIntArrayRef output_size, bool align_corners, c10::optional<at::ArrayRef<double>> scale_factors) {
    
    static auto op = create_upsample_trilinear3d_vec_typed_handle();
    return op.redispatch(dispatchKeySet, input, output_size, align_corners, scale_factors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bicubic2d_aa_vec, name, "aten::_upsample_bicubic2d_aa")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bicubic2d_aa_vec, overload_name, "vec")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bicubic2d_aa_vec, schema_str, "_upsample_bicubic2d_aa.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor")

// aten::_upsample_bicubic2d_aa.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_upsample_bicubic2d_aa_vec::schema> create__upsample_bicubic2d_aa_vec_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_upsample_bicubic2d_aa_vec::name, _upsample_bicubic2d_aa_vec::overload_name)
      .typed<_upsample_bicubic2d_aa_vec::schema>();
}

// aten::_upsample_bicubic2d_aa.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor
at::Tensor _upsample_bicubic2d_aa_vec::call(const at::Tensor & input, at::OptionalSymIntArrayRef output_size, bool align_corners, c10::optional<at::ArrayRef<double>> scale_factors) {
    
    static auto op = create__upsample_bicubic2d_aa_vec_typed_handle();
    return op.call(input, output_size, align_corners, scale_factors);
}

// aten::_upsample_bicubic2d_aa.vec(Tensor input, SymInt[]? output_size, bool align_corners, float[]? scale_factors) -> Tensor
at::Tensor _upsample_bicubic2d_aa_vec::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, at::OptionalSymIntArrayRef output_size, bool align_corners, c10::optional<at::ArrayRef<double>> scale_factors) {
    
    static auto op = create__upsample_bicubic2d_aa_vec_typed_handle();
    return op.redispatch(dispatchKeySet, input, output_size, align_corners, scale_factors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest3d_vec, name, "aten::upsample_nearest3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest3d_vec, overload_name, "vec")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest3d_vec, schema_str, "upsample_nearest3d.vec(Tensor input, SymInt[]? output_size, float[]? scale_factors) -> Tensor")

// aten::upsample_nearest3d.vec(Tensor input, SymInt[]? output_size, float[]? scale_factors) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<upsample_nearest3d_vec::schema> create_upsample_nearest3d_vec_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_nearest3d_vec::name, upsample_nearest3d_vec::overload_name)
      .typed<upsample_nearest3d_vec::schema>();
}

// aten::upsample_nearest3d.vec(Tensor input, SymInt[]? output_size, float[]? scale_factors) -> Tensor
at::Tensor upsample_nearest3d_vec::call(const at::Tensor & input, at::OptionalSymIntArrayRef output_size, c10::optional<at::ArrayRef<double>> scale_factors) {
    
    static auto op = create_upsample_nearest3d_vec_typed_handle();
    return op.call(input, output_size, scale_factors);
}

// aten::upsample_nearest3d.vec(Tensor input, SymInt[]? output_size, float[]? scale_factors) -> Tensor
at::Tensor upsample_nearest3d_vec::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, at::OptionalSymIntArrayRef output_size, c10::optional<at::ArrayRef<double>> scale_factors) {
    
    static auto op = create_upsample_nearest3d_vec_typed_handle();
    return op.redispatch(dispatchKeySet, input, output_size, scale_factors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_backward_grad_input, name, "aten::_upsample_bilinear2d_aa_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_backward_grad_input, schema_str, "_upsample_bilinear2d_aa_backward.grad_input(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::_upsample_bilinear2d_aa_backward.grad_input(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_upsample_bilinear2d_aa_backward_grad_input::schema> create__upsample_bilinear2d_aa_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_upsample_bilinear2d_aa_backward_grad_input::name, _upsample_bilinear2d_aa_backward_grad_input::overload_name)
      .typed<_upsample_bilinear2d_aa_backward_grad_input::schema>();
}

// aten::_upsample_bilinear2d_aa_backward.grad_input(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & _upsample_bilinear2d_aa_backward_grad_input::call(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
    
    static auto op = create__upsample_bilinear2d_aa_backward_grad_input_typed_handle();
    return op.call(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}

// aten::_upsample_bilinear2d_aa_backward.grad_input(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & _upsample_bilinear2d_aa_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
    
    static auto op = create__upsample_bilinear2d_aa_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_backward, name, "aten::_upsample_bilinear2d_aa_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bilinear2d_aa_backward, schema_str, "_upsample_bilinear2d_aa_backward(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor")

// aten::_upsample_bilinear2d_aa_backward(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_upsample_bilinear2d_aa_backward::schema> create__upsample_bilinear2d_aa_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_upsample_bilinear2d_aa_backward::name, _upsample_bilinear2d_aa_backward::overload_name)
      .typed<_upsample_bilinear2d_aa_backward::schema>();
}

// aten::_upsample_bilinear2d_aa_backward(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor _upsample_bilinear2d_aa_backward::call(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create__upsample_bilinear2d_aa_backward_typed_handle();
    return op.call(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}

// aten::_upsample_bilinear2d_aa_backward(Tensor grad_output, SymInt[2] output_size, SymInt[4] input_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor _upsample_bilinear2d_aa_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create__upsample_bilinear2d_aa_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bicubic2d_aa_out, name, "aten::_upsample_bicubic2d_aa")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bicubic2d_aa_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bicubic2d_aa_out, schema_str, "_upsample_bicubic2d_aa.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_upsample_bicubic2d_aa.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_upsample_bicubic2d_aa_out::schema> create__upsample_bicubic2d_aa_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_upsample_bicubic2d_aa_out::name, _upsample_bicubic2d_aa_out::overload_name)
      .typed<_upsample_bicubic2d_aa_out::schema>();
}

// aten::_upsample_bicubic2d_aa.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _upsample_bicubic2d_aa_out::call(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
    
    static auto op = create__upsample_bicubic2d_aa_out_typed_handle();
    return op.call(self, output_size, align_corners, scales_h, scales_w, out);
}

// aten::_upsample_bicubic2d_aa.out(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _upsample_bicubic2d_aa_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
    
    static auto op = create__upsample_bicubic2d_aa_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, align_corners, scales_h, scales_w, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bicubic2d_aa, name, "aten::_upsample_bicubic2d_aa")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bicubic2d_aa, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_upsample_bicubic2d_aa, schema_str, "_upsample_bicubic2d_aa(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor")

// aten::_upsample_bicubic2d_aa(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_upsample_bicubic2d_aa::schema> create__upsample_bicubic2d_aa_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_upsample_bicubic2d_aa::name, _upsample_bicubic2d_aa::overload_name)
      .typed<_upsample_bicubic2d_aa::schema>();
}

// aten::_upsample_bicubic2d_aa(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor _upsample_bicubic2d_aa::call(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create__upsample_bicubic2d_aa_typed_handle();
    return op.call(self, output_size, align_corners, scales_h, scales_w);
}

// aten::_upsample_bicubic2d_aa(Tensor self, SymInt[2] output_size, bool align_corners, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor _upsample_bicubic2d_aa::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create__upsample_bicubic2d_aa_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, align_corners, scales_h, scales_w);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_trilinear3d_out, name, "aten::upsample_trilinear3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_trilinear3d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_trilinear3d_out, schema_str, "upsample_trilinear3d.out(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::upsample_trilinear3d.out(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<upsample_trilinear3d_out::schema> create_upsample_trilinear3d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_trilinear3d_out::name, upsample_trilinear3d_out::overload_name)
      .typed<upsample_trilinear3d_out::schema>();
}

// aten::upsample_trilinear3d.out(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & upsample_trilinear3d_out::call(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
    
    static auto op = create_upsample_trilinear3d_out_typed_handle();
    return op.call(self, output_size, align_corners, scales_d, scales_h, scales_w, out);
}

// aten::upsample_trilinear3d.out(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & upsample_trilinear3d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
    
    static auto op = create_upsample_trilinear3d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, align_corners, scales_d, scales_h, scales_w, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_trilinear3d, name, "aten::upsample_trilinear3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_trilinear3d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_trilinear3d, schema_str, "upsample_trilinear3d(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor")

// aten::upsample_trilinear3d(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<upsample_trilinear3d::schema> create_upsample_trilinear3d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_trilinear3d::name, upsample_trilinear3d::overload_name)
      .typed<upsample_trilinear3d::schema>();
}

// aten::upsample_trilinear3d(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor upsample_trilinear3d::call(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create_upsample_trilinear3d_typed_handle();
    return op.call(self, output_size, align_corners, scales_d, scales_h, scales_w);
}

// aten::upsample_trilinear3d(Tensor self, SymInt[3] output_size, bool align_corners, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor upsample_trilinear3d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create_upsample_trilinear3d_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, align_corners, scales_d, scales_h, scales_w);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest3d_out, name, "aten::upsample_nearest3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest3d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest3d_out, schema_str, "upsample_nearest3d.out(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::upsample_nearest3d.out(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<upsample_nearest3d_out::schema> create_upsample_nearest3d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_nearest3d_out::name, upsample_nearest3d_out::overload_name)
      .typed<upsample_nearest3d_out::schema>();
}

// aten::upsample_nearest3d.out(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & upsample_nearest3d_out::call(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
    
    static auto op = create_upsample_nearest3d_out_typed_handle();
    return op.call(self, output_size, scales_d, scales_h, scales_w, out);
}

// aten::upsample_nearest3d.out(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & upsample_nearest3d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
    
    static auto op = create_upsample_nearest3d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, scales_d, scales_h, scales_w, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest3d, name, "aten::upsample_nearest3d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest3d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(upsample_nearest3d, schema_str, "upsample_nearest3d(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor")

// aten::upsample_nearest3d(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<upsample_nearest3d::schema> create_upsample_nearest3d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(upsample_nearest3d::name, upsample_nearest3d::overload_name)
      .typed<upsample_nearest3d::schema>();
}

// aten::upsample_nearest3d(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor upsample_nearest3d::call(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create_upsample_nearest3d_typed_handle();
    return op.call(self, output_size, scales_d, scales_h, scales_w);
}

// aten::upsample_nearest3d(Tensor self, SymInt[3] output_size, float? scales_d=None, float? scales_h=None, float? scales_w=None) -> Tensor
at::Tensor upsample_nearest3d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    
    static auto op = create_upsample_nearest3d_typed_handle();
    return op.redispatch(dispatchKeySet, self, output_size, scales_d, scales_h, scales_w);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sigmoid_backward_grad_input, name, "aten::sigmoid_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sigmoid_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sigmoid_backward_grad_input, schema_str, "sigmoid_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::sigmoid_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sigmoid_backward_grad_input::schema> create_sigmoid_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sigmoid_backward_grad_input::name, sigmoid_backward_grad_input::overload_name)
      .typed<sigmoid_backward_grad_input::schema>();
}

// aten::sigmoid_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & sigmoid_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
    
    static auto op = create_sigmoid_backward_grad_input_typed_handle();
    return op.call(grad_output, output, grad_input);
}

// aten::sigmoid_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & sigmoid_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
    
    static auto op = create_sigmoid_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sigmoid_backward, name, "aten::sigmoid_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sigmoid_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sigmoid_backward, schema_str, "sigmoid_backward(Tensor grad_output, Tensor output) -> Tensor")

// aten::sigmoid_backward(Tensor grad_output, Tensor output) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sigmoid_backward::schema> create_sigmoid_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sigmoid_backward::name, sigmoid_backward::overload_name)
      .typed<sigmoid_backward::schema>();
}

// aten::sigmoid_backward(Tensor grad_output, Tensor output) -> Tensor
at::Tensor sigmoid_backward::call(const at::Tensor & grad_output, const at::Tensor & output) {
    
    static auto op = create_sigmoid_backward_typed_handle();
    return op.call(grad_output, output);
}

// aten::sigmoid_backward(Tensor grad_output, Tensor output) -> Tensor
at::Tensor sigmoid_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output) {
    
    static auto op = create_sigmoid_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tanh_backward_grad_input, name, "aten::tanh_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tanh_backward_grad_input, overload_name, "grad_input")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tanh_backward_grad_input, schema_str, "tanh_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)")

// aten::tanh_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<tanh_backward_grad_input::schema> create_tanh_backward_grad_input_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(tanh_backward_grad_input::name, tanh_backward_grad_input::overload_name)
      .typed<tanh_backward_grad_input::schema>();
}

// aten::tanh_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & tanh_backward_grad_input::call(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
    
    static auto op = create_tanh_backward_grad_input_typed_handle();
    return op.call(grad_output, output, grad_input);
}

// aten::tanh_backward.grad_input(Tensor grad_output, Tensor output, *, Tensor(a!) grad_input) -> Tensor(a!)
at::Tensor & tanh_backward_grad_input::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
    
    static auto op = create_tanh_backward_grad_input_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output, grad_input);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tanh_backward, name, "aten::tanh_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tanh_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(tanh_backward, schema_str, "tanh_backward(Tensor grad_output, Tensor output) -> Tensor")

// aten::tanh_backward(Tensor grad_output, Tensor output) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<tanh_backward::schema> create_tanh_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(tanh_backward::name, tanh_backward::overload_name)
      .typed<tanh_backward::schema>();
}

// aten::tanh_backward(Tensor grad_output, Tensor output) -> Tensor
at::Tensor tanh_backward::call(const at::Tensor & grad_output, const at::Tensor & output) {
    
    static auto op = create_tanh_backward_typed_handle();
    return op.call(grad_output, output);
}

// aten::tanh_backward(Tensor grad_output, Tensor output) -> Tensor
at::Tensor tanh_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output) {
    
    static auto op = create_tanh_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(thnn_conv2d_out, name, "aten::thnn_conv2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(thnn_conv2d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(thnn_conv2d_out, schema_str, "thnn_conv2d.out(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0, *, Tensor(a!) out) -> Tensor(a!)")

// aten::thnn_conv2d.out(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<thnn_conv2d_out::schema> create_thnn_conv2d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(thnn_conv2d_out::name, thnn_conv2d_out::overload_name)
      .typed<thnn_conv2d_out::schema>();
}

// aten::thnn_conv2d.out(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & thnn_conv2d_out::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & out) {
    
    static auto op = create_thnn_conv2d_out_typed_handle();
    return op.call(self, weight, kernel_size, bias, stride, padding, out);
}

// aten::thnn_conv2d.out(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & thnn_conv2d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & out) {
    
    static auto op = create_thnn_conv2d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, kernel_size, bias, stride, padding, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(thnn_conv2d, name, "aten::thnn_conv2d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(thnn_conv2d, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(thnn_conv2d, schema_str, "thnn_conv2d(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0) -> Tensor")

// aten::thnn_conv2d(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<thnn_conv2d::schema> create_thnn_conv2d_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(thnn_conv2d::name, thnn_conv2d::overload_name)
      .typed<thnn_conv2d::schema>();
}

// aten::thnn_conv2d(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0) -> Tensor
at::Tensor thnn_conv2d::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
    
    static auto op = create_thnn_conv2d_typed_handle();
    return op.call(self, weight, kernel_size, bias, stride, padding);
}

// aten::thnn_conv2d(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias=None, SymInt[2] stride=1, SymInt[2] padding=0) -> Tensor
at::Tensor thnn_conv2d::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
    
    static auto op = create_thnn_conv2d_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, kernel_size, bias, stride, padding);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_slow_conv2d_forward_output, name, "aten::_slow_conv2d_forward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_slow_conv2d_forward_output, overload_name, "output")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_slow_conv2d_forward_output, schema_str, "_slow_conv2d_forward.output(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias, SymInt[2] stride, SymInt[2] padding, *, Tensor(a!) output) -> Tensor(a!)")

// aten::_slow_conv2d_forward.output(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias, SymInt[2] stride, SymInt[2] padding, *, Tensor(a!) output) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_slow_conv2d_forward_output::schema> create__slow_conv2d_forward_output_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_slow_conv2d_forward_output::name, _slow_conv2d_forward_output::overload_name)
      .typed<_slow_conv2d_forward_output::schema>();
}

// aten::_slow_conv2d_forward.output(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias, SymInt[2] stride, SymInt[2] padding, *, Tensor(a!) output) -> Tensor(a!)
at::Tensor & _slow_conv2d_forward_output::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
    
    static auto op = create__slow_conv2d_forward_output_typed_handle();
    return op.call(self, weight, kernel_size, bias, stride, padding, output);
}

// aten::_slow_conv2d_forward.output(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias, SymInt[2] stride, SymInt[2] padding, *, Tensor(a!) output) -> Tensor(a!)
at::Tensor & _slow_conv2d_forward_output::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
    
    static auto op = create__slow_conv2d_forward_output_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, kernel_size, bias, stride, padding, output);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_slow_conv2d_forward, name, "aten::_slow_conv2d_forward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_slow_conv2d_forward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_slow_conv2d_forward, schema_str, "_slow_conv2d_forward(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias, SymInt[2] stride, SymInt[2] padding) -> Tensor")

// aten::_slow_conv2d_forward(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias, SymInt[2] stride, SymInt[2] padding) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_slow_conv2d_forward::schema> create__slow_conv2d_forward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_slow_conv2d_forward::name, _slow_conv2d_forward::overload_name)
      .typed<_slow_conv2d_forward::schema>();
}

// aten::_slow_conv2d_forward(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias, SymInt[2] stride, SymInt[2] padding) -> Tensor
at::Tensor _slow_conv2d_forward::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
    
    static auto op = create__slow_conv2d_forward_typed_handle();
    return op.call(self, weight, kernel_size, bias, stride, padding);
}

// aten::_slow_conv2d_forward(Tensor self, Tensor weight, SymInt[2] kernel_size, Tensor? bias, SymInt[2] stride, SymInt[2] padding) -> Tensor
at::Tensor _slow_conv2d_forward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
    
    static auto op = create__slow_conv2d_forward_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, kernel_size, bias, stride, padding);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(column_stack, name, "aten::column_stack")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(column_stack, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(column_stack, schema_str, "column_stack(Tensor[] tensors) -> Tensor")

// aten::column_stack(Tensor[] tensors) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<column_stack::schema> create_column_stack_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(column_stack::name, column_stack::overload_name)
      .typed<column_stack::schema>();
}

// aten::column_stack(Tensor[] tensors) -> Tensor
at::Tensor column_stack::call(at::TensorList tensors) {
    
    static auto op = create_column_stack_typed_handle();
    return op.call(tensors);
}

// aten::column_stack(Tensor[] tensors) -> Tensor
at::Tensor column_stack::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors) {
    
    static auto op = create_column_stack_typed_handle();
    return op.redispatch(dispatchKeySet, tensors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(column_stack_out, name, "aten::column_stack")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(column_stack_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(column_stack_out, schema_str, "column_stack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)")

// aten::column_stack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<column_stack_out::schema> create_column_stack_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(column_stack_out::name, column_stack_out::overload_name)
      .typed<column_stack_out::schema>();
}

// aten::column_stack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & column_stack_out::call(at::TensorList tensors, at::Tensor & out) {
    
    static auto op = create_column_stack_out_typed_handle();
    return op.call(tensors, out);
}

// aten::column_stack.out(Tensor[] tensors, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & column_stack_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList tensors, at::Tensor & out) {
    
    static auto op = create_column_stack_out_typed_handle();
    return op.redispatch(dispatchKeySet, tensors, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_entr, name, "aten::special_entr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_entr, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_entr, schema_str, "special_entr(Tensor self) -> Tensor")

// aten::special_entr(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_entr::schema> create_special_entr_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_entr::name, special_entr::overload_name)
      .typed<special_entr::schema>();
}

// aten::special_entr(Tensor self) -> Tensor
at::Tensor special_entr::call(const at::Tensor & self) {
    
    static auto op = create_special_entr_typed_handle();
    return op.call(self);
}

// aten::special_entr(Tensor self) -> Tensor
at::Tensor special_entr::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_entr_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_entr_out, name, "aten::special_entr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_entr_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_entr_out, schema_str, "special_entr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_entr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_entr_out::schema> create_special_entr_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_entr_out::name, special_entr_out::overload_name)
      .typed<special_entr_out::schema>();
}

// aten::special_entr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_entr_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_entr_out_typed_handle();
    return op.call(self, out);
}

// aten::special_entr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_entr_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_entr_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_ndtri, name, "aten::special_ndtri")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_ndtri, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_ndtri, schema_str, "special_ndtri(Tensor self) -> Tensor")

// aten::special_ndtri(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_ndtri::schema> create_special_ndtri_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_ndtri::name, special_ndtri::overload_name)
      .typed<special_ndtri::schema>();
}

// aten::special_ndtri(Tensor self) -> Tensor
at::Tensor special_ndtri::call(const at::Tensor & self) {
    
    static auto op = create_special_ndtri_typed_handle();
    return op.call(self);
}

// aten::special_ndtri(Tensor self) -> Tensor
at::Tensor special_ndtri::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_ndtri_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_ndtri_out, name, "aten::special_ndtri")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_ndtri_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_ndtri_out, schema_str, "special_ndtri.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_ndtri.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_ndtri_out::schema> create_special_ndtri_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_ndtri_out::name, special_ndtri_out::overload_name)
      .typed<special_ndtri_out::schema>();
}

// aten::special_ndtri.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_ndtri_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_ndtri_out_typed_handle();
    return op.call(self, out);
}

// aten::special_ndtri.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_ndtri_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_ndtri_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfc, name, "aten::special_erfc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfc, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfc, schema_str, "special_erfc(Tensor self) -> Tensor")

// aten::special_erfc(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_erfc::schema> create_special_erfc_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_erfc::name, special_erfc::overload_name)
      .typed<special_erfc::schema>();
}

// aten::special_erfc(Tensor self) -> Tensor
at::Tensor special_erfc::call(const at::Tensor & self) {
    
    static auto op = create_special_erfc_typed_handle();
    return op.call(self);
}

// aten::special_erfc(Tensor self) -> Tensor
at::Tensor special_erfc::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_erfc_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfc_out, name, "aten::special_erfc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfc_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_erfc_out, schema_str, "special_erfc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_erfc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_erfc_out::schema> create_special_erfc_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_erfc_out::name, special_erfc_out::overload_name)
      .typed<special_erfc_out::schema>();
}

// aten::special_erfc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_erfc_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_erfc_out_typed_handle();
    return op.call(self, out);
}

// aten::special_erfc.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_erfc_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_erfc_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1e, name, "aten::special_i1e")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1e, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1e, schema_str, "special_i1e(Tensor self) -> Tensor")

// aten::special_i1e(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_i1e::schema> create_special_i1e_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_i1e::name, special_i1e::overload_name)
      .typed<special_i1e::schema>();
}

// aten::special_i1e(Tensor self) -> Tensor
at::Tensor special_i1e::call(const at::Tensor & self) {
    
    static auto op = create_special_i1e_typed_handle();
    return op.call(self);
}

// aten::special_i1e(Tensor self) -> Tensor
at::Tensor special_i1e::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_i1e_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1e_out, name, "aten::special_i1e")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1e_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_i1e_out, schema_str, "special_i1e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_i1e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_i1e_out::schema> create_special_i1e_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_i1e_out::name, special_i1e_out::overload_name)
      .typed<special_i1e_out::schema>();
}

// aten::special_i1e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_i1e_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_i1e_out_typed_handle();
    return op.call(self, out);
}

// aten::special_i1e.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_i1e_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_i1e_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logsumexp, name, "aten::special_logsumexp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logsumexp, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logsumexp, schema_str, "special_logsumexp(Tensor self, int[1] dim, bool keepdim=False) -> Tensor")

// aten::special_logsumexp(Tensor self, int[1] dim, bool keepdim=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_logsumexp::schema> create_special_logsumexp_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_logsumexp::name, special_logsumexp::overload_name)
      .typed<special_logsumexp::schema>();
}

// aten::special_logsumexp(Tensor self, int[1] dim, bool keepdim=False) -> Tensor
at::Tensor special_logsumexp::call(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
    
    static auto op = create_special_logsumexp_typed_handle();
    return op.call(self, dim, keepdim);
}

// aten::special_logsumexp(Tensor self, int[1] dim, bool keepdim=False) -> Tensor
at::Tensor special_logsumexp::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
    
    static auto op = create_special_logsumexp_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logsumexp_out, name, "aten::special_logsumexp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logsumexp_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_logsumexp_out, schema_str, "special_logsumexp.out(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_logsumexp.out(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_logsumexp_out::schema> create_special_logsumexp_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_logsumexp_out::name, special_logsumexp_out::overload_name)
      .typed<special_logsumexp_out::schema>();
}

// aten::special_logsumexp.out(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_logsumexp_out::call(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_special_logsumexp_out_typed_handle();
    return op.call(self, dim, keepdim, out);
}

// aten::special_logsumexp.out(Tensor self, int[1] dim, bool keepdim=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_logsumexp_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
    
    static auto op = create_special_logsumexp_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammainc_out, name, "aten::special_gammainc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammainc_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammainc_out, schema_str, "special_gammainc.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_gammainc.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_gammainc_out::schema> create_special_gammainc_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_gammainc_out::name, special_gammainc_out::overload_name)
      .typed<special_gammainc_out::schema>();
}

// aten::special_gammainc.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_gammainc_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_special_gammainc_out_typed_handle();
    return op.call(self, other, out);
}

// aten::special_gammainc.out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_gammainc_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_special_gammainc_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammainc, name, "aten::special_gammainc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammainc, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_gammainc, schema_str, "special_gammainc(Tensor self, Tensor other) -> Tensor")

// aten::special_gammainc(Tensor self, Tensor other) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_gammainc::schema> create_special_gammainc_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_gammainc::name, special_gammainc::overload_name)
      .typed<special_gammainc::schema>();
}

// aten::special_gammainc(Tensor self, Tensor other) -> Tensor
at::Tensor special_gammainc::call(const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_special_gammainc_typed_handle();
    return op.call(self, other);
}

// aten::special_gammainc(Tensor self, Tensor other) -> Tensor
at::Tensor special_gammainc::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other) {
    
    static auto op = create_special_gammainc_typed_handle();
    return op.redispatch(dispatchKeySet, self, other);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_rfft2, name, "aten::fft_rfft2")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_rfft2, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_rfft2, schema_str, "fft_rfft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None) -> Tensor")

// aten::fft_rfft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fft_rfft2::schema> create_fft_rfft2_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fft_rfft2::name, fft_rfft2::overload_name)
      .typed<fft_rfft2::schema>();
}

// aten::fft_rfft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None) -> Tensor
at::Tensor fft_rfft2::call(const at::Tensor & self, at::OptionalSymIntArrayRef s, at::IntArrayRef dim, c10::optional<c10::string_view> norm) {
    
    static auto op = create_fft_rfft2_typed_handle();
    return op.call(self, s, dim, norm);
}

// aten::fft_rfft2(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None) -> Tensor
at::Tensor fft_rfft2::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalSymIntArrayRef s, at::IntArrayRef dim, c10::optional<c10::string_view> norm) {
    
    static auto op = create_fft_rfft2_typed_handle();
    return op.redispatch(dispatchKeySet, self, s, dim, norm);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_rfft2_out, name, "aten::fft_rfft2")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_rfft2_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_rfft2_out, schema_str, "fft_rfft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::fft_rfft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fft_rfft2_out::schema> create_fft_rfft2_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fft_rfft2_out::name, fft_rfft2_out::overload_name)
      .typed<fft_rfft2_out::schema>();
}

// aten::fft_rfft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fft_rfft2_out::call(const at::Tensor & self, at::OptionalSymIntArrayRef s, at::IntArrayRef dim, c10::optional<c10::string_view> norm, at::Tensor & out) {
    
    static auto op = create_fft_rfft2_out_typed_handle();
    return op.call(self, s, dim, norm, out);
}

// aten::fft_rfft2.out(Tensor self, SymInt[1]? s=None, int[1] dim=[-2,-1], str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fft_rfft2_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalSymIntArrayRef s, at::IntArrayRef dim, c10::optional<c10::string_view> norm, at::Tensor & out) {
    
    static auto op = create_fft_rfft2_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, s, dim, norm, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_hfftn, name, "aten::fft_hfftn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_hfftn, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_hfftn, schema_str, "fft_hfftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor")

// aten::fft_hfftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<fft_hfftn::schema> create_fft_hfftn_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fft_hfftn::name, fft_hfftn::overload_name)
      .typed<fft_hfftn::schema>();
}

// aten::fft_hfftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor
at::Tensor fft_hfftn::call(const at::Tensor & self, at::OptionalSymIntArrayRef s, at::OptionalIntArrayRef dim, c10::optional<c10::string_view> norm) {
    
    static auto op = create_fft_hfftn_typed_handle();
    return op.call(self, s, dim, norm);
}

// aten::fft_hfftn(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None) -> Tensor
at::Tensor fft_hfftn::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalSymIntArrayRef s, at::OptionalIntArrayRef dim, c10::optional<c10::string_view> norm) {
    
    static auto op = create_fft_hfftn_typed_handle();
    return op.redispatch(dispatchKeySet, self, s, dim, norm);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_hfftn_out, name, "aten::fft_hfftn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_hfftn_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fft_hfftn_out, schema_str, "fft_hfftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::fft_hfftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fft_hfftn_out::schema> create_fft_hfftn_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fft_hfftn_out::name, fft_hfftn_out::overload_name)
      .typed<fft_hfftn_out::schema>();
}

// aten::fft_hfftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
const at::Tensor & fft_hfftn_out::call(const at::Tensor & self, at::OptionalSymIntArrayRef s, at::OptionalIntArrayRef dim, c10::optional<c10::string_view> norm, const at::Tensor & out) {
    
    static auto op = create_fft_hfftn_out_typed_handle();
    return op.call(self, s, dim, norm, out);
}

// aten::fft_hfftn.out(Tensor self, SymInt[1]? s=None, int[1]? dim=None, str? norm=None, *, Tensor(a!) out) -> Tensor(a!)
const at::Tensor & fft_hfftn_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::OptionalSymIntArrayRef s, at::OptionalIntArrayRef dim, c10::optional<c10::string_view> norm, const at::Tensor & out) {
    
    static auto op = create_fft_hfftn_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, s, dim, norm, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu, name, "aten::linalg_lu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu, schema_str, "linalg_lu(Tensor A, *, bool pivot=True) -> (Tensor P, Tensor L, Tensor U)")

// aten::linalg_lu(Tensor A, *, bool pivot=True) -> (Tensor P, Tensor L, Tensor U)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_lu::schema> create_linalg_lu_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_lu::name, linalg_lu::overload_name)
      .typed<linalg_lu::schema>();
}

// aten::linalg_lu(Tensor A, *, bool pivot=True) -> (Tensor P, Tensor L, Tensor U)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_lu::call(const at::Tensor & A, bool pivot) {
    
    static auto op = create_linalg_lu_typed_handle();
    return op.call(A, pivot);
}

// aten::linalg_lu(Tensor A, *, bool pivot=True) -> (Tensor P, Tensor L, Tensor U)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_lu::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, bool pivot) {
    
    static auto op = create_linalg_lu_typed_handle();
    return op.redispatch(dispatchKeySet, A, pivot);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_out, name, "aten::linalg_lu")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lu_out, schema_str, "linalg_lu.out(Tensor A, *, bool pivot=True, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)")

// aten::linalg_lu.out(Tensor A, *, bool pivot=True, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_lu_out::schema> create_linalg_lu_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_lu_out::name, linalg_lu_out::overload_name)
      .typed<linalg_lu_out::schema>();
}

// aten::linalg_lu.out(Tensor A, *, bool pivot=True, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_out::call(const at::Tensor & A, bool pivot, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
    
    static auto op = create_linalg_lu_out_typed_handle();
    return op.call(A, pivot, P, L, U);
}

// aten::linalg_lu.out(Tensor A, *, bool pivot=True, Tensor(a!) P, Tensor(b!) L, Tensor(c!) U) -> (Tensor(a!) P, Tensor(b!) L, Tensor(c!) U)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, bool pivot, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
    
    static auto op = create_linalg_lu_out_typed_handle();
    return op.redispatch(dispatchKeySet, A, pivot, P, L, U);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_factor_ex, name, "aten::linalg_ldl_factor_ex")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_factor_ex, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_factor_ex, schema_str, "linalg_ldl_factor_ex(Tensor self, *, bool hermitian=False, bool check_errors=False) -> (Tensor LD, Tensor pivots, Tensor info)")

// aten::linalg_ldl_factor_ex(Tensor self, *, bool hermitian=False, bool check_errors=False) -> (Tensor LD, Tensor pivots, Tensor info)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_ldl_factor_ex::schema> create_linalg_ldl_factor_ex_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_ldl_factor_ex::name, linalg_ldl_factor_ex::overload_name)
      .typed<linalg_ldl_factor_ex::schema>();
}

// aten::linalg_ldl_factor_ex(Tensor self, *, bool hermitian=False, bool check_errors=False) -> (Tensor LD, Tensor pivots, Tensor info)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_ldl_factor_ex::call(const at::Tensor & self, bool hermitian, bool check_errors) {
    
    static auto op = create_linalg_ldl_factor_ex_typed_handle();
    return op.call(self, hermitian, check_errors);
}

// aten::linalg_ldl_factor_ex(Tensor self, *, bool hermitian=False, bool check_errors=False) -> (Tensor LD, Tensor pivots, Tensor info)
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_ldl_factor_ex::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool hermitian, bool check_errors) {
    
    static auto op = create_linalg_ldl_factor_ex_typed_handle();
    return op.redispatch(dispatchKeySet, self, hermitian, check_errors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_factor_ex_out, name, "aten::linalg_ldl_factor_ex")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_factor_ex_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_factor_ex_out, schema_str, "linalg_ldl_factor_ex.out(Tensor self, *, bool hermitian=False, bool check_errors=False, Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info) -> (Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info)")

// aten::linalg_ldl_factor_ex.out(Tensor self, *, bool hermitian=False, bool check_errors=False, Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info) -> (Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_ldl_factor_ex_out::schema> create_linalg_ldl_factor_ex_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_ldl_factor_ex_out::name, linalg_ldl_factor_ex_out::overload_name)
      .typed<linalg_ldl_factor_ex_out::schema>();
}

// aten::linalg_ldl_factor_ex.out(Tensor self, *, bool hermitian=False, bool check_errors=False, Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info) -> (Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_ldl_factor_ex_out::call(const at::Tensor & self, bool hermitian, bool check_errors, at::Tensor & LD, at::Tensor & pivots, at::Tensor & info) {
    
    static auto op = create_linalg_ldl_factor_ex_out_typed_handle();
    return op.call(self, hermitian, check_errors, LD, pivots, info);
}

// aten::linalg_ldl_factor_ex.out(Tensor self, *, bool hermitian=False, bool check_errors=False, Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info) -> (Tensor(a!) LD, Tensor(b!) pivots, Tensor(c!) info)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_ldl_factor_ex_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool hermitian, bool check_errors, at::Tensor & LD, at::Tensor & pivots, at::Tensor & info) {
    
    static auto op = create_linalg_ldl_factor_ex_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, hermitian, check_errors, LD, pivots, info);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_solve, name, "aten::linalg_ldl_solve")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_solve, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_solve, schema_str, "linalg_ldl_solve(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False) -> Tensor")

// aten::linalg_ldl_solve(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_ldl_solve::schema> create_linalg_ldl_solve_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_ldl_solve::name, linalg_ldl_solve::overload_name)
      .typed<linalg_ldl_solve::schema>();
}

// aten::linalg_ldl_solve(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False) -> Tensor
at::Tensor linalg_ldl_solve::call(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian) {
    
    static auto op = create_linalg_ldl_solve_typed_handle();
    return op.call(LD, pivots, B, hermitian);
}

// aten::linalg_ldl_solve(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False) -> Tensor
at::Tensor linalg_ldl_solve::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian) {
    
    static auto op = create_linalg_ldl_solve_typed_handle();
    return op.redispatch(dispatchKeySet, LD, pivots, B, hermitian);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_solve_out, name, "aten::linalg_ldl_solve")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_solve_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_ldl_solve_out, schema_str, "linalg_ldl_solve.out(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_ldl_solve.out(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_ldl_solve_out::schema> create_linalg_ldl_solve_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_ldl_solve_out::name, linalg_ldl_solve_out::overload_name)
      .typed<linalg_ldl_solve_out::schema>();
}

// aten::linalg_ldl_solve.out(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_ldl_solve_out::call(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian, at::Tensor & out) {
    
    static auto op = create_linalg_ldl_solve_out_typed_handle();
    return op.call(LD, pivots, B, hermitian, out);
}

// aten::linalg_ldl_solve.out(Tensor LD, Tensor pivots, Tensor B, *, bool hermitian=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_ldl_solve_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian, at::Tensor & out) {
    
    static auto op = create_linalg_ldl_solve_out_typed_handle();
    return op.redispatch(dispatchKeySet, LD, pivots, B, hermitian, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lstsq, name, "aten::linalg_lstsq")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lstsq, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lstsq, schema_str, "linalg_lstsq(Tensor self, Tensor b, float? rcond=None, *, str? driver=None) -> (Tensor solution, Tensor residuals, Tensor rank, Tensor singular_values)")

// aten::linalg_lstsq(Tensor self, Tensor b, float? rcond=None, *, str? driver=None) -> (Tensor solution, Tensor residuals, Tensor rank, Tensor singular_values)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_lstsq::schema> create_linalg_lstsq_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_lstsq::name, linalg_lstsq::overload_name)
      .typed<linalg_lstsq::schema>();
}

// aten::linalg_lstsq(Tensor self, Tensor b, float? rcond=None, *, str? driver=None) -> (Tensor solution, Tensor residuals, Tensor rank, Tensor singular_values)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> linalg_lstsq::call(const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver) {
    
    static auto op = create_linalg_lstsq_typed_handle();
    return op.call(self, b, rcond, driver);
}

// aten::linalg_lstsq(Tensor self, Tensor b, float? rcond=None, *, str? driver=None) -> (Tensor solution, Tensor residuals, Tensor rank, Tensor singular_values)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> linalg_lstsq::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver) {
    
    static auto op = create_linalg_lstsq_typed_handle();
    return op.redispatch(dispatchKeySet, self, b, rcond, driver);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lstsq_out, name, "aten::linalg_lstsq")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lstsq_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_lstsq_out, schema_str, "linalg_lstsq.out(Tensor self, Tensor b, float? rcond=None, *, str? driver=None, Tensor(a!) solution, Tensor(b!) residuals, Tensor(c!) rank, Tensor(d!) singular_values) -> (Tensor(a!) solution, Tensor(b!) residuals, Tensor(c!) rank, Tensor(d!) singular_values)")

// aten::linalg_lstsq.out(Tensor self, Tensor b, float? rcond=None, *, str? driver=None, Tensor(a!) solution, Tensor(b!) residuals, Tensor(c!) rank, Tensor(d!) singular_values) -> (Tensor(a!) solution, Tensor(b!) residuals, Tensor(c!) rank, Tensor(d!) singular_values)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_lstsq_out::schema> create_linalg_lstsq_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_lstsq_out::name, linalg_lstsq_out::overload_name)
      .typed<linalg_lstsq_out::schema>();
}

// aten::linalg_lstsq.out(Tensor self, Tensor b, float? rcond=None, *, str? driver=None, Tensor(a!) solution, Tensor(b!) residuals, Tensor(c!) rank, Tensor(d!) singular_values) -> (Tensor(a!) solution, Tensor(b!) residuals, Tensor(c!) rank, Tensor(d!) singular_values)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> linalg_lstsq_out::call(const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver, at::Tensor & solution, at::Tensor & residuals, at::Tensor & rank, at::Tensor & singular_values) {
    
    static auto op = create_linalg_lstsq_out_typed_handle();
    return op.call(self, b, rcond, driver, solution, residuals, rank, singular_values);
}

// aten::linalg_lstsq.out(Tensor self, Tensor b, float? rcond=None, *, str? driver=None, Tensor(a!) solution, Tensor(b!) residuals, Tensor(c!) rank, Tensor(d!) singular_values) -> (Tensor(a!) solution, Tensor(b!) residuals, Tensor(c!) rank, Tensor(d!) singular_values)
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> linalg_lstsq_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver, at::Tensor & solution, at::Tensor & residuals, at::Tensor & rank, at::Tensor & singular_values) {
    
    static auto op = create_linalg_lstsq_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, b, rcond, driver, solution, residuals, rank, singular_values);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_vecdot, name, "aten::linalg_vecdot")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_vecdot, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_vecdot, schema_str, "linalg_vecdot(Tensor x, Tensor y, *, int dim=-1) -> Tensor")

// aten::linalg_vecdot(Tensor x, Tensor y, *, int dim=-1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_vecdot::schema> create_linalg_vecdot_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_vecdot::name, linalg_vecdot::overload_name)
      .typed<linalg_vecdot::schema>();
}

// aten::linalg_vecdot(Tensor x, Tensor y, *, int dim=-1) -> Tensor
at::Tensor linalg_vecdot::call(const at::Tensor & x, const at::Tensor & y, int64_t dim) {
    
    static auto op = create_linalg_vecdot_typed_handle();
    return op.call(x, y, dim);
}

// aten::linalg_vecdot(Tensor x, Tensor y, *, int dim=-1) -> Tensor
at::Tensor linalg_vecdot::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & y, int64_t dim) {
    
    static auto op = create_linalg_vecdot_typed_handle();
    return op.redispatch(dispatchKeySet, x, y, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_vecdot_out, name, "aten::linalg_vecdot")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_vecdot_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_vecdot_out, schema_str, "linalg_vecdot.out(Tensor x, Tensor y, *, int dim=-1, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_vecdot.out(Tensor x, Tensor y, *, int dim=-1, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_vecdot_out::schema> create_linalg_vecdot_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_vecdot_out::name, linalg_vecdot_out::overload_name)
      .typed<linalg_vecdot_out::schema>();
}

// aten::linalg_vecdot.out(Tensor x, Tensor y, *, int dim=-1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_vecdot_out::call(const at::Tensor & x, const at::Tensor & y, int64_t dim, at::Tensor & out) {
    
    static auto op = create_linalg_vecdot_out_typed_handle();
    return op.call(x, y, dim, out);
}

// aten::linalg_vecdot.out(Tensor x, Tensor y, *, int dim=-1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_vecdot_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & y, int64_t dim, at::Tensor & out) {
    
    static auto op = create_linalg_vecdot_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, y, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_exp, name, "aten::linalg_matrix_exp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_exp, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_exp, schema_str, "linalg_matrix_exp(Tensor self) -> Tensor")

// aten::linalg_matrix_exp(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_matrix_exp::schema> create_linalg_matrix_exp_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_matrix_exp::name, linalg_matrix_exp::overload_name)
      .typed<linalg_matrix_exp::schema>();
}

// aten::linalg_matrix_exp(Tensor self) -> Tensor
at::Tensor linalg_matrix_exp::call(const at::Tensor & self) {
    
    static auto op = create_linalg_matrix_exp_typed_handle();
    return op.call(self);
}

// aten::linalg_matrix_exp(Tensor self) -> Tensor
at::Tensor linalg_matrix_exp::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_linalg_matrix_exp_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_eigh, name, "aten::_linalg_eigh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_eigh, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_eigh, schema_str, "_linalg_eigh(Tensor A, str UPLO=\"L\", bool compute_v=True) -> (Tensor eigenvalues, Tensor eigenvectors)")

// aten::_linalg_eigh(Tensor A, str UPLO="L", bool compute_v=True) -> (Tensor eigenvalues, Tensor eigenvectors)
static C10_NOINLINE c10::TypedOperatorHandle<_linalg_eigh::schema> create__linalg_eigh_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_linalg_eigh::name, _linalg_eigh::overload_name)
      .typed<_linalg_eigh::schema>();
}

// aten::_linalg_eigh(Tensor A, str UPLO="L", bool compute_v=True) -> (Tensor eigenvalues, Tensor eigenvectors)
::std::tuple<at::Tensor,at::Tensor> _linalg_eigh::call(const at::Tensor & A, c10::string_view UPLO, bool compute_v) {
    
    static auto op = create__linalg_eigh_typed_handle();
    return op.call(A, UPLO, compute_v);
}

// aten::_linalg_eigh(Tensor A, str UPLO="L", bool compute_v=True) -> (Tensor eigenvalues, Tensor eigenvectors)
::std::tuple<at::Tensor,at::Tensor> _linalg_eigh::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, c10::string_view UPLO, bool compute_v) {
    
    static auto op = create__linalg_eigh_typed_handle();
    return op.redispatch(dispatchKeySet, A, UPLO, compute_v);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_eigh_eigenvalues, name, "aten::_linalg_eigh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_eigh_eigenvalues, overload_name, "eigenvalues")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_linalg_eigh_eigenvalues, schema_str, "_linalg_eigh.eigenvalues(Tensor A, str UPLO=\"L\", bool compute_v=True, *, Tensor(a!) eigenvalues, Tensor(b!) eigenvectors) -> (Tensor(a!) eigenvalues, Tensor(b!) eigenvectors)")

// aten::_linalg_eigh.eigenvalues(Tensor A, str UPLO="L", bool compute_v=True, *, Tensor(a!) eigenvalues, Tensor(b!) eigenvectors) -> (Tensor(a!) eigenvalues, Tensor(b!) eigenvectors)
static C10_NOINLINE c10::TypedOperatorHandle<_linalg_eigh_eigenvalues::schema> create__linalg_eigh_eigenvalues_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_linalg_eigh_eigenvalues::name, _linalg_eigh_eigenvalues::overload_name)
      .typed<_linalg_eigh_eigenvalues::schema>();
}

// aten::_linalg_eigh.eigenvalues(Tensor A, str UPLO="L", bool compute_v=True, *, Tensor(a!) eigenvalues, Tensor(b!) eigenvectors) -> (Tensor(a!) eigenvalues, Tensor(b!) eigenvectors)
::std::tuple<at::Tensor &,at::Tensor &> _linalg_eigh_eigenvalues::call(const at::Tensor & A, c10::string_view UPLO, bool compute_v, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
    
    static auto op = create__linalg_eigh_eigenvalues_typed_handle();
    return op.call(A, UPLO, compute_v, eigenvalues, eigenvectors);
}

// aten::_linalg_eigh.eigenvalues(Tensor A, str UPLO="L", bool compute_v=True, *, Tensor(a!) eigenvalues, Tensor(b!) eigenvectors) -> (Tensor(a!) eigenvalues, Tensor(b!) eigenvectors)
::std::tuple<at::Tensor &,at::Tensor &> _linalg_eigh_eigenvalues::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, c10::string_view UPLO, bool compute_v, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
    
    static auto op = create__linalg_eigh_eigenvalues_typed_handle();
    return op.redispatch(dispatchKeySet, A, UPLO, compute_v, eigenvalues, eigenvectors);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm, name, "aten::linalg_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm, schema_str, "linalg_norm(Tensor self, Scalar? ord=None, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor")

// aten::linalg_norm(Tensor self, Scalar? ord=None, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_norm::schema> create_linalg_norm_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_norm::name, linalg_norm::overload_name)
      .typed<linalg_norm::schema>();
}

// aten::linalg_norm(Tensor self, Scalar? ord=None, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
at::Tensor linalg_norm::call(const at::Tensor & self, const c10::optional<at::Scalar> & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_linalg_norm_typed_handle();
    return op.call(self, ord, dim, keepdim, dtype);
}

// aten::linalg_norm(Tensor self, Scalar? ord=None, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
at::Tensor linalg_norm::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const c10::optional<at::Scalar> & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_linalg_norm_typed_handle();
    return op.redispatch(dispatchKeySet, self, ord, dim, keepdim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm_ord_str, name, "aten::linalg_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm_ord_str, overload_name, "ord_str")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm_ord_str, schema_str, "linalg_norm.ord_str(Tensor self, str ord, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor")

// aten::linalg_norm.ord_str(Tensor self, str ord, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_norm_ord_str::schema> create_linalg_norm_ord_str_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_norm_ord_str::name, linalg_norm_ord_str::overload_name)
      .typed<linalg_norm_ord_str::schema>();
}

// aten::linalg_norm.ord_str(Tensor self, str ord, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
at::Tensor linalg_norm_ord_str::call(const at::Tensor & self, c10::string_view ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_linalg_norm_ord_str_typed_handle();
    return op.call(self, ord, dim, keepdim, dtype);
}

// aten::linalg_norm.ord_str(Tensor self, str ord, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None) -> Tensor
at::Tensor linalg_norm_ord_str::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::string_view ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    
    static auto op = create_linalg_norm_ord_str_typed_handle();
    return op.redispatch(dispatchKeySet, self, ord, dim, keepdim, dtype);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm_out, name, "aten::linalg_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm_out, schema_str, "linalg_norm.out(Tensor self, Scalar? ord=None, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_norm.out(Tensor self, Scalar? ord=None, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_norm_out::schema> create_linalg_norm_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_norm_out::name, linalg_norm_out::overload_name)
      .typed<linalg_norm_out::schema>();
}

// aten::linalg_norm.out(Tensor self, Scalar? ord=None, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_norm_out::call(const at::Tensor & self, const c10::optional<at::Scalar> & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_linalg_norm_out_typed_handle();
    return op.call(self, ord, dim, keepdim, dtype, out);
}

// aten::linalg_norm.out(Tensor self, Scalar? ord=None, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_norm_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const c10::optional<at::Scalar> & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_linalg_norm_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, ord, dim, keepdim, dtype, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm_ord_str_out, name, "aten::linalg_norm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm_ord_str_out, overload_name, "ord_str_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_norm_ord_str_out, schema_str, "linalg_norm.ord_str_out(Tensor self, str ord, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_norm.ord_str_out(Tensor self, str ord, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_norm_ord_str_out::schema> create_linalg_norm_ord_str_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_norm_ord_str_out::name, linalg_norm_ord_str_out::overload_name)
      .typed<linalg_norm_ord_str_out::schema>();
}

// aten::linalg_norm.ord_str_out(Tensor self, str ord, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_norm_ord_str_out::call(const at::Tensor & self, c10::string_view ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_linalg_norm_ord_str_out_typed_handle();
    return op.call(self, ord, dim, keepdim, dtype, out);
}

// aten::linalg_norm.ord_str_out(Tensor self, str ord, int[1]? dim=None, bool keepdim=False, *, ScalarType? dtype=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_norm_ord_str_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::string_view ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_linalg_norm_ord_str_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, ord, dim, keepdim, dtype, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_svdvals, name, "aten::linalg_svdvals")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_svdvals, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_svdvals, schema_str, "linalg_svdvals(Tensor A, *, str? driver=None) -> Tensor")

// aten::linalg_svdvals(Tensor A, *, str? driver=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_svdvals::schema> create_linalg_svdvals_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_svdvals::name, linalg_svdvals::overload_name)
      .typed<linalg_svdvals::schema>();
}

// aten::linalg_svdvals(Tensor A, *, str? driver=None) -> Tensor
at::Tensor linalg_svdvals::call(const at::Tensor & A, c10::optional<c10::string_view> driver) {
    
    static auto op = create_linalg_svdvals_typed_handle();
    return op.call(A, driver);
}

// aten::linalg_svdvals(Tensor A, *, str? driver=None) -> Tensor
at::Tensor linalg_svdvals::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, c10::optional<c10::string_view> driver) {
    
    static auto op = create_linalg_svdvals_typed_handle();
    return op.redispatch(dispatchKeySet, A, driver);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_svdvals_out, name, "aten::linalg_svdvals")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_svdvals_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_svdvals_out, schema_str, "linalg_svdvals.out(Tensor A, *, str? driver=None, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_svdvals.out(Tensor A, *, str? driver=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_svdvals_out::schema> create_linalg_svdvals_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_svdvals_out::name, linalg_svdvals_out::overload_name)
      .typed<linalg_svdvals_out::schema>();
}

// aten::linalg_svdvals.out(Tensor A, *, str? driver=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_svdvals_out::call(const at::Tensor & A, c10::optional<c10::string_view> driver, at::Tensor & out) {
    
    static auto op = create_linalg_svdvals_out_typed_handle();
    return op.call(A, driver, out);
}

// aten::linalg_svdvals.out(Tensor A, *, str? driver=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_svdvals_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & A, c10::optional<c10::string_view> driver, at::Tensor & out) {
    
    static auto op = create_linalg_svdvals_out_typed_handle();
    return op.redispatch(dispatchKeySet, A, driver, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_power, name, "aten::linalg_matrix_power")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_power, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_power, schema_str, "linalg_matrix_power(Tensor self, int n) -> Tensor")

// aten::linalg_matrix_power(Tensor self, int n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<linalg_matrix_power::schema> create_linalg_matrix_power_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_matrix_power::name, linalg_matrix_power::overload_name)
      .typed<linalg_matrix_power::schema>();
}

// aten::linalg_matrix_power(Tensor self, int n) -> Tensor
at::Tensor linalg_matrix_power::call(const at::Tensor & self, int64_t n) {
    
    static auto op = create_linalg_matrix_power_typed_handle();
    return op.call(self, n);
}

// aten::linalg_matrix_power(Tensor self, int n) -> Tensor
at::Tensor linalg_matrix_power::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t n) {
    
    static auto op = create_linalg_matrix_power_typed_handle();
    return op.redispatch(dispatchKeySet, self, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_power_out, name, "aten::linalg_matrix_power")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_power_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_power_out, schema_str, "linalg_matrix_power.out(Tensor self, int n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_matrix_power.out(Tensor self, int n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_matrix_power_out::schema> create_linalg_matrix_power_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_matrix_power_out::name, linalg_matrix_power_out::overload_name)
      .typed<linalg_matrix_power_out::schema>();
}

// aten::linalg_matrix_power.out(Tensor self, int n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_matrix_power_out::call(const at::Tensor & self, int64_t n, at::Tensor & out) {
    
    static auto op = create_linalg_matrix_power_out_typed_handle();
    return op.call(self, n, out);
}

// aten::linalg_matrix_power.out(Tensor self, int n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_matrix_power_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t n, at::Tensor & out) {
    
    static auto op = create_linalg_matrix_power_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_serialization_subcmul, name, "aten::_test_serialization_subcmul")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_serialization_subcmul, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_serialization_subcmul, schema_str, "_test_serialization_subcmul(Tensor self, Tensor other, Scalar alpha=1) -> Tensor")

// aten::_test_serialization_subcmul(Tensor self, Tensor other, Scalar alpha=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_test_serialization_subcmul::schema> create__test_serialization_subcmul_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_serialization_subcmul::name, _test_serialization_subcmul::overload_name)
      .typed<_test_serialization_subcmul::schema>();
}

// aten::_test_serialization_subcmul(Tensor self, Tensor other, Scalar alpha=1) -> Tensor
at::Tensor _test_serialization_subcmul::call(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create__test_serialization_subcmul_typed_handle();
    return op.call(self, other, alpha);
}

// aten::_test_serialization_subcmul(Tensor self, Tensor other, Scalar alpha=1) -> Tensor
at::Tensor _test_serialization_subcmul::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    
    static auto op = create__test_serialization_subcmul_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_optional_intlist, name, "aten::_test_optional_intlist")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_optional_intlist, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_optional_intlist, schema_str, "_test_optional_intlist(Tensor values, int[]? addends) -> Tensor")

// aten::_test_optional_intlist(Tensor values, int[]? addends) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_test_optional_intlist::schema> create__test_optional_intlist_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_optional_intlist::name, _test_optional_intlist::overload_name)
      .typed<_test_optional_intlist::schema>();
}

// aten::_test_optional_intlist(Tensor values, int[]? addends) -> Tensor
at::Tensor _test_optional_intlist::call(const at::Tensor & values, at::OptionalIntArrayRef addends) {
    
    static auto op = create__test_optional_intlist_typed_handle();
    return op.call(values, addends);
}

// aten::_test_optional_intlist(Tensor values, int[]? addends) -> Tensor
at::Tensor _test_optional_intlist::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & values, at::OptionalIntArrayRef addends) {
    
    static auto op = create__test_optional_intlist_typed_handle();
    return op.redispatch(dispatchKeySet, values, addends);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_ambiguous_defaults_a, name, "aten::_test_ambiguous_defaults")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_ambiguous_defaults_a, overload_name, "a")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_ambiguous_defaults_a, schema_str, "_test_ambiguous_defaults.a(Tensor dummy, int a=1, int b=1) -> Tensor")

// aten::_test_ambiguous_defaults.a(Tensor dummy, int a=1, int b=1) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_test_ambiguous_defaults_a::schema> create__test_ambiguous_defaults_a_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_ambiguous_defaults_a::name, _test_ambiguous_defaults_a::overload_name)
      .typed<_test_ambiguous_defaults_a::schema>();
}

// aten::_test_ambiguous_defaults.a(Tensor dummy, int a=1, int b=1) -> Tensor
at::Tensor _test_ambiguous_defaults_a::call(const at::Tensor & dummy, int64_t a, int64_t b) {
    
    static auto op = create__test_ambiguous_defaults_a_typed_handle();
    return op.call(dummy, a, b);
}

// aten::_test_ambiguous_defaults.a(Tensor dummy, int a=1, int b=1) -> Tensor
at::Tensor _test_ambiguous_defaults_a::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & dummy, int64_t a, int64_t b) {
    
    static auto op = create__test_ambiguous_defaults_a_typed_handle();
    return op.redispatch(dispatchKeySet, dummy, a, b);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_ambiguous_defaults_b, name, "aten::_test_ambiguous_defaults")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_ambiguous_defaults_b, overload_name, "b")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_ambiguous_defaults_b, schema_str, "_test_ambiguous_defaults.b(Tensor dummy, int a=2, str b=\"2\") -> Tensor")

// aten::_test_ambiguous_defaults.b(Tensor dummy, int a=2, str b="2") -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_test_ambiguous_defaults_b::schema> create__test_ambiguous_defaults_b_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_ambiguous_defaults_b::name, _test_ambiguous_defaults_b::overload_name)
      .typed<_test_ambiguous_defaults_b::schema>();
}

// aten::_test_ambiguous_defaults.b(Tensor dummy, int a=2, str b="2") -> Tensor
at::Tensor _test_ambiguous_defaults_b::call(const at::Tensor & dummy, int64_t a, c10::string_view b) {
    
    static auto op = create__test_ambiguous_defaults_b_typed_handle();
    return op.call(dummy, a, b);
}

// aten::_test_ambiguous_defaults.b(Tensor dummy, int a=2, str b="2") -> Tensor
at::Tensor _test_ambiguous_defaults_b::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & dummy, int64_t a, c10::string_view b) {
    
    static auto op = create__test_ambiguous_defaults_b_typed_handle();
    return op.redispatch(dispatchKeySet, dummy, a, b);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_fullcoverage, name, "aten::_test_autograd_multiple_dispatch")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_fullcoverage, overload_name, "fullcoverage")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_fullcoverage, schema_str, "_test_autograd_multiple_dispatch.fullcoverage(Tensor self) -> Tensor")

// aten::_test_autograd_multiple_dispatch.fullcoverage(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_test_autograd_multiple_dispatch_fullcoverage::schema> create__test_autograd_multiple_dispatch_fullcoverage_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_autograd_multiple_dispatch_fullcoverage::name, _test_autograd_multiple_dispatch_fullcoverage::overload_name)
      .typed<_test_autograd_multiple_dispatch_fullcoverage::schema>();
}

// aten::_test_autograd_multiple_dispatch.fullcoverage(Tensor self) -> Tensor
at::Tensor _test_autograd_multiple_dispatch_fullcoverage::call(const at::Tensor & self) {
    
    static auto op = create__test_autograd_multiple_dispatch_fullcoverage_typed_handle();
    return op.call(self);
}

// aten::_test_autograd_multiple_dispatch.fullcoverage(Tensor self) -> Tensor
at::Tensor _test_autograd_multiple_dispatch_fullcoverage::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__test_autograd_multiple_dispatch_fullcoverage_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_ntonly, name, "aten::_test_autograd_multiple_dispatch")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_ntonly, overload_name, "ntonly")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_ntonly, schema_str, "_test_autograd_multiple_dispatch.ntonly(Tensor self, bool b) -> Tensor")

// aten::_test_autograd_multiple_dispatch.ntonly(Tensor self, bool b) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_test_autograd_multiple_dispatch_ntonly::schema> create__test_autograd_multiple_dispatch_ntonly_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_autograd_multiple_dispatch_ntonly::name, _test_autograd_multiple_dispatch_ntonly::overload_name)
      .typed<_test_autograd_multiple_dispatch_ntonly::schema>();
}

// aten::_test_autograd_multiple_dispatch.ntonly(Tensor self, bool b) -> Tensor
at::Tensor _test_autograd_multiple_dispatch_ntonly::call(const at::Tensor & self, bool b) {
    
    static auto op = create__test_autograd_multiple_dispatch_ntonly_typed_handle();
    return op.call(self, b);
}

// aten::_test_autograd_multiple_dispatch.ntonly(Tensor self, bool b) -> Tensor
at::Tensor _test_autograd_multiple_dispatch_ntonly::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool b) {
    
    static auto op = create__test_autograd_multiple_dispatch_ntonly_typed_handle();
    return op.redispatch(dispatchKeySet, self, b);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(segment_reduce, name, "aten::segment_reduce")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(segment_reduce, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(segment_reduce, schema_str, "segment_reduce(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None) -> Tensor")

// aten::segment_reduce(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<segment_reduce::schema> create_segment_reduce_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(segment_reduce::name, segment_reduce::overload_name)
      .typed<segment_reduce::schema>();
}

// aten::segment_reduce(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None) -> Tensor
at::Tensor segment_reduce::call(const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & indices, const c10::optional<at::Tensor> & offsets, int64_t axis, bool unsafe, const c10::optional<at::Scalar> & initial) {
    
    static auto op = create_segment_reduce_typed_handle();
    return op.call(data, reduce, lengths, indices, offsets, axis, unsafe, initial);
}

// aten::segment_reduce(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None) -> Tensor
at::Tensor segment_reduce::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & indices, const c10::optional<at::Tensor> & offsets, int64_t axis, bool unsafe, const c10::optional<at::Scalar> & initial) {
    
    static auto op = create_segment_reduce_typed_handle();
    return op.redispatch(dispatchKeySet, data, reduce, lengths, indices, offsets, axis, unsafe, initial);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_segment_reduce_backward, name, "aten::_segment_reduce_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_segment_reduce_backward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_segment_reduce_backward, schema_str, "_segment_reduce_backward(Tensor grad, Tensor output, Tensor data, str reduce, *, Tensor? lengths=None, Tensor? offsets=None, int axis=0, Scalar? initial=None) -> Tensor")

// aten::_segment_reduce_backward(Tensor grad, Tensor output, Tensor data, str reduce, *, Tensor? lengths=None, Tensor? offsets=None, int axis=0, Scalar? initial=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_segment_reduce_backward::schema> create__segment_reduce_backward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_segment_reduce_backward::name, _segment_reduce_backward::overload_name)
      .typed<_segment_reduce_backward::schema>();
}

// aten::_segment_reduce_backward(Tensor grad, Tensor output, Tensor data, str reduce, *, Tensor? lengths=None, Tensor? offsets=None, int axis=0, Scalar? initial=None) -> Tensor
at::Tensor _segment_reduce_backward::call(const at::Tensor & grad, const at::Tensor & output, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & offsets, int64_t axis, const c10::optional<at::Scalar> & initial) {
    
    static auto op = create__segment_reduce_backward_typed_handle();
    return op.call(grad, output, data, reduce, lengths, offsets, axis, initial);
}

// aten::_segment_reduce_backward(Tensor grad, Tensor output, Tensor data, str reduce, *, Tensor? lengths=None, Tensor? offsets=None, int axis=0, Scalar? initial=None) -> Tensor
at::Tensor _segment_reduce_backward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & output, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & offsets, int64_t axis, const c10::optional<at::Scalar> & initial) {
    
    static auto op = create__segment_reduce_backward_typed_handle();
    return op.redispatch(dispatchKeySet, grad, output, data, reduce, lengths, offsets, axis, initial);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_dual_copy, name, "aten::_make_dual_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_dual_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_dual_copy, schema_str, "_make_dual_copy(Tensor primal, Tensor tangent, int level) -> Tensor")

// aten::_make_dual_copy(Tensor primal, Tensor tangent, int level) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_make_dual_copy::schema> create__make_dual_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_make_dual_copy::name, _make_dual_copy::overload_name)
      .typed<_make_dual_copy::schema>();
}

// aten::_make_dual_copy(Tensor primal, Tensor tangent, int level) -> Tensor
at::Tensor _make_dual_copy::call(const at::Tensor & primal, const at::Tensor & tangent, int64_t level) {
    
    static auto op = create__make_dual_copy_typed_handle();
    return op.call(primal, tangent, level);
}

// aten::_make_dual_copy(Tensor primal, Tensor tangent, int level) -> Tensor
at::Tensor _make_dual_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & primal, const at::Tensor & tangent, int64_t level) {
    
    static auto op = create__make_dual_copy_typed_handle();
    return op.redispatch(dispatchKeySet, primal, tangent, level);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_complex_copy, name, "aten::view_as_complex_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_complex_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_complex_copy, schema_str, "view_as_complex_copy(Tensor self) -> Tensor")

// aten::view_as_complex_copy(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<view_as_complex_copy::schema> create_view_as_complex_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(view_as_complex_copy::name, view_as_complex_copy::overload_name)
      .typed<view_as_complex_copy::schema>();
}

// aten::view_as_complex_copy(Tensor self) -> Tensor
at::Tensor view_as_complex_copy::call(const at::Tensor & self) {
    
    static auto op = create_view_as_complex_copy_typed_handle();
    return op.call(self);
}

// aten::view_as_complex_copy(Tensor self) -> Tensor
at::Tensor view_as_complex_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_view_as_complex_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_neg_view_copy, name, "aten::_neg_view_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_neg_view_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_neg_view_copy, schema_str, "_neg_view_copy(Tensor self) -> Tensor")

// aten::_neg_view_copy(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_neg_view_copy::schema> create__neg_view_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_neg_view_copy::name, _neg_view_copy::overload_name)
      .typed<_neg_view_copy::schema>();
}

// aten::_neg_view_copy(Tensor self) -> Tensor
at::Tensor _neg_view_copy::call(const at::Tensor & self) {
    
    static auto op = create__neg_view_copy_typed_handle();
    return op.call(self);
}

// aten::_neg_view_copy(Tensor self) -> Tensor
at::Tensor _neg_view_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create__neg_view_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expand_copy, name, "aten::expand_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expand_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expand_copy, schema_str, "expand_copy(Tensor self, SymInt[] size, *, bool implicit=False) -> Tensor")

// aten::expand_copy(Tensor self, SymInt[] size, *, bool implicit=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<expand_copy::schema> create_expand_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(expand_copy::name, expand_copy::overload_name)
      .typed<expand_copy::schema>();
}

// aten::expand_copy(Tensor self, SymInt[] size, *, bool implicit=False) -> Tensor
at::Tensor expand_copy::call(const at::Tensor & self, c10::SymIntArrayRef size, bool implicit) {
    
    static auto op = create_expand_copy_typed_handle();
    return op.call(self, size, implicit);
}

// aten::expand_copy(Tensor self, SymInt[] size, *, bool implicit=False) -> Tensor
at::Tensor expand_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, bool implicit) {
    
    static auto op = create_expand_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, implicit);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze_copy, name, "aten::unsqueeze_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze_copy, schema_str, "unsqueeze_copy(Tensor self, int dim) -> Tensor")

// aten::unsqueeze_copy(Tensor self, int dim) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<unsqueeze_copy::schema> create_unsqueeze_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unsqueeze_copy::name, unsqueeze_copy::overload_name)
      .typed<unsqueeze_copy::schema>();
}

// aten::unsqueeze_copy(Tensor self, int dim) -> Tensor
at::Tensor unsqueeze_copy::call(const at::Tensor & self, int64_t dim) {
    
    static auto op = create_unsqueeze_copy_typed_handle();
    return op.call(self, dim);
}

// aten::unsqueeze_copy(Tensor self, int dim) -> Tensor
at::Tensor unsqueeze_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim) {
    
    static auto op = create_unsqueeze_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(crow_indices_copy, name, "aten::crow_indices_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(crow_indices_copy, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(crow_indices_copy, schema_str, "crow_indices_copy(Tensor self) -> Tensor")

// aten::crow_indices_copy(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<crow_indices_copy::schema> create_crow_indices_copy_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(crow_indices_copy::name, crow_indices_copy::overload_name)
      .typed<crow_indices_copy::schema>();
}

// aten::crow_indices_copy(Tensor self) -> Tensor
at::Tensor crow_indices_copy::call(const at::Tensor & self) {
    
    static auto op = create_crow_indices_copy_typed_handle();
    return op.call(self);
}

// aten::crow_indices_copy(Tensor self) -> Tensor
at::Tensor crow_indices_copy::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_crow_indices_copy_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_padded_tensor, name, "aten::to_padded_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_padded_tensor, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_padded_tensor, schema_str, "to_padded_tensor(Tensor self, float padding, SymInt[]? output_size=None) -> Tensor")

// aten::to_padded_tensor(Tensor self, float padding, SymInt[]? output_size=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<to_padded_tensor::schema> create_to_padded_tensor_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_padded_tensor::name, to_padded_tensor::overload_name)
      .typed<to_padded_tensor::schema>();
}

// aten::to_padded_tensor(Tensor self, float padding, SymInt[]? output_size=None) -> Tensor
at::Tensor to_padded_tensor::call(const at::Tensor & self, double padding, at::OptionalSymIntArrayRef output_size) {
    
    static auto op = create_to_padded_tensor_typed_handle();
    return op.call(self, padding, output_size);
}

// aten::to_padded_tensor(Tensor self, float padding, SymInt[]? output_size=None) -> Tensor
at::Tensor to_padded_tensor::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double padding, at::OptionalSymIntArrayRef output_size) {
    
    static auto op = create_to_padded_tensor_typed_handle();
    return op.redispatch(dispatchKeySet, self, padding, output_size);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_softmax_with_shape, name, "aten::_nested_tensor_softmax_with_shape")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_softmax_with_shape, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_nested_tensor_softmax_with_shape, schema_str, "_nested_tensor_softmax_with_shape(Tensor self, Tensor query) -> Tensor")

// aten::_nested_tensor_softmax_with_shape(Tensor self, Tensor query) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_nested_tensor_softmax_with_shape::schema> create__nested_tensor_softmax_with_shape_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_nested_tensor_softmax_with_shape::name, _nested_tensor_softmax_with_shape::overload_name)
      .typed<_nested_tensor_softmax_with_shape::schema>();
}

// aten::_nested_tensor_softmax_with_shape(Tensor self, Tensor query) -> Tensor
at::Tensor _nested_tensor_softmax_with_shape::call(const at::Tensor & self, const at::Tensor & query) {
    
    static auto op = create__nested_tensor_softmax_with_shape_typed_handle();
    return op.call(self, query);
}

// aten::_nested_tensor_softmax_with_shape(Tensor self, Tensor query) -> Tensor
at::Tensor _nested_tensor_softmax_with_shape::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & query) {
    
    static auto op = create__nested_tensor_softmax_with_shape_typed_handle();
    return op.redispatch(dispatchKeySet, self, query);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_flash_attention_forward, name, "aten::_flash_attention_forward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_flash_attention_forward, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_flash_attention_forward, schema_str, "_flash_attention_forward(Tensor query, Tensor key, Tensor value, Tensor? cum_seq_q, Tensor? cum_seq_k, SymInt max_q, SymInt max_k, float dropout_p, bool is_causal, bool return_debug_mask, *, float? scale=None) -> (Tensor output, Tensor softmax_logsumexp, Tensor philox_seed, Tensor philox_offset, Tensor debug_attn_mask)")

// aten::_flash_attention_forward(Tensor query, Tensor key, Tensor value, Tensor? cum_seq_q, Tensor? cum_seq_k, SymInt max_q, SymInt max_k, float dropout_p, bool is_causal, bool return_debug_mask, *, float? scale=None) -> (Tensor output, Tensor softmax_logsumexp, Tensor philox_seed, Tensor philox_offset, Tensor debug_attn_mask)
static C10_NOINLINE c10::TypedOperatorHandle<_flash_attention_forward::schema> create__flash_attention_forward_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_flash_attention_forward::name, _flash_attention_forward::overload_name)
      .typed<_flash_attention_forward::schema>();
}

// aten::_flash_attention_forward(Tensor query, Tensor key, Tensor value, Tensor? cum_seq_q, Tensor? cum_seq_k, SymInt max_q, SymInt max_k, float dropout_p, bool is_causal, bool return_debug_mask, *, float? scale=None) -> (Tensor output, Tensor softmax_logsumexp, Tensor philox_seed, Tensor philox_offset, Tensor debug_attn_mask)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _flash_attention_forward::call(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & cum_seq_q, const c10::optional<at::Tensor> & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, bool return_debug_mask, c10::optional<double> scale) {
    
    static auto op = create__flash_attention_forward_typed_handle();
    return op.call(query, key, value, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, return_debug_mask, scale);
}

// aten::_flash_attention_forward(Tensor query, Tensor key, Tensor value, Tensor? cum_seq_q, Tensor? cum_seq_k, SymInt max_q, SymInt max_k, float dropout_p, bool is_causal, bool return_debug_mask, *, float? scale=None) -> (Tensor output, Tensor softmax_logsumexp, Tensor philox_seed, Tensor philox_offset, Tensor debug_attn_mask)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _flash_attention_forward::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & cum_seq_q, const c10::optional<at::Tensor> & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, bool return_debug_mask, c10::optional<double> scale) {
    
    static auto op = create__flash_attention_forward_typed_handle();
    return op.redispatch(dispatchKeySet, query, key, value, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, return_debug_mask, scale);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_j0, name, "aten::special_bessel_j0")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_j0, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_j0, schema_str, "special_bessel_j0(Tensor self) -> Tensor")

// aten::special_bessel_j0(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_bessel_j0::schema> create_special_bessel_j0_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_bessel_j0::name, special_bessel_j0::overload_name)
      .typed<special_bessel_j0::schema>();
}

// aten::special_bessel_j0(Tensor self) -> Tensor
at::Tensor special_bessel_j0::call(const at::Tensor & self) {
    
    static auto op = create_special_bessel_j0_typed_handle();
    return op.call(self);
}

// aten::special_bessel_j0(Tensor self) -> Tensor
at::Tensor special_bessel_j0::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_bessel_j0_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_j0_out, name, "aten::special_bessel_j0")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_j0_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_j0_out, schema_str, "special_bessel_j0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_bessel_j0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_bessel_j0_out::schema> create_special_bessel_j0_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_bessel_j0_out::name, special_bessel_j0_out::overload_name)
      .typed<special_bessel_j0_out::schema>();
}

// aten::special_bessel_j0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_bessel_j0_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_bessel_j0_out_typed_handle();
    return op.call(self, out);
}

// aten::special_bessel_j0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_bessel_j0_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_bessel_j0_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_y0, name, "aten::special_bessel_y0")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_y0, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_y0, schema_str, "special_bessel_y0(Tensor self) -> Tensor")

// aten::special_bessel_y0(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_bessel_y0::schema> create_special_bessel_y0_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_bessel_y0::name, special_bessel_y0::overload_name)
      .typed<special_bessel_y0::schema>();
}

// aten::special_bessel_y0(Tensor self) -> Tensor
at::Tensor special_bessel_y0::call(const at::Tensor & self) {
    
    static auto op = create_special_bessel_y0_typed_handle();
    return op.call(self);
}

// aten::special_bessel_y0(Tensor self) -> Tensor
at::Tensor special_bessel_y0::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_bessel_y0_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_y0_out, name, "aten::special_bessel_y0")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_y0_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_bessel_y0_out, schema_str, "special_bessel_y0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_bessel_y0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_bessel_y0_out::schema> create_special_bessel_y0_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_bessel_y0_out::name, special_bessel_y0_out::overload_name)
      .typed<special_bessel_y0_out::schema>();
}

// aten::special_bessel_y0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_bessel_y0_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_bessel_y0_out_typed_handle();
    return op.call(self, out);
}

// aten::special_bessel_y0.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_bessel_y0_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_bessel_y0_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u, name, "aten::special_chebyshev_polynomial_u")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u, schema_str, "special_chebyshev_polynomial_u(Tensor x, Tensor n) -> Tensor")

// aten::special_chebyshev_polynomial_u(Tensor x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_u::schema> create_special_chebyshev_polynomial_u_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_u::name, special_chebyshev_polynomial_u::overload_name)
      .typed<special_chebyshev_polynomial_u::schema>();
}

// aten::special_chebyshev_polynomial_u(Tensor x, Tensor n) -> Tensor
at::Tensor special_chebyshev_polynomial_u::call(const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_chebyshev_polynomial_u_typed_handle();
    return op.call(x, n);
}

// aten::special_chebyshev_polynomial_u(Tensor x, Tensor n) -> Tensor
at::Tensor special_chebyshev_polynomial_u::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_chebyshev_polynomial_u_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_x_scalar, name, "aten::special_chebyshev_polynomial_u")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_x_scalar, overload_name, "x_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_x_scalar, schema_str, "special_chebyshev_polynomial_u.x_scalar(Scalar x, Tensor n) -> Tensor")

// aten::special_chebyshev_polynomial_u.x_scalar(Scalar x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_u_x_scalar::schema> create_special_chebyshev_polynomial_u_x_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_u_x_scalar::name, special_chebyshev_polynomial_u_x_scalar::overload_name)
      .typed<special_chebyshev_polynomial_u_x_scalar::schema>();
}

// aten::special_chebyshev_polynomial_u.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_chebyshev_polynomial_u_x_scalar::call(const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_chebyshev_polynomial_u_x_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_chebyshev_polynomial_u.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_chebyshev_polynomial_u_x_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_chebyshev_polynomial_u_x_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_n_scalar, name, "aten::special_chebyshev_polynomial_u")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_n_scalar, overload_name, "n_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_n_scalar, schema_str, "special_chebyshev_polynomial_u.n_scalar(Tensor x, Scalar n) -> Tensor")

// aten::special_chebyshev_polynomial_u.n_scalar(Tensor x, Scalar n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_u_n_scalar::schema> create_special_chebyshev_polynomial_u_n_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_u_n_scalar::name, special_chebyshev_polynomial_u_n_scalar::overload_name)
      .typed<special_chebyshev_polynomial_u_n_scalar::schema>();
}

// aten::special_chebyshev_polynomial_u.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_chebyshev_polynomial_u_n_scalar::call(const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_chebyshev_polynomial_u_n_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_chebyshev_polynomial_u.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_chebyshev_polynomial_u_n_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_chebyshev_polynomial_u_n_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_out, name, "aten::special_chebyshev_polynomial_u")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_out, schema_str, "special_chebyshev_polynomial_u.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_chebyshev_polynomial_u.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_u_out::schema> create_special_chebyshev_polynomial_u_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_u_out::name, special_chebyshev_polynomial_u_out::overload_name)
      .typed<special_chebyshev_polynomial_u_out::schema>();
}

// aten::special_chebyshev_polynomial_u.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_u_out::call(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_u_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_chebyshev_polynomial_u.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_u_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_u_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_x_scalar_out, name, "aten::special_chebyshev_polynomial_u")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_x_scalar_out, overload_name, "x_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_x_scalar_out, schema_str, "special_chebyshev_polynomial_u.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_chebyshev_polynomial_u.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_u_x_scalar_out::schema> create_special_chebyshev_polynomial_u_x_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_u_x_scalar_out::name, special_chebyshev_polynomial_u_x_scalar_out::overload_name)
      .typed<special_chebyshev_polynomial_u_x_scalar_out::schema>();
}

// aten::special_chebyshev_polynomial_u.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_u_x_scalar_out::call(const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_u_x_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_chebyshev_polynomial_u.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_u_x_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_u_x_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_n_scalar_out, name, "aten::special_chebyshev_polynomial_u")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_n_scalar_out, overload_name, "n_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_chebyshev_polynomial_u_n_scalar_out, schema_str, "special_chebyshev_polynomial_u.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_chebyshev_polynomial_u.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_chebyshev_polynomial_u_n_scalar_out::schema> create_special_chebyshev_polynomial_u_n_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_chebyshev_polynomial_u_n_scalar_out::name, special_chebyshev_polynomial_u_n_scalar_out::overload_name)
      .typed<special_chebyshev_polynomial_u_n_scalar_out::schema>();
}

// aten::special_chebyshev_polynomial_u.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_u_n_scalar_out::call(const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_u_n_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_chebyshev_polynomial_u.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_chebyshev_polynomial_u_n_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_chebyshev_polynomial_u_n_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he, name, "aten::special_hermite_polynomial_he")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he, schema_str, "special_hermite_polynomial_he(Tensor x, Tensor n) -> Tensor")

// aten::special_hermite_polynomial_he(Tensor x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_hermite_polynomial_he::schema> create_special_hermite_polynomial_he_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_hermite_polynomial_he::name, special_hermite_polynomial_he::overload_name)
      .typed<special_hermite_polynomial_he::schema>();
}

// aten::special_hermite_polynomial_he(Tensor x, Tensor n) -> Tensor
at::Tensor special_hermite_polynomial_he::call(const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_hermite_polynomial_he_typed_handle();
    return op.call(x, n);
}

// aten::special_hermite_polynomial_he(Tensor x, Tensor n) -> Tensor
at::Tensor special_hermite_polynomial_he::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_hermite_polynomial_he_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_x_scalar, name, "aten::special_hermite_polynomial_he")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_x_scalar, overload_name, "x_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_x_scalar, schema_str, "special_hermite_polynomial_he.x_scalar(Scalar x, Tensor n) -> Tensor")

// aten::special_hermite_polynomial_he.x_scalar(Scalar x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_hermite_polynomial_he_x_scalar::schema> create_special_hermite_polynomial_he_x_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_hermite_polynomial_he_x_scalar::name, special_hermite_polynomial_he_x_scalar::overload_name)
      .typed<special_hermite_polynomial_he_x_scalar::schema>();
}

// aten::special_hermite_polynomial_he.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_hermite_polynomial_he_x_scalar::call(const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_hermite_polynomial_he_x_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_hermite_polynomial_he.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_hermite_polynomial_he_x_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_hermite_polynomial_he_x_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_n_scalar, name, "aten::special_hermite_polynomial_he")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_n_scalar, overload_name, "n_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_n_scalar, schema_str, "special_hermite_polynomial_he.n_scalar(Tensor x, Scalar n) -> Tensor")

// aten::special_hermite_polynomial_he.n_scalar(Tensor x, Scalar n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_hermite_polynomial_he_n_scalar::schema> create_special_hermite_polynomial_he_n_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_hermite_polynomial_he_n_scalar::name, special_hermite_polynomial_he_n_scalar::overload_name)
      .typed<special_hermite_polynomial_he_n_scalar::schema>();
}

// aten::special_hermite_polynomial_he.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_hermite_polynomial_he_n_scalar::call(const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_hermite_polynomial_he_n_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_hermite_polynomial_he.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_hermite_polynomial_he_n_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_hermite_polynomial_he_n_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_out, name, "aten::special_hermite_polynomial_he")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_out, schema_str, "special_hermite_polynomial_he.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_hermite_polynomial_he.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_hermite_polynomial_he_out::schema> create_special_hermite_polynomial_he_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_hermite_polynomial_he_out::name, special_hermite_polynomial_he_out::overload_name)
      .typed<special_hermite_polynomial_he_out::schema>();
}

// aten::special_hermite_polynomial_he.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_hermite_polynomial_he_out::call(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_hermite_polynomial_he_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_hermite_polynomial_he.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_hermite_polynomial_he_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_hermite_polynomial_he_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_x_scalar_out, name, "aten::special_hermite_polynomial_he")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_x_scalar_out, overload_name, "x_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_x_scalar_out, schema_str, "special_hermite_polynomial_he.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_hermite_polynomial_he.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_hermite_polynomial_he_x_scalar_out::schema> create_special_hermite_polynomial_he_x_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_hermite_polynomial_he_x_scalar_out::name, special_hermite_polynomial_he_x_scalar_out::overload_name)
      .typed<special_hermite_polynomial_he_x_scalar_out::schema>();
}

// aten::special_hermite_polynomial_he.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_hermite_polynomial_he_x_scalar_out::call(const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_hermite_polynomial_he_x_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_hermite_polynomial_he.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_hermite_polynomial_he_x_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_hermite_polynomial_he_x_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_n_scalar_out, name, "aten::special_hermite_polynomial_he")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_n_scalar_out, overload_name, "n_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_hermite_polynomial_he_n_scalar_out, schema_str, "special_hermite_polynomial_he.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_hermite_polynomial_he.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_hermite_polynomial_he_n_scalar_out::schema> create_special_hermite_polynomial_he_n_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_hermite_polynomial_he_n_scalar_out::name, special_hermite_polynomial_he_n_scalar_out::overload_name)
      .typed<special_hermite_polynomial_he_n_scalar_out::schema>();
}

// aten::special_hermite_polynomial_he.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_hermite_polynomial_he_n_scalar_out::call(const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_hermite_polynomial_he_n_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_hermite_polynomial_he.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_hermite_polynomial_he_n_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_hermite_polynomial_he_n_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_modified_bessel_i1, name, "aten::special_modified_bessel_i1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_modified_bessel_i1, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_modified_bessel_i1, schema_str, "special_modified_bessel_i1(Tensor self) -> Tensor")

// aten::special_modified_bessel_i1(Tensor self) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_modified_bessel_i1::schema> create_special_modified_bessel_i1_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_modified_bessel_i1::name, special_modified_bessel_i1::overload_name)
      .typed<special_modified_bessel_i1::schema>();
}

// aten::special_modified_bessel_i1(Tensor self) -> Tensor
at::Tensor special_modified_bessel_i1::call(const at::Tensor & self) {
    
    static auto op = create_special_modified_bessel_i1_typed_handle();
    return op.call(self);
}

// aten::special_modified_bessel_i1(Tensor self) -> Tensor
at::Tensor special_modified_bessel_i1::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self) {
    
    static auto op = create_special_modified_bessel_i1_typed_handle();
    return op.redispatch(dispatchKeySet, self);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_modified_bessel_i1_out, name, "aten::special_modified_bessel_i1")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_modified_bessel_i1_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_modified_bessel_i1_out, schema_str, "special_modified_bessel_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_modified_bessel_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_modified_bessel_i1_out::schema> create_special_modified_bessel_i1_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_modified_bessel_i1_out::name, special_modified_bessel_i1_out::overload_name)
      .typed<special_modified_bessel_i1_out::schema>();
}

// aten::special_modified_bessel_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_modified_bessel_i1_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_modified_bessel_i1_out_typed_handle();
    return op.call(self, out);
}

// aten::special_modified_bessel_i1.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_modified_bessel_i1_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_special_modified_bessel_i1_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v, name, "aten::special_shifted_chebyshev_polynomial_v")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v, schema_str, "special_shifted_chebyshev_polynomial_v(Tensor x, Tensor n) -> Tensor")

// aten::special_shifted_chebyshev_polynomial_v(Tensor x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_v::schema> create_special_shifted_chebyshev_polynomial_v_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_v::name, special_shifted_chebyshev_polynomial_v::overload_name)
      .typed<special_shifted_chebyshev_polynomial_v::schema>();
}

// aten::special_shifted_chebyshev_polynomial_v(Tensor x, Tensor n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_v::call(const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_typed_handle();
    return op.call(x, n);
}

// aten::special_shifted_chebyshev_polynomial_v(Tensor x, Tensor n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_v::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_x_scalar, name, "aten::special_shifted_chebyshev_polynomial_v")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_x_scalar, overload_name, "x_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_x_scalar, schema_str, "special_shifted_chebyshev_polynomial_v.x_scalar(Scalar x, Tensor n) -> Tensor")

// aten::special_shifted_chebyshev_polynomial_v.x_scalar(Scalar x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_v_x_scalar::schema> create_special_shifted_chebyshev_polynomial_v_x_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_v_x_scalar::name, special_shifted_chebyshev_polynomial_v_x_scalar::overload_name)
      .typed<special_shifted_chebyshev_polynomial_v_x_scalar::schema>();
}

// aten::special_shifted_chebyshev_polynomial_v.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_v_x_scalar::call(const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_x_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_shifted_chebyshev_polynomial_v.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_v_x_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_x_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_n_scalar, name, "aten::special_shifted_chebyshev_polynomial_v")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_n_scalar, overload_name, "n_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_n_scalar, schema_str, "special_shifted_chebyshev_polynomial_v.n_scalar(Tensor x, Scalar n) -> Tensor")

// aten::special_shifted_chebyshev_polynomial_v.n_scalar(Tensor x, Scalar n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_v_n_scalar::schema> create_special_shifted_chebyshev_polynomial_v_n_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_v_n_scalar::name, special_shifted_chebyshev_polynomial_v_n_scalar::overload_name)
      .typed<special_shifted_chebyshev_polynomial_v_n_scalar::schema>();
}

// aten::special_shifted_chebyshev_polynomial_v.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_v_n_scalar::call(const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_n_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_shifted_chebyshev_polynomial_v.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_v_n_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_n_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_out, name, "aten::special_shifted_chebyshev_polynomial_v")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_out, schema_str, "special_shifted_chebyshev_polynomial_v.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_shifted_chebyshev_polynomial_v.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_v_out::schema> create_special_shifted_chebyshev_polynomial_v_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_v_out::name, special_shifted_chebyshev_polynomial_v_out::overload_name)
      .typed<special_shifted_chebyshev_polynomial_v_out::schema>();
}

// aten::special_shifted_chebyshev_polynomial_v.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_v_out::call(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_shifted_chebyshev_polynomial_v.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_v_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_x_scalar_out, name, "aten::special_shifted_chebyshev_polynomial_v")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_x_scalar_out, overload_name, "x_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_x_scalar_out, schema_str, "special_shifted_chebyshev_polynomial_v.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_shifted_chebyshev_polynomial_v.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_v_x_scalar_out::schema> create_special_shifted_chebyshev_polynomial_v_x_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_v_x_scalar_out::name, special_shifted_chebyshev_polynomial_v_x_scalar_out::overload_name)
      .typed<special_shifted_chebyshev_polynomial_v_x_scalar_out::schema>();
}

// aten::special_shifted_chebyshev_polynomial_v.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_v_x_scalar_out::call(const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_x_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_shifted_chebyshev_polynomial_v.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_v_x_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_x_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_n_scalar_out, name, "aten::special_shifted_chebyshev_polynomial_v")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_n_scalar_out, overload_name, "n_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_v_n_scalar_out, schema_str, "special_shifted_chebyshev_polynomial_v.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_shifted_chebyshev_polynomial_v.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_v_n_scalar_out::schema> create_special_shifted_chebyshev_polynomial_v_n_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_v_n_scalar_out::name, special_shifted_chebyshev_polynomial_v_n_scalar_out::overload_name)
      .typed<special_shifted_chebyshev_polynomial_v_n_scalar_out::schema>();
}

// aten::special_shifted_chebyshev_polynomial_v.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_v_n_scalar_out::call(const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_n_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_shifted_chebyshev_polynomial_v.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_v_n_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_v_n_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w, name, "aten::special_shifted_chebyshev_polynomial_w")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w, schema_str, "special_shifted_chebyshev_polynomial_w(Tensor x, Tensor n) -> Tensor")

// aten::special_shifted_chebyshev_polynomial_w(Tensor x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_w::schema> create_special_shifted_chebyshev_polynomial_w_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_w::name, special_shifted_chebyshev_polynomial_w::overload_name)
      .typed<special_shifted_chebyshev_polynomial_w::schema>();
}

// aten::special_shifted_chebyshev_polynomial_w(Tensor x, Tensor n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_w::call(const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_typed_handle();
    return op.call(x, n);
}

// aten::special_shifted_chebyshev_polynomial_w(Tensor x, Tensor n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_w::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_x_scalar, name, "aten::special_shifted_chebyshev_polynomial_w")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_x_scalar, overload_name, "x_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_x_scalar, schema_str, "special_shifted_chebyshev_polynomial_w.x_scalar(Scalar x, Tensor n) -> Tensor")

// aten::special_shifted_chebyshev_polynomial_w.x_scalar(Scalar x, Tensor n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_w_x_scalar::schema> create_special_shifted_chebyshev_polynomial_w_x_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_w_x_scalar::name, special_shifted_chebyshev_polynomial_w_x_scalar::overload_name)
      .typed<special_shifted_chebyshev_polynomial_w_x_scalar::schema>();
}

// aten::special_shifted_chebyshev_polynomial_w.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_w_x_scalar::call(const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_x_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_shifted_chebyshev_polynomial_w.x_scalar(Scalar x, Tensor n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_w_x_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_x_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_n_scalar, name, "aten::special_shifted_chebyshev_polynomial_w")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_n_scalar, overload_name, "n_scalar")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_n_scalar, schema_str, "special_shifted_chebyshev_polynomial_w.n_scalar(Tensor x, Scalar n) -> Tensor")

// aten::special_shifted_chebyshev_polynomial_w.n_scalar(Tensor x, Scalar n) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_w_n_scalar::schema> create_special_shifted_chebyshev_polynomial_w_n_scalar_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_w_n_scalar::name, special_shifted_chebyshev_polynomial_w_n_scalar::overload_name)
      .typed<special_shifted_chebyshev_polynomial_w_n_scalar::schema>();
}

// aten::special_shifted_chebyshev_polynomial_w.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_w_n_scalar::call(const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_n_scalar_typed_handle();
    return op.call(x, n);
}

// aten::special_shifted_chebyshev_polynomial_w.n_scalar(Tensor x, Scalar n) -> Tensor
at::Tensor special_shifted_chebyshev_polynomial_w_n_scalar::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_n_scalar_typed_handle();
    return op.redispatch(dispatchKeySet, x, n);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_out, name, "aten::special_shifted_chebyshev_polynomial_w")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_out, schema_str, "special_shifted_chebyshev_polynomial_w.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_shifted_chebyshev_polynomial_w.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_w_out::schema> create_special_shifted_chebyshev_polynomial_w_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_w_out::name, special_shifted_chebyshev_polynomial_w_out::overload_name)
      .typed<special_shifted_chebyshev_polynomial_w_out::schema>();
}

// aten::special_shifted_chebyshev_polynomial_w.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_w_out::call(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_shifted_chebyshev_polynomial_w.out(Tensor x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_w_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_x_scalar_out, name, "aten::special_shifted_chebyshev_polynomial_w")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_x_scalar_out, overload_name, "x_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_x_scalar_out, schema_str, "special_shifted_chebyshev_polynomial_w.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_shifted_chebyshev_polynomial_w.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_w_x_scalar_out::schema> create_special_shifted_chebyshev_polynomial_w_x_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_w_x_scalar_out::name, special_shifted_chebyshev_polynomial_w_x_scalar_out::overload_name)
      .typed<special_shifted_chebyshev_polynomial_w_x_scalar_out::schema>();
}

// aten::special_shifted_chebyshev_polynomial_w.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_w_x_scalar_out::call(const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_x_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_shifted_chebyshev_polynomial_w.x_scalar_out(Scalar x, Tensor n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_w_x_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & x, const at::Tensor & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_x_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_n_scalar_out, name, "aten::special_shifted_chebyshev_polynomial_w")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_n_scalar_out, overload_name, "n_scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_shifted_chebyshev_polynomial_w_n_scalar_out, schema_str, "special_shifted_chebyshev_polynomial_w.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_shifted_chebyshev_polynomial_w.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_shifted_chebyshev_polynomial_w_n_scalar_out::schema> create_special_shifted_chebyshev_polynomial_w_n_scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_shifted_chebyshev_polynomial_w_n_scalar_out::name, special_shifted_chebyshev_polynomial_w_n_scalar_out::overload_name)
      .typed<special_shifted_chebyshev_polynomial_w_n_scalar_out::schema>();
}

// aten::special_shifted_chebyshev_polynomial_w.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_w_n_scalar_out::call(const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_n_scalar_out_typed_handle();
    return op.call(x, n, out);
}

// aten::special_shifted_chebyshev_polynomial_w.n_scalar_out(Tensor x, Scalar n, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_shifted_chebyshev_polynomial_w_n_scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, const at::Scalar & n, at::Tensor & out) {
    
    static auto op = create_special_shifted_chebyshev_polynomial_w_n_scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, n, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_spherical_bessel_j0, name, "aten::special_spherical_bessel_j0")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_spherical_bessel_j0, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_spherical_bessel_j0, schema_str, "special_spherical_bessel_j0(Tensor x) -> Tensor")

// aten::special_spherical_bessel_j0(Tensor x) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<special_spherical_bessel_j0::schema> create_special_spherical_bessel_j0_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_spherical_bessel_j0::name, special_spherical_bessel_j0::overload_name)
      .typed<special_spherical_bessel_j0::schema>();
}

// aten::special_spherical_bessel_j0(Tensor x) -> Tensor
at::Tensor special_spherical_bessel_j0::call(const at::Tensor & x) {
    
    static auto op = create_special_spherical_bessel_j0_typed_handle();
    return op.call(x);
}

// aten::special_spherical_bessel_j0(Tensor x) -> Tensor
at::Tensor special_spherical_bessel_j0::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x) {
    
    static auto op = create_special_spherical_bessel_j0_typed_handle();
    return op.redispatch(dispatchKeySet, x);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_spherical_bessel_j0_out, name, "aten::special_spherical_bessel_j0")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_spherical_bessel_j0_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(special_spherical_bessel_j0_out, schema_str, "special_spherical_bessel_j0.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)")

// aten::special_spherical_bessel_j0.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<special_spherical_bessel_j0_out::schema> create_special_spherical_bessel_j0_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(special_spherical_bessel_j0_out::name, special_spherical_bessel_j0_out::overload_name)
      .typed<special_spherical_bessel_j0_out::schema>();
}

// aten::special_spherical_bessel_j0.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_spherical_bessel_j0_out::call(const at::Tensor & x, at::Tensor & out) {
    
    static auto op = create_special_spherical_bessel_j0_out_typed_handle();
    return op.call(x, out);
}

// aten::special_spherical_bessel_j0.out(Tensor x, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & special_spherical_bessel_j0_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & x, at::Tensor & out) {
    
    static auto op = create_special_spherical_bessel_j0_out_typed_handle();
    return op.redispatch(dispatchKeySet, x, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_ctc_loss_out, name, "aten::_cudnn_ctc_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_ctc_loss_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_ctc_loss_out, schema_str, "_cudnn_ctc_loss.out(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank, bool deterministic, bool zero_infinity, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::_cudnn_ctc_loss.out(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank, bool deterministic, bool zero_infinity, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<_cudnn_ctc_loss_out::schema> create__cudnn_ctc_loss_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cudnn_ctc_loss_out::name, _cudnn_ctc_loss_out::overload_name)
      .typed<_cudnn_ctc_loss_out::schema>();
}

// aten::_cudnn_ctc_loss.out(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank, bool deterministic, bool zero_infinity, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _cudnn_ctc_loss_out::call(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool deterministic, bool zero_infinity, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__cudnn_ctc_loss_out_typed_handle();
    return op.call(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity, out0, out1);
}

// aten::_cudnn_ctc_loss.out(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank, bool deterministic, bool zero_infinity, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _cudnn_ctc_loss_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool deterministic, bool zero_infinity, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__cudnn_ctc_loss_out_typed_handle();
    return op.redispatch(dispatchKeySet, log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_rnn_out, name, "aten::_cudnn_rnn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_rnn_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_cudnn_rnn_out, schema_str, "_cudnn_rnn.out(Tensor input, Tensor[] weight, int weight_stride0, Tensor? weight_buf, Tensor hx, Tensor? cx, int mode, SymInt hidden_size, SymInt proj_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, SymInt[] batch_sizes, Tensor? dropout_state, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3, Tensor(e!) out4) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!), Tensor(e!))")

// aten::_cudnn_rnn.out(Tensor input, Tensor[] weight, int weight_stride0, Tensor? weight_buf, Tensor hx, Tensor? cx, int mode, SymInt hidden_size, SymInt proj_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, SymInt[] batch_sizes, Tensor? dropout_state, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3, Tensor(e!) out4) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!), Tensor(e!))
static C10_NOINLINE c10::TypedOperatorHandle<_cudnn_rnn_out::schema> create__cudnn_rnn_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_cudnn_rnn_out::name, _cudnn_rnn_out::overload_name)
      .typed<_cudnn_rnn_out::schema>();
}

// aten::_cudnn_rnn.out(Tensor input, Tensor[] weight, int weight_stride0, Tensor? weight_buf, Tensor hx, Tensor? cx, int mode, SymInt hidden_size, SymInt proj_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, SymInt[] batch_sizes, Tensor? dropout_state, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3, Tensor(e!) out4) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!), Tensor(e!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _cudnn_rnn_out::call(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const c10::optional<at::Tensor> & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3, at::Tensor & out4) {
    
    static auto op = create__cudnn_rnn_out_typed_handle();
    return op.call(input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, out0, out1, out2, out3, out4);
}

// aten::_cudnn_rnn.out(Tensor input, Tensor[] weight, int weight_stride0, Tensor? weight_buf, Tensor hx, Tensor? cx, int mode, SymInt hidden_size, SymInt proj_size, int num_layers, bool batch_first, float dropout, bool train, bool bidirectional, SymInt[] batch_sizes, Tensor? dropout_state, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3, Tensor(e!) out4) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!), Tensor(e!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _cudnn_rnn_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const c10::optional<at::Tensor> & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3, at::Tensor & out4) {
    
    static auto op = create__cudnn_rnn_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, out0, out1, out2, out3, out4);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_dropout_out, name, "aten::_fused_dropout")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_dropout_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_dropout_out, schema_str, "_fused_dropout.out(Tensor self, float p, Generator? generator=None, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::_fused_dropout.out(Tensor self, float p, Generator? generator=None, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<_fused_dropout_out::schema> create__fused_dropout_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_fused_dropout_out::name, _fused_dropout_out::overload_name)
      .typed<_fused_dropout_out::schema>();
}

// aten::_fused_dropout.out(Tensor self, float p, Generator? generator=None, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _fused_dropout_out::call(const at::Tensor & self, double p, c10::optional<at::Generator> generator, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__fused_dropout_out_typed_handle();
    return op.call(self, p, generator, out0, out1);
}

// aten::_fused_dropout.out(Tensor self, float p, Generator? generator=None, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _fused_dropout_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double p, c10::optional<at::Generator> generator, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__fused_dropout_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, p, generator, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_conj_physical_out, name, "aten::_conj_physical")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_conj_physical_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_conj_physical_out, schema_str, "_conj_physical.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_conj_physical.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_conj_physical_out::schema> create__conj_physical_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_conj_physical_out::name, _conj_physical_out::overload_name)
      .typed<_conj_physical_out::schema>();
}

// aten::_conj_physical.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _conj_physical_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__conj_physical_out_typed_handle();
    return op.call(self, out);
}

// aten::_conj_physical.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _conj_physical_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__conj_physical_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window_out, name, "aten::blackman_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window_out, schema_str, "blackman_window.out(int window_length, *, Tensor(a!) out) -> Tensor(a!)")

// aten::blackman_window.out(int window_length, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<blackman_window_out::schema> create_blackman_window_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(blackman_window_out::name, blackman_window_out::overload_name)
      .typed<blackman_window_out::schema>();
}

// aten::blackman_window.out(int window_length, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & blackman_window_out::call(int64_t window_length, at::Tensor & out) {
    
    static auto op = create_blackman_window_out_typed_handle();
    return op.call(window_length, out);
}

// aten::blackman_window.out(int window_length, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & blackman_window_out::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, at::Tensor & out) {
    
    static auto op = create_blackman_window_out_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window_periodic_out, name, "aten::blackman_window")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window_periodic_out, overload_name, "periodic_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(blackman_window_periodic_out, schema_str, "blackman_window.periodic_out(int window_length, bool periodic, *, Tensor(a!) out) -> Tensor(a!)")

// aten::blackman_window.periodic_out(int window_length, bool periodic, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<blackman_window_periodic_out::schema> create_blackman_window_periodic_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(blackman_window_periodic_out::name, blackman_window_periodic_out::overload_name)
      .typed<blackman_window_periodic_out::schema>();
}

// aten::blackman_window.periodic_out(int window_length, bool periodic, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & blackman_window_periodic_out::call(int64_t window_length, bool periodic, at::Tensor & out) {
    
    static auto op = create_blackman_window_periodic_out_typed_handle();
    return op.call(window_length, periodic, out);
}

// aten::blackman_window.periodic_out(int window_length, bool periodic, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & blackman_window_periodic_out::redispatch(c10::DispatchKeySet dispatchKeySet, int64_t window_length, bool periodic, at::Tensor & out) {
    
    static auto op = create_blackman_window_periodic_out_typed_handle();
    return op.redispatch(dispatchKeySet, window_length, periodic, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_out, name, "aten::convolution")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_out, schema_str, "convolution.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)")

// aten::convolution.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<convolution_out::schema> create_convolution_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(convolution_out::name, convolution_out::overload_name)
      .typed<convolution_out::schema>();
}

// aten::convolution.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & convolution_out::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_convolution_out_typed_handle();
    return op.call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, out);
}

// aten::convolution.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & convolution_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_convolution_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward_overrideable_out, name, "aten::convolution_backward_overrideable")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward_overrideable_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(convolution_backward_overrideable_out, schema_str, "convolution_backward_overrideable.out(Tensor grad_output, Tensor input, Tensor weight, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))")

// aten::convolution_backward_overrideable.out(Tensor grad_output, Tensor input, Tensor weight, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
static C10_NOINLINE c10::TypedOperatorHandle<convolution_backward_overrideable_out::schema> create_convolution_backward_overrideable_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(convolution_backward_overrideable_out::name, convolution_backward_overrideable_out::overload_name)
      .typed<convolution_backward_overrideable_out::schema>();
}

// aten::convolution_backward_overrideable.out(Tensor grad_output, Tensor input, Tensor weight, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> convolution_backward_overrideable_out::call(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_convolution_backward_overrideable_out_typed_handle();
    return op.call(grad_output, input, weight, stride, padding, dilation, transposed, output_padding, groups, output_mask, out0, out1, out2);
}

// aten::convolution_backward_overrideable.out(Tensor grad_output, Tensor input, Tensor weight, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool[3] output_mask, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> convolution_backward_overrideable_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_convolution_backward_overrideable_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, input, weight, stride, padding, dilation, transposed, output_padding, groups, output_mask, out0, out1, out2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution_out, name, "aten::_convolution")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_convolution_out, schema_str, "_convolution.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_convolution.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_convolution_out::schema> create__convolution_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_convolution_out::name, _convolution_out::overload_name)
      .typed<_convolution_out::schema>();
}

// aten::_convolution.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _convolution_out::call(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32, at::Tensor & out) {
    
    static auto op = create__convolution_out_typed_handle();
    return op.call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32, out);
}

// aten::_convolution.out(Tensor input, Tensor weight, Tensor? bias, SymInt[] stride, SymInt[] padding, SymInt[] dilation, bool transposed, SymInt[] output_padding, SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _convolution_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32, at::Tensor & out) {
    
    static auto op = create__convolution_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_affine_grid_generator_out, name, "aten::cudnn_affine_grid_generator")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_affine_grid_generator_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_affine_grid_generator_out, schema_str, "cudnn_affine_grid_generator.out(Tensor theta, int N, int C, int H, int W, *, Tensor(a!) out) -> Tensor(a!)")

// aten::cudnn_affine_grid_generator.out(Tensor theta, int N, int C, int H, int W, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_affine_grid_generator_out::schema> create_cudnn_affine_grid_generator_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_affine_grid_generator_out::name, cudnn_affine_grid_generator_out::overload_name)
      .typed<cudnn_affine_grid_generator_out::schema>();
}

// aten::cudnn_affine_grid_generator.out(Tensor theta, int N, int C, int H, int W, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cudnn_affine_grid_generator_out::call(const at::Tensor & theta, int64_t N, int64_t C, int64_t H, int64_t W, at::Tensor & out) {
    
    static auto op = create_cudnn_affine_grid_generator_out_typed_handle();
    return op.call(theta, N, C, H, W, out);
}

// aten::cudnn_affine_grid_generator.out(Tensor theta, int N, int C, int H, int W, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cudnn_affine_grid_generator_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & theta, int64_t N, int64_t C, int64_t H, int64_t W, at::Tensor & out) {
    
    static auto op = create_cudnn_affine_grid_generator_out_typed_handle();
    return op.redispatch(dispatchKeySet, theta, N, C, H, W, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm_backward_out, name, "aten::cudnn_batch_norm_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_batch_norm_backward_out, schema_str, "cudnn_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))")

// aten::cudnn_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_batch_norm_backward_out::schema> create_cudnn_batch_norm_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_batch_norm_backward_out::name, cudnn_batch_norm_backward_out::overload_name)
      .typed<cudnn_batch_norm_backward_out::schema>();
}

// aten::cudnn_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> cudnn_batch_norm_backward_out::call(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, const at::Tensor & reserveSpace, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_cudnn_batch_norm_backward_out_typed_handle();
    return op.call(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace, out0, out1, out2);
}

// aten::cudnn_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, Tensor reserveSpace, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> cudnn_batch_norm_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, const at::Tensor & reserveSpace, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_cudnn_batch_norm_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace, out0, out1, out2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_convolution_transpose_out, name, "aten::cudnn_convolution_transpose")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_convolution_transpose_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_convolution_transpose_out, schema_str, "cudnn_convolution_transpose.out(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, bool allow_tf32, *, Tensor(a!) out) -> Tensor(a!)")

// aten::cudnn_convolution_transpose.out(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, bool allow_tf32, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_convolution_transpose_out::schema> create_cudnn_convolution_transpose_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_convolution_transpose_out::name, cudnn_convolution_transpose_out::overload_name)
      .typed<cudnn_convolution_transpose_out::schema>();
}

// aten::cudnn_convolution_transpose.out(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, bool allow_tf32, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cudnn_convolution_transpose_out::call(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32, at::Tensor & out) {
    
    static auto op = create_cudnn_convolution_transpose_out_typed_handle();
    return op.call(self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32, out);
}

// aten::cudnn_convolution_transpose.out(Tensor self, Tensor weight, SymInt[] padding, SymInt[] output_padding, SymInt[] stride, SymInt[] dilation, SymInt groups, bool benchmark, bool deterministic, bool allow_tf32, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & cudnn_convolution_transpose_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32, at::Tensor & out) {
    
    static auto op = create_cudnn_convolution_transpose_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_grid_sampler_backward_out, name, "aten::cudnn_grid_sampler_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_grid_sampler_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(cudnn_grid_sampler_backward_out, schema_str, "cudnn_grid_sampler_backward.out(Tensor self, Tensor grid, Tensor grad_output, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::cudnn_grid_sampler_backward.out(Tensor self, Tensor grid, Tensor grad_output, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<cudnn_grid_sampler_backward_out::schema> create_cudnn_grid_sampler_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(cudnn_grid_sampler_backward_out::name, cudnn_grid_sampler_backward_out::overload_name)
      .typed<cudnn_grid_sampler_backward_out::schema>();
}

// aten::cudnn_grid_sampler_backward.out(Tensor self, Tensor grid, Tensor grad_output, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> cudnn_grid_sampler_backward_out::call(const at::Tensor & self, const at::Tensor & grid, const at::Tensor & grad_output, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_cudnn_grid_sampler_backward_out_typed_handle();
    return op.call(self, grid, grad_output, out0, out1);
}

// aten::cudnn_grid_sampler_backward.out(Tensor self, Tensor grid, Tensor grad_output, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> cudnn_grid_sampler_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & grid, const at::Tensor & grad_output, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_cudnn_grid_sampler_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, grid, grad_output, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss_out, name, "aten::_ctc_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss_out, schema_str, "_ctc_loss.out(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, bool zero_infinity=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::_ctc_loss.out(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, bool zero_infinity=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<_ctc_loss_out::schema> create__ctc_loss_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_ctc_loss_out::name, _ctc_loss_out::overload_name)
      .typed<_ctc_loss_out::schema>();
}

// aten::_ctc_loss.out(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, bool zero_infinity=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _ctc_loss_out::call(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool zero_infinity, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__ctc_loss_out_typed_handle();
    return op.call(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity, out0, out1);
}

// aten::_ctc_loss.out(Tensor log_probs, Tensor targets, int[] input_lengths, int[] target_lengths, int blank=0, bool zero_infinity=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _ctc_loss_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool zero_infinity, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__ctc_loss_out_typed_handle();
    return op.redispatch(dispatchKeySet, log_probs, targets, input_lengths, target_lengths, blank, zero_infinity, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss_Tensor_out, name, "aten::_ctc_loss")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_ctc_loss_Tensor_out, schema_str, "_ctc_loss.Tensor_out(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank=0, bool zero_infinity=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::_ctc_loss.Tensor_out(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank=0, bool zero_infinity=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<_ctc_loss_Tensor_out::schema> create__ctc_loss_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_ctc_loss_Tensor_out::name, _ctc_loss_Tensor_out::overload_name)
      .typed<_ctc_loss_Tensor_out::schema>();
}

// aten::_ctc_loss.Tensor_out(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank=0, bool zero_infinity=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _ctc_loss_Tensor_out::call(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool zero_infinity, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__ctc_loss_Tensor_out_typed_handle();
    return op.call(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity, out0, out1);
}

// aten::_ctc_loss.Tensor_out(Tensor log_probs, Tensor targets, Tensor input_lengths, Tensor target_lengths, int blank=0, bool zero_infinity=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _ctc_loss_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool zero_infinity, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__ctc_loss_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, log_probs, targets, input_lengths, target_lengths, blank, zero_infinity, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_dense_backward_out, name, "aten::embedding_dense_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_dense_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(embedding_dense_backward_out, schema_str, "embedding_dense_backward.out(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq, *, Tensor(a!) out) -> Tensor(a!)")

// aten::embedding_dense_backward.out(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<embedding_dense_backward_out::schema> create_embedding_dense_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(embedding_dense_backward_out::name, embedding_dense_backward_out::overload_name)
      .typed<embedding_dense_backward_out::schema>();
}

// aten::embedding_dense_backward.out(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & embedding_dense_backward_out::call(const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq, at::Tensor & out) {
    
    static auto op = create_embedding_dense_backward_out_typed_handle();
    return op.call(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq, out);
}

// aten::embedding_dense_backward.out(Tensor grad_output, Tensor indices, SymInt num_weights, SymInt padding_idx, bool scale_grad_by_freq, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & embedding_dense_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq, at::Tensor & out) {
    
    static auto op = create_embedding_dense_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, indices, num_weights, padding_idx, scale_grad_by_freq, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_out, name, "aten::_embedding_bag")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_embedding_bag_out, schema_str, "_embedding_bag.out(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None, bool include_last_offset=False, int padding_idx=-1, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))")

// aten::_embedding_bag.out(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None, bool include_last_offset=False, int padding_idx=-1, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))
static C10_NOINLINE c10::TypedOperatorHandle<_embedding_bag_out::schema> create__embedding_bag_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_embedding_bag_out::name, _embedding_bag_out::overload_name)
      .typed<_embedding_bag_out::schema>();
}

// aten::_embedding_bag.out(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None, bool include_last_offset=False, int padding_idx=-1, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _embedding_bag_out::call(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3) {
    
    static auto op = create__embedding_bag_out_typed_handle();
    return op.call(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx, out0, out1, out2, out3);
}

// aten::_embedding_bag.out(Tensor weight, Tensor indices, Tensor offsets, bool scale_grad_by_freq=False, int mode=0, bool sparse=False, Tensor? per_sample_weights=None, bool include_last_offset=False, int padding_idx=-1, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2, Tensor(d!) out3) -> (Tensor(a!), Tensor(b!), Tensor(c!), Tensor(d!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _embedding_bag_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3) {
    
    static auto op = create__embedding_bag_out_typed_handle();
    return op.redispatch(dispatchKeySet, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx, out0, out1, out2, out3);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(new_empty_out, name, "aten::new_empty")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(new_empty_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(new_empty_out, schema_str, "new_empty.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)")

// aten::new_empty.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<new_empty_out::schema> create_new_empty_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(new_empty_out::name, new_empty_out::overload_name)
      .typed<new_empty_out::schema>();
}

// aten::new_empty.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & new_empty_out::call(const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create_new_empty_out_typed_handle();
    return op.call(self, size, out);
}

// aten::new_empty.out(Tensor self, SymInt[] size, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & new_empty_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
    
    static auto op = create_new_empty_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Scalar_out, name, "aten::fill")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Scalar_out, schema_str, "fill.Scalar_out(Tensor self, Scalar value, *, Tensor(a!) out) -> Tensor(a!)")

// aten::fill.Scalar_out(Tensor self, Scalar value, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fill_Scalar_out::schema> create_fill_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fill_Scalar_out::name, fill_Scalar_out::overload_name)
      .typed<fill_Scalar_out::schema>();
}

// aten::fill.Scalar_out(Tensor self, Scalar value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fill_Scalar_out::call(const at::Tensor & self, const at::Scalar & value, at::Tensor & out) {
    
    static auto op = create_fill_Scalar_out_typed_handle();
    return op.call(self, value, out);
}

// aten::fill.Scalar_out(Tensor self, Scalar value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fill_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & value, at::Tensor & out) {
    
    static auto op = create_fill_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, value, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Tensor_out, name, "aten::fill")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fill_Tensor_out, schema_str, "fill.Tensor_out(Tensor self, Tensor value, *, Tensor(a!) out) -> Tensor(a!)")

// aten::fill.Tensor_out(Tensor self, Tensor value, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<fill_Tensor_out::schema> create_fill_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fill_Tensor_out::name, fill_Tensor_out::overload_name)
      .typed<fill_Tensor_out::schema>();
}

// aten::fill.Tensor_out(Tensor self, Tensor value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fill_Tensor_out::call(const at::Tensor & self, const at::Tensor & value, at::Tensor & out) {
    
    static auto op = create_fill_Tensor_out_typed_handle();
    return op.call(self, value, out);
}

// aten::fill.Tensor_out(Tensor self, Tensor value, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & fill_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & value, at::Tensor & out) {
    
    static auto op = create_fill_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, value, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d_backward_out, name, "aten::grid_sampler_2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(grid_sampler_2d_backward_out, schema_str, "grid_sampler_2d_backward.out(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::grid_sampler_2d_backward.out(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<grid_sampler_2d_backward_out::schema> create_grid_sampler_2d_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(grid_sampler_2d_backward_out::name, grid_sampler_2d_backward_out::overload_name)
      .typed<grid_sampler_2d_backward_out::schema>();
}

// aten::grid_sampler_2d_backward.out(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> grid_sampler_2d_backward_out::call(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_grid_sampler_2d_backward_out_typed_handle();
    return op.call(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask, out0, out1);
}

// aten::grid_sampler_2d_backward.out(Tensor grad_output, Tensor input, Tensor grid, int interpolation_mode, int padding_mode, bool align_corners, bool[2] output_mask, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> grid_sampler_2d_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_grid_sampler_2d_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_index_put_impl_out, name, "aten::_index_put_impl")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_index_put_impl_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_index_put_impl_out, schema_str, "_index_put_impl.out(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_index_put_impl.out(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_index_put_impl_out::schema> create__index_put_impl_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_index_put_impl_out::name, _index_put_impl_out::overload_name)
      .typed<_index_put_impl_out::schema>();
}

// aten::_index_put_impl.out(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _index_put_impl_out::call(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe, at::Tensor & out) {
    
    static auto op = create__index_put_impl_out_typed_handle();
    return op.call(self, indices, values, accumulate, unsafe, out);
}

// aten::_index_put_impl.out(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _index_put_impl_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe, at::Tensor & out) {
    
    static auto op = create__index_put_impl_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, indices, values, accumulate, unsafe, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_index_put_impl, name, "aten::_index_put_impl")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_index_put_impl, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_index_put_impl, schema_str, "_index_put_impl(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False) -> Tensor")

// aten::_index_put_impl(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<_index_put_impl::schema> create__index_put_impl_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_index_put_impl::name, _index_put_impl::overload_name)
      .typed<_index_put_impl::schema>();
}

// aten::_index_put_impl(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False) -> Tensor
at::Tensor _index_put_impl::call(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
    
    static auto op = create__index_put_impl_typed_handle();
    return op.call(self, indices, values, accumulate, unsafe);
}

// aten::_index_put_impl(Tensor self, Tensor?[] indices, Tensor values, bool accumulate=False, bool unsafe=False) -> Tensor
at::Tensor _index_put_impl::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
    
    static auto op = create__index_put_impl_typed_handle();
    return op.redispatch(dispatchKeySet, self, indices, values, accumulate, unsafe);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear_out, name, "aten::mkldnn_linear")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear_out, schema_str, "mkldnn_linear.out(Tensor self, Tensor weight, Tensor? bias=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mkldnn_linear.out(Tensor self, Tensor weight, Tensor? bias=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_linear_out::schema> create_mkldnn_linear_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_linear_out::name, mkldnn_linear_out::overload_name)
      .typed<mkldnn_linear_out::schema>();
}

// aten::mkldnn_linear.out(Tensor self, Tensor weight, Tensor? bias=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_linear_out::call(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::Tensor & out) {
    
    static auto op = create_mkldnn_linear_out_typed_handle();
    return op.call(self, weight, bias, out);
}

// aten::mkldnn_linear.out(Tensor self, Tensor weight, Tensor? bias=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_linear_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::Tensor & out) {
    
    static auto op = create_mkldnn_linear_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, bias, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear_backward_weights_out, name, "aten::mkldnn_linear_backward_weights")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear_backward_weights_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_linear_backward_weights_out, schema_str, "mkldnn_linear_backward_weights.out(Tensor grad_output, Tensor input, Tensor weight, bool bias_defined, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::mkldnn_linear_backward_weights.out(Tensor grad_output, Tensor input, Tensor weight, bool bias_defined, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_linear_backward_weights_out::schema> create_mkldnn_linear_backward_weights_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_linear_backward_weights_out::name, mkldnn_linear_backward_weights_out::overload_name)
      .typed<mkldnn_linear_backward_weights_out::schema>();
}

// aten::mkldnn_linear_backward_weights.out(Tensor grad_output, Tensor input, Tensor weight, bool bias_defined, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> mkldnn_linear_backward_weights_out::call(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, bool bias_defined, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_mkldnn_linear_backward_weights_out_typed_handle();
    return op.call(grad_output, input, weight, bias_defined, out0, out1);
}

// aten::mkldnn_linear_backward_weights.out(Tensor grad_output, Tensor input, Tensor weight, bool bias_defined, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> mkldnn_linear_backward_weights_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, bool bias_defined, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_mkldnn_linear_backward_weights_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, input, weight, bias_defined, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax_out, name, "aten::_aminmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax_out, schema_str, "_aminmax.out(Tensor self, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::_aminmax.out(Tensor self, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<_aminmax_out::schema> create__aminmax_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_aminmax_out::name, _aminmax_out::overload_name)
      .typed<_aminmax_out::schema>();
}

// aten::_aminmax.out(Tensor self, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _aminmax_out::call(const at::Tensor & self, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__aminmax_out_typed_handle();
    return op.call(self, out0, out1);
}

// aten::_aminmax.out(Tensor self, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _aminmax_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__aminmax_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax_dim_out, name, "aten::_aminmax")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax_dim_out, overload_name, "dim_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_aminmax_dim_out, schema_str, "_aminmax.dim_out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::_aminmax.dim_out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<_aminmax_dim_out::schema> create__aminmax_dim_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_aminmax_dim_out::name, _aminmax_dim_out::overload_name)
      .typed<_aminmax_dim_out::schema>();
}

// aten::_aminmax.dim_out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _aminmax_dim_out::call(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__aminmax_dim_out_typed_handle();
    return op.call(self, dim, keepdim, out0, out1);
}

// aten::_aminmax.dim_out(Tensor self, int dim, bool keepdim=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _aminmax_dim_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__aminmax_dim_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, keepdim, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool3d_backward_out, name, "aten::mkldnn_max_pool3d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool3d_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_max_pool3d_backward_out, schema_str, "mkldnn_max_pool3d_backward.out(Tensor grad_output, Tensor output, Tensor input, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mkldnn_max_pool3d_backward.out(Tensor grad_output, Tensor output, Tensor input, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_max_pool3d_backward_out::schema> create_mkldnn_max_pool3d_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_max_pool3d_backward_out::name, mkldnn_max_pool3d_backward_out::overload_name)
      .typed<mkldnn_max_pool3d_backward_out::schema>();
}

// aten::mkldnn_max_pool3d_backward.out(Tensor grad_output, Tensor output, Tensor input, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_max_pool3d_backward_out::call(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
    
    static auto op = create_mkldnn_max_pool3d_backward_out_typed_handle();
    return op.call(grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode, out);
}

// aten::mkldnn_max_pool3d_backward.out(Tensor grad_output, Tensor output, Tensor input, int[3] kernel_size, int[3] stride=[], int[3] padding=0, int[3] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_max_pool3d_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
    
    static auto op = create_mkldnn_max_pool3d_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_max_pool1d_out, name, "aten::quantized_max_pool1d")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_max_pool1d_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(quantized_max_pool1d_out, schema_str, "quantized_max_pool1d.out(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::quantized_max_pool1d.out(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<quantized_max_pool1d_out::schema> create_quantized_max_pool1d_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(quantized_max_pool1d_out::name, quantized_max_pool1d_out::overload_name)
      .typed<quantized_max_pool1d_out::schema>();
}

// aten::quantized_max_pool1d.out(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & quantized_max_pool1d_out::call(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
    
    static auto op = create_quantized_max_pool1d_out_typed_handle();
    return op.call(self, kernel_size, stride, padding, dilation, ceil_mode, out);
}

// aten::quantized_max_pool1d.out(Tensor self, int[1] kernel_size, int[1] stride=[], int[1] padding=0, int[1] dilation=1, bool ceil_mode=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & quantized_max_pool1d_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
    
    static auto op = create_quantized_max_pool1d_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, kernel_size, stride, padding, dilation, ceil_mode, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_convolution_out, name, "aten::mkldnn_convolution")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_convolution_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_convolution_out, schema_str, "mkldnn_convolution.out(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] stride, SymInt[] dilation, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mkldnn_convolution.out(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] stride, SymInt[] dilation, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_convolution_out::schema> create_mkldnn_convolution_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_convolution_out::name, mkldnn_convolution_out::overload_name)
      .typed<mkldnn_convolution_out::schema>();
}

// aten::mkldnn_convolution.out(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] stride, SymInt[] dilation, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_convolution_out::call(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_mkldnn_convolution_out_typed_handle();
    return op.call(self, weight, bias, padding, stride, dilation, groups, out);
}

// aten::mkldnn_convolution.out(Tensor self, Tensor weight, Tensor? bias, SymInt[] padding, SymInt[] stride, SymInt[] dilation, SymInt groups, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_convolution_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
    
    static auto op = create_mkldnn_convolution_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, weight, bias, padding, stride, dilation, groups, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm_backward_out, name, "aten::miopen_batch_norm_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(miopen_batch_norm_backward_out, schema_str, "miopen_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))")

// aten::miopen_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
static C10_NOINLINE c10::TypedOperatorHandle<miopen_batch_norm_backward_out::schema> create_miopen_batch_norm_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(miopen_batch_norm_backward_out::name, miopen_batch_norm_backward_out::overload_name)
      .typed<miopen_batch_norm_backward_out::schema>();
}

// aten::miopen_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> miopen_batch_norm_backward_out::call(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_miopen_batch_norm_backward_out_typed_handle();
    return op.call(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, out0, out1, out2);
}

// aten::miopen_batch_norm_backward.out(Tensor input, Tensor grad_output, Tensor weight, Tensor? running_mean, Tensor? running_var, Tensor? save_mean, Tensor? save_var, float epsilon, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> miopen_batch_norm_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create_miopen_batch_norm_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, out0, out1, out2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_Scalar_out, name, "aten::mul")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mul_Scalar_out, schema_str, "mul.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mul.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mul_Scalar_out::schema> create_mul_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mul_Scalar_out::name, mul_Scalar_out::overload_name)
      .typed<mul_Scalar_out::schema>();
}

// aten::mul.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mul_Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_mul_Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::mul.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mul_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create_mul_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_backward_elemt_out, name, "aten::batch_norm_backward_elemt")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_backward_elemt_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(batch_norm_backward_elemt_out, schema_str, "batch_norm_backward_elemt.out(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, Tensor? weight, Tensor sum_dy, Tensor sum_dy_xmu, Tensor count, *, Tensor(a!) out) -> Tensor(a!)")

// aten::batch_norm_backward_elemt.out(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, Tensor? weight, Tensor sum_dy, Tensor sum_dy_xmu, Tensor count, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<batch_norm_backward_elemt_out::schema> create_batch_norm_backward_elemt_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(batch_norm_backward_elemt_out::name, batch_norm_backward_elemt_out::overload_name)
      .typed<batch_norm_backward_elemt_out::schema>();
}

// aten::batch_norm_backward_elemt.out(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, Tensor? weight, Tensor sum_dy, Tensor sum_dy_xmu, Tensor count, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & batch_norm_backward_elemt_out::call(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, const at::Tensor & sum_dy, const at::Tensor & sum_dy_xmu, const at::Tensor & count, at::Tensor & out) {
    
    static auto op = create_batch_norm_backward_elemt_out_typed_handle();
    return op.call(grad_out, input, mean, invstd, weight, sum_dy, sum_dy_xmu, count, out);
}

// aten::batch_norm_backward_elemt.out(Tensor grad_out, Tensor input, Tensor mean, Tensor invstd, Tensor? weight, Tensor sum_dy, Tensor sum_dy_xmu, Tensor count, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & batch_norm_backward_elemt_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, const at::Tensor & sum_dy, const at::Tensor & sum_dy_xmu, const at::Tensor & count, at::Tensor & out) {
    
    static auto op = create_batch_norm_backward_elemt_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_out, input, mean, invstd, weight, sum_dy, sum_dy_xmu, count, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pixel_unshuffle_out, name, "aten::pixel_unshuffle")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pixel_unshuffle_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(pixel_unshuffle_out, schema_str, "pixel_unshuffle.out(Tensor self, int downscale_factor, *, Tensor(a!) out) -> Tensor(a!)")

// aten::pixel_unshuffle.out(Tensor self, int downscale_factor, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<pixel_unshuffle_out::schema> create_pixel_unshuffle_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(pixel_unshuffle_out::name, pixel_unshuffle_out::overload_name)
      .typed<pixel_unshuffle_out::schema>();
}

// aten::pixel_unshuffle.out(Tensor self, int downscale_factor, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & pixel_unshuffle_out::call(const at::Tensor & self, int64_t downscale_factor, at::Tensor & out) {
    
    static auto op = create_pixel_unshuffle_out_typed_handle();
    return op.call(self, downscale_factor, out);
}

// aten::pixel_unshuffle.out(Tensor self, int downscale_factor, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & pixel_unshuffle_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t downscale_factor, at::Tensor & out) {
    
    static auto op = create_pixel_unshuffle_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, downscale_factor, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pin_memory_out, name, "aten::_pin_memory")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pin_memory_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_pin_memory_out, schema_str, "_pin_memory.out(Tensor self, Device? device=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_pin_memory.out(Tensor self, Device? device=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_pin_memory_out::schema> create__pin_memory_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_pin_memory_out::name, _pin_memory_out::overload_name)
      .typed<_pin_memory_out::schema>();
}

// aten::_pin_memory.out(Tensor self, Device? device=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _pin_memory_out::call(const at::Tensor & self, c10::optional<at::Device> device, at::Tensor & out) {
    
    static auto op = create__pin_memory_out_typed_handle();
    return op.call(self, device, out);
}

// aten::_pin_memory.out(Tensor self, Device? device=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _pin_memory_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Device> device, at::Tensor & out) {
    
    static auto op = create__pin_memory_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, device, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_names_out, name, "aten::randn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_names_out, overload_name, "names_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_names_out, schema_str, "randn.names_out(SymInt[] size, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)")

// aten::randn.names_out(SymInt[] size, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<randn_names_out::schema> create_randn_names_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randn_names_out::name, randn_names_out::overload_name)
      .typed<randn_names_out::schema>();
}

// aten::randn.names_out(SymInt[] size, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randn_names_out::call(c10::SymIntArrayRef size, c10::optional<at::DimnameList> names, at::Tensor & out) {
    
    static auto op = create_randn_names_out_typed_handle();
    return op.call(size, names, out);
}

// aten::randn.names_out(SymInt[] size, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randn_names_out::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, c10::optional<at::DimnameList> names, at::Tensor & out) {
    
    static auto op = create_randn_names_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, names, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator_with_names_out, name, "aten::randn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator_with_names_out, overload_name, "generator_with_names_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(randn_generator_with_names_out, schema_str, "randn.generator_with_names_out(SymInt[] size, *, Generator? generator, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)")

// aten::randn.generator_with_names_out(SymInt[] size, *, Generator? generator, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<randn_generator_with_names_out::schema> create_randn_generator_with_names_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(randn_generator_with_names_out::name, randn_generator_with_names_out::overload_name)
      .typed<randn_generator_with_names_out::schema>();
}

// aten::randn.generator_with_names_out(SymInt[] size, *, Generator? generator, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randn_generator_with_names_out::call(c10::SymIntArrayRef size, c10::optional<at::Generator> generator, c10::optional<at::DimnameList> names, at::Tensor & out) {
    
    static auto op = create_randn_generator_with_names_out_typed_handle();
    return op.call(size, generator, names, out);
}

// aten::randn.generator_with_names_out(SymInt[] size, *, Generator? generator, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
at::Tensor & randn_generator_with_names_out::redispatch(c10::DispatchKeySet dispatchKeySet, c10::SymIntArrayRef size, c10::optional<at::Generator> generator, c10::optional<at::DimnameList> names, at::Tensor & out) {
    
    static auto op = create_randn_generator_with_names_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, generator, names, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_scatter_out, name, "aten::diagonal_scatter")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_scatter_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(diagonal_scatter_out, schema_str, "diagonal_scatter.out(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)")

// aten::diagonal_scatter.out(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<diagonal_scatter_out::schema> create_diagonal_scatter_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(diagonal_scatter_out::name, diagonal_scatter_out::overload_name)
      .typed<diagonal_scatter_out::schema>();
}

// aten::diagonal_scatter.out(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & diagonal_scatter_out::call(const at::Tensor & self, const at::Tensor & src, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
    
    static auto op = create_diagonal_scatter_out_typed_handle();
    return op.call(self, src, offset, dim1, dim2, out);
}

// aten::diagonal_scatter.out(Tensor self, Tensor src, int offset=0, int dim1=0, int dim2=1, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & diagonal_scatter_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & src, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
    
    static auto op = create_diagonal_scatter_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, offset, dim1, dim2, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided_scatter_out, name, "aten::as_strided_scatter")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided_scatter_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(as_strided_scatter_out, schema_str, "as_strided_scatter.out(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::as_strided_scatter.out(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<as_strided_scatter_out::schema> create_as_strided_scatter_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(as_strided_scatter_out::name, as_strided_scatter_out::overload_name)
      .typed<as_strided_scatter_out::schema>();
}

// aten::as_strided_scatter.out(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & as_strided_scatter_out::call(const at::Tensor & self, const at::Tensor & src, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset, at::Tensor & out) {
    
    static auto op = create_as_strided_scatter_out_typed_handle();
    return op.call(self, src, size, stride, storage_offset, out);
}

// aten::as_strided_scatter.out(Tensor self, Tensor src, SymInt[] size, SymInt[] stride, SymInt? storage_offset=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & as_strided_scatter_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & src, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset, at::Tensor & out) {
    
    static auto op = create_as_strided_scatter_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, size, stride, storage_offset, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_transform_bias_rescale_qkv_out, name, "aten::_transform_bias_rescale_qkv")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_transform_bias_rescale_qkv_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_transform_bias_rescale_qkv_out, schema_str, "_transform_bias_rescale_qkv.out(Tensor qkv, Tensor qkv_bias, int num_heads, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))")

// aten::_transform_bias_rescale_qkv.out(Tensor qkv, Tensor qkv_bias, int num_heads, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
static C10_NOINLINE c10::TypedOperatorHandle<_transform_bias_rescale_qkv_out::schema> create__transform_bias_rescale_qkv_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_transform_bias_rescale_qkv_out::name, _transform_bias_rescale_qkv_out::overload_name)
      .typed<_transform_bias_rescale_qkv_out::schema>();
}

// aten::_transform_bias_rescale_qkv.out(Tensor qkv, Tensor qkv_bias, int num_heads, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _transform_bias_rescale_qkv_out::call(const at::Tensor & qkv, const at::Tensor & qkv_bias, int64_t num_heads, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create__transform_bias_rescale_qkv_out_typed_handle();
    return op.call(qkv, qkv_bias, num_heads, out0, out1, out2);
}

// aten::_transform_bias_rescale_qkv.out(Tensor qkv, Tensor qkv_bias, int num_heads, *, Tensor(a!) out0, Tensor(b!) out1, Tensor(c!) out2) -> (Tensor(a!), Tensor(b!), Tensor(c!))
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _transform_bias_rescale_qkv_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & qkv, const at::Tensor & qkv_bias, int64_t num_heads, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
    
    static auto op = create__transform_bias_rescale_qkv_out_typed_handle();
    return op.redispatch(dispatchKeySet, qkv, qkv_bias, num_heads, out0, out1, out2);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unique_out, name, "aten::_unique")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unique_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_unique_out, schema_str, "_unique.out(Tensor self, bool sorted=True, bool return_inverse=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::_unique.out(Tensor self, bool sorted=True, bool return_inverse=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<_unique_out::schema> create__unique_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_unique_out::name, _unique_out::overload_name)
      .typed<_unique_out::schema>();
}

// aten::_unique.out(Tensor self, bool sorted=True, bool return_inverse=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _unique_out::call(const at::Tensor & self, bool sorted, bool return_inverse, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__unique_out_typed_handle();
    return op.call(self, sorted, return_inverse, out0, out1);
}

// aten::_unique.out(Tensor self, bool sorted=True, bool return_inverse=False, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _unique_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool sorted, bool return_inverse, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__unique_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, sorted, return_inverse, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm_interface_out, name, "aten::_weight_norm_interface")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm_interface_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_weight_norm_interface_out, schema_str, "_weight_norm_interface.out(Tensor v, Tensor g, int dim=0, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::_weight_norm_interface.out(Tensor v, Tensor g, int dim=0, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<_weight_norm_interface_out::schema> create__weight_norm_interface_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_weight_norm_interface_out::name, _weight_norm_interface_out::overload_name)
      .typed<_weight_norm_interface_out::schema>();
}

// aten::_weight_norm_interface.out(Tensor v, Tensor g, int dim=0, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _weight_norm_interface_out::call(const at::Tensor & v, const at::Tensor & g, int64_t dim, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__weight_norm_interface_out_typed_handle();
    return op.call(v, g, dim, out0, out1);
}

// aten::_weight_norm_interface.out(Tensor v, Tensor g, int dim=0, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> _weight_norm_interface_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & v, const at::Tensor & g, int64_t dim, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__weight_norm_interface_out_typed_handle();
    return op.redispatch(dispatchKeySet, v, g, dim, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros_names_out, name, "aten::zeros")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros_names_out, overload_name, "names_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(zeros_names_out, schema_str, "zeros.names_out(int[] size, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)")

// aten::zeros.names_out(int[] size, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<zeros_names_out::schema> create_zeros_names_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(zeros_names_out::name, zeros_names_out::overload_name)
      .typed<zeros_names_out::schema>();
}

// aten::zeros.names_out(int[] size, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
at::Tensor & zeros_names_out::call(at::IntArrayRef size, c10::optional<at::DimnameList> names, at::Tensor & out) {
    
    static auto op = create_zeros_names_out_typed_handle();
    return op.call(size, names, out);
}

// aten::zeros.names_out(int[] size, *, Dimname[]? names, Tensor(a!) out) -> Tensor(a!)
at::Tensor & zeros_names_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::IntArrayRef size, c10::optional<at::DimnameList> names, at::Tensor & out) {
    
    static auto op = create_zeros_names_out_typed_handle();
    return op.redispatch(dispatchKeySet, size, names, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_standard_gamma_out, name, "aten::_standard_gamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_standard_gamma_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_standard_gamma_out, schema_str, "_standard_gamma.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_standard_gamma.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_standard_gamma_out::schema> create__standard_gamma_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_standard_gamma_out::name, _standard_gamma_out::overload_name)
      .typed<_standard_gamma_out::schema>();
}

// aten::_standard_gamma.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _standard_gamma_out::call(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create__standard_gamma_out_typed_handle();
    return op.call(self, generator, out);
}

// aten::_standard_gamma.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _standard_gamma_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create__standard_gamma_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, generator, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sample_dirichlet_out, name, "aten::_sample_dirichlet")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sample_dirichlet_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sample_dirichlet_out, schema_str, "_sample_dirichlet.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_sample_dirichlet.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_sample_dirichlet_out::schema> create__sample_dirichlet_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sample_dirichlet_out::name, _sample_dirichlet_out::overload_name)
      .typed<_sample_dirichlet_out::schema>();
}

// aten::_sample_dirichlet.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _sample_dirichlet_out::call(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create__sample_dirichlet_out_typed_handle();
    return op.call(self, generator, out);
}

// aten::_sample_dirichlet.out(Tensor self, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _sample_dirichlet_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create__sample_dirichlet_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, generator, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(binomial_out, name, "aten::binomial")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(binomial_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(binomial_out, schema_str, "binomial.out(Tensor count, Tensor prob, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::binomial.out(Tensor count, Tensor prob, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<binomial_out::schema> create_binomial_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(binomial_out::name, binomial_out::overload_name)
      .typed<binomial_out::schema>();
}

// aten::binomial.out(Tensor count, Tensor prob, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & binomial_out::call(const at::Tensor & count, const at::Tensor & prob, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_binomial_out_typed_handle();
    return op.call(count, prob, generator, out);
}

// aten::binomial.out(Tensor count, Tensor prob, Generator? generator=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & binomial_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & count, const at::Tensor & prob, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_binomial_out_typed_handle();
    return op.redispatch(dispatchKeySet, count, prob, generator, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dim_out, name, "aten::_sparse_sum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dim_out, overload_name, "dim_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_sum_dim_out, schema_str, "_sparse_sum.dim_out(Tensor self, int[1] dim, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_sparse_sum.dim_out(Tensor self, int[1] dim, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_sum_dim_out::schema> create__sparse_sum_dim_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_sum_dim_out::name, _sparse_sum_dim_out::overload_name)
      .typed<_sparse_sum_dim_out::schema>();
}

// aten::_sparse_sum.dim_out(Tensor self, int[1] dim, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _sparse_sum_dim_out::call(const at::Tensor & self, at::IntArrayRef dim, at::Tensor & out) {
    
    static auto op = create__sparse_sum_dim_out_typed_handle();
    return op.call(self, dim, out);
}

// aten::_sparse_sum.dim_out(Tensor self, int[1] dim, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _sparse_sum_dim_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef dim, at::Tensor & out) {
    
    static auto op = create__sparse_sum_dim_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_addmm_out, name, "aten::_sparse_addmm")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_addmm_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_sparse_addmm_out, schema_str, "_sparse_addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)")

// aten::_sparse_addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_sparse_addmm_out::schema> create__sparse_addmm_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_sparse_addmm_out::name, _sparse_addmm_out::overload_name)
      .typed<_sparse_addmm_out::schema>();
}

// aten::_sparse_addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _sparse_addmm_out::call(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create__sparse_addmm_out_typed_handle();
    return op.call(self, mat1, mat2, beta, alpha, out);
}

// aten::_sparse_addmm.out(Tensor self, Tensor mat1, Tensor mat2, *, Scalar beta=1, Scalar alpha=1, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _sparse_addmm_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
    
    static auto op = create__sparse_addmm_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, mat1, mat2, beta, alpha, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_out, name, "aten::sparse_resize")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize_out, schema_str, "sparse_resize.out(Tensor self, int[] size, int sparse_dim, int dense_dim, *, Tensor(a!) out) -> Tensor(a!)")

// aten::sparse_resize.out(Tensor self, int[] size, int sparse_dim, int dense_dim, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sparse_resize_out::schema> create_sparse_resize_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_resize_out::name, sparse_resize_out::overload_name)
      .typed<sparse_resize_out::schema>();
}

// aten::sparse_resize.out(Tensor self, int[] size, int sparse_dim, int dense_dim, *, Tensor(a!) out) -> Tensor(a!)
const at::Tensor & sparse_resize_out::call(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim, const at::Tensor & out) {
    
    static auto op = create_sparse_resize_out_typed_handle();
    return op.call(self, size, sparse_dim, dense_dim, out);
}

// aten::sparse_resize.out(Tensor self, int[] size, int sparse_dim, int dense_dim, *, Tensor(a!) out) -> Tensor(a!)
const at::Tensor & sparse_resize_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim, const at::Tensor & out) {
    
    static auto op = create_sparse_resize_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, sparse_dim, dense_dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize, name, "aten::sparse_resize")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_resize, schema_str, "sparse_resize(Tensor self, int[] size, int sparse_dim, int dense_dim) -> Tensor")

// aten::sparse_resize(Tensor self, int[] size, int sparse_dim, int dense_dim) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<sparse_resize::schema> create_sparse_resize_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_resize::name, sparse_resize::overload_name)
      .typed<sparse_resize::schema>();
}

// aten::sparse_resize(Tensor self, int[] size, int sparse_dim, int dense_dim) -> Tensor
at::Tensor sparse_resize::call(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
    
    static auto op = create_sparse_resize_typed_handle();
    return op.call(self, size, sparse_dim, dense_dim);
}

// aten::sparse_resize(Tensor self, int[] size, int sparse_dim, int dense_dim) -> Tensor
at::Tensor sparse_resize::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
    
    static auto op = create_sparse_resize_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, sparse_dim, dense_dim);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_mask_out, name, "aten::sparse_mask")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_mask_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(sparse_mask_out, schema_str, "sparse_mask.out(Tensor self, Tensor mask, *, Tensor(a!) out) -> Tensor(a!)")

// aten::sparse_mask.out(Tensor self, Tensor mask, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<sparse_mask_out::schema> create_sparse_mask_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(sparse_mask_out::name, sparse_mask_out::overload_name)
      .typed<sparse_mask_out::schema>();
}

// aten::sparse_mask.out(Tensor self, Tensor mask, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sparse_mask_out::call(const at::Tensor & self, const at::Tensor & mask, at::Tensor & out) {
    
    static auto op = create_sparse_mask_out_typed_handle();
    return op.call(self, mask, out);
}

// aten::sparse_mask.out(Tensor self, Tensor mask, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & sparse_mask_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & mask, at::Tensor & out) {
    
    static auto op = create_sparse_mask_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, mask, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copy_sparse_to_sparse_out, name, "aten::copy_sparse_to_sparse")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copy_sparse_to_sparse_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copy_sparse_to_sparse_out, schema_str, "copy_sparse_to_sparse.out(Tensor self, Tensor src, bool non_blocking=False, *, Tensor(a!) out) -> Tensor(a!)")

// aten::copy_sparse_to_sparse.out(Tensor self, Tensor src, bool non_blocking=False, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<copy_sparse_to_sparse_out::schema> create_copy_sparse_to_sparse_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(copy_sparse_to_sparse_out::name, copy_sparse_to_sparse_out::overload_name)
      .typed<copy_sparse_to_sparse_out::schema>();
}

// aten::copy_sparse_to_sparse.out(Tensor self, Tensor src, bool non_blocking=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & copy_sparse_to_sparse_out::call(const at::Tensor & self, const at::Tensor & src, bool non_blocking, at::Tensor & out) {
    
    static auto op = create_copy_sparse_to_sparse_out_typed_handle();
    return op.call(self, src, non_blocking, out);
}

// aten::copy_sparse_to_sparse.out(Tensor self, Tensor src, bool non_blocking=False, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & copy_sparse_to_sparse_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & src, bool non_blocking, at::Tensor & out) {
    
    static auto op = create_copy_sparse_to_sparse_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, non_blocking, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copy_sparse_to_sparse, name, "aten::copy_sparse_to_sparse")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copy_sparse_to_sparse, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(copy_sparse_to_sparse, schema_str, "copy_sparse_to_sparse(Tensor self, Tensor src, bool non_blocking=False) -> Tensor")

// aten::copy_sparse_to_sparse(Tensor self, Tensor src, bool non_blocking=False) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<copy_sparse_to_sparse::schema> create_copy_sparse_to_sparse_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(copy_sparse_to_sparse::name, copy_sparse_to_sparse::overload_name)
      .typed<copy_sparse_to_sparse::schema>();
}

// aten::copy_sparse_to_sparse(Tensor self, Tensor src, bool non_blocking=False) -> Tensor
at::Tensor copy_sparse_to_sparse::call(const at::Tensor & self, const at::Tensor & src, bool non_blocking) {
    
    static auto op = create_copy_sparse_to_sparse_typed_handle();
    return op.call(self, src, non_blocking);
}

// aten::copy_sparse_to_sparse(Tensor self, Tensor src, bool non_blocking=False) -> Tensor
at::Tensor copy_sparse_to_sparse::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & src, bool non_blocking) {
    
    static auto op = create_copy_sparse_to_sparse_typed_handle();
    return op.redispatch(dispatchKeySet, self, src, non_blocking);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_mkldnn_out, name, "aten::to_mkldnn")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_mkldnn_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_mkldnn_out, schema_str, "to_mkldnn.out(Tensor self, ScalarType? dtype=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::to_mkldnn.out(Tensor self, ScalarType? dtype=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<to_mkldnn_out::schema> create_to_mkldnn_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_mkldnn_out::name, to_mkldnn_out::overload_name)
      .typed<to_mkldnn_out::schema>();
}

// aten::to_mkldnn.out(Tensor self, ScalarType? dtype=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & to_mkldnn_out::call(const at::Tensor & self, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_to_mkldnn_out_typed_handle();
    return op.call(self, dtype, out);
}

// aten::to_mkldnn.out(Tensor self, ScalarType? dtype=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & to_mkldnn_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    
    static auto op = create_to_mkldnn_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dtype, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(int_repr_out, name, "aten::int_repr")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(int_repr_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(int_repr_out, schema_str, "int_repr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::int_repr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<int_repr_out::schema> create_int_repr_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(int_repr_out::name, int_repr_out::overload_name)
      .typed<int_repr_out::schema>();
}

// aten::int_repr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & int_repr_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_int_repr_out_typed_handle();
    return op.call(self, out);
}

// aten::int_repr.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & int_repr_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_int_repr_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine_cachemask_out, name, "aten::fake_quantize_per_channel_affine_cachemask")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine_cachemask_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(fake_quantize_per_channel_affine_cachemask_out, schema_str, "fake_quantize_per_channel_affine_cachemask.out(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))")

// aten::fake_quantize_per_channel_affine_cachemask.out(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
static C10_NOINLINE c10::TypedOperatorHandle<fake_quantize_per_channel_affine_cachemask_out::schema> create_fake_quantize_per_channel_affine_cachemask_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(fake_quantize_per_channel_affine_cachemask_out::name, fake_quantize_per_channel_affine_cachemask_out::overload_name)
      .typed<fake_quantize_per_channel_affine_cachemask_out::schema>();
}

// aten::fake_quantize_per_channel_affine_cachemask.out(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> fake_quantize_per_channel_affine_cachemask_out::call(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_fake_quantize_per_channel_affine_cachemask_out_typed_handle();
    return op.call(self, scale, zero_point, axis, quant_min, quant_max, out0, out1);
}

// aten::fake_quantize_per_channel_affine_cachemask.out(Tensor self, Tensor scale, Tensor zero_point, int axis, int quant_min, int quant_max, *, Tensor(a!) out0, Tensor(b!) out1) -> (Tensor(a!), Tensor(b!))
::std::tuple<at::Tensor &,at::Tensor &> fake_quantize_per_channel_affine_cachemask_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create_fake_quantize_per_channel_affine_cachemask_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scale, zero_point, axis, quant_min, quant_max, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_moving_avg_obs_fq_helper_out, name, "aten::_fused_moving_avg_obs_fq_helper")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_moving_avg_obs_fq_helper_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_moving_avg_obs_fq_helper_out, schema_str, "_fused_moving_avg_obs_fq_helper.out(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor(a!) running_min, Tensor(b!) running_max, Tensor(c!) scale, Tensor(d!) zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False, *, Tensor(e!) out0, Tensor(f!) out1) -> (Tensor(e!), Tensor(f!))")

// aten::_fused_moving_avg_obs_fq_helper.out(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor(a!) running_min, Tensor(b!) running_max, Tensor(c!) scale, Tensor(d!) zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False, *, Tensor(e!) out0, Tensor(f!) out1) -> (Tensor(e!), Tensor(f!))
static C10_NOINLINE c10::TypedOperatorHandle<_fused_moving_avg_obs_fq_helper_out::schema> create__fused_moving_avg_obs_fq_helper_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_fused_moving_avg_obs_fq_helper_out::name, _fused_moving_avg_obs_fq_helper_out::overload_name)
      .typed<_fused_moving_avg_obs_fq_helper_out::schema>();
}

// aten::_fused_moving_avg_obs_fq_helper.out(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor(a!) running_min, Tensor(b!) running_max, Tensor(c!) scale, Tensor(d!) zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False, *, Tensor(e!) out0, Tensor(f!) out1) -> (Tensor(e!), Tensor(f!))
::std::tuple<at::Tensor &,at::Tensor &> _fused_moving_avg_obs_fq_helper_out::call(const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, at::Tensor & running_min, at::Tensor & running_max, at::Tensor & scale, at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__fused_moving_avg_obs_fq_helper_out_typed_handle();
    return op.call(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant, out0, out1);
}

// aten::_fused_moving_avg_obs_fq_helper.out(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor(a!) running_min, Tensor(b!) running_max, Tensor(c!) scale, Tensor(d!) zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False, *, Tensor(e!) out0, Tensor(f!) out1) -> (Tensor(e!), Tensor(f!))
::std::tuple<at::Tensor &,at::Tensor &> _fused_moving_avg_obs_fq_helper_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, at::Tensor & running_min, at::Tensor & running_max, at::Tensor & scale, at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant, at::Tensor & out0, at::Tensor & out1) {
    
    static auto op = create__fused_moving_avg_obs_fq_helper_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant, out0, out1);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_moving_avg_obs_fq_helper_functional, name, "aten::_fused_moving_avg_obs_fq_helper_functional")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_moving_avg_obs_fq_helper_functional, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_fused_moving_avg_obs_fq_helper_functional, schema_str, "_fused_moving_avg_obs_fq_helper_functional(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor running_min, Tensor running_max, Tensor scale, Tensor zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False) -> (Tensor output, Tensor mask, Tensor running_min_out, Tensor running_max_out, Tensor scale_out, Tensor zero_point_out)")

// aten::_fused_moving_avg_obs_fq_helper_functional(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor running_min, Tensor running_max, Tensor scale, Tensor zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False) -> (Tensor output, Tensor mask, Tensor running_min_out, Tensor running_max_out, Tensor scale_out, Tensor zero_point_out)
static C10_NOINLINE c10::TypedOperatorHandle<_fused_moving_avg_obs_fq_helper_functional::schema> create__fused_moving_avg_obs_fq_helper_functional_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_fused_moving_avg_obs_fq_helper_functional::name, _fused_moving_avg_obs_fq_helper_functional::overload_name)
      .typed<_fused_moving_avg_obs_fq_helper_functional::schema>();
}

// aten::_fused_moving_avg_obs_fq_helper_functional(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor running_min, Tensor running_max, Tensor scale, Tensor zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False) -> (Tensor output, Tensor mask, Tensor running_min_out, Tensor running_max_out, Tensor scale_out, Tensor zero_point_out)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _fused_moving_avg_obs_fq_helper_functional::call(const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, const at::Tensor & running_min, const at::Tensor & running_max, const at::Tensor & scale, const at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant) {
    
    static auto op = create__fused_moving_avg_obs_fq_helper_functional_typed_handle();
    return op.call(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
}

// aten::_fused_moving_avg_obs_fq_helper_functional(Tensor self, Tensor observer_on, Tensor fake_quant_on, Tensor running_min, Tensor running_max, Tensor scale, Tensor zero_point, float averaging_const, int quant_min, int quant_max, int ch_axis, bool per_row_fake_quant=False, bool symmetric_quant=False) -> (Tensor output, Tensor mask, Tensor running_min_out, Tensor running_max_out, Tensor scale_out, Tensor zero_point_out)
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _fused_moving_avg_obs_fq_helper_functional::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, const at::Tensor & running_min, const at::Tensor & running_max, const at::Tensor & scale, const at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant) {
    
    static auto op = create__fused_moving_avg_obs_fq_helper_functional_typed_handle();
    return op.redispatch(dispatchKeySet, self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_copy_out, name, "aten::_to_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_to_copy_out, schema_str, "_to_copy.out(Tensor self, *, bool non_blocking=False, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)")

// aten::_to_copy.out(Tensor self, *, bool non_blocking=False, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_to_copy_out::schema> create__to_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_to_copy_out::name, _to_copy_out::overload_name)
      .typed<_to_copy_out::schema>();
}

// aten::_to_copy.out(Tensor self, *, bool non_blocking=False, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _to_copy_out::call(const at::Tensor & self, bool non_blocking, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
    
    static auto op = create__to_copy_out_typed_handle();
    return op.call(self, non_blocking, memory_format, out);
}

// aten::_to_copy.out(Tensor self, *, bool non_blocking=False, MemoryFormat? memory_format=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _to_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, bool non_blocking, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
    
    static auto op = create__to_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, non_blocking, memory_format, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lift_out, name, "aten::lift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lift_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(lift_out, schema_str, "lift.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::lift.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<lift_out::schema> create_lift_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(lift_out::name, lift_out::overload_name)
      .typed<lift_out::schema>();
}

// aten::lift.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & lift_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_lift_out_typed_handle();
    return op.call(self, out);
}

// aten::lift.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & lift_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_lift_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar_Tensor_out, name, "aten::bitwise_and")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar_Tensor_out, overload_name, "Scalar_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_and_Scalar_Tensor_out, schema_str, "bitwise_and.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_and.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_and_Scalar_Tensor_out::schema> create_bitwise_and_Scalar_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_and_Scalar_Tensor_out::name, bitwise_and_Scalar_Tensor_out::overload_name)
      .typed<bitwise_and_Scalar_Tensor_out::schema>();
}

// aten::bitwise_and.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_and_Scalar_Tensor_out::call(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_and_Scalar_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_and.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_and_Scalar_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_and_Scalar_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar_Tensor_out, name, "aten::bitwise_xor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar_Tensor_out, overload_name, "Scalar_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_xor_Scalar_Tensor_out, schema_str, "bitwise_xor.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_xor.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_xor_Scalar_Tensor_out::schema> create_bitwise_xor_Scalar_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_xor_Scalar_Tensor_out::name, bitwise_xor_Scalar_Tensor_out::overload_name)
      .typed<bitwise_xor_Scalar_Tensor_out::schema>();
}

// aten::bitwise_xor.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_xor_Scalar_Tensor_out::call(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_xor_Scalar_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_xor.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_xor_Scalar_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_xor_Scalar_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Scalar_out, name, "aten::__lshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Scalar_out, schema_str, "__lshift__.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::__lshift__.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__lshift___Scalar_out::schema> create___lshift___Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__lshift___Scalar_out::name, __lshift___Scalar_out::overload_name)
      .typed<__lshift___Scalar_out::schema>();
}

// aten::__lshift__.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & __lshift___Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create___lshift___Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::__lshift__.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & __lshift___Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create___lshift___Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Tensor_out, name, "aten::__lshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__lshift___Tensor_out, schema_str, "__lshift__.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::__lshift__.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__lshift___Tensor_out::schema> create___lshift___Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__lshift___Tensor_out::name, __lshift___Tensor_out::overload_name)
      .typed<__lshift___Tensor_out::schema>();
}

// aten::__lshift__.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & __lshift___Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create___lshift___Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::__lshift__.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & __lshift___Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create___lshift___Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Scalar_Tensor_out, name, "aten::bitwise_left_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Scalar_Tensor_out, overload_name, "Scalar_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_left_shift_Scalar_Tensor_out, schema_str, "bitwise_left_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_left_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_left_shift_Scalar_Tensor_out::schema> create_bitwise_left_shift_Scalar_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_left_shift_Scalar_Tensor_out::name, bitwise_left_shift_Scalar_Tensor_out::overload_name)
      .typed<bitwise_left_shift_Scalar_Tensor_out::schema>();
}

// aten::bitwise_left_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_left_shift_Scalar_Tensor_out::call(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_left_shift_Scalar_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_left_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_left_shift_Scalar_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_left_shift_Scalar_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Scalar_out, name, "aten::__rshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Scalar_out, schema_str, "__rshift__.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::__rshift__.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__rshift___Scalar_out::schema> create___rshift___Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__rshift___Scalar_out::name, __rshift___Scalar_out::overload_name)
      .typed<__rshift___Scalar_out::schema>();
}

// aten::__rshift__.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & __rshift___Scalar_out::call(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create___rshift___Scalar_out_typed_handle();
    return op.call(self, other, out);
}

// aten::__rshift__.Scalar_out(Tensor self, Scalar other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & __rshift___Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
    
    static auto op = create___rshift___Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Tensor_out, name, "aten::__rshift__")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(__rshift___Tensor_out, schema_str, "__rshift__.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::__rshift__.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<__rshift___Tensor_out::schema> create___rshift___Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(__rshift___Tensor_out::name, __rshift___Tensor_out::overload_name)
      .typed<__rshift___Tensor_out::schema>();
}

// aten::__rshift__.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & __rshift___Tensor_out::call(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create___rshift___Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::__rshift__.Tensor_out(Tensor self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & __rshift___Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create___rshift___Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Scalar_Tensor_out, name, "aten::bitwise_right_shift")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Scalar_Tensor_out, overload_name, "Scalar_Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(bitwise_right_shift_Scalar_Tensor_out, schema_str, "bitwise_right_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)")

// aten::bitwise_right_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<bitwise_right_shift_Scalar_Tensor_out::schema> create_bitwise_right_shift_Scalar_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(bitwise_right_shift_Scalar_Tensor_out::name, bitwise_right_shift_Scalar_Tensor_out::overload_name)
      .typed<bitwise_right_shift_Scalar_Tensor_out::schema>();
}

// aten::bitwise_right_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_right_shift_Scalar_Tensor_out::call(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_right_shift_Scalar_Tensor_out_typed_handle();
    return op.call(self, other, out);
}

// aten::bitwise_right_shift.Scalar_Tensor_out(Scalar self, Tensor other, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & bitwise_right_shift_Scalar_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
    
    static auto op = create_bitwise_right_shift_Scalar_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(exponential_out, name, "aten::exponential")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(exponential_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(exponential_out, schema_str, "exponential.out(Tensor self, float lambd=1, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)")

// aten::exponential.out(Tensor self, float lambd=1, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<exponential_out::schema> create_exponential_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(exponential_out::name, exponential_out::overload_name)
      .typed<exponential_out::schema>();
}

// aten::exponential.out(Tensor self, float lambd=1, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & exponential_out::call(const at::Tensor & self, double lambd, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_exponential_out_typed_handle();
    return op.call(self, lambd, generator, out);
}

// aten::exponential.out(Tensor self, float lambd=1, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & exponential_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double lambd, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_exponential_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, lambd, generator, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(exponential, name, "aten::exponential")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(exponential, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(exponential, schema_str, "exponential(Tensor self, float lambd=1, *, Generator? generator=None) -> Tensor")

// aten::exponential(Tensor self, float lambd=1, *, Generator? generator=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<exponential::schema> create_exponential_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(exponential::name, exponential::overload_name)
      .typed<exponential::schema>();
}

// aten::exponential(Tensor self, float lambd=1, *, Generator? generator=None) -> Tensor
at::Tensor exponential::call(const at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
    
    static auto op = create_exponential_typed_handle();
    return op.call(self, lambd, generator);
}

// aten::exponential(Tensor self, float lambd=1, *, Generator? generator=None) -> Tensor
at::Tensor exponential::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
    
    static auto op = create_exponential_typed_handle();
    return op.redispatch(dispatchKeySet, self, lambd, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geometric_out, name, "aten::geometric")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geometric_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geometric_out, schema_str, "geometric.out(Tensor self, float p, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)")

// aten::geometric.out(Tensor self, float p, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<geometric_out::schema> create_geometric_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(geometric_out::name, geometric_out::overload_name)
      .typed<geometric_out::schema>();
}

// aten::geometric.out(Tensor self, float p, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & geometric_out::call(const at::Tensor & self, double p, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_geometric_out_typed_handle();
    return op.call(self, p, generator, out);
}

// aten::geometric.out(Tensor self, float p, *, Generator? generator=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & geometric_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double p, c10::optional<at::Generator> generator, at::Tensor & out) {
    
    static auto op = create_geometric_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, p, generator, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geometric, name, "aten::geometric")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geometric, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(geometric, schema_str, "geometric(Tensor self, float p, *, Generator? generator=None) -> Tensor")

// aten::geometric(Tensor self, float p, *, Generator? generator=None) -> Tensor
static C10_NOINLINE c10::TypedOperatorHandle<geometric::schema> create_geometric_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(geometric::name, geometric::overload_name)
      .typed<geometric::schema>();
}

// aten::geometric(Tensor self, float p, *, Generator? generator=None) -> Tensor
at::Tensor geometric::call(const at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    
    static auto op = create_geometric_typed_handle();
    return op.call(self, p, generator);
}

// aten::geometric(Tensor self, float p, *, Generator? generator=None) -> Tensor
at::Tensor geometric::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    
    static auto op = create_geometric_typed_handle();
    return op.redispatch(dispatchKeySet, self, p, generator);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_amp_foreach_non_finite_check_and_unscale_out, name, "aten::_amp_foreach_non_finite_check_and_unscale")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_amp_foreach_non_finite_check_and_unscale_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_amp_foreach_non_finite_check_and_unscale_out, schema_str, "_amp_foreach_non_finite_check_and_unscale.out(Tensor[] self, Tensor(b!) found_inf, Tensor inv_scale, *, Tensor(a!)[] out) -> ()")

// aten::_amp_foreach_non_finite_check_and_unscale.out(Tensor[] self, Tensor(b!) found_inf, Tensor inv_scale, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_amp_foreach_non_finite_check_and_unscale_out::schema> create__amp_foreach_non_finite_check_and_unscale_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_amp_foreach_non_finite_check_and_unscale_out::name, _amp_foreach_non_finite_check_and_unscale_out::overload_name)
      .typed<_amp_foreach_non_finite_check_and_unscale_out::schema>();
}

// aten::_amp_foreach_non_finite_check_and_unscale.out(Tensor[] self, Tensor(b!) found_inf, Tensor inv_scale, *, Tensor(a!)[] out) -> ()
void _amp_foreach_non_finite_check_and_unscale_out::call(at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale, at::TensorList out) {
    
    static auto op = create__amp_foreach_non_finite_check_and_unscale_out_typed_handle();
    return op.call(self, found_inf, inv_scale, out);
}

// aten::_amp_foreach_non_finite_check_and_unscale.out(Tensor[] self, Tensor(b!) found_inf, Tensor inv_scale, *, Tensor(a!)[] out) -> ()
void _amp_foreach_non_finite_check_and_unscale_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale, at::TensorList out) {
    
    static auto op = create__amp_foreach_non_finite_check_and_unscale_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, found_inf, inv_scale, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_amp_foreach_non_finite_check_and_unscale, name, "aten::_amp_foreach_non_finite_check_and_unscale")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_amp_foreach_non_finite_check_and_unscale, overload_name, "")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_amp_foreach_non_finite_check_and_unscale, schema_str, "_amp_foreach_non_finite_check_and_unscale(Tensor[] self, Tensor found_inf, Tensor inv_scale) -> (Tensor[] self_out, Tensor found_inf_out)")

// aten::_amp_foreach_non_finite_check_and_unscale(Tensor[] self, Tensor found_inf, Tensor inv_scale) -> (Tensor[] self_out, Tensor found_inf_out)
static C10_NOINLINE c10::TypedOperatorHandle<_amp_foreach_non_finite_check_and_unscale::schema> create__amp_foreach_non_finite_check_and_unscale_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_amp_foreach_non_finite_check_and_unscale::name, _amp_foreach_non_finite_check_and_unscale::overload_name)
      .typed<_amp_foreach_non_finite_check_and_unscale::schema>();
}

// aten::_amp_foreach_non_finite_check_and_unscale(Tensor[] self, Tensor found_inf, Tensor inv_scale) -> (Tensor[] self_out, Tensor found_inf_out)
::std::tuple<::std::vector<at::Tensor>,at::Tensor> _amp_foreach_non_finite_check_and_unscale::call(at::TensorList self, const at::Tensor & found_inf, const at::Tensor & inv_scale) {
    
    static auto op = create__amp_foreach_non_finite_check_and_unscale_typed_handle();
    return op.call(self, found_inf, inv_scale);
}

// aten::_amp_foreach_non_finite_check_and_unscale(Tensor[] self, Tensor found_inf, Tensor inv_scale) -> (Tensor[] self_out, Tensor found_inf_out)
::std::tuple<::std::vector<at::Tensor>,at::Tensor> _amp_foreach_non_finite_check_and_unscale::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Tensor & found_inf, const at::Tensor & inv_scale) {
    
    static auto op = create__amp_foreach_non_finite_check_and_unscale_typed_handle();
    return op.redispatch(dispatchKeySet, self, found_inf, inv_scale);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Scalar_out, name, "aten::_foreach_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Scalar_out, schema_str, "_foreach_add.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_add.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add_Scalar_out::schema> create__foreach_add_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add_Scalar_out::name, _foreach_add_Scalar_out::overload_name)
      .typed<_foreach_add_Scalar_out::schema>();
}

// aten::_foreach_add.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
void _foreach_add_Scalar_out::call(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
    
    static auto op = create__foreach_add_Scalar_out_typed_handle();
    return op.call(self, scalar, out);
}

// aten::_foreach_add.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
void _foreach_add_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
    
    static auto op = create__foreach_add_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_List_out, name, "aten::_foreach_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_List_out, overload_name, "List_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_List_out, schema_str, "_foreach_add.List_out(Tensor[] self, Tensor[] other, *, Scalar alpha=1, Tensor(a!)[] out) -> ()")

// aten::_foreach_add.List_out(Tensor[] self, Tensor[] other, *, Scalar alpha=1, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add_List_out::schema> create__foreach_add_List_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add_List_out::name, _foreach_add_List_out::overload_name)
      .typed<_foreach_add_List_out::schema>();
}

// aten::_foreach_add.List_out(Tensor[] self, Tensor[] other, *, Scalar alpha=1, Tensor(a!)[] out) -> ()
void _foreach_add_List_out::call(at::TensorList self, at::TensorList other, const at::Scalar & alpha, at::TensorList out) {
    
    static auto op = create__foreach_add_List_out_typed_handle();
    return op.call(self, other, alpha, out);
}

// aten::_foreach_add.List_out(Tensor[] self, Tensor[] other, *, Scalar alpha=1, Tensor(a!)[] out) -> ()
void _foreach_add_List_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other, const at::Scalar & alpha, at::TensorList out) {
    
    static auto op = create__foreach_add_List_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_ScalarList_out, name, "aten::_foreach_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_ScalarList_out, overload_name, "ScalarList_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_ScalarList_out, schema_str, "_foreach_add.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_add.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add_ScalarList_out::schema> create__foreach_add_ScalarList_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add_ScalarList_out::name, _foreach_add_ScalarList_out::overload_name)
      .typed<_foreach_add_ScalarList_out::schema>();
}

// aten::_foreach_add.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
void _foreach_add_ScalarList_out::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
    
    static auto op = create__foreach_add_ScalarList_out_typed_handle();
    return op.call(self, scalars, out);
}

// aten::_foreach_add.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
void _foreach_add_ScalarList_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
    
    static auto op = create__foreach_add_ScalarList_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Tensor_out, name, "aten::_foreach_add")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Tensor_out, overload_name, "Tensor_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_add_Tensor_out, schema_str, "_foreach_add.Tensor_out(Tensor[] self, Tensor other, *, Scalar alpha=1, Tensor(a!)[] out) -> ()")

// aten::_foreach_add.Tensor_out(Tensor[] self, Tensor other, *, Scalar alpha=1, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_add_Tensor_out::schema> create__foreach_add_Tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_add_Tensor_out::name, _foreach_add_Tensor_out::overload_name)
      .typed<_foreach_add_Tensor_out::schema>();
}

// aten::_foreach_add.Tensor_out(Tensor[] self, Tensor other, *, Scalar alpha=1, Tensor(a!)[] out) -> ()
void _foreach_add_Tensor_out::call(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha, at::TensorList out) {
    
    static auto op = create__foreach_add_Tensor_out_typed_handle();
    return op.call(self, other, alpha, out);
}

// aten::_foreach_add.Tensor_out(Tensor[] self, Tensor other, *, Scalar alpha=1, Tensor(a!)[] out) -> ()
void _foreach_add_Tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Tensor & other, const at::Scalar & alpha, at::TensorList out) {
    
    static auto op = create__foreach_add_Tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, alpha, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_Scalar_out, name, "aten::_foreach_clamp_min")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_Scalar_out, schema_str, "_foreach_clamp_min.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_clamp_min.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_min_Scalar_out::schema> create__foreach_clamp_min_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_min_Scalar_out::name, _foreach_clamp_min_Scalar_out::overload_name)
      .typed<_foreach_clamp_min_Scalar_out::schema>();
}

// aten::_foreach_clamp_min.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_min_Scalar_out::call(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
    
    static auto op = create__foreach_clamp_min_Scalar_out_typed_handle();
    return op.call(self, scalar, out);
}

// aten::_foreach_clamp_min.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_min_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
    
    static auto op = create__foreach_clamp_min_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_List_out, name, "aten::_foreach_clamp_min")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_List_out, overload_name, "List_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_List_out, schema_str, "_foreach_clamp_min.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_clamp_min.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_min_List_out::schema> create__foreach_clamp_min_List_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_min_List_out::name, _foreach_clamp_min_List_out::overload_name)
      .typed<_foreach_clamp_min_List_out::schema>();
}

// aten::_foreach_clamp_min.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_min_List_out::call(at::TensorList self, at::TensorList other, at::TensorList out) {
    
    static auto op = create__foreach_clamp_min_List_out_typed_handle();
    return op.call(self, other, out);
}

// aten::_foreach_clamp_min.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_min_List_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other, at::TensorList out) {
    
    static auto op = create__foreach_clamp_min_List_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_ScalarList_out, name, "aten::_foreach_clamp_min")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_ScalarList_out, overload_name, "ScalarList_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_clamp_min_ScalarList_out, schema_str, "_foreach_clamp_min.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_clamp_min.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_clamp_min_ScalarList_out::schema> create__foreach_clamp_min_ScalarList_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_clamp_min_ScalarList_out::name, _foreach_clamp_min_ScalarList_out::overload_name)
      .typed<_foreach_clamp_min_ScalarList_out::schema>();
}

// aten::_foreach_clamp_min.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_min_ScalarList_out::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
    
    static auto op = create__foreach_clamp_min_ScalarList_out_typed_handle();
    return op.call(self, scalars, out);
}

// aten::_foreach_clamp_min.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
void _foreach_clamp_min_ScalarList_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
    
    static auto op = create__foreach_clamp_min_ScalarList_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_Scalar_out, name, "aten::_foreach_minimum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_Scalar_out, schema_str, "_foreach_minimum.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_minimum.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_minimum_Scalar_out::schema> create__foreach_minimum_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_minimum_Scalar_out::name, _foreach_minimum_Scalar_out::overload_name)
      .typed<_foreach_minimum_Scalar_out::schema>();
}

// aten::_foreach_minimum.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
void _foreach_minimum_Scalar_out::call(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
    
    static auto op = create__foreach_minimum_Scalar_out_typed_handle();
    return op.call(self, scalar, out);
}

// aten::_foreach_minimum.Scalar_out(Tensor[] self, Scalar scalar, *, Tensor(a!)[] out) -> ()
void _foreach_minimum_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
    
    static auto op = create__foreach_minimum_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalar, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_List_out, name, "aten::_foreach_minimum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_List_out, overload_name, "List_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_List_out, schema_str, "_foreach_minimum.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_minimum.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_minimum_List_out::schema> create__foreach_minimum_List_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_minimum_List_out::name, _foreach_minimum_List_out::overload_name)
      .typed<_foreach_minimum_List_out::schema>();
}

// aten::_foreach_minimum.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()
void _foreach_minimum_List_out::call(at::TensorList self, at::TensorList other, at::TensorList out) {
    
    static auto op = create__foreach_minimum_List_out_typed_handle();
    return op.call(self, other, out);
}

// aten::_foreach_minimum.List_out(Tensor[] self, Tensor[] other, *, Tensor(a!)[] out) -> ()
void _foreach_minimum_List_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList other, at::TensorList out) {
    
    static auto op = create__foreach_minimum_List_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, other, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_ScalarList_out, name, "aten::_foreach_minimum")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_ScalarList_out, overload_name, "ScalarList_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_minimum_ScalarList_out, schema_str, "_foreach_minimum.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_minimum.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_minimum_ScalarList_out::schema> create__foreach_minimum_ScalarList_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_minimum_ScalarList_out::name, _foreach_minimum_ScalarList_out::overload_name)
      .typed<_foreach_minimum_ScalarList_out::schema>();
}

// aten::_foreach_minimum.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
void _foreach_minimum_ScalarList_out::call(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
    
    static auto op = create__foreach_minimum_ScalarList_out_typed_handle();
    return op.call(self, scalars, out);
}

// aten::_foreach_minimum.ScalarList_out(Tensor[] self, Scalar[] scalars, *, Tensor(a!)[] out) -> ()
void _foreach_minimum_ScalarList_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
    
    static auto op = create__foreach_minimum_ScalarList_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, scalars, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_cosh_out, name, "aten::_foreach_cosh")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_cosh_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_cosh_out, schema_str, "_foreach_cosh.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_cosh.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_cosh_out::schema> create__foreach_cosh_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_cosh_out::name, _foreach_cosh_out::overload_name)
      .typed<_foreach_cosh_out::schema>();
}

// aten::_foreach_cosh.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_cosh_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_cosh_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_cosh.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_cosh_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_cosh_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_erfc_out, name, "aten::_foreach_erfc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_erfc_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_erfc_out, schema_str, "_foreach_erfc.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_erfc.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_erfc_out::schema> create__foreach_erfc_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_erfc_out::name, _foreach_erfc_out::overload_name)
      .typed<_foreach_erfc_out::schema>();
}

// aten::_foreach_erfc.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_erfc_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_erfc_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_erfc.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_erfc_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_erfc_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_frac_out, name, "aten::_foreach_frac")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_frac_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_frac_out, schema_str, "_foreach_frac.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_frac.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_frac_out::schema> create__foreach_frac_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_frac_out::name, _foreach_frac_out::overload_name)
      .typed<_foreach_frac_out::schema>();
}

// aten::_foreach_frac.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_frac_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_frac_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_frac.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_frac_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_frac_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_List_out, name, "aten::_foreach_lerp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_List_out, overload_name, "List_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_List_out, schema_str, "_foreach_lerp.List_out(Tensor[] self, Tensor[] tensors1, Tensor[] weights, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_lerp.List_out(Tensor[] self, Tensor[] tensors1, Tensor[] weights, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_lerp_List_out::schema> create__foreach_lerp_List_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_lerp_List_out::name, _foreach_lerp_List_out::overload_name)
      .typed<_foreach_lerp_List_out::schema>();
}

// aten::_foreach_lerp.List_out(Tensor[] self, Tensor[] tensors1, Tensor[] weights, *, Tensor(a!)[] out) -> ()
void _foreach_lerp_List_out::call(at::TensorList self, at::TensorList tensors1, at::TensorList weights, at::TensorList out) {
    
    static auto op = create__foreach_lerp_List_out_typed_handle();
    return op.call(self, tensors1, weights, out);
}

// aten::_foreach_lerp.List_out(Tensor[] self, Tensor[] tensors1, Tensor[] weights, *, Tensor(a!)[] out) -> ()
void _foreach_lerp_List_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList tensors1, at::TensorList weights, at::TensorList out) {
    
    static auto op = create__foreach_lerp_List_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, tensors1, weights, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_Scalar_out, name, "aten::_foreach_lerp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_Scalar_out, overload_name, "Scalar_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lerp_Scalar_out, schema_str, "_foreach_lerp.Scalar_out(Tensor[] self, Tensor[] tensors1, Scalar weight, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_lerp.Scalar_out(Tensor[] self, Tensor[] tensors1, Scalar weight, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_lerp_Scalar_out::schema> create__foreach_lerp_Scalar_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_lerp_Scalar_out::name, _foreach_lerp_Scalar_out::overload_name)
      .typed<_foreach_lerp_Scalar_out::schema>();
}

// aten::_foreach_lerp.Scalar_out(Tensor[] self, Tensor[] tensors1, Scalar weight, *, Tensor(a!)[] out) -> ()
void _foreach_lerp_Scalar_out::call(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight, at::TensorList out) {
    
    static auto op = create__foreach_lerp_Scalar_out_typed_handle();
    return op.call(self, tensors1, weight, out);
}

// aten::_foreach_lerp.Scalar_out(Tensor[] self, Tensor[] tensors1, Scalar weight, *, Tensor(a!)[] out) -> ()
void _foreach_lerp_Scalar_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList tensors1, const at::Scalar & weight, at::TensorList out) {
    
    static auto op = create__foreach_lerp_Scalar_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, tensors1, weight, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lgamma_out, name, "aten::_foreach_lgamma")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lgamma_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_lgamma_out, schema_str, "_foreach_lgamma.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_lgamma.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_lgamma_out::schema> create__foreach_lgamma_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_lgamma_out::name, _foreach_lgamma_out::overload_name)
      .typed<_foreach_lgamma_out::schema>();
}

// aten::_foreach_lgamma.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_lgamma_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_lgamma_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_lgamma.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_lgamma_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_lgamma_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_round_out, name, "aten::_foreach_round")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_round_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_round_out, schema_str, "_foreach_round.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_round.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_round_out::schema> create__foreach_round_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_round_out::name, _foreach_round_out::overload_name)
      .typed<_foreach_round_out::schema>();
}

// aten::_foreach_round.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_round_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_round_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_round.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_round_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_round_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_trunc_out, name, "aten::_foreach_trunc")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_trunc_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_foreach_trunc_out, schema_str, "_foreach_trunc.out(Tensor[] self, *, Tensor(a!)[] out) -> ()")

// aten::_foreach_trunc.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
static C10_NOINLINE c10::TypedOperatorHandle<_foreach_trunc_out::schema> create__foreach_trunc_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_foreach_trunc_out::name, _foreach_trunc_out::overload_name)
      .typed<_foreach_trunc_out::schema>();
}

// aten::_foreach_trunc.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_trunc_out::call(at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_trunc_out_typed_handle();
    return op.call(self, out);
}

// aten::_foreach_trunc.out(Tensor[] self, *, Tensor(a!)[] out) -> ()
void _foreach_trunc_out::redispatch(c10::DispatchKeySet dispatchKeySet, at::TensorList self, at::TensorList out) {
    
    static auto op = create__foreach_trunc_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu_with_noise_backward_out, name, "aten::rrelu_with_noise_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu_with_noise_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(rrelu_with_noise_backward_out, schema_str, "rrelu_with_noise_backward.out(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result, *, Tensor(a!) out) -> Tensor(a!)")

// aten::rrelu_with_noise_backward.out(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<rrelu_with_noise_backward_out::schema> create_rrelu_with_noise_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(rrelu_with_noise_backward_out::name, rrelu_with_noise_backward_out::overload_name)
      .typed<rrelu_with_noise_backward_out::schema>();
}

// aten::rrelu_with_noise_backward.out(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & rrelu_with_noise_backward_out::call(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, bool self_is_result, at::Tensor & out) {
    
    static auto op = create_rrelu_with_noise_backward_out_typed_handle();
    return op.call(grad_output, self, noise, lower, upper, training, self_is_result, out);
}

// aten::rrelu_with_noise_backward.out(Tensor grad_output, Tensor self, Tensor noise, Scalar lower, Scalar upper, bool training, bool self_is_result, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & rrelu_with_noise_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, bool self_is_result, at::Tensor & out) {
    
    static auto op = create_rrelu_with_noise_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, noise, lower, upper, training, self_is_result, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d_backward_out, name, "aten::mkldnn_adaptive_avg_pool2d_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(mkldnn_adaptive_avg_pool2d_backward_out, schema_str, "mkldnn_adaptive_avg_pool2d_backward.out(Tensor grad_output, Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::mkldnn_adaptive_avg_pool2d_backward.out(Tensor grad_output, Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<mkldnn_adaptive_avg_pool2d_backward_out::schema> create_mkldnn_adaptive_avg_pool2d_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(mkldnn_adaptive_avg_pool2d_backward_out::name, mkldnn_adaptive_avg_pool2d_backward_out::overload_name)
      .typed<mkldnn_adaptive_avg_pool2d_backward_out::schema>();
}

// aten::mkldnn_adaptive_avg_pool2d_backward.out(Tensor grad_output, Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_adaptive_avg_pool2d_backward_out::call(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_mkldnn_adaptive_avg_pool2d_backward_out_typed_handle();
    return op.call(grad_output, self, out);
}

// aten::mkldnn_adaptive_avg_pool2d_backward.out(Tensor grad_output, Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & mkldnn_adaptive_avg_pool2d_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_mkldnn_adaptive_avg_pool2d_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad_output, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_exp_out, name, "aten::linalg_matrix_exp")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_exp_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(linalg_matrix_exp_out, schema_str, "linalg_matrix_exp.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::linalg_matrix_exp.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<linalg_matrix_exp_out::schema> create_linalg_matrix_exp_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(linalg_matrix_exp_out::name, linalg_matrix_exp_out::overload_name)
      .typed<linalg_matrix_exp_out::schema>();
}

// aten::linalg_matrix_exp.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_matrix_exp_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_linalg_matrix_exp_out_typed_handle();
    return op.call(self, out);
}

// aten::linalg_matrix_exp.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & linalg_matrix_exp_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_linalg_matrix_exp_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_optional_intlist_out, name, "aten::_test_optional_intlist")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_optional_intlist_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_optional_intlist_out, schema_str, "_test_optional_intlist.out(Tensor values, int[]? addends, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_test_optional_intlist.out(Tensor values, int[]? addends, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_test_optional_intlist_out::schema> create__test_optional_intlist_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_optional_intlist_out::name, _test_optional_intlist_out::overload_name)
      .typed<_test_optional_intlist_out::schema>();
}

// aten::_test_optional_intlist.out(Tensor values, int[]? addends, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _test_optional_intlist_out::call(const at::Tensor & values, at::OptionalIntArrayRef addends, at::Tensor & out) {
    
    static auto op = create__test_optional_intlist_out_typed_handle();
    return op.call(values, addends, out);
}

// aten::_test_optional_intlist.out(Tensor values, int[]? addends, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _test_optional_intlist_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & values, at::OptionalIntArrayRef addends, at::Tensor & out) {
    
    static auto op = create__test_optional_intlist_out_typed_handle();
    return op.redispatch(dispatchKeySet, values, addends, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_fullcoverage_out, name, "aten::_test_autograd_multiple_dispatch")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_fullcoverage_out, overload_name, "fullcoverage_out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_test_autograd_multiple_dispatch_fullcoverage_out, schema_str, "_test_autograd_multiple_dispatch.fullcoverage_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_test_autograd_multiple_dispatch.fullcoverage_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_test_autograd_multiple_dispatch_fullcoverage_out::schema> create__test_autograd_multiple_dispatch_fullcoverage_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_test_autograd_multiple_dispatch_fullcoverage_out::name, _test_autograd_multiple_dispatch_fullcoverage_out::overload_name)
      .typed<_test_autograd_multiple_dispatch_fullcoverage_out::schema>();
}

// aten::_test_autograd_multiple_dispatch.fullcoverage_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _test_autograd_multiple_dispatch_fullcoverage_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__test_autograd_multiple_dispatch_fullcoverage_out_typed_handle();
    return op.call(self, out);
}

// aten::_test_autograd_multiple_dispatch.fullcoverage_out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _test_autograd_multiple_dispatch_fullcoverage_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__test_autograd_multiple_dispatch_fullcoverage_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(segment_reduce_out, name, "aten::segment_reduce")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(segment_reduce_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(segment_reduce_out, schema_str, "segment_reduce.out(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None, Tensor(a!) out) -> Tensor(a!)")

// aten::segment_reduce.out(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<segment_reduce_out::schema> create_segment_reduce_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(segment_reduce_out::name, segment_reduce_out::overload_name)
      .typed<segment_reduce_out::schema>();
}

// aten::segment_reduce.out(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & segment_reduce_out::call(const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & indices, const c10::optional<at::Tensor> & offsets, int64_t axis, bool unsafe, const c10::optional<at::Scalar> & initial, at::Tensor & out) {
    
    static auto op = create_segment_reduce_out_typed_handle();
    return op.call(data, reduce, lengths, indices, offsets, axis, unsafe, initial, out);
}

// aten::segment_reduce.out(Tensor data, str reduce, *, Tensor? lengths=None, Tensor? indices=None, Tensor? offsets=None, int axis=0, bool unsafe=False, Scalar? initial=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & segment_reduce_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & indices, const c10::optional<at::Tensor> & offsets, int64_t axis, bool unsafe, const c10::optional<at::Scalar> & initial, at::Tensor & out) {
    
    static auto op = create_segment_reduce_out_typed_handle();
    return op.redispatch(dispatchKeySet, data, reduce, lengths, indices, offsets, axis, unsafe, initial, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_segment_reduce_backward_out, name, "aten::_segment_reduce_backward")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_segment_reduce_backward_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_segment_reduce_backward_out, schema_str, "_segment_reduce_backward.out(Tensor grad, Tensor output, Tensor data, str reduce, *, Tensor? lengths=None, Tensor? offsets=None, int axis=0, Scalar? initial=None, Tensor(a!) out) -> Tensor(a!)")

// aten::_segment_reduce_backward.out(Tensor grad, Tensor output, Tensor data, str reduce, *, Tensor? lengths=None, Tensor? offsets=None, int axis=0, Scalar? initial=None, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_segment_reduce_backward_out::schema> create__segment_reduce_backward_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_segment_reduce_backward_out::name, _segment_reduce_backward_out::overload_name)
      .typed<_segment_reduce_backward_out::schema>();
}

// aten::_segment_reduce_backward.out(Tensor grad, Tensor output, Tensor data, str reduce, *, Tensor? lengths=None, Tensor? offsets=None, int axis=0, Scalar? initial=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _segment_reduce_backward_out::call(const at::Tensor & grad, const at::Tensor & output, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & offsets, int64_t axis, const c10::optional<at::Scalar> & initial, at::Tensor & out) {
    
    static auto op = create__segment_reduce_backward_out_typed_handle();
    return op.call(grad, output, data, reduce, lengths, offsets, axis, initial, out);
}

// aten::_segment_reduce_backward.out(Tensor grad, Tensor output, Tensor data, str reduce, *, Tensor? lengths=None, Tensor? offsets=None, int axis=0, Scalar? initial=None, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _segment_reduce_backward_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & grad, const at::Tensor & output, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & offsets, int64_t axis, const c10::optional<at::Scalar> & initial, at::Tensor & out) {
    
    static auto op = create__segment_reduce_backward_out_typed_handle();
    return op.redispatch(dispatchKeySet, grad, output, data, reduce, lengths, offsets, axis, initial, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_dual_copy_out, name, "aten::_make_dual_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_dual_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_make_dual_copy_out, schema_str, "_make_dual_copy.out(Tensor primal, Tensor tangent, int level, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_make_dual_copy.out(Tensor primal, Tensor tangent, int level, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_make_dual_copy_out::schema> create__make_dual_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_make_dual_copy_out::name, _make_dual_copy_out::overload_name)
      .typed<_make_dual_copy_out::schema>();
}

// aten::_make_dual_copy.out(Tensor primal, Tensor tangent, int level, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _make_dual_copy_out::call(const at::Tensor & primal, const at::Tensor & tangent, int64_t level, at::Tensor & out) {
    
    static auto op = create__make_dual_copy_out_typed_handle();
    return op.call(primal, tangent, level, out);
}

// aten::_make_dual_copy.out(Tensor primal, Tensor tangent, int level, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _make_dual_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & primal, const at::Tensor & tangent, int64_t level, at::Tensor & out) {
    
    static auto op = create__make_dual_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, primal, tangent, level, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_complex_copy_out, name, "aten::view_as_complex_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_complex_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(view_as_complex_copy_out, schema_str, "view_as_complex_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::view_as_complex_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<view_as_complex_copy_out::schema> create_view_as_complex_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(view_as_complex_copy_out::name, view_as_complex_copy_out::overload_name)
      .typed<view_as_complex_copy_out::schema>();
}

// aten::view_as_complex_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & view_as_complex_copy_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_view_as_complex_copy_out_typed_handle();
    return op.call(self, out);
}

// aten::view_as_complex_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & view_as_complex_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_view_as_complex_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_neg_view_copy_out, name, "aten::_neg_view_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_neg_view_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(_neg_view_copy_out, schema_str, "_neg_view_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::_neg_view_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<_neg_view_copy_out::schema> create__neg_view_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(_neg_view_copy_out::name, _neg_view_copy_out::overload_name)
      .typed<_neg_view_copy_out::schema>();
}

// aten::_neg_view_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _neg_view_copy_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__neg_view_copy_out_typed_handle();
    return op.call(self, out);
}

// aten::_neg_view_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & _neg_view_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create__neg_view_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expand_copy_out, name, "aten::expand_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expand_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(expand_copy_out, schema_str, "expand_copy.out(Tensor self, SymInt[] size, *, bool implicit=False, Tensor(a!) out) -> Tensor(a!)")

// aten::expand_copy.out(Tensor self, SymInt[] size, *, bool implicit=False, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<expand_copy_out::schema> create_expand_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(expand_copy_out::name, expand_copy_out::overload_name)
      .typed<expand_copy_out::schema>();
}

// aten::expand_copy.out(Tensor self, SymInt[] size, *, bool implicit=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & expand_copy_out::call(const at::Tensor & self, c10::SymIntArrayRef size, bool implicit, at::Tensor & out) {
    
    static auto op = create_expand_copy_out_typed_handle();
    return op.call(self, size, implicit, out);
}

// aten::expand_copy.out(Tensor self, SymInt[] size, *, bool implicit=False, Tensor(a!) out) -> Tensor(a!)
at::Tensor & expand_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, c10::SymIntArrayRef size, bool implicit, at::Tensor & out) {
    
    static auto op = create_expand_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, size, implicit, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze_copy_out, name, "aten::unsqueeze_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(unsqueeze_copy_out, schema_str, "unsqueeze_copy.out(Tensor self, int dim, *, Tensor(a!) out) -> Tensor(a!)")

// aten::unsqueeze_copy.out(Tensor self, int dim, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<unsqueeze_copy_out::schema> create_unsqueeze_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(unsqueeze_copy_out::name, unsqueeze_copy_out::overload_name)
      .typed<unsqueeze_copy_out::schema>();
}

// aten::unsqueeze_copy.out(Tensor self, int dim, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & unsqueeze_copy_out::call(const at::Tensor & self, int64_t dim, at::Tensor & out) {
    
    static auto op = create_unsqueeze_copy_out_typed_handle();
    return op.call(self, dim, out);
}

// aten::unsqueeze_copy.out(Tensor self, int dim, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & unsqueeze_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, int64_t dim, at::Tensor & out) {
    
    static auto op = create_unsqueeze_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, dim, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(crow_indices_copy_out, name, "aten::crow_indices_copy")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(crow_indices_copy_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(crow_indices_copy_out, schema_str, "crow_indices_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)")

// aten::crow_indices_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<crow_indices_copy_out::schema> create_crow_indices_copy_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(crow_indices_copy_out::name, crow_indices_copy_out::overload_name)
      .typed<crow_indices_copy_out::schema>();
}

// aten::crow_indices_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & crow_indices_copy_out::call(const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_crow_indices_copy_out_typed_handle();
    return op.call(self, out);
}

// aten::crow_indices_copy.out(Tensor self, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & crow_indices_copy_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, at::Tensor & out) {
    
    static auto op = create_crow_indices_copy_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, out);
}

STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_padded_tensor_out, name, "aten::to_padded_tensor")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_padded_tensor_out, overload_name, "out")
STATIC_CONST_STR_OUT_OF_LINE_FOR_WIN_CUDA(to_padded_tensor_out, schema_str, "to_padded_tensor.out(Tensor self, float padding, SymInt[]? output_size=None, *, Tensor(a!) out) -> Tensor(a!)")

// aten::to_padded_tensor.out(Tensor self, float padding, SymInt[]? output_size=None, *, Tensor(a!) out) -> Tensor(a!)
static C10_NOINLINE c10::TypedOperatorHandle<to_padded_tensor_out::schema> create_to_padded_tensor_out_typed_handle() {
  return c10::Dispatcher::singleton()
      .findSchemaOrThrow(to_padded_tensor_out::name, to_padded_tensor_out::overload_name)
      .typed<to_padded_tensor_out::schema>();
}

// aten::to_padded_tensor.out(Tensor self, float padding, SymInt[]? output_size=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & to_padded_tensor_out::call(const at::Tensor & self, double padding, at::OptionalSymIntArrayRef output_size, at::Tensor & out) {
    
    static auto op = create_to_padded_tensor_out_typed_handle();
    return op.call(self, padding, output_size, out);
}

// aten::to_padded_tensor.out(Tensor self, float padding, SymInt[]? output_size=None, *, Tensor(a!) out) -> Tensor(a!)
at::Tensor & to_padded_tensor_out::redispatch(c10::DispatchKeySet dispatchKeySet, const at::Tensor & self, double padding, at::OptionalSymIntArrayRef output_size, at::Tensor & out) {
    
    static auto op = create_to_padded_tensor_out_typed_handle();
    return op.redispatch(dispatchKeySet, self, padding, output_size, out);
}

}} // namespace at::_ops
