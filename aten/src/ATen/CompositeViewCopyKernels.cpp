#define TORCH_ASSERT_ONLY_METHOD_OPERATORS
// @generated by torchgen/gen.py from CompositeViewCopyKernels.cpp

#include <ATen/InferSize.h>
#include <ATen/Tensor.h>
#include <ATen/native/Resize.h>

#ifndef AT_PER_OPERATOR_HEADERS
#include <ATen/Operators.h>
#else
#include <ATen/ops/clone.h>
#include <ATen/ops/_fw_primal_ops.h>
#include <ATen/ops/_fw_primal_native.h>
#include <ATen/ops/_fw_primal_copy_ops.h>
#include <ATen/ops/_fw_primal_copy_native.h>
#include <ATen/ops/_make_dual_ops.h>
#include <ATen/ops/_make_dual_native.h>
#include <ATen/ops/_make_dual_copy_ops.h>
#include <ATen/ops/_make_dual_copy_native.h>
#include <ATen/ops/_unpack_dual_ops.h>
#include <ATen/ops/_unpack_dual_native.h>
#include <ATen/ops/rename_ops.h>
#include <ATen/ops/rename_native.h>
#include <ATen/ops/align_to_ops.h>
#include <ATen/ops/align_to_native.h>
#include <ATen/ops/align_to_ops.h>
#include <ATen/ops/align_to_native.h>
#include <ATen/ops/refine_names_ops.h>
#include <ATen/ops/refine_names_native.h>
#include <ATen/ops/view_as_real_ops.h>
#include <ATen/ops/view_as_real_native.h>
#include <ATen/ops/view_as_real_copy_ops.h>
#include <ATen/ops/view_as_real_copy_native.h>
#include <ATen/ops/view_as_complex_ops.h>
#include <ATen/ops/view_as_complex_native.h>
#include <ATen/ops/view_as_complex_copy_ops.h>
#include <ATen/ops/view_as_complex_copy_native.h>
#include <ATen/ops/real_ops.h>
#include <ATen/ops/real_native.h>
#include <ATen/ops/imag_ops.h>
#include <ATen/ops/imag_native.h>
#include <ATen/ops/_conj_ops.h>
#include <ATen/ops/_conj_native.h>
#include <ATen/ops/_conj_copy_ops.h>
#include <ATen/ops/_conj_copy_native.h>
#include <ATen/ops/conj_ops.h>
#include <ATen/ops/conj_native.h>
#include <ATen/ops/resolve_conj_ops.h>
#include <ATen/ops/resolve_conj_native.h>
#include <ATen/ops/resolve_neg_ops.h>
#include <ATen/ops/resolve_neg_native.h>
#include <ATen/ops/_neg_view_ops.h>
#include <ATen/ops/_neg_view_native.h>
#include <ATen/ops/_neg_view_copy_ops.h>
#include <ATen/ops/_neg_view_copy_native.h>
#include <ATen/ops/as_strided_ops.h>
#include <ATen/ops/as_strided_native.h>
#include <ATen/ops/as_strided_copy_ops.h>
#include <ATen/ops/as_strided_copy_native.h>
#include <ATen/ops/broadcast_to_ops.h>
#include <ATen/ops/broadcast_to_native.h>
#include <ATen/ops/_sparse_broadcast_to_ops.h>
#include <ATen/ops/_sparse_broadcast_to_native.h>
#include <ATen/ops/_sparse_broadcast_to_copy_ops.h>
#include <ATen/ops/_sparse_broadcast_to_copy_native.h>
#include <ATen/ops/chunk_ops.h>
#include <ATen/ops/chunk_native.h>
#include <ATen/ops/tensor_split_ops.h>
#include <ATen/ops/tensor_split_native.h>
#include <ATen/ops/tensor_split_ops.h>
#include <ATen/ops/tensor_split_native.h>
#include <ATen/ops/tensor_split_ops.h>
#include <ATen/ops/tensor_split_native.h>
#include <ATen/ops/contiguous_ops.h>
#include <ATen/ops/contiguous_native.h>
#include <ATen/ops/diagonal_ops.h>
#include <ATen/ops/diagonal_native.h>
#include <ATen/ops/diagonal_copy_ops.h>
#include <ATen/ops/diagonal_copy_native.h>
#include <ATen/ops/linalg_diagonal_ops.h>
#include <ATen/ops/linalg_diagonal_native.h>
#include <ATen/ops/diagonal_ops.h>
#include <ATen/ops/diagonal_native.h>
#include <ATen/ops/expand_ops.h>
#include <ATen/ops/expand_native.h>
#include <ATen/ops/expand_copy_ops.h>
#include <ATen/ops/expand_copy_native.h>
#include <ATen/ops/expand_as_ops.h>
#include <ATen/ops/expand_as_native.h>
#include <ATen/ops/flatten_ops.h>
#include <ATen/ops/flatten_native.h>
#include <ATen/ops/flatten_ops.h>
#include <ATen/ops/flatten_native.h>
#include <ATen/ops/flatten_ops.h>
#include <ATen/ops/flatten_native.h>
#include <ATen/ops/flatten_ops.h>
#include <ATen/ops/flatten_native.h>
#include <ATen/ops/unflatten_ops.h>
#include <ATen/ops/unflatten_native.h>
#include <ATen/ops/unflatten_ops.h>
#include <ATen/ops/unflatten_native.h>
#include <ATen/ops/narrow_ops.h>
#include <ATen/ops/narrow_native.h>
#include <ATen/ops/narrow_copy_ops.h>
#include <ATen/ops/narrow_copy_native.h>
#include <ATen/ops/narrow_ops.h>
#include <ATen/ops/narrow_native.h>
#include <ATen/ops/permute_ops.h>
#include <ATen/ops/permute_native.h>
#include <ATen/ops/permute_copy_ops.h>
#include <ATen/ops/permute_copy_native.h>
#include <ATen/ops/movedim_ops.h>
#include <ATen/ops/movedim_native.h>
#include <ATen/ops/movedim_ops.h>
#include <ATen/ops/movedim_native.h>
#include <ATen/ops/moveaxis_ops.h>
#include <ATen/ops/moveaxis_native.h>
#include <ATen/ops/moveaxis_ops.h>
#include <ATen/ops/moveaxis_native.h>
#include <ATen/ops/numpy_T_ops.h>
#include <ATen/ops/numpy_T_native.h>
#include <ATen/ops/matrix_H_ops.h>
#include <ATen/ops/matrix_H_native.h>
#include <ATen/ops/mT_ops.h>
#include <ATen/ops/mT_native.h>
#include <ATen/ops/mH_ops.h>
#include <ATen/ops/mH_native.h>
#include <ATen/ops/adjoint_ops.h>
#include <ATen/ops/adjoint_native.h>
#include <ATen/ops/pin_memory_ops.h>
#include <ATen/ops/pin_memory_native.h>
#include <ATen/ops/ravel_ops.h>
#include <ATen/ops/ravel_native.h>
#include <ATen/ops/reshape_ops.h>
#include <ATen/ops/reshape_native.h>
#include <ATen/ops/_reshape_alias_ops.h>
#include <ATen/ops/_reshape_alias_native.h>
#include <ATen/ops/_reshape_alias_copy_ops.h>
#include <ATen/ops/_reshape_alias_copy_native.h>
#include <ATen/ops/reshape_as_ops.h>
#include <ATen/ops/reshape_as_native.h>
#include <ATen/ops/select_ops.h>
#include <ATen/ops/select_native.h>
#include <ATen/ops/select_ops.h>
#include <ATen/ops/select_native.h>
#include <ATen/ops/select_copy_ops.h>
#include <ATen/ops/select_copy_native.h>
#include <ATen/ops/detach_ops.h>
#include <ATen/ops/detach_native.h>
#include <ATen/ops/detach_copy_ops.h>
#include <ATen/ops/detach_copy_native.h>
#include <ATen/ops/slice_ops.h>
#include <ATen/ops/slice_native.h>
#include <ATen/ops/slice_copy_ops.h>
#include <ATen/ops/slice_copy_native.h>
#include <ATen/ops/slice_inverse_ops.h>
#include <ATen/ops/slice_inverse_native.h>
#include <ATen/ops/slice_scatter_ops.h>
#include <ATen/ops/slice_scatter_native.h>
#include <ATen/ops/split_ops.h>
#include <ATen/ops/split_native.h>
#include <ATen/ops/split_copy_ops.h>
#include <ATen/ops/split_copy_native.h>
#include <ATen/ops/split_ops.h>
#include <ATen/ops/split_native.h>
#include <ATen/ops/split_with_sizes_ops.h>
#include <ATen/ops/split_with_sizes_native.h>
#include <ATen/ops/split_with_sizes_copy_ops.h>
#include <ATen/ops/split_with_sizes_copy_native.h>
#include <ATen/ops/hsplit_ops.h>
#include <ATen/ops/hsplit_native.h>
#include <ATen/ops/hsplit_ops.h>
#include <ATen/ops/hsplit_native.h>
#include <ATen/ops/vsplit_ops.h>
#include <ATen/ops/vsplit_native.h>
#include <ATen/ops/vsplit_ops.h>
#include <ATen/ops/vsplit_native.h>
#include <ATen/ops/dsplit_ops.h>
#include <ATen/ops/dsplit_native.h>
#include <ATen/ops/dsplit_ops.h>
#include <ATen/ops/dsplit_native.h>
#include <ATen/ops/squeeze_ops.h>
#include <ATen/ops/squeeze_native.h>
#include <ATen/ops/squeeze_copy_ops.h>
#include <ATen/ops/squeeze_copy_native.h>
#include <ATen/ops/squeeze_ops.h>
#include <ATen/ops/squeeze_native.h>
#include <ATen/ops/squeeze_copy_ops.h>
#include <ATen/ops/squeeze_copy_native.h>
#include <ATen/ops/squeeze_ops.h>
#include <ATen/ops/squeeze_native.h>
#include <ATen/ops/squeeze_ops.h>
#include <ATen/ops/squeeze_native.h>
#include <ATen/ops/squeeze_copy_ops.h>
#include <ATen/ops/squeeze_copy_native.h>
#include <ATen/ops/t_ops.h>
#include <ATen/ops/t_native.h>
#include <ATen/ops/t_copy_ops.h>
#include <ATen/ops/t_copy_native.h>
#include <ATen/ops/transpose_ops.h>
#include <ATen/ops/transpose_native.h>
#include <ATen/ops/transpose_copy_ops.h>
#include <ATen/ops/transpose_copy_native.h>
#include <ATen/ops/transpose_ops.h>
#include <ATen/ops/transpose_native.h>
#include <ATen/ops/_nested_view_from_buffer_ops.h>
#include <ATen/ops/_nested_view_from_buffer_native.h>
#include <ATen/ops/_nested_view_from_buffer_copy_ops.h>
#include <ATen/ops/_nested_view_from_buffer_copy_native.h>
#include <ATen/ops/unsqueeze_ops.h>
#include <ATen/ops/unsqueeze_native.h>
#include <ATen/ops/unsqueeze_copy_ops.h>
#include <ATen/ops/unsqueeze_copy_native.h>
#include <ATen/ops/view_as_ops.h>
#include <ATen/ops/view_as_native.h>
#include <ATen/ops/positive_ops.h>
#include <ATen/ops/positive_native.h>
#include <ATen/ops/coalesce_ops.h>
#include <ATen/ops/coalesce_native.h>
#include <ATen/ops/_indices_ops.h>
#include <ATen/ops/_indices_native.h>
#include <ATen/ops/_indices_copy_ops.h>
#include <ATen/ops/_indices_copy_native.h>
#include <ATen/ops/_values_ops.h>
#include <ATen/ops/_values_native.h>
#include <ATen/ops/_values_copy_ops.h>
#include <ATen/ops/_values_copy_native.h>
#include <ATen/ops/indices_ops.h>
#include <ATen/ops/indices_native.h>
#include <ATen/ops/indices_copy_ops.h>
#include <ATen/ops/indices_copy_native.h>
#include <ATen/ops/values_ops.h>
#include <ATen/ops/values_native.h>
#include <ATen/ops/values_copy_ops.h>
#include <ATen/ops/values_copy_native.h>
#include <ATen/ops/crow_indices_ops.h>
#include <ATen/ops/crow_indices_native.h>
#include <ATen/ops/crow_indices_copy_ops.h>
#include <ATen/ops/crow_indices_copy_native.h>
#include <ATen/ops/col_indices_ops.h>
#include <ATen/ops/col_indices_native.h>
#include <ATen/ops/col_indices_copy_ops.h>
#include <ATen/ops/col_indices_copy_native.h>
#include <ATen/ops/ccol_indices_ops.h>
#include <ATen/ops/ccol_indices_native.h>
#include <ATen/ops/ccol_indices_copy_ops.h>
#include <ATen/ops/ccol_indices_copy_native.h>
#include <ATen/ops/row_indices_ops.h>
#include <ATen/ops/row_indices_native.h>
#include <ATen/ops/row_indices_copy_ops.h>
#include <ATen/ops/row_indices_copy_native.h>
#include <ATen/ops/unbind_ops.h>
#include <ATen/ops/unbind_native.h>
#include <ATen/ops/unbind_copy_ops.h>
#include <ATen/ops/unbind_copy_native.h>
#include <ATen/ops/unbind_ops.h>
#include <ATen/ops/unbind_native.h>
#include <ATen/ops/_autocast_to_reduced_precision_ops.h>
#include <ATen/ops/_autocast_to_reduced_precision_native.h>
#include <ATen/ops/_autocast_to_full_precision_ops.h>
#include <ATen/ops/_autocast_to_full_precision_native.h>
#include <ATen/ops/to_ops.h>
#include <ATen/ops/to_native.h>
#include <ATen/ops/to_ops.h>
#include <ATen/ops/to_native.h>
#include <ATen/ops/to_ops.h>
#include <ATen/ops/to_native.h>
#include <ATen/ops/to_ops.h>
#include <ATen/ops/to_native.h>
#include <ATen/ops/lift_fresh_ops.h>
#include <ATen/ops/lift_fresh_native.h>
#include <ATen/ops/lift_fresh_copy_ops.h>
#include <ATen/ops/lift_fresh_copy_native.h>
#include <ATen/ops/view_ops.h>
#include <ATen/ops/view_native.h>
#include <ATen/ops/view_copy_ops.h>
#include <ATen/ops/view_copy_native.h>
#include <ATen/ops/view_ops.h>
#include <ATen/ops/view_native.h>
#include <ATen/ops/view_copy_ops.h>
#include <ATen/ops/view_copy_native.h>
#include <ATen/ops/swapaxes_ops.h>
#include <ATen/ops/swapaxes_native.h>
#include <ATen/ops/swapdims_ops.h>
#include <ATen/ops/swapdims_native.h>
#include <ATen/ops/unfold_ops.h>
#include <ATen/ops/unfold_native.h>
#include <ATen/ops/unfold_copy_ops.h>
#include <ATen/ops/unfold_copy_native.h>
#include <ATen/ops/alias_ops.h>
#include <ATen/ops/alias_native.h>
#include <ATen/ops/alias_copy_ops.h>
#include <ATen/ops/alias_copy_native.h>
#include <ATen/ops/_test_autograd_multiple_dispatch_view_ops.h>
#include <ATen/ops/_test_autograd_multiple_dispatch_view_native.h>
#include <ATen/ops/_test_autograd_multiple_dispatch_view_copy_ops.h>
#include <ATen/ops/_test_autograd_multiple_dispatch_view_copy_native.h>
#include <ATen/ops/_new_zeros_with_same_feature_meta_ops.h>
#include <ATen/ops/_cudnn_ctc_loss_ops.h>
#include <ATen/ops/_cudnn_rnn_flatten_weight_ops.h>
#include <ATen/ops/_cudnn_rnn_ops.h>
#include <ATen/ops/_cudnn_rnn_backward_ops.h>
#include <ATen/ops/_cudnn_init_dropout_state_ops.h>
#include <ATen/ops/_fused_dropout_ops.h>
#include <ATen/ops/_masked_scale_ops.h>
#include <ATen/ops/native_dropout_ops.h>
#include <ATen/ops/native_dropout_backward_ops.h>
#include <ATen/ops/abs_ops.h>
#include <ATen/ops/abs_ops.h>
#include <ATen/ops/absolute_ops.h>
#include <ATen/ops/absolute_ops.h>
#include <ATen/ops/angle_ops.h>
#include <ATen/ops/sgn_ops.h>
#include <ATen/ops/sgn_ops.h>
#include <ATen/ops/_conj_physical_ops.h>
#include <ATen/ops/conj_physical_ops.h>
#include <ATen/ops/conj_physical_ops.h>
#include <ATen/ops/acos_ops.h>
#include <ATen/ops/acos_ops.h>
#include <ATen/ops/arccos_ops.h>
#include <ATen/ops/arccos_ops.h>
#include <ATen/ops/add_ops.h>
#include <ATen/ops/add_ops.h>
#include <ATen/ops/_add_relu_ops.h>
#include <ATen/ops/_add_relu_ops.h>
#include <ATen/ops/_add_relu_ops.h>
#include <ATen/ops/_add_relu_ops.h>
#include <ATen/ops/add_ops.h>
#include <ATen/ops/add_ops.h>
#include <ATen/ops/addmv_ops.h>
#include <ATen/ops/addmv_ops.h>
#include <ATen/ops/addr_ops.h>
#include <ATen/ops/addr_ops.h>
#include <ATen/ops/affine_grid_generator_ops.h>
#include <ATen/ops/_test_functorch_fallback_ops.h>
#include <ATen/ops/all_ops.h>
#include <ATen/ops/all_ops.h>
#include <ATen/ops/all_ops.h>
#include <ATen/ops/any_ops.h>
#include <ATen/ops/any_ops.h>
#include <ATen/ops/any_ops.h>
#include <ATen/ops/arange_ops.h>
#include <ATen/ops/arange_ops.h>
#include <ATen/ops/argmax_ops.h>
#include <ATen/ops/argmin_ops.h>
#include <ATen/ops/acosh_ops.h>
#include <ATen/ops/acosh_ops.h>
#include <ATen/ops/arccosh_ops.h>
#include <ATen/ops/arccosh_ops.h>
#include <ATen/ops/asinh_ops.h>
#include <ATen/ops/asinh_ops.h>
#include <ATen/ops/arcsinh_ops.h>
#include <ATen/ops/arcsinh_ops.h>
#include <ATen/ops/atanh_ops.h>
#include <ATen/ops/atanh_ops.h>
#include <ATen/ops/arctanh_ops.h>
#include <ATen/ops/arctanh_ops.h>
#include <ATen/ops/asin_ops.h>
#include <ATen/ops/asin_ops.h>
#include <ATen/ops/arcsin_ops.h>
#include <ATen/ops/arcsin_ops.h>
#include <ATen/ops/atan_ops.h>
#include <ATen/ops/atan_ops.h>
#include <ATen/ops/arctan_ops.h>
#include <ATen/ops/arctan_ops.h>
#include <ATen/ops/baddbmm_ops.h>
#include <ATen/ops/baddbmm_ops.h>
#include <ATen/ops/bartlett_window_ops.h>
#include <ATen/ops/bartlett_window_ops.h>
#include <ATen/ops/quantized_batch_norm_ops.h>
#include <ATen/ops/bernoulli_ops.h>
#include <ATen/ops/bernoulli_ops.h>
#include <ATen/ops/bernoulli_ops.h>
#include <ATen/ops/bernoulli_ops.h>
#include <ATen/ops/binary_cross_entropy_ops.h>
#include <ATen/ops/binary_cross_entropy_backward_ops.h>
#include <ATen/ops/binary_cross_entropy_with_logits_ops.h>
#include <ATen/ops/bincount_ops.h>
#include <ATen/ops/bitwise_not_ops.h>
#include <ATen/ops/bitwise_not_ops.h>
#include <ATen/ops/copysign_ops.h>
#include <ATen/ops/copysign_ops.h>
#include <ATen/ops/copysign_ops.h>
#include <ATen/ops/copysign_ops.h>
#include <ATen/ops/logical_not_ops.h>
#include <ATen/ops/logical_not_ops.h>
#include <ATen/ops/logical_xor_ops.h>
#include <ATen/ops/logical_xor_ops.h>
#include <ATen/ops/logical_and_ops.h>
#include <ATen/ops/logical_and_ops.h>
#include <ATen/ops/logical_or_ops.h>
#include <ATen/ops/logical_or_ops.h>
#include <ATen/ops/blackman_window_ops.h>
#include <ATen/ops/blackman_window_ops.h>
#include <ATen/ops/bmm_ops.h>
#include <ATen/ops/cat_ops.h>
#include <ATen/ops/cat_ops.h>
#include <ATen/ops/concat_ops.h>
#include <ATen/ops/concat_ops.h>
#include <ATen/ops/concatenate_ops.h>
#include <ATen/ops/concatenate_ops.h>
#include <ATen/ops/block_diag_ops.h>
#include <ATen/ops/ceil_ops.h>
#include <ATen/ops/ceil_ops.h>
#include <ATen/ops/chain_matmul_ops.h>
#include <ATen/ops/clamp_ops.h>
#include <ATen/ops/clamp_ops.h>
#include <ATen/ops/clamp_ops.h>
#include <ATen/ops/clamp_ops.h>
#include <ATen/ops/clamp_max_ops.h>
#include <ATen/ops/clamp_max_ops.h>
#include <ATen/ops/clamp_max_ops.h>
#include <ATen/ops/clamp_max_ops.h>
#include <ATen/ops/clamp_min_ops.h>
#include <ATen/ops/clamp_min_ops.h>
#include <ATen/ops/clamp_min_ops.h>
#include <ATen/ops/clamp_min_ops.h>
#include <ATen/ops/clip_ops.h>
#include <ATen/ops/clip_ops.h>
#include <ATen/ops/clip_ops.h>
#include <ATen/ops/clip_ops.h>
#include <ATen/ops/complex_ops.h>
#include <ATen/ops/polar_ops.h>
#include <ATen/ops/constant_pad_nd_ops.h>
#include <ATen/ops/convolution_ops.h>
#include <ATen/ops/convolution_backward_ops.h>
#include <ATen/ops/convolution_overrideable_ops.h>
#include <ATen/ops/convolution_backward_overrideable_ops.h>
#include <ATen/ops/_convolution_ops.h>
#include <ATen/ops/conv_tbc_ops.h>
#include <ATen/ops/copy_ops.h>
#include <ATen/ops/copy_ops.h>
#include <ATen/ops/_copy_from_ops.h>
#include <ATen/ops/_copy_from_and_resize_ops.h>
#include <ATen/ops/cos_ops.h>
#include <ATen/ops/cos_ops.h>
#include <ATen/ops/cosh_ops.h>
#include <ATen/ops/cosh_ops.h>
#include <ATen/ops/count_nonzero_ops.h>
#include <ATen/ops/count_nonzero_ops.h>
#include <ATen/ops/cudnn_affine_grid_generator_ops.h>
#include <ATen/ops/cudnn_affine_grid_generator_backward_ops.h>
#include <ATen/ops/cudnn_batch_norm_ops.h>
#include <ATen/ops/cudnn_batch_norm_backward_ops.h>
#include <ATen/ops/cudnn_convolution_ops.h>
#include <ATen/ops/cudnn_convolution_transpose_ops.h>
#include <ATen/ops/_mps_convolution_transpose_ops.h>
#include <ATen/ops/mps_convolution_transpose_backward_ops.h>
#include <ATen/ops/cudnn_convolution_relu_ops.h>
#include <ATen/ops/cudnn_convolution_add_relu_ops.h>
#include <ATen/ops/cudnn_grid_sampler_ops.h>
#include <ATen/ops/cudnn_grid_sampler_backward_ops.h>
#include <ATen/ops/cummax_ops.h>
#include <ATen/ops/cummax_ops.h>
#include <ATen/ops/cummin_ops.h>
#include <ATen/ops/cummin_ops.h>
#include <ATen/ops/cumprod_ops.h>
#include <ATen/ops/cumprod_ops.h>
#include <ATen/ops/cumprod_ops.h>
#include <ATen/ops/cumprod_ops.h>
#include <ATen/ops/cumsum_ops.h>
#include <ATen/ops/cumsum_ops.h>
#include <ATen/ops/cumsum_ops.h>
#include <ATen/ops/cumsum_ops.h>
#include <ATen/ops/_ctc_loss_ops.h>
#include <ATen/ops/_ctc_loss_ops.h>
#include <ATen/ops/_ctc_loss_backward_ops.h>
#include <ATen/ops/diag_embed_ops.h>
#include <ATen/ops/diagonal_backward_ops.h>
#include <ATen/ops/diff_ops.h>
#include <ATen/ops/div_ops.h>
#include <ATen/ops/div_ops.h>
#include <ATen/ops/div_ops.h>
#include <ATen/ops/div_ops.h>
#include <ATen/ops/div_ops.h>
#include <ATen/ops/div_ops.h>
#include <ATen/ops/div_ops.h>
#include <ATen/ops/div_ops.h>
#include <ATen/ops/divide_ops.h>
#include <ATen/ops/divide_ops.h>
#include <ATen/ops/divide_ops.h>
#include <ATen/ops/divide_ops.h>
#include <ATen/ops/true_divide_ops.h>
#include <ATen/ops/true_divide_ops.h>
#include <ATen/ops/dot_ops.h>
#include <ATen/ops/vdot_ops.h>
#include <ATen/ops/embedding_ops.h>
#include <ATen/ops/embedding_dense_backward_ops.h>
#include <ATen/ops/embedding_renorm_ops.h>
#include <ATen/ops/_embedding_bag_forward_only_ops.h>
#include <ATen/ops/row_stack_ops.h>
#include <ATen/ops/_embedding_bag_ops.h>
#include <ATen/ops/_embedding_bag_dense_backward_ops.h>
#include <ATen/ops/_embedding_bag_per_sample_weights_backward_ops.h>
#include <ATen/ops/empty_ops.h>
#include <ATen/ops/empty_ops.h>
#include <ATen/ops/empty_permuted_ops.h>
#include <ATen/ops/new_empty_ops.h>
#include <ATen/ops/new_empty_strided_ops.h>
#include <ATen/ops/new_full_ops.h>
#include <ATen/ops/new_zeros_ops.h>
#include <ATen/ops/new_ones_ops.h>
#include <ATen/ops/_empty_affine_quantized_ops.h>
#include <ATen/ops/_empty_per_channel_affine_quantized_ops.h>
#include <ATen/ops/resize_ops.h>
#include <ATen/ops/_resize_output_ops.h>
#include <ATen/ops/empty_quantized_ops.h>
#include <ATen/ops/empty_like_ops.h>
#include <ATen/ops/empty_strided_ops.h>
#include <ATen/ops/erf_ops.h>
#include <ATen/ops/erf_ops.h>
#include <ATen/ops/erfc_ops.h>
#include <ATen/ops/erfc_ops.h>
#include <ATen/ops/exp_ops.h>
#include <ATen/ops/exp_ops.h>
#include <ATen/ops/exp2_ops.h>
#include <ATen/ops/exp2_ops.h>
#include <ATen/ops/expm1_ops.h>
#include <ATen/ops/expm1_ops.h>
#include <ATen/ops/eye_ops.h>
#include <ATen/ops/eye_ops.h>
#include <ATen/ops/fill_ops.h>
#include <ATen/ops/fill_ops.h>
#include <ATen/ops/fill_ops.h>
#include <ATen/ops/fill_ops.h>
#include <ATen/ops/floor_ops.h>
#include <ATen/ops/floor_ops.h>
#include <ATen/ops/floor_divide_ops.h>
#include <ATen/ops/floor_divide_ops.h>
#include <ATen/ops/floor_divide_ops.h>
#include <ATen/ops/floor_divide_ops.h>
#include <ATen/ops/frac_ops.h>
#include <ATen/ops/frac_ops.h>
#include <ATen/ops/full_ops.h>
#include <ATen/ops/full_ops.h>
#include <ATen/ops/full_like_ops.h>
#include <ATen/ops/from_file_ops.h>
#include <ATen/ops/gcd_ops.h>
#include <ATen/ops/gcd_ops.h>
#include <ATen/ops/lcm_ops.h>
#include <ATen/ops/lcm_ops.h>
#include <ATen/ops/grid_sampler_2d_ops.h>
#include <ATen/ops/grid_sampler_2d_backward_ops.h>
#include <ATen/ops/_grid_sampler_2d_cpu_fallback_ops.h>
#include <ATen/ops/grid_sampler_3d_ops.h>
#include <ATen/ops/grid_sampler_3d_backward_ops.h>
#include <ATen/ops/hann_window_ops.h>
#include <ATen/ops/hann_window_ops.h>
#include <ATen/ops/hamming_window_ops.h>
#include <ATen/ops/hamming_window_ops.h>
#include <ATen/ops/hamming_window_ops.h>
#include <ATen/ops/hamming_window_ops.h>
#include <ATen/ops/kaiser_window_ops.h>
#include <ATen/ops/kaiser_window_ops.h>
#include <ATen/ops/kaiser_window_ops.h>
#include <ATen/ops/native_group_norm_ops.h>
#include <ATen/ops/native_group_norm_backward_ops.h>
#include <ATen/ops/_fft_r2c_ops.h>
#include <ATen/ops/_fft_c2r_ops.h>
#include <ATen/ops/_fft_c2c_ops.h>
#include <ATen/ops/index_ops.h>
#include <ATen/ops/index_copy_ops.h>
#include <ATen/ops/index_copy_ops.h>
#include <ATen/ops/index_put_ops.h>
#include <ATen/ops/index_put_ops.h>
#include <ATen/ops/_index_put_impl_ops.h>
#include <ATen/ops/isin_ops.h>
#include <ATen/ops/isin_ops.h>
#include <ATen/ops/isin_ops.h>
#include <ATen/ops/isnan_ops.h>
#include <ATen/ops/kron_ops.h>
#include <ATen/ops/kthvalue_ops.h>
#include <ATen/ops/kthvalue_ops.h>
#include <ATen/ops/native_layer_norm_ops.h>
#include <ATen/ops/native_layer_norm_backward_ops.h>
#include <ATen/ops/nan_to_num_ops.h>
#include <ATen/ops/nan_to_num_ops.h>
#include <ATen/ops/linear_ops.h>
#include <ATen/ops/linear_backward_ops.h>
#include <ATen/ops/mkldnn_linear_ops.h>
#include <ATen/ops/mkldnn_linear_backward_input_ops.h>
#include <ATen/ops/mkldnn_linear_backward_weights_ops.h>
#include <ATen/ops/mkldnn_linear_backward_ops.h>
#include <ATen/ops/ldexp_ops.h>
#include <ATen/ops/ldexp_ops.h>
#include <ATen/ops/linspace_ops.h>
#include <ATen/ops/linspace_ops.h>
#include <ATen/ops/linspace_ops.h>
#include <ATen/ops/linspace_ops.h>
#include <ATen/ops/log_ops.h>
#include <ATen/ops/log_ops.h>
#include <ATen/ops/log10_ops.h>
#include <ATen/ops/log10_ops.h>
#include <ATen/ops/log1p_ops.h>
#include <ATen/ops/log1p_ops.h>
#include <ATen/ops/log2_ops.h>
#include <ATen/ops/log2_ops.h>
#include <ATen/ops/logaddexp_ops.h>
#include <ATen/ops/logaddexp2_ops.h>
#include <ATen/ops/xlogy_ops.h>
#include <ATen/ops/xlogy_ops.h>
#include <ATen/ops/xlogy_ops.h>
#include <ATen/ops/xlogy_ops.h>
#include <ATen/ops/xlogy_ops.h>
#include <ATen/ops/logspace_ops.h>
#include <ATen/ops/logspace_ops.h>
#include <ATen/ops/logspace_ops.h>
#include <ATen/ops/logspace_ops.h>
#include <ATen/ops/log_softmax_ops.h>
#include <ATen/ops/_log_softmax_ops.h>
#include <ATen/ops/_log_softmax_backward_data_ops.h>
#include <ATen/ops/_logcumsumexp_ops.h>
#include <ATen/ops/logcumsumexp_ops.h>
#include <ATen/ops/logcumsumexp_ops.h>
#include <ATen/ops/logsumexp_ops.h>
#include <ATen/ops/logsumexp_ops.h>
#include <ATen/ops/matmul_ops.h>
#include <ATen/ops/matmul_backward_ops.h>
#include <ATen/ops/matrix_power_ops.h>
#include <ATen/ops/_aminmax_ops.h>
#include <ATen/ops/_aminmax_ops.h>
#include <ATen/ops/aminmax_ops.h>
#include <ATen/ops/_compute_linear_combination_ops.h>
#include <ATen/ops/max_ops.h>
#include <ATen/ops/max_ops.h>
#include <ATen/ops/amax_ops.h>
#include <ATen/ops/max_pool2d_backward_ops.h>
#include <ATen/ops/mkldnn_max_pool2d_ops.h>
#include <ATen/ops/mkldnn_max_pool2d_backward_ops.h>
#include <ATen/ops/mkldnn_max_pool3d_ops.h>
#include <ATen/ops/mkldnn_max_pool3d_backward_ops.h>
#include <ATen/ops/quantized_max_pool1d_ops.h>
#include <ATen/ops/quantized_max_pool2d_ops.h>
#include <ATen/ops/quantized_max_pool3d_ops.h>
#include <ATen/ops/mean_ops.h>
#include <ATen/ops/mean_ops.h>
#include <ATen/ops/nanmean_ops.h>
#include <ATen/ops/median_ops.h>
#include <ATen/ops/median_ops.h>
#include <ATen/ops/median_ops.h>
#include <ATen/ops/nanmedian_ops.h>
#include <ATen/ops/nanmedian_ops.h>
#include <ATen/ops/nanmedian_ops.h>
#include <ATen/ops/min_ops.h>
#include <ATen/ops/min_ops.h>
#include <ATen/ops/amin_ops.h>
#include <ATen/ops/_mps_convolution_ops.h>
#include <ATen/ops/mps_convolution_backward_ops.h>
#include <ATen/ops/mkldnn_convolution_ops.h>
#include <ATen/ops/mkldnn_rnn_layer_ops.h>
#include <ATen/ops/mkldnn_rnn_layer_backward_ops.h>
#include <ATen/ops/miopen_batch_norm_ops.h>
#include <ATen/ops/miopen_batch_norm_backward_ops.h>
#include <ATen/ops/miopen_convolution_ops.h>
#include <ATen/ops/miopen_convolution_transpose_ops.h>
#include <ATen/ops/miopen_depthwise_convolution_ops.h>
#include <ATen/ops/miopen_rnn_ops.h>
#include <ATen/ops/miopen_rnn_backward_ops.h>
#include <ATen/ops/mm_ops.h>
#include <ATen/ops/_int_mm_ops.h>
#include <ATen/ops/_sparse_sparse_matmul_ops.h>
#include <ATen/ops/mode_ops.h>
#include <ATen/ops/mode_ops.h>
#include <ATen/ops/mul_ops.h>
#include <ATen/ops/mul_ops.h>
#include <ATen/ops/mul_ops.h>
#include <ATen/ops/mul_ops.h>
#include <ATen/ops/multiply_ops.h>
#include <ATen/ops/multiply_ops.h>
#include <ATen/ops/mv_ops.h>
#include <ATen/ops/mvlgamma_ops.h>
#include <ATen/ops/mvlgamma_ops.h>
#include <ATen/ops/narrow_copy_ops.h>
#include <ATen/ops/native_batch_norm_ops.h>
#include <ATen/ops/_native_batch_norm_legit_ops.h>
#include <ATen/ops/_native_batch_norm_legit_no_training_ops.h>
#include <ATen/ops/_native_batch_norm_legit_ops.h>
#include <ATen/ops/batch_norm_stats_ops.h>
#include <ATen/ops/batch_norm_elemt_ops.h>
#include <ATen/ops/batch_norm_gather_stats_ops.h>
#include <ATen/ops/batch_norm_gather_stats_with_counts_ops.h>
#include <ATen/ops/native_batch_norm_backward_ops.h>
#include <ATen/ops/batch_norm_backward_reduce_ops.h>
#include <ATen/ops/batch_norm_backward_elemt_ops.h>
#include <ATen/ops/batch_norm_update_stats_ops.h>
#include <ATen/ops/_nnpack_spatial_convolution_ops.h>
#include <ATen/ops/ones_ops.h>
#include <ATen/ops/ones_ops.h>
#include <ATen/ops/ones_like_ops.h>
#include <ATen/ops/_euclidean_dist_ops.h>
#include <ATen/ops/_cdist_forward_ops.h>
#include <ATen/ops/_cdist_backward_ops.h>
#include <ATen/ops/_pdist_forward_ops.h>
#include <ATen/ops/_pdist_backward_ops.h>
#include <ATen/ops/pixel_shuffle_ops.h>
#include <ATen/ops/pixel_unshuffle_ops.h>
#include <ATen/ops/channel_shuffle_ops.h>
#include <ATen/ops/_pin_memory_ops.h>
#include <ATen/ops/rad2deg_ops.h>
#include <ATen/ops/rad2deg_ops.h>
#include <ATen/ops/deg2rad_ops.h>
#include <ATen/ops/deg2rad_ops.h>
#include <ATen/ops/scalar_tensor_ops.h>
#include <ATen/ops/rand_ops.h>
#include <ATen/ops/rand_ops.h>
#include <ATen/ops/rand_ops.h>
#include <ATen/ops/rand_ops.h>
#include <ATen/ops/rand_like_ops.h>
#include <ATen/ops/randint_ops.h>
#include <ATen/ops/randint_ops.h>
#include <ATen/ops/randint_ops.h>
#include <ATen/ops/randint_ops.h>
#include <ATen/ops/randint_like_ops.h>
#include <ATen/ops/randint_like_ops.h>
#include <ATen/ops/randn_ops.h>
#include <ATen/ops/randn_ops.h>
#include <ATen/ops/randn_ops.h>
#include <ATen/ops/randn_ops.h>
#include <ATen/ops/randn_like_ops.h>
#include <ATen/ops/randperm_ops.h>
#include <ATen/ops/randperm_ops.h>
#include <ATen/ops/range_ops.h>
#include <ATen/ops/range_ops.h>
#include <ATen/ops/reciprocal_ops.h>
#include <ATen/ops/reciprocal_ops.h>
#include <ATen/ops/neg_ops.h>
#include <ATen/ops/neg_ops.h>
#include <ATen/ops/negative_ops.h>
#include <ATen/ops/negative_ops.h>
#include <ATen/ops/repeat_ops.h>
#include <ATen/ops/repeat_interleave_ops.h>
#include <ATen/ops/_mkldnn_reshape_ops.h>
#include <ATen/ops/round_ops.h>
#include <ATen/ops/round_ops.h>
#include <ATen/ops/round_ops.h>
#include <ATen/ops/round_ops.h>
#include <ATen/ops/relu_ops.h>
#include <ATen/ops/relu_ops.h>
#include <ATen/ops/gelu_ops.h>
#include <ATen/ops/gelu_ops.h>
#include <ATen/ops/gelu_backward_ops.h>
#include <ATen/ops/hardshrink_ops.h>
#include <ATen/ops/hardshrink_backward_ops.h>
#include <ATen/ops/rsqrt_ops.h>
#include <ATen/ops/rsqrt_ops.h>
#include <ATen/ops/select_backward_ops.h>
#include <ATen/ops/celu_ops.h>
#include <ATen/ops/celu_ops.h>
#include <ATen/ops/silu_ops.h>
#include <ATen/ops/silu_ops.h>
#include <ATen/ops/silu_backward_ops.h>
#include <ATen/ops/mish_ops.h>
#include <ATen/ops/mish_ops.h>
#include <ATen/ops/sigmoid_ops.h>
#include <ATen/ops/sigmoid_ops.h>
#include <ATen/ops/logit_ops.h>
#include <ATen/ops/logit_ops.h>
#include <ATen/ops/sin_ops.h>
#include <ATen/ops/sin_ops.h>
#include <ATen/ops/sinc_ops.h>
#include <ATen/ops/sinc_ops.h>
#include <ATen/ops/sinh_ops.h>
#include <ATen/ops/sinh_ops.h>
#include <ATen/ops/slice_backward_ops.h>
#include <ATen/ops/slice_scatter_ops.h>
#include <ATen/ops/select_scatter_ops.h>
#include <ATen/ops/diagonal_scatter_ops.h>
#include <ATen/ops/as_strided_scatter_ops.h>
#include <ATen/ops/softmax_ops.h>
#include <ATen/ops/_softmax_ops.h>
#include <ATen/ops/_softmax_backward_data_ops.h>
#include <ATen/ops/unsafe_split_ops.h>
#include <ATen/ops/unsafe_split_with_sizes_ops.h>
#include <ATen/ops/sspaddmm_ops.h>
#include <ATen/ops/stack_ops.h>
#include <ATen/ops/_stack_ops.h>
#include <ATen/ops/hstack_ops.h>
#include <ATen/ops/vstack_ops.h>
#include <ATen/ops/dstack_ops.h>
#include <ATen/ops/sum_ops.h>
#include <ATen/ops/sum_ops.h>
#include <ATen/ops/sum_ops.h>
#include <ATen/ops/nansum_ops.h>
#include <ATen/ops/sqrt_ops.h>
#include <ATen/ops/sqrt_ops.h>
#include <ATen/ops/square_ops.h>
#include <ATen/ops/square_ops.h>
#include <ATen/ops/std_ops.h>
#include <ATen/ops/std_ops.h>
#include <ATen/ops/std_mean_ops.h>
#include <ATen/ops/std_ops.h>
#include <ATen/ops/std_ops.h>
#include <ATen/ops/prod_ops.h>
#include <ATen/ops/prod_ops.h>
#include <ATen/ops/prod_ops.h>
#include <ATen/ops/tan_ops.h>
#include <ATen/ops/tan_ops.h>
#include <ATen/ops/tanh_ops.h>
#include <ATen/ops/tanh_ops.h>
#include <ATen/ops/tensordot_ops.h>
#include <ATen/ops/threshold_ops.h>
#include <ATen/ops/threshold_ops.h>
#include <ATen/ops/threshold_backward_ops.h>
#include <ATen/ops/_mkldnn_transpose_ops.h>
#include <ATen/ops/_mkldnn_transpose_ops.h>
#include <ATen/ops/flip_ops.h>
#include <ATen/ops/roll_ops.h>
#include <ATen/ops/rot90_ops.h>
#include <ATen/ops/_transform_bias_rescale_qkv_ops.h>
#include <ATen/ops/_nested_tensor_from_mask_ops.h>
#include <ATen/ops/_nested_from_padded_ops.h>
#include <ATen/ops/_nested_tensor_size_ops.h>
#include <ATen/ops/_nested_tensor_strides_ops.h>
#include <ATen/ops/_nested_tensor_storage_offsets_ops.h>
#include <ATen/ops/_nested_from_padded_and_nested_example_ops.h>
#include <ATen/ops/_nested_view_from_buffer_copy_ops.h>
#include <ATen/ops/_trilinear_ops.h>
#include <ATen/ops/trunc_ops.h>
#include <ATen/ops/trunc_ops.h>
#include <ATen/ops/fix_ops.h>
#include <ATen/ops/fix_ops.h>
#include <ATen/ops/_unique_ops.h>
#include <ATen/ops/unique_dim_ops.h>
#include <ATen/ops/unique_consecutive_ops.h>
#include <ATen/ops/unique_dim_consecutive_ops.h>
#include <ATen/ops/_unique2_ops.h>
#include <ATen/ops/_unsafe_view_ops.h>
#include <ATen/ops/var_ops.h>
#include <ATen/ops/var_ops.h>
#include <ATen/ops/var_ops.h>
#include <ATen/ops/var_ops.h>
#include <ATen/ops/var_mean_ops.h>
#include <ATen/ops/where_ops.h>
#include <ATen/ops/_weight_norm_interface_ops.h>
#include <ATen/ops/_weight_norm_interface_backward_ops.h>
#include <ATen/ops/zeros_ops.h>
#include <ATen/ops/_efficientzerotensor_ops.h>
#include <ATen/ops/zeros_ops.h>
#include <ATen/ops/zeros_like_ops.h>
#include <ATen/ops/_standard_gamma_grad_ops.h>
#include <ATen/ops/_standard_gamma_ops.h>
#include <ATen/ops/_dirichlet_grad_ops.h>
#include <ATen/ops/_sample_dirichlet_ops.h>
#include <ATen/ops/poisson_ops.h>
#include <ATen/ops/binomial_ops.h>
#include <ATen/ops/native_norm_ops.h>
#include <ATen/ops/native_norm_ops.h>
#include <ATen/ops/_sparse_sum_ops.h>
#include <ATen/ops/_sparse_sum_backward_ops.h>
#include <ATen/ops/_sparse_csr_sum_ops.h>
#include <ATen/ops/_sparse_csr_prod_ops.h>
#include <ATen/ops/_sparse_softmax_ops.h>
#include <ATen/ops/_sparse_softmax_backward_data_ops.h>
#include <ATen/ops/_sparse_log_softmax_ops.h>
#include <ATen/ops/_sparse_log_softmax_backward_data_ops.h>
#include <ATen/ops/_spdiags_ops.h>
#include <ATen/ops/norm_ops.h>
#include <ATen/ops/norm_ops.h>
#include <ATen/ops/norm_ops.h>
#include <ATen/ops/norm_ops.h>
#include <ATen/ops/norm_ops.h>
#include <ATen/ops/norm_ops.h>
#include <ATen/ops/frexp_ops.h>
#include <ATen/ops/frobenius_norm_ops.h>
#include <ATen/ops/nuclear_norm_ops.h>
#include <ATen/ops/nuclear_norm_ops.h>
#include <ATen/ops/clone_ops.h>
#include <ATen/ops/resize_as_ops.h>
#include <ATen/ops/resize_as_sparse_ops.h>
#include <ATen/ops/zero_ops.h>
#include <ATen/ops/sub_ops.h>
#include <ATen/ops/sub_ops.h>
#include <ATen/ops/sub_ops.h>
#include <ATen/ops/sub_ops.h>
#include <ATen/ops/subtract_ops.h>
#include <ATen/ops/subtract_ops.h>
#include <ATen/ops/rsub_ops.h>
#include <ATen/ops/heaviside_ops.h>
#include <ATen/ops/heaviside_ops.h>
#include <ATen/ops/rsub_ops.h>
#include <ATen/ops/_sparse_addmm_ops.h>
#include <ATen/ops/sparse_sampled_addmm_ops.h>
#include <ATen/ops/addmm_ops.h>
#include <ATen/ops/addmm_ops.h>
#include <ATen/ops/_addmm_activation_ops.h>
#include <ATen/ops/_scaled_mm_ops.h>
#include <ATen/ops/sparse_coo_tensor_ops.h>
#include <ATen/ops/_sparse_coo_tensor_with_dims_ops.h>
#include <ATen/ops/_sparse_coo_tensor_with_dims_and_tensors_ops.h>
#include <ATen/ops/sparse_resize_ops.h>
#include <ATen/ops/sparse_resize_and_clear_ops.h>
#include <ATen/ops/sparse_mask_ops.h>
#include <ATen/ops/_sparse_mask_projection_ops.h>
#include <ATen/ops/_to_dense_ops.h>
#include <ATen/ops/_coalesce_ops.h>
#include <ATen/ops/_coalesced_ops.h>
#include <ATen/ops/hspmm_ops.h>
#include <ATen/ops/copy_sparse_to_sparse_ops.h>
#include <ATen/ops/_to_sparse_ops.h>
#include <ATen/ops/_to_sparse_ops.h>
#include <ATen/ops/_to_sparse_csr_ops.h>
#include <ATen/ops/_to_sparse_csc_ops.h>
#include <ATen/ops/_to_sparse_bsr_ops.h>
#include <ATen/ops/_to_sparse_bsc_ops.h>
#include <ATen/ops/to_mkldnn_ops.h>
#include <ATen/ops/mkldnn_reorder_conv2d_weight_ops.h>
#include <ATen/ops/mkldnn_reorder_conv3d_weight_ops.h>
#include <ATen/ops/quantize_per_tensor_dynamic_ops.h>
#include <ATen/ops/quantize_per_tensor_ops.h>
#include <ATen/ops/quantize_per_tensor_ops.h>
#include <ATen/ops/quantize_per_tensor_ops.h>
#include <ATen/ops/quantize_per_channel_ops.h>
#include <ATen/ops/dequantize_ops.h>
#include <ATen/ops/dequantize_ops.h>
#include <ATen/ops/q_per_channel_scales_ops.h>
#include <ATen/ops/q_per_channel_zero_points_ops.h>
#include <ATen/ops/int_repr_ops.h>
#include <ATen/ops/_make_per_tensor_quantized_tensor_ops.h>
#include <ATen/ops/_make_per_channel_quantized_tensor_ops.h>
#include <ATen/ops/fake_quantize_per_tensor_affine_cachemask_ops.h>
#include <ATen/ops/_fake_quantize_per_tensor_affine_cachemask_tensor_qparams_ops.h>
#include <ATen/ops/_fake_quantize_learnable_per_tensor_affine_ops.h>
#include <ATen/ops/fake_quantize_per_channel_affine_cachemask_ops.h>
#include <ATen/ops/_fake_quantize_learnable_per_channel_affine_ops.h>
#include <ATen/ops/_fused_moving_avg_obs_fq_helper_ops.h>
#include <ATen/ops/_to_copy_ops.h>
#include <ATen/ops/_lstm_mps_ops.h>
#include <ATen/ops/lstm_mps_backward_ops.h>
#include <ATen/ops/_thnn_fused_lstm_cell_ops.h>
#include <ATen/ops/_thnn_fused_lstm_cell_backward_impl_ops.h>
#include <ATen/ops/_thnn_fused_gru_cell_ops.h>
#include <ATen/ops/_thnn_fused_gru_cell_backward_ops.h>
#include <ATen/ops/_pack_padded_sequence_ops.h>
#include <ATen/ops/set_ops.h>
#include <ATen/ops/set_ops.h>
#include <ATen/ops/set_ops.h>
#include <ATen/ops/set_ops.h>
#include <ATen/ops/lift_ops.h>
#include <ATen/ops/lift_fresh_copy_ops.h>
#include <ATen/ops/masked_fill_ops.h>
#include <ATen/ops/masked_fill_ops.h>
#include <ATen/ops/masked_fill_ops.h>
#include <ATen/ops/masked_fill_ops.h>
#include <ATen/ops/masked_scatter_ops.h>
#include <ATen/ops/masked_scatter_ops.h>
#include <ATen/ops/_masked_softmax_ops.h>
#include <ATen/ops/_masked_softmax_backward_ops.h>
#include <ATen/ops/put_ops.h>
#include <ATen/ops/put_ops.h>
#include <ATen/ops/index_add_ops.h>
#include <ATen/ops/index_add_ops.h>
#include <ATen/ops/index_reduce_ops.h>
#include <ATen/ops/index_reduce_ops.h>
#include <ATen/ops/index_fill_ops.h>
#include <ATen/ops/index_fill_ops.h>
#include <ATen/ops/index_fill_ops.h>
#include <ATen/ops/index_fill_ops.h>
#include <ATen/ops/scatter_ops.h>
#include <ATen/ops/scatter_ops.h>
#include <ATen/ops/scatter_ops.h>
#include <ATen/ops/scatter_ops.h>
#include <ATen/ops/scatter_ops.h>
#include <ATen/ops/scatter_ops.h>
#include <ATen/ops/scatter_ops.h>
#include <ATen/ops/scatter_ops.h>
#include <ATen/ops/scatter_add_ops.h>
#include <ATen/ops/scatter_add_ops.h>
#include <ATen/ops/scatter_reduce_ops.h>
#include <ATen/ops/scatter_reduce_ops.h>
#include <ATen/ops/eq_ops.h>
#include <ATen/ops/eq_ops.h>
#include <ATen/ops/eq_ops.h>
#include <ATen/ops/eq_ops.h>
#include <ATen/ops/bitwise_and_ops.h>
#include <ATen/ops/bitwise_and_ops.h>
#include <ATen/ops/bitwise_and_ops.h>
#include <ATen/ops/bitwise_and_ops.h>
#include <ATen/ops/bitwise_and_ops.h>
#include <ATen/ops/bitwise_or_ops.h>
#include <ATen/ops/bitwise_or_ops.h>
#include <ATen/ops/bitwise_or_ops.h>
#include <ATen/ops/bitwise_or_ops.h>
#include <ATen/ops/bitwise_or_ops.h>
#include <ATen/ops/bitwise_xor_ops.h>
#include <ATen/ops/bitwise_xor_ops.h>
#include <ATen/ops/bitwise_xor_ops.h>
#include <ATen/ops/bitwise_xor_ops.h>
#include <ATen/ops/bitwise_xor_ops.h>
#include <ATen/ops/lshift_ops.h>
#include <ATen/ops/lshift_ops.h>
#include <ATen/ops/lshift_ops.h>
#include <ATen/ops/lshift_ops.h>
#include <ATen/ops/bitwise_left_shift_ops.h>
#include <ATen/ops/bitwise_left_shift_ops.h>
#include <ATen/ops/bitwise_left_shift_ops.h>
#include <ATen/ops/bitwise_left_shift_ops.h>
#include <ATen/ops/bitwise_left_shift_ops.h>
#include <ATen/ops/rshift_ops.h>
#include <ATen/ops/rshift_ops.h>
#include <ATen/ops/rshift_ops.h>
#include <ATen/ops/rshift_ops.h>
#include <ATen/ops/bitwise_right_shift_ops.h>
#include <ATen/ops/bitwise_right_shift_ops.h>
#include <ATen/ops/bitwise_right_shift_ops.h>
#include <ATen/ops/bitwise_right_shift_ops.h>
#include <ATen/ops/bitwise_right_shift_ops.h>
#include <ATen/ops/tril_ops.h>
#include <ATen/ops/tril_ops.h>
#include <ATen/ops/triu_ops.h>
#include <ATen/ops/triu_ops.h>
#include <ATen/ops/digamma_ops.h>
#include <ATen/ops/digamma_ops.h>
#include <ATen/ops/lerp_ops.h>
#include <ATen/ops/lerp_ops.h>
#include <ATen/ops/lerp_ops.h>
#include <ATen/ops/lerp_ops.h>
#include <ATen/ops/addbmm_ops.h>
#include <ATen/ops/addbmm_ops.h>
#include <ATen/ops/random_ops.h>
#include <ATen/ops/random_ops.h>
#include <ATen/ops/random_ops.h>
#include <ATen/ops/uniform_ops.h>
#include <ATen/ops/cauchy_ops.h>
#include <ATen/ops/log_normal_ops.h>
#include <ATen/ops/exponential_ops.h>
#include <ATen/ops/geometric_ops.h>
#include <ATen/ops/diag_ops.h>
#include <ATen/ops/cross_ops.h>
#include <ATen/ops/tril_indices_ops.h>
#include <ATen/ops/triu_indices_ops.h>
#include <ATen/ops/trace_ops.h>
#include <ATen/ops/ne_ops.h>
#include <ATen/ops/ne_ops.h>
#include <ATen/ops/ne_ops.h>
#include <ATen/ops/ne_ops.h>
#include <ATen/ops/not_equal_ops.h>
#include <ATen/ops/not_equal_ops.h>
#include <ATen/ops/not_equal_ops.h>
#include <ATen/ops/not_equal_ops.h>
#include <ATen/ops/ge_ops.h>
#include <ATen/ops/ge_ops.h>
#include <ATen/ops/ge_ops.h>
#include <ATen/ops/ge_ops.h>
#include <ATen/ops/greater_equal_ops.h>
#include <ATen/ops/greater_equal_ops.h>
#include <ATen/ops/greater_equal_ops.h>
#include <ATen/ops/greater_equal_ops.h>
#include <ATen/ops/le_ops.h>
#include <ATen/ops/le_ops.h>
#include <ATen/ops/le_ops.h>
#include <ATen/ops/le_ops.h>
#include <ATen/ops/less_equal_ops.h>
#include <ATen/ops/less_equal_ops.h>
#include <ATen/ops/less_equal_ops.h>
#include <ATen/ops/less_equal_ops.h>
#include <ATen/ops/gt_ops.h>
#include <ATen/ops/gt_ops.h>
#include <ATen/ops/gt_ops.h>
#include <ATen/ops/gt_ops.h>
#include <ATen/ops/greater_ops.h>
#include <ATen/ops/greater_ops.h>
#include <ATen/ops/greater_ops.h>
#include <ATen/ops/greater_ops.h>
#include <ATen/ops/lt_ops.h>
#include <ATen/ops/lt_ops.h>
#include <ATen/ops/lt_ops.h>
#include <ATen/ops/lt_ops.h>
#include <ATen/ops/less_ops.h>
#include <ATen/ops/less_ops.h>
#include <ATen/ops/less_ops.h>
#include <ATen/ops/less_ops.h>
#include <ATen/ops/take_ops.h>
#include <ATen/ops/take_along_dim_ops.h>
#include <ATen/ops/index_select_ops.h>
#include <ATen/ops/index_select_ops.h>
#include <ATen/ops/masked_select_ops.h>
#include <ATen/ops/nonzero_ops.h>
#include <ATen/ops/nonzero_static_ops.h>
#include <ATen/ops/gather_ops.h>
#include <ATen/ops/gather_ops.h>
#include <ATen/ops/addcmul_ops.h>
#include <ATen/ops/addcmul_ops.h>
#include <ATen/ops/addcdiv_ops.h>
#include <ATen/ops/addcdiv_ops.h>
#include <ATen/ops/triangular_solve_ops.h>
#include <ATen/ops/linalg_solve_triangular_ops.h>
#include <ATen/ops/svd_ops.h>
#include <ATen/ops/cholesky_ops.h>
#include <ATen/ops/cholesky_solve_ops.h>
#include <ATen/ops/_cholesky_solve_helper_ops.h>
#include <ATen/ops/cholesky_inverse_ops.h>
#include <ATen/ops/qr_ops.h>
#include <ATen/ops/geqrf_ops.h>
#include <ATen/ops/orgqr_ops.h>
#include <ATen/ops/ormqr_ops.h>
#include <ATen/ops/lu_solve_ops.h>
#include <ATen/ops/lu_unpack_ops.h>
#include <ATen/ops/multinomial_ops.h>
#include <ATen/ops/lgamma_ops.h>
#include <ATen/ops/lgamma_ops.h>
#include <ATen/ops/polygamma_ops.h>
#include <ATen/ops/erfinv_ops.h>
#include <ATen/ops/erfinv_ops.h>
#include <ATen/ops/i0_ops.h>
#include <ATen/ops/i0_ops.h>
#include <ATen/ops/sign_ops.h>
#include <ATen/ops/sign_ops.h>
#include <ATen/ops/signbit_ops.h>
#include <ATen/ops/dist_ops.h>
#include <ATen/ops/atan2_ops.h>
#include <ATen/ops/atan2_ops.h>
#include <ATen/ops/arctan2_ops.h>
#include <ATen/ops/arctan2_ops.h>
#include <ATen/ops/histc_ops.h>
#include <ATen/ops/histogram_ops.h>
#include <ATen/ops/histogram_ops.h>
#include <ATen/ops/_histogramdd_bin_edges_ops.h>
#include <ATen/ops/_histogramdd_from_bin_cts_ops.h>
#include <ATen/ops/_histogramdd_from_bin_tensors_ops.h>
#include <ATen/ops/fmod_ops.h>
#include <ATen/ops/fmod_ops.h>
#include <ATen/ops/fmod_ops.h>
#include <ATen/ops/fmod_ops.h>
#include <ATen/ops/hypot_ops.h>
#include <ATen/ops/hypot_ops.h>
#include <ATen/ops/igamma_ops.h>
#include <ATen/ops/igamma_ops.h>
#include <ATen/ops/igammac_ops.h>
#include <ATen/ops/igammac_ops.h>
#include <ATen/ops/nextafter_ops.h>
#include <ATen/ops/nextafter_ops.h>
#include <ATen/ops/remainder_ops.h>
#include <ATen/ops/remainder_ops.h>
#include <ATen/ops/remainder_ops.h>
#include <ATen/ops/remainder_ops.h>
#include <ATen/ops/remainder_ops.h>
#include <ATen/ops/min_ops.h>
#include <ATen/ops/fmin_ops.h>
#include <ATen/ops/max_ops.h>
#include <ATen/ops/fmax_ops.h>
#include <ATen/ops/maximum_ops.h>
#include <ATen/ops/max_ops.h>
#include <ATen/ops/minimum_ops.h>
#include <ATen/ops/min_ops.h>
#include <ATen/ops/quantile_ops.h>
#include <ATen/ops/quantile_ops.h>
#include <ATen/ops/nanquantile_ops.h>
#include <ATen/ops/nanquantile_ops.h>
#include <ATen/ops/sort_ops.h>
#include <ATen/ops/sort_ops.h>
#include <ATen/ops/sort_ops.h>
#include <ATen/ops/sort_ops.h>
#include <ATen/ops/msort_ops.h>
#include <ATen/ops/argsort_ops.h>
#include <ATen/ops/topk_ops.h>
#include <ATen/ops/all_ops.h>
#include <ATen/ops/any_ops.h>
#include <ATen/ops/renorm_ops.h>
#include <ATen/ops/renorm_ops.h>
#include <ATen/ops/unfold_backward_ops.h>
#include <ATen/ops/pow_ops.h>
#include <ATen/ops/pow_ops.h>
#include <ATen/ops/pow_ops.h>
#include <ATen/ops/pow_ops.h>
#include <ATen/ops/pow_ops.h>
#include <ATen/ops/float_power_ops.h>
#include <ATen/ops/float_power_ops.h>
#include <ATen/ops/float_power_ops.h>
#include <ATen/ops/float_power_ops.h>
#include <ATen/ops/float_power_ops.h>
#include <ATen/ops/normal_ops.h>
#include <ATen/ops/normal_ops.h>
#include <ATen/ops/normal_ops.h>
#include <ATen/ops/normal_ops.h>
#include <ATen/ops/normal_ops.h>
#include <ATen/ops/normal_ops.h>
#include <ATen/ops/_amp_foreach_non_finite_check_and_unscale_ops.h>
#include <ATen/ops/_amp_update_scale_ops.h>
#include <ATen/ops/_foreach_add_ops.h>
#include <ATen/ops/_foreach_add_ops.h>
#include <ATen/ops/_foreach_add_ops.h>
#include <ATen/ops/_foreach_add_ops.h>
#include <ATen/ops/_foreach_add_ops.h>
#include <ATen/ops/_foreach_add_ops.h>
#include <ATen/ops/_foreach_add_ops.h>
#include <ATen/ops/_foreach_add_ops.h>
#include <ATen/ops/_foreach_sub_ops.h>
#include <ATen/ops/_foreach_sub_ops.h>
#include <ATen/ops/_foreach_sub_ops.h>
#include <ATen/ops/_foreach_sub_ops.h>
#include <ATen/ops/_foreach_sub_ops.h>
#include <ATen/ops/_foreach_sub_ops.h>
#include <ATen/ops/_foreach_mul_ops.h>
#include <ATen/ops/_foreach_mul_ops.h>
#include <ATen/ops/_foreach_mul_ops.h>
#include <ATen/ops/_foreach_mul_ops.h>
#include <ATen/ops/_foreach_mul_ops.h>
#include <ATen/ops/_foreach_mul_ops.h>
#include <ATen/ops/_foreach_mul_ops.h>
#include <ATen/ops/_foreach_mul_ops.h>
#include <ATen/ops/_foreach_div_ops.h>
#include <ATen/ops/_foreach_div_ops.h>
#include <ATen/ops/_foreach_div_ops.h>
#include <ATen/ops/_foreach_div_ops.h>
#include <ATen/ops/_foreach_div_ops.h>
#include <ATen/ops/_foreach_div_ops.h>
#include <ATen/ops/_foreach_div_ops.h>
#include <ATen/ops/_foreach_div_ops.h>
#include <ATen/ops/_foreach_clamp_max_ops.h>
#include <ATen/ops/_foreach_clamp_max_ops.h>
#include <ATen/ops/_foreach_clamp_max_ops.h>
#include <ATen/ops/_foreach_clamp_max_ops.h>
#include <ATen/ops/_foreach_clamp_max_ops.h>
#include <ATen/ops/_foreach_clamp_max_ops.h>
#include <ATen/ops/_foreach_clamp_min_ops.h>
#include <ATen/ops/_foreach_clamp_min_ops.h>
#include <ATen/ops/_foreach_clamp_min_ops.h>
#include <ATen/ops/_foreach_clamp_min_ops.h>
#include <ATen/ops/_foreach_clamp_min_ops.h>
#include <ATen/ops/_foreach_clamp_min_ops.h>
#include <ATen/ops/_foreach_maximum_ops.h>
#include <ATen/ops/_foreach_maximum_ops.h>
#include <ATen/ops/_foreach_maximum_ops.h>
#include <ATen/ops/_foreach_maximum_ops.h>
#include <ATen/ops/_foreach_maximum_ops.h>
#include <ATen/ops/_foreach_maximum_ops.h>
#include <ATen/ops/_foreach_minimum_ops.h>
#include <ATen/ops/_foreach_minimum_ops.h>
#include <ATen/ops/_foreach_minimum_ops.h>
#include <ATen/ops/_foreach_minimum_ops.h>
#include <ATen/ops/_foreach_minimum_ops.h>
#include <ATen/ops/_foreach_minimum_ops.h>
#include <ATen/ops/_foreach_addcdiv_ops.h>
#include <ATen/ops/_foreach_addcdiv_ops.h>
#include <ATen/ops/_foreach_addcdiv_ops.h>
#include <ATen/ops/_foreach_addcdiv_ops.h>
#include <ATen/ops/_foreach_addcdiv_ops.h>
#include <ATen/ops/_foreach_addcdiv_ops.h>
#include <ATen/ops/_foreach_addcmul_ops.h>
#include <ATen/ops/_foreach_addcmul_ops.h>
#include <ATen/ops/_foreach_addcmul_ops.h>
#include <ATen/ops/_foreach_addcmul_ops.h>
#include <ATen/ops/_foreach_addcmul_ops.h>
#include <ATen/ops/_foreach_addcmul_ops.h>
#include <ATen/ops/_foreach_abs_ops.h>
#include <ATen/ops/_foreach_abs_ops.h>
#include <ATen/ops/_foreach_acos_ops.h>
#include <ATen/ops/_foreach_acos_ops.h>
#include <ATen/ops/_foreach_asin_ops.h>
#include <ATen/ops/_foreach_asin_ops.h>
#include <ATen/ops/_foreach_atan_ops.h>
#include <ATen/ops/_foreach_atan_ops.h>
#include <ATen/ops/_foreach_ceil_ops.h>
#include <ATen/ops/_foreach_ceil_ops.h>
#include <ATen/ops/_foreach_cos_ops.h>
#include <ATen/ops/_foreach_cos_ops.h>
#include <ATen/ops/_foreach_cosh_ops.h>
#include <ATen/ops/_foreach_cosh_ops.h>
#include <ATen/ops/_foreach_erf_ops.h>
#include <ATen/ops/_foreach_erf_ops.h>
#include <ATen/ops/_foreach_erfc_ops.h>
#include <ATen/ops/_foreach_erfc_ops.h>
#include <ATen/ops/_foreach_exp_ops.h>
#include <ATen/ops/_foreach_exp_ops.h>
#include <ATen/ops/_foreach_expm1_ops.h>
#include <ATen/ops/_foreach_expm1_ops.h>
#include <ATen/ops/_foreach_floor_ops.h>
#include <ATen/ops/_foreach_floor_ops.h>
#include <ATen/ops/_foreach_frac_ops.h>
#include <ATen/ops/_foreach_frac_ops.h>
#include <ATen/ops/_foreach_lerp_ops.h>
#include <ATen/ops/_foreach_lerp_ops.h>
#include <ATen/ops/_foreach_lerp_ops.h>
#include <ATen/ops/_foreach_lerp_ops.h>
#include <ATen/ops/_foreach_lgamma_ops.h>
#include <ATen/ops/_foreach_lgamma_ops.h>
#include <ATen/ops/_foreach_log_ops.h>
#include <ATen/ops/_foreach_log_ops.h>
#include <ATen/ops/_foreach_log10_ops.h>
#include <ATen/ops/_foreach_log10_ops.h>
#include <ATen/ops/_foreach_log1p_ops.h>
#include <ATen/ops/_foreach_log1p_ops.h>
#include <ATen/ops/_foreach_log2_ops.h>
#include <ATen/ops/_foreach_log2_ops.h>
#include <ATen/ops/_foreach_neg_ops.h>
#include <ATen/ops/_foreach_neg_ops.h>
#include <ATen/ops/_foreach_norm_ops.h>
#include <ATen/ops/_foreach_pow_ops.h>
#include <ATen/ops/_foreach_pow_ops.h>
#include <ATen/ops/_foreach_pow_ops.h>
#include <ATen/ops/_foreach_pow_ops.h>
#include <ATen/ops/_foreach_pow_ops.h>
#include <ATen/ops/_foreach_pow_ops.h>
#include <ATen/ops/_foreach_reciprocal_ops.h>
#include <ATen/ops/_foreach_reciprocal_ops.h>
#include <ATen/ops/_foreach_round_ops.h>
#include <ATen/ops/_foreach_round_ops.h>
#include <ATen/ops/_foreach_sigmoid_ops.h>
#include <ATen/ops/_foreach_sigmoid_ops.h>
#include <ATen/ops/_foreach_sign_ops.h>
#include <ATen/ops/_foreach_sign_ops.h>
#include <ATen/ops/_foreach_sin_ops.h>
#include <ATen/ops/_foreach_sin_ops.h>
#include <ATen/ops/_foreach_sinh_ops.h>
#include <ATen/ops/_foreach_sinh_ops.h>
#include <ATen/ops/_foreach_sqrt_ops.h>
#include <ATen/ops/_foreach_sqrt_ops.h>
#include <ATen/ops/_foreach_tan_ops.h>
#include <ATen/ops/_foreach_tan_ops.h>
#include <ATen/ops/_foreach_tanh_ops.h>
#include <ATen/ops/_foreach_tanh_ops.h>
#include <ATen/ops/_foreach_trunc_ops.h>
#include <ATen/ops/_foreach_trunc_ops.h>
#include <ATen/ops/_foreach_zero_ops.h>
#include <ATen/ops/_foreach_copy_ops.h>
#include <ATen/ops/bucketize_ops.h>
#include <ATen/ops/bucketize_ops.h>
#include <ATen/ops/searchsorted_ops.h>
#include <ATen/ops/searchsorted_ops.h>
#include <ATen/ops/_convert_indices_from_coo_to_csr_ops.h>
#include <ATen/ops/_convert_indices_from_csr_to_coo_ops.h>
#include <ATen/ops/mse_loss_ops.h>
#include <ATen/ops/mse_loss_backward_ops.h>
#include <ATen/ops/multi_margin_loss_ops.h>
#include <ATen/ops/multi_margin_loss_backward_ops.h>
#include <ATen/ops/multilabel_margin_loss_ops.h>
#include <ATen/ops/multilabel_margin_loss_forward_ops.h>
#include <ATen/ops/multilabel_margin_loss_backward_ops.h>
#include <ATen/ops/nll_loss_ops.h>
#include <ATen/ops/nll_loss_forward_ops.h>
#include <ATen/ops/nll_loss_backward_ops.h>
#include <ATen/ops/nll_loss2d_ops.h>
#include <ATen/ops/nll_loss2d_forward_ops.h>
#include <ATen/ops/nll_loss2d_backward_ops.h>
#include <ATen/ops/smooth_l1_loss_ops.h>
#include <ATen/ops/smooth_l1_loss_backward_ops.h>
#include <ATen/ops/huber_loss_ops.h>
#include <ATen/ops/huber_loss_backward_ops.h>
#include <ATen/ops/soft_margin_loss_ops.h>
#include <ATen/ops/soft_margin_loss_backward_ops.h>
#include <ATen/ops/elu_ops.h>
#include <ATen/ops/elu_ops.h>
#include <ATen/ops/elu_backward_ops.h>
#include <ATen/ops/glu_ops.h>
#include <ATen/ops/glu_backward_ops.h>
#include <ATen/ops/glu_jvp_ops.h>
#include <ATen/ops/glu_backward_jvp_ops.h>
#include <ATen/ops/hardsigmoid_ops.h>
#include <ATen/ops/hardsigmoid_ops.h>
#include <ATen/ops/hardsigmoid_backward_ops.h>
#include <ATen/ops/hardtanh_ops.h>
#include <ATen/ops/hardtanh_ops.h>
#include <ATen/ops/hardtanh_backward_ops.h>
#include <ATen/ops/hardswish_ops.h>
#include <ATen/ops/hardswish_ops.h>
#include <ATen/ops/hardswish_backward_ops.h>
#include <ATen/ops/leaky_relu_ops.h>
#include <ATen/ops/leaky_relu_ops.h>
#include <ATen/ops/leaky_relu_backward_ops.h>
#include <ATen/ops/log_sigmoid_ops.h>
#include <ATen/ops/log_sigmoid_forward_ops.h>
#include <ATen/ops/log_sigmoid_backward_ops.h>
#include <ATen/ops/rrelu_with_noise_ops.h>
#include <ATen/ops/rrelu_with_noise_ops.h>
#include <ATen/ops/rrelu_with_noise_backward_ops.h>
#include <ATen/ops/softplus_ops.h>
#include <ATen/ops/softplus_backward_ops.h>
#include <ATen/ops/softshrink_ops.h>
#include <ATen/ops/softshrink_backward_ops.h>
#include <ATen/ops/adaptive_avg_pool2d_ops.h>
#include <ATen/ops/mkldnn_adaptive_avg_pool2d_ops.h>
#include <ATen/ops/mkldnn_adaptive_avg_pool2d_backward_ops.h>
#include <ATen/ops/_adaptive_avg_pool2d_ops.h>
#include <ATen/ops/_adaptive_avg_pool2d_backward_ops.h>
#include <ATen/ops/adaptive_avg_pool3d_ops.h>
#include <ATen/ops/_adaptive_avg_pool3d_ops.h>
#include <ATen/ops/_adaptive_avg_pool3d_backward_ops.h>
#include <ATen/ops/adaptive_max_pool2d_ops.h>
#include <ATen/ops/adaptive_max_pool2d_backward_ops.h>
#include <ATen/ops/adaptive_max_pool3d_ops.h>
#include <ATen/ops/adaptive_max_pool3d_backward_ops.h>
#include <ATen/ops/avg_pool2d_ops.h>
#include <ATen/ops/avg_pool2d_backward_ops.h>
#include <ATen/ops/avg_pool3d_ops.h>
#include <ATen/ops/avg_pool3d_backward_ops.h>
#include <ATen/ops/fractional_max_pool2d_ops.h>
#include <ATen/ops/fractional_max_pool2d_backward_ops.h>
#include <ATen/ops/fractional_max_pool3d_ops.h>
#include <ATen/ops/fractional_max_pool3d_backward_ops.h>
#include <ATen/ops/max_pool2d_with_indices_ops.h>
#include <ATen/ops/max_pool2d_with_indices_backward_ops.h>
#include <ATen/ops/max_pool3d_with_indices_ops.h>
#include <ATen/ops/max_pool3d_with_indices_backward_ops.h>
#include <ATen/ops/max_unpool2d_ops.h>
#include <ATen/ops/max_unpool3d_ops.h>
#include <ATen/ops/reflection_pad1d_ops.h>
#include <ATen/ops/reflection_pad1d_backward_ops.h>
#include <ATen/ops/reflection_pad2d_ops.h>
#include <ATen/ops/reflection_pad2d_backward_ops.h>
#include <ATen/ops/reflection_pad3d_ops.h>
#include <ATen/ops/reflection_pad3d_backward_ops.h>
#include <ATen/ops/replication_pad1d_ops.h>
#include <ATen/ops/replication_pad1d_backward_ops.h>
#include <ATen/ops/replication_pad2d_ops.h>
#include <ATen/ops/replication_pad2d_backward_ops.h>
#include <ATen/ops/replication_pad3d_ops.h>
#include <ATen/ops/replication_pad3d_backward_ops.h>
#include <ATen/ops/upsample_linear1d_ops.h>
#include <ATen/ops/upsample_linear1d_backward_ops.h>
#include <ATen/ops/upsample_bilinear2d_ops.h>
#include <ATen/ops/upsample_bilinear2d_backward_ops.h>
#include <ATen/ops/_upsample_bilinear2d_aa_ops.h>
#include <ATen/ops/_upsample_bilinear2d_aa_backward_ops.h>
#include <ATen/ops/upsample_bicubic2d_ops.h>
#include <ATen/ops/upsample_bicubic2d_backward_ops.h>
#include <ATen/ops/_upsample_bicubic2d_aa_ops.h>
#include <ATen/ops/_upsample_bicubic2d_aa_backward_ops.h>
#include <ATen/ops/upsample_trilinear3d_ops.h>
#include <ATen/ops/upsample_trilinear3d_backward_ops.h>
#include <ATen/ops/upsample_nearest1d_ops.h>
#include <ATen/ops/_upsample_nearest_exact1d_ops.h>
#include <ATen/ops/upsample_nearest1d_backward_ops.h>
#include <ATen/ops/_upsample_nearest_exact1d_backward_ops.h>
#include <ATen/ops/upsample_nearest2d_ops.h>
#include <ATen/ops/_upsample_nearest_exact2d_ops.h>
#include <ATen/ops/upsample_nearest2d_backward_ops.h>
#include <ATen/ops/_upsample_nearest_exact2d_backward_ops.h>
#include <ATen/ops/upsample_nearest3d_ops.h>
#include <ATen/ops/_upsample_nearest_exact3d_ops.h>
#include <ATen/ops/upsample_nearest3d_backward_ops.h>
#include <ATen/ops/_upsample_nearest_exact3d_backward_ops.h>
#include <ATen/ops/sigmoid_backward_ops.h>
#include <ATen/ops/logit_backward_ops.h>
#include <ATen/ops/tanh_backward_ops.h>
#include <ATen/ops/slow_conv_transpose2d_ops.h>
#include <ATen/ops/slow_conv_transpose3d_ops.h>
#include <ATen/ops/thnn_conv2d_ops.h>
#include <ATen/ops/_slow_conv2d_forward_ops.h>
#include <ATen/ops/_slow_conv2d_backward_ops.h>
#include <ATen/ops/_conv_depthwise2d_ops.h>
#include <ATen/ops/conv_depthwise3d_ops.h>
#include <ATen/ops/slow_conv3d_ops.h>
#include <ATen/ops/slow_conv3d_forward_ops.h>
#include <ATen/ops/slow_conv_dilated2d_ops.h>
#include <ATen/ops/slow_conv_dilated3d_ops.h>
#include <ATen/ops/col2im_ops.h>
#include <ATen/ops/column_stack_ops.h>
#include <ATen/ops/im2col_ops.h>
#include <ATen/ops/isinf_ops.h>
#include <ATen/ops/isposinf_ops.h>
#include <ATen/ops/isneginf_ops.h>
#include <ATen/ops/special_entr_ops.h>
#include <ATen/ops/special_ndtri_ops.h>
#include <ATen/ops/special_log_ndtr_ops.h>
#include <ATen/ops/special_expm1_ops.h>
#include <ATen/ops/special_exp2_ops.h>
#include <ATen/ops/special_psi_ops.h>
#include <ATen/ops/special_digamma_ops.h>
#include <ATen/ops/special_gammaln_ops.h>
#include <ATen/ops/special_erf_ops.h>
#include <ATen/ops/special_erfc_ops.h>
#include <ATen/ops/special_erfcx_ops.h>
#include <ATen/ops/special_erfinv_ops.h>
#include <ATen/ops/special_ndtr_ops.h>
#include <ATen/ops/special_xlog1py_ops.h>
#include <ATen/ops/special_xlog1py_ops.h>
#include <ATen/ops/special_xlog1py_ops.h>
#include <ATen/ops/special_xlogy_ops.h>
#include <ATen/ops/special_xlogy_ops.h>
#include <ATen/ops/special_xlogy_ops.h>
#include <ATen/ops/special_zeta_ops.h>
#include <ATen/ops/special_zeta_ops.h>
#include <ATen/ops/special_zeta_ops.h>
#include <ATen/ops/special_i0_ops.h>
#include <ATen/ops/special_i0e_ops.h>
#include <ATen/ops/special_i1_ops.h>
#include <ATen/ops/special_i1e_ops.h>
#include <ATen/ops/special_logit_ops.h>
#include <ATen/ops/special_polygamma_ops.h>
#include <ATen/ops/special_logsumexp_ops.h>
#include <ATen/ops/special_expit_ops.h>
#include <ATen/ops/special_sinc_ops.h>
#include <ATen/ops/special_round_ops.h>
#include <ATen/ops/special_log1p_ops.h>
#include <ATen/ops/special_gammainc_ops.h>
#include <ATen/ops/special_gammaincc_ops.h>
#include <ATen/ops/special_multigammaln_ops.h>
#include <ATen/ops/fft_fft_ops.h>
#include <ATen/ops/fft_ifft_ops.h>
#include <ATen/ops/fft_rfft_ops.h>
#include <ATen/ops/fft_irfft_ops.h>
#include <ATen/ops/fft_hfft_ops.h>
#include <ATen/ops/fft_ihfft_ops.h>
#include <ATen/ops/fft_fft2_ops.h>
#include <ATen/ops/fft_ifft2_ops.h>
#include <ATen/ops/fft_rfft2_ops.h>
#include <ATen/ops/fft_irfft2_ops.h>
#include <ATen/ops/fft_hfft2_ops.h>
#include <ATen/ops/fft_ihfft2_ops.h>
#include <ATen/ops/fft_fftn_ops.h>
#include <ATen/ops/fft_ifftn_ops.h>
#include <ATen/ops/fft_rfftn_ops.h>
#include <ATen/ops/fft_irfftn_ops.h>
#include <ATen/ops/fft_hfftn_ops.h>
#include <ATen/ops/fft_ihfftn_ops.h>
#include <ATen/ops/fft_fftfreq_ops.h>
#include <ATen/ops/fft_rfftfreq_ops.h>
#include <ATen/ops/linalg_cholesky_ex_ops.h>
#include <ATen/ops/linalg_cholesky_ops.h>
#include <ATen/ops/linalg_cross_ops.h>
#include <ATen/ops/linalg_lu_factor_ops.h>
#include <ATen/ops/linalg_lu_factor_ex_ops.h>
#include <ATen/ops/linalg_lu_ops.h>
#include <ATen/ops/linalg_lu_solve_ops.h>
#include <ATen/ops/_linalg_det_ops.h>
#include <ATen/ops/linalg_det_ops.h>
#include <ATen/ops/linalg_ldl_factor_ex_ops.h>
#include <ATen/ops/linalg_ldl_factor_ops.h>
#include <ATen/ops/linalg_ldl_solve_ops.h>
#include <ATen/ops/linalg_lstsq_ops.h>
#include <ATen/ops/linalg_matmul_ops.h>
#include <ATen/ops/linalg_vecdot_ops.h>
#include <ATen/ops/linalg_matrix_exp_ops.h>
#include <ATen/ops/_linalg_slogdet_ops.h>
#include <ATen/ops/linalg_slogdet_ops.h>
#include <ATen/ops/slogdet_ops.h>
#include <ATen/ops/linalg_eig_ops.h>
#include <ATen/ops/linalg_eigvals_ops.h>
#include <ATen/ops/_linalg_eigh_ops.h>
#include <ATen/ops/linalg_eigh_ops.h>
#include <ATen/ops/linalg_eigvalsh_ops.h>
#include <ATen/ops/linalg_householder_product_ops.h>
#include <ATen/ops/linalg_inv_ex_ops.h>
#include <ATen/ops/linalg_inv_ops.h>
#include <ATen/ops/inverse_ops.h>
#include <ATen/ops/inner_ops.h>
#include <ATen/ops/outer_ops.h>
#include <ATen/ops/ger_ops.h>
#include <ATen/ops/linalg_norm_ops.h>
#include <ATen/ops/linalg_norm_ops.h>
#include <ATen/ops/linalg_vector_norm_ops.h>
#include <ATen/ops/linalg_matrix_norm_ops.h>
#include <ATen/ops/linalg_matrix_norm_ops.h>
#include <ATen/ops/_linalg_svd_ops.h>
#include <ATen/ops/linalg_svd_ops.h>
#include <ATen/ops/linalg_svdvals_ops.h>
#include <ATen/ops/linalg_cond_ops.h>
#include <ATen/ops/linalg_cond_ops.h>
#include <ATen/ops/linalg_pinv_ops.h>
#include <ATen/ops/linalg_pinv_ops.h>
#include <ATen/ops/linalg_pinv_ops.h>
#include <ATen/ops/linalg_pinv_ops.h>
#include <ATen/ops/_linalg_solve_ex_ops.h>
#include <ATen/ops/linalg_solve_ex_ops.h>
#include <ATen/ops/linalg_solve_ops.h>
#include <ATen/ops/linalg_tensorinv_ops.h>
#include <ATen/ops/linalg_tensorsolve_ops.h>
#include <ATen/ops/linalg_qr_ops.h>
#include <ATen/ops/linalg_matrix_power_ops.h>
#include <ATen/ops/linalg_matrix_rank_ops.h>
#include <ATen/ops/linalg_matrix_rank_ops.h>
#include <ATen/ops/linalg_matrix_rank_ops.h>
#include <ATen/ops/linalg_matrix_rank_ops.h>
#include <ATen/ops/linalg_multi_dot_ops.h>
#include <ATen/ops/_test_optional_intlist_ops.h>
#include <ATen/ops/_test_optional_filled_intlist_ops.h>
#include <ATen/ops/_test_optional_floatlist_ops.h>
#include <ATen/ops/_test_warn_in_autograd_ops.h>
#include <ATen/ops/_test_autograd_multiple_dispatch_ops.h>
#include <ATen/ops/_test_autograd_multiple_dispatch_view_copy_ops.h>
#include <ATen/ops/segment_reduce_ops.h>
#include <ATen/ops/_segment_reduce_backward_ops.h>
#include <ATen/ops/_nested_tensor_from_tensor_list_ops.h>
#include <ATen/ops/_fw_primal_copy_ops.h>
#include <ATen/ops/_make_dual_copy_ops.h>
#include <ATen/ops/view_as_real_copy_ops.h>
#include <ATen/ops/view_as_complex_copy_ops.h>
#include <ATen/ops/_conj_copy_ops.h>
#include <ATen/ops/_neg_view_copy_ops.h>
#include <ATen/ops/as_strided_copy_ops.h>
#include <ATen/ops/_sparse_broadcast_to_copy_ops.h>
#include <ATen/ops/diagonal_copy_ops.h>
#include <ATen/ops/expand_copy_ops.h>
#include <ATen/ops/permute_copy_ops.h>
#include <ATen/ops/_reshape_alias_copy_ops.h>
#include <ATen/ops/select_copy_ops.h>
#include <ATen/ops/detach_copy_ops.h>
#include <ATen/ops/slice_copy_ops.h>
#include <ATen/ops/split_copy_ops.h>
#include <ATen/ops/split_with_sizes_copy_ops.h>
#include <ATen/ops/squeeze_copy_ops.h>
#include <ATen/ops/squeeze_copy_ops.h>
#include <ATen/ops/squeeze_copy_ops.h>
#include <ATen/ops/t_copy_ops.h>
#include <ATen/ops/transpose_copy_ops.h>
#include <ATen/ops/unsqueeze_copy_ops.h>
#include <ATen/ops/_indices_copy_ops.h>
#include <ATen/ops/_values_copy_ops.h>
#include <ATen/ops/indices_copy_ops.h>
#include <ATen/ops/values_copy_ops.h>
#include <ATen/ops/crow_indices_copy_ops.h>
#include <ATen/ops/col_indices_copy_ops.h>
#include <ATen/ops/ccol_indices_copy_ops.h>
#include <ATen/ops/row_indices_copy_ops.h>
#include <ATen/ops/unbind_copy_ops.h>
#include <ATen/ops/view_copy_ops.h>
#include <ATen/ops/view_copy_ops.h>
#include <ATen/ops/unfold_copy_ops.h>
#include <ATen/ops/alias_copy_ops.h>
#include <ATen/ops/to_padded_tensor_ops.h>
#include <ATen/ops/_transformer_encoder_layer_fwd_ops.h>
#include <ATen/ops/_native_multi_head_attention_ops.h>
#include <ATen/ops/_triton_scaled_dot_attention_ops.h>
#include <ATen/ops/_triton_multi_head_attention_ops.h>
#include <ATen/ops/special_airy_ai_ops.h>
#include <ATen/ops/special_bessel_j0_ops.h>
#include <ATen/ops/special_bessel_j1_ops.h>
#include <ATen/ops/special_bessel_y0_ops.h>
#include <ATen/ops/special_bessel_y1_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_t_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_t_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_t_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_u_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_u_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_u_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_v_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_v_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_v_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_w_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_w_ops.h>
#include <ATen/ops/special_chebyshev_polynomial_w_ops.h>
#include <ATen/ops/special_hermite_polynomial_h_ops.h>
#include <ATen/ops/special_hermite_polynomial_h_ops.h>
#include <ATen/ops/special_hermite_polynomial_h_ops.h>
#include <ATen/ops/special_hermite_polynomial_he_ops.h>
#include <ATen/ops/special_hermite_polynomial_he_ops.h>
#include <ATen/ops/special_hermite_polynomial_he_ops.h>
#include <ATen/ops/special_laguerre_polynomial_l_ops.h>
#include <ATen/ops/special_laguerre_polynomial_l_ops.h>
#include <ATen/ops/special_laguerre_polynomial_l_ops.h>
#include <ATen/ops/special_legendre_polynomial_p_ops.h>
#include <ATen/ops/special_legendre_polynomial_p_ops.h>
#include <ATen/ops/special_legendre_polynomial_p_ops.h>
#include <ATen/ops/special_modified_bessel_i0_ops.h>
#include <ATen/ops/special_modified_bessel_i1_ops.h>
#include <ATen/ops/special_modified_bessel_k0_ops.h>
#include <ATen/ops/special_modified_bessel_k1_ops.h>
#include <ATen/ops/special_scaled_modified_bessel_k0_ops.h>
#include <ATen/ops/special_scaled_modified_bessel_k1_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_t_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_t_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_t_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_u_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_u_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_u_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_v_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_v_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_v_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_w_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_w_ops.h>
#include <ATen/ops/special_shifted_chebyshev_polynomial_w_ops.h>
#include <ATen/ops/special_spherical_bessel_j0_ops.h>
#include <ATen/ops/_foobar_ops.h>
#include <ATen/ops/_fused_adam_ops.h>
#include <ATen/ops/_fused_adam_ops.h>
#include <ATen/ops/_fused_adamw_ops.h>
#include <ATen/ops/_fused_adamw_ops.h>
#include <ATen/ops/_fused_sgd_ops.h>
#include <ATen/ops/_fused_sgd_ops.h>
#endif

namespace at {
namespace native {

// This file contains a number of kernels for aten functions that are fully code-generated.
// TODO: rename this file to something more generic.

namespace {
at::Tensor clone_arg(const at::Tensor& t) {
    return t.clone();
}

std::vector<at::Tensor> clone_arg(const at::TensorList& t_list) {
    std::vector<at::Tensor> out(t_list.size());
    for (const auto& i : c10::irange(t_list.size())) {
        out[i] = t_list[i].clone();
    }
    return out;
}

// duped with gen_resize_out_helper from structured kernels
void copy_arg(const at::Tensor& dst, const at::Tensor& src) {
    TORCH_CHECK(src.dtype() == dst.dtype(),
        "Expected out tensor to have dtype ", src.dtype(), ", but got ", dst.dtype(), " instead");
    TORCH_CHECK(src.device() == dst.device(),
        "Expected out tensor to have device ", src.device(), ", but got ", dst.device(), " instead");
    dst.copy_(src);
}

void copy_arg(const at::TensorList& dst, const at::TensorList& src) {
    TORCH_INTERNAL_ASSERT(dst.size() == src.size());
    for (const auto& i : c10::irange(dst.size())) {
        copy_arg(dst[i], src[i]);
    }
}

// TODO: this doesn't handle restriding empty tensors correctly; see
// gen_resize_out_helper for the correct algorithm

void resize_out_helper(const at::Tensor& dst, const at::Tensor& src) {
    at::native::resize_output(dst, src.sizes());
}

void resize_out_helper(const at::TensorList& dst, const at::TensorList& src) {
    TORCH_INTERNAL_ASSERT(dst.size() == src.size());
    for (const auto& i : c10::irange(dst.size())) {
        at::native::resize_output(dst[i], src[i].sizes());
    }
}
}



at::Tensor _fw_primal_copy(const at::Tensor & self, int64_t level) {
  auto output = at::_ops::_fw_primal::call(self, level);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor _make_dual_copy(const at::Tensor & primal, const at::Tensor & tangent, int64_t level) {
  auto output = at::_ops::_make_dual::call(primal, tangent, level);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor view_as_real_copy(const at::Tensor & self) {
  auto output = at::_ops::view_as_real::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor view_as_complex_copy(const at::Tensor & self) {
  auto output = at::_ops::view_as_complex::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor _conj_copy(const at::Tensor & self) {
  auto output = at::_ops::_conj::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor _neg_view_copy(const at::Tensor & self) {
  auto output = at::_ops::_neg_view::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor as_strided_copy_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
  auto output = at::_ops::as_strided::call(self, size, stride, storage_offset);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor _sparse_broadcast_to_copy(const at::Tensor & self, at::IntArrayRef size) {
  auto output = at::_ops::_sparse_broadcast_to::call(self, size);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor diagonal_copy(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2) {
  auto output = at::_ops::diagonal::call(self, offset, dim1, dim2);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor expand_copy_symint(const at::Tensor & self, c10::SymIntArrayRef size, bool implicit) {
  auto output = at::_ops::expand::call(self, size, implicit);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor narrow_copy_dense_symint(const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length) {
  auto output = at::_ops::narrow::call(self, dim, start, length);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor permute_copy(const at::Tensor & self, at::IntArrayRef dims) {
  auto output = at::_ops::permute::call(self, dims);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor _reshape_alias_copy_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
  auto output = at::_ops::_reshape_alias::call(self, size, stride);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor select_copy_symint(const at::Tensor & self, int64_t dim, c10::SymInt index) {
  auto output = at::_ops::select_int::call(self, dim, index);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor detach_copy(const at::Tensor & self) {
  auto output = at::_ops::detach::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor slice_copy_Tensor_symint(const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step) {
  auto output = at::_ops::slice_Tensor::call(self, dim, start, end, step);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

::std::vector<at::Tensor> split_copy_Tensor_symint(const at::Tensor & self, c10::SymInt split_size, int64_t dim) {
  auto output = at::_ops::split_Tensor::call(self, split_size, dim);
    ::std::vector<at::Tensor> out_clone;
  for (const auto i : c10::irange(output.size())) {
    out_clone.push_back(output[i].clone(/*memory_format=*/at::MemoryFormat::Contiguous));
  }
  return out_clone;
}

::std::vector<at::Tensor> split_with_sizes_copy_symint(const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim) {
  auto output = at::_ops::split_with_sizes::call(self, split_sizes, dim);
    ::std::vector<at::Tensor> out_clone;
  for (const auto i : c10::irange(output.size())) {
    out_clone.push_back(output[i].clone(/*memory_format=*/at::MemoryFormat::Contiguous));
  }
  return out_clone;
}

at::Tensor squeeze_copy(const at::Tensor & self) {
  auto output = at::_ops::squeeze::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor squeeze_copy_dim(const at::Tensor & self, int64_t dim) {
  auto output = at::_ops::squeeze_dim::call(self, dim);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor squeeze_copy_dims(const at::Tensor & self, at::IntArrayRef dim) {
  auto output = at::_ops::squeeze_dims::call(self, dim);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor t_copy(const at::Tensor & self) {
  auto output = at::_ops::t::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor transpose_copy_int(const at::Tensor & self, int64_t dim0, int64_t dim1) {
  auto output = at::_ops::transpose_int::call(self, dim0, dim1);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor _nested_view_from_buffer_copy(const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets) {
  auto output = at::_ops::_nested_view_from_buffer::call(self, nested_size, nested_strides, offsets);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor unsqueeze_copy(const at::Tensor & self, int64_t dim) {
  auto output = at::_ops::unsqueeze::call(self, dim);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor _indices_copy(const at::Tensor & self) {
  auto output = at::_ops::_indices::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor _values_copy(const at::Tensor & self) {
  auto output = at::_ops::_values::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor indices_copy(const at::Tensor & self) {
  auto output = at::_ops::indices::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor values_copy(const at::Tensor & self) {
  auto output = at::_ops::values::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor crow_indices_copy(const at::Tensor & self) {
  auto output = at::_ops::crow_indices::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor col_indices_copy(const at::Tensor & self) {
  auto output = at::_ops::col_indices::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor ccol_indices_copy(const at::Tensor & self) {
  auto output = at::_ops::ccol_indices::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor row_indices_copy(const at::Tensor & self) {
  auto output = at::_ops::row_indices::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

::std::vector<at::Tensor> unbind_copy_int(const at::Tensor & self, int64_t dim) {
  auto output = at::_ops::unbind_int::call(self, dim);
    ::std::vector<at::Tensor> out_clone;
  for (const auto i : c10::irange(output.size())) {
    out_clone.push_back(output[i].clone(/*memory_format=*/at::MemoryFormat::Contiguous));
  }
  return out_clone;
}

at::Tensor lift_fresh_copy(const at::Tensor & self) {
  auto output = at::_ops::lift_fresh::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}
at::Tensor view_copy_symint(const at::Tensor & self, at::SymIntArrayRef size) {
  c10::SymDimVector shape = infer_size_dv(size, self.sym_numel());
  if (!at::detail::computeStride(self.sym_sizes(), self.sym_strides(), shape).has_value()) {
    return self.reshape_symint(size);
  } else {
    auto output = at::_ops::view::call(self, size);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
  }
}

at::Tensor view_copy_dtype(const at::Tensor & self, at::ScalarType dtype) {
  auto output = at::_ops::view_dtype::call(self, dtype);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor unfold_copy(const at::Tensor & self, int64_t dimension, int64_t size, int64_t step) {
  auto output = at::_ops::unfold::call(self, dimension, size, step);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor alias_copy(const at::Tensor & self) {
  auto output = at::_ops::alias::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}

at::Tensor _test_autograd_multiple_dispatch_view_copy(const at::Tensor & self) {
  auto output = at::_ops::_test_autograd_multiple_dispatch_view::call(self);
    return output.clone(/*memory_format=*/at::MemoryFormat::Contiguous);
}


at::Tensor bernoulli(const at::Tensor & self, const at::Tensor & p, c10::optional<at::Generator> generator) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::bernoulli__Tensor::call(const_cast<Tensor&>(self_clone), p, generator);
  return self_clone;
}

at::Tensor embedding_renorm(const at::Tensor & self, const at::Tensor & indices, double max_norm, double norm_type) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::embedding_renorm_::call(const_cast<Tensor&>(self_clone), indices, max_norm, norm_type);
  return self_clone;
}

at::Tensor resize_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::resize_::call(self_clone, size, memory_format);
  return self_clone;
}

at::Tensor _resize_output_symint(const at::Tensor & self, c10::SymIntArrayRef size, at::Device device) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::_resize_output_::call(self_clone, size, device);
  return self_clone;
}

at::Tensor _index_put_impl(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::_index_put_impl_::call(const_cast<Tensor&>(self_clone), indices, values, accumulate, unsafe);
  return self_clone;
}

::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _native_batch_norm_legit_functional(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & running_mean, const at::Tensor & running_var, bool training, double momentum, double eps) {
  auto running_mean_clone = clone_arg(running_mean);
auto running_var_clone = clone_arg(running_var);
  auto output = at::_ops::_native_batch_norm_legit::call(input, weight, bias, const_cast<Tensor&>(running_mean_clone), const_cast<Tensor&>(running_var_clone), training, momentum, eps);
  return ::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(std::get<0>(output), std::get<1>(output), std::get<2>(output), running_mean_clone, running_var_clone);
}

at::Tensor resize_as(const at::Tensor & self, const at::Tensor & the_template, c10::optional<at::MemoryFormat> memory_format) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::resize_as_::call(self_clone, the_template, memory_format);
  return self_clone;
}

at::Tensor resize_as_sparse(const at::Tensor & self, const at::Tensor & the_template) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::resize_as_sparse_::call(self_clone, the_template);
  return self_clone;
}

at::Tensor zero(const at::Tensor & self) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::zero_::call(const_cast<Tensor&>(self_clone));
  return self_clone;
}

at::Tensor sparse_resize(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::sparse_resize_::call(self_clone, size, sparse_dim, dense_dim);
  return self_clone;
}

at::Tensor sparse_resize_and_clear(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::sparse_resize_and_clear_::call(self_clone, size, sparse_dim, dense_dim);
  return self_clone;
}

at::Tensor _coalesced(const at::Tensor & self, bool coalesced) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::_coalesced_::call(const_cast<Tensor&>(self_clone), coalesced);
  return self_clone;
}

at::Tensor copy_sparse_to_sparse(const at::Tensor & self, const at::Tensor & src, bool non_blocking) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::copy_sparse_to_sparse_::call(const_cast<Tensor&>(self_clone), src, non_blocking);
  return self_clone;
}

::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _fused_moving_avg_obs_fq_helper_functional(const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, const at::Tensor & running_min, const at::Tensor & running_max, const at::Tensor & scale, const at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant) {
  auto running_min_clone = clone_arg(running_min);
auto running_max_clone = clone_arg(running_max);
auto scale_clone = clone_arg(scale);
auto zero_point_clone = clone_arg(zero_point);
  auto output = at::_ops::_fused_moving_avg_obs_fq_helper::call(self, observer_on, fake_quant_on, const_cast<Tensor&>(running_min_clone), const_cast<Tensor&>(running_max_clone), const_cast<Tensor&>(scale_clone), const_cast<Tensor&>(zero_point_clone), averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
  return ::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(std::get<0>(output), std::get<1>(output), running_min_clone, running_max_clone, scale_clone, zero_point_clone);
}

at::Tensor set(const at::Tensor & self, at::Storage source) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::set__source_Storage::call(const_cast<Tensor&>(self_clone), source);
  return self_clone;
}

at::Tensor set_symint(const at::Tensor & self, at::Storage source, c10::SymInt storage_offset, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::set__source_Storage_storage_offset::call(const_cast<Tensor&>(self_clone), source, storage_offset, size, stride);
  return self_clone;
}

at::Tensor set(const at::Tensor & self, const at::Tensor & source) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::set__source_Tensor::call(const_cast<Tensor&>(self_clone), source);
  return self_clone;
}

at::Tensor set(const at::Tensor & self) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::set_::call(const_cast<Tensor&>(self_clone));
  return self_clone;
}

at::Tensor random(const at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::random__from::call(const_cast<Tensor&>(self_clone), from, to, generator);
  return self_clone;
}

at::Tensor random(const at::Tensor & self, int64_t to, c10::optional<at::Generator> generator) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::random__to::call(const_cast<Tensor&>(self_clone), to, generator);
  return self_clone;
}

at::Tensor random(const at::Tensor & self, c10::optional<at::Generator> generator) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::random_::call(const_cast<Tensor&>(self_clone), generator);
  return self_clone;
}

at::Tensor uniform(const at::Tensor & self, double from, double to, c10::optional<at::Generator> generator) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::uniform_::call(const_cast<Tensor&>(self_clone), from, to, generator);
  return self_clone;
}

at::Tensor cauchy(const at::Tensor & self, double median, double sigma, c10::optional<at::Generator> generator) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::cauchy_::call(const_cast<Tensor&>(self_clone), median, sigma, generator);
  return self_clone;
}

at::Tensor log_normal(const at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::log_normal_::call(const_cast<Tensor&>(self_clone), mean, std, generator);
  return self_clone;
}

at::Tensor exponential(const at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::exponential_::call(const_cast<Tensor&>(self_clone), lambd, generator);
  return self_clone;
}

at::Tensor geometric(const at::Tensor & self, double p, c10::optional<at::Generator> generator) {
  auto self_clone = clone_arg(self);
  auto output = at::_ops::geometric_::call(const_cast<Tensor&>(self_clone), p, generator);
  return self_clone;
}

::std::tuple<::std::vector<at::Tensor>,at::Tensor> _amp_foreach_non_finite_check_and_unscale(at::TensorList self, const at::Tensor & found_inf, const at::Tensor & inv_scale) {
  auto self_clone = clone_arg(self);
auto found_inf_clone = clone_arg(found_inf);
  at::_ops::_amp_foreach_non_finite_check_and_unscale_::call(self_clone, const_cast<Tensor&>(found_inf_clone), inv_scale);
  return ::std::tuple<::std::vector<at::Tensor>,at::Tensor>(self_clone, found_inf_clone);
}

::std::tuple<at::Tensor,at::Tensor> _amp_update_scale(const at::Tensor & self, const at::Tensor & growth_tracker, const at::Tensor & found_inf, double scale_growth_factor, double scale_backoff_factor, int64_t growth_interval) {
  auto self_clone = clone_arg(self);
auto growth_tracker_clone = clone_arg(growth_tracker);
  auto output = at::_ops::_amp_update_scale_::call(const_cast<Tensor&>(self_clone), const_cast<Tensor&>(growth_tracker_clone), found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
  return ::std::tuple<at::Tensor,at::Tensor>(self_clone, growth_tracker_clone);
}

::std::vector<at::Tensor> _foreach_zero(at::TensorList self) {
  auto self_clone = clone_arg(self);
  at::_ops::_foreach_zero_::call(self_clone);
  return self_clone;
}

::std::vector<at::Tensor> _foreach_copy(at::TensorList self, at::TensorList src, bool non_blocking) {
  auto self_clone = clone_arg(self);
  at::_ops::_foreach_copy_::call(self_clone, src, non_blocking);
  return self_clone;
}

::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>> _fused_adam(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, double lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
  auto self_clone = clone_arg(self);
auto grads_clone = clone_arg(grads);
auto exp_avgs_clone = clone_arg(exp_avgs);
auto exp_avg_sqs_clone = clone_arg(exp_avg_sqs);
auto max_exp_avg_sqs_clone = clone_arg(max_exp_avg_sqs);
  at::_ops::_fused_adam_::call(self_clone, grads_clone, exp_avgs_clone, exp_avg_sqs_clone, max_exp_avg_sqs_clone, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
  return ::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>>(self_clone, grads_clone, exp_avgs_clone, exp_avg_sqs_clone, max_exp_avg_sqs_clone);
}

::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>> _fused_adam(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, const at::Tensor & lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
  auto self_clone = clone_arg(self);
auto grads_clone = clone_arg(grads);
auto exp_avgs_clone = clone_arg(exp_avgs);
auto exp_avg_sqs_clone = clone_arg(exp_avg_sqs);
auto max_exp_avg_sqs_clone = clone_arg(max_exp_avg_sqs);
  at::_ops::_fused_adam__tensor_lr::call(self_clone, grads_clone, exp_avgs_clone, exp_avg_sqs_clone, max_exp_avg_sqs_clone, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
  return ::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>>(self_clone, grads_clone, exp_avgs_clone, exp_avg_sqs_clone, max_exp_avg_sqs_clone);
}

::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>> _fused_adamw(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, double lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
  auto self_clone = clone_arg(self);
auto grads_clone = clone_arg(grads);
auto exp_avgs_clone = clone_arg(exp_avgs);
auto exp_avg_sqs_clone = clone_arg(exp_avg_sqs);
auto max_exp_avg_sqs_clone = clone_arg(max_exp_avg_sqs);
  at::_ops::_fused_adamw_::call(self_clone, grads_clone, exp_avgs_clone, exp_avg_sqs_clone, max_exp_avg_sqs_clone, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
  return ::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>>(self_clone, grads_clone, exp_avgs_clone, exp_avg_sqs_clone, max_exp_avg_sqs_clone);
}

::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>> _fused_adamw(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, const at::Tensor & lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
  auto self_clone = clone_arg(self);
auto grads_clone = clone_arg(grads);
auto exp_avgs_clone = clone_arg(exp_avgs);
auto exp_avg_sqs_clone = clone_arg(exp_avg_sqs);
auto max_exp_avg_sqs_clone = clone_arg(max_exp_avg_sqs);
  at::_ops::_fused_adamw__tensor_lr::call(self_clone, grads_clone, exp_avgs_clone, exp_avg_sqs_clone, max_exp_avg_sqs_clone, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
  return ::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>>(self_clone, grads_clone, exp_avgs_clone, exp_avg_sqs_clone, max_exp_avg_sqs_clone);
}

::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>> _fused_sgd(at::TensorList self, at::TensorList grads, at::TensorList momentum_buffer_list, double weight_decay, double momentum, double lr, double dampening, bool nesterov, bool maximize, bool is_first_step, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
  auto self_clone = clone_arg(self);
auto grads_clone = clone_arg(grads);
auto momentum_buffer_list_clone = clone_arg(momentum_buffer_list);
  at::_ops::_fused_sgd_::call(self_clone, grads_clone, momentum_buffer_list_clone, weight_decay, momentum, lr, dampening, nesterov, maximize, is_first_step, grad_scale, found_inf);
  return ::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>>(self_clone, grads_clone, momentum_buffer_list_clone);
}

::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>> _fused_sgd(at::TensorList self, at::TensorList grads, at::TensorList momentum_buffer_list, double weight_decay, double momentum, const at::Tensor & lr, double dampening, bool nesterov, bool maximize, bool is_first_step, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
  auto self_clone = clone_arg(self);
auto grads_clone = clone_arg(grads);
auto momentum_buffer_list_clone = clone_arg(momentum_buffer_list);
  at::_ops::_fused_sgd__tensor_lr::call(self_clone, grads_clone, momentum_buffer_list_clone, weight_decay, momentum, lr, dampening, nesterov, maximize, is_first_step, grad_scale, found_inf);
  return ::std::tuple<::std::vector<at::Tensor>,::std::vector<at::Tensor>,::std::vector<at::Tensor>>(self_clone, grads_clone, momentum_buffer_list_clone);
}


at::Tensor & _new_zeros_with_same_feature_meta_out(const at::Tensor & self, const at::Tensor & other, int64_t self_num_batch_dims, at::Tensor & out) {
  auto tmp_output = at::_ops::_new_zeros_with_same_feature_meta::call(self, other, self_num_batch_dims);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> _cudnn_ctc_loss_out(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool deterministic, bool zero_infinity, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_cudnn_ctc_loss::call(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & _cudnn_rnn_flatten_weight_out_symint(at::TensorList weight_arr, int64_t weight_stride0, c10::SymInt input_size, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, bool bidirectional, at::Tensor & out) {
  auto tmp_output = at::_ops::_cudnn_rnn_flatten_weight::call(weight_arr, weight_stride0, input_size, mode, hidden_size, proj_size, num_layers, batch_first, bidirectional);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _cudnn_rnn_out_symint(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const c10::optional<at::Tensor> & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3, at::Tensor & out4) {
  auto tmp_output = at::_ops::_cudnn_rnn::call(input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  resize_out_helper(out4, std::get<4>(tmp_output));
  copy_arg(out4, std::get<4>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3, out4);
}

void _cudnn_rnn_backward_out_symint(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::TensorList out3) {
  auto tmp_output = at::_ops::_cudnn_rnn_backward::call(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  
}

at::Tensor & _cudnn_init_dropout_state_out(double dropout, bool train, int64_t dropout_seed, at::Tensor & out) {
  auto tmp_output = at::_ops::_cudnn_init_dropout_state::call(dropout, train, dropout_seed, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> _fused_dropout_out(const at::Tensor & self, double p, c10::optional<at::Generator> generator, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_fused_dropout::call(self, p, generator);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & _masked_scale_out(const at::Tensor & self, const at::Tensor & mask, double scale, at::Tensor & out) {
  auto tmp_output = at::_ops::_masked_scale::call(self, mask, scale);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> native_dropout_out(const at::Tensor & input, double p, c10::optional<bool> train, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::native_dropout::call(input, p, train);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & native_dropout_backward_out(const at::Tensor & grad_output, const at::Tensor & mask, double scale, at::Tensor & out) {
  auto tmp_output = at::_ops::native_dropout_backward::call(grad_output, mask, scale);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _conj_physical_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_conj_physical::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _add_relu_Scalar_out(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha, at::Tensor & out) {
  auto tmp_output = at::_ops::_add_relu_Scalar::call(self, other, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & add_Scalar_out(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha, at::Tensor & out) {
  auto tmp_output = at::_ops::add_Scalar::call(self, other, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & affine_grid_generator_out_symint(const at::Tensor & theta, c10::SymIntArrayRef size, bool align_corners, at::Tensor & out) {
  auto tmp_output = at::_ops::affine_grid_generator::call(theta, size, align_corners);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _test_functorch_fallback_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::_test_functorch_fallback::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bartlett_window_out(int64_t window_length, at::Tensor & out) {
  auto tmp_output = at::_ops::bartlett_window::call(window_length, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bartlett_window_periodic_out(int64_t window_length, bool periodic, at::Tensor & out) {
  auto tmp_output = at::_ops::bartlett_window_periodic::call(window_length, periodic, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & quantized_batch_norm_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & var, double eps, double output_scale, int64_t output_zero_point, at::Tensor & out) {
  auto tmp_output = at::_ops::quantized_batch_norm::call(input, weight, bias, mean, var, eps, output_scale, output_zero_point);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bernoulli_Tensor_out(const at::Tensor & self, const at::Tensor & p, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::bernoulli_Tensor::call(self, p, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bernoulli_float_out(const at::Tensor & self, double p, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::bernoulli_p::call(self, p, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & binary_cross_entropy_with_logits_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & pos_weight, int64_t reduction, at::Tensor & out) {
  auto tmp_output = at::_ops::binary_cross_entropy_with_logits::call(self, target, weight, pos_weight, reduction);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bincount_out(const at::Tensor & self, const c10::optional<at::Tensor> & weights, int64_t minlength, at::Tensor & out) {
  auto tmp_output = at::_ops::bincount::call(self, weights, minlength);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & blackman_window_out(int64_t window_length, at::Tensor & out) {
  auto tmp_output = at::_ops::blackman_window::call(window_length, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & blackman_window_periodic_out(int64_t window_length, bool periodic, at::Tensor & out) {
  auto tmp_output = at::_ops::blackman_window_periodic::call(window_length, periodic, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & block_diag_out(at::TensorList tensors, at::Tensor & out) {
  auto tmp_output = at::_ops::block_diag::call(tensors);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & constant_pad_nd_out_symint(const at::Tensor & self, c10::SymIntArrayRef pad, const at::Scalar & value, at::Tensor & out) {
  auto tmp_output = at::_ops::constant_pad_nd::call(self, pad, value);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & convolution_out_symint(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, at::Tensor & out) {
  auto tmp_output = at::_ops::convolution::call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> convolution_backward_out_symint(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalSymIntArrayRef bias_sizes, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::convolution_backward::call(grad_output, input, weight, bias_sizes, stride, padding, dilation, transposed, output_padding, groups, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & convolution_overrideable_out_symint(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, at::Tensor & out) {
  auto tmp_output = at::_ops::convolution_overrideable::call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> convolution_backward_overrideable_out_symint(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::convolution_backward_overrideable::call(grad_output, input, weight, stride, padding, dilation, transposed, output_padding, groups, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & _convolution_out_symint(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, bool benchmark, bool deterministic, bool cudnn_enabled, bool allow_tf32, at::Tensor & out) {
  auto tmp_output = at::_ops::_convolution::call(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & conv_tbc_out(const at::Tensor & self, const at::Tensor & weight, const at::Tensor & bias, int64_t pad, at::Tensor & out) {
  auto tmp_output = at::_ops::conv_tbc::call(self, weight, bias, pad);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & copy_out(const at::Tensor & self, const at::Tensor & src, bool non_blocking, at::Tensor & out) {
  auto tmp_output = at::_ops::copy::call(self, src, non_blocking);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _copy_from_out(const at::Tensor & self, const at::Tensor & dst, bool non_blocking, at::Tensor & out) {
  auto tmp_output = at::_ops::_copy_from::call(self, dst, non_blocking);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _copy_from_and_resize_out(const at::Tensor & self, const at::Tensor & dst, at::Tensor & out) {
  auto tmp_output = at::_ops::_copy_from_and_resize::call(self, dst);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & count_nonzero_dim_IntList_out(const at::Tensor & self, at::IntArrayRef dim, at::Tensor & out) {
  auto tmp_output = at::_ops::count_nonzero_dim_IntList::call(self, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & count_nonzero_out(const at::Tensor & self, c10::optional<int64_t> dim, at::Tensor & out) {
  auto tmp_output = at::_ops::count_nonzero::call(self, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & cudnn_affine_grid_generator_out(const at::Tensor & theta, int64_t N, int64_t C, int64_t H, int64_t W, at::Tensor & out) {
  auto tmp_output = at::_ops::cudnn_affine_grid_generator::call(theta, N, C, H, W);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & cudnn_affine_grid_generator_backward_out(const at::Tensor & grad, int64_t N, int64_t C, int64_t H, int64_t W, at::Tensor & out) {
  auto tmp_output = at::_ops::cudnn_affine_grid_generator_backward::call(grad, N, C, H, W);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> cudnn_batch_norm_out(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3) {
  auto tmp_output = at::_ops::cudnn_batch_norm::call(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> cudnn_batch_norm_backward_out(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, const at::Tensor & reserveSpace, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::cudnn_batch_norm_backward::call(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & cudnn_convolution_transpose_out_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32, at::Tensor & out) {
  auto tmp_output = at::_ops::cudnn_convolution_transpose::call(self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _mps_convolution_transpose_out_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
  auto tmp_output = at::_ops::_mps_convolution_transpose::call(self, weight, padding, output_padding, stride, dilation, groups);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> mps_convolution_transpose_backward_out_symint(const at::Tensor & self, const at::Tensor & grad_output, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, ::std::array<bool,2> output_mask, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::mps_convolution_transpose_backward::call(self, grad_output, weight, padding, output_padding, stride, dilation, groups, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & cudnn_convolution_relu_out_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
  auto tmp_output = at::_ops::cudnn_convolution_relu::call(self, weight, bias, stride, padding, dilation, groups);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & cudnn_convolution_add_relu_out_symint(const at::Tensor & self, const at::Tensor & weight, const at::Tensor & z, const c10::optional<at::Scalar> & alpha, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
  auto tmp_output = at::_ops::cudnn_convolution_add_relu::call(self, weight, z, alpha, bias, stride, padding, dilation, groups);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & cudnn_grid_sampler_out(const at::Tensor & self, const at::Tensor & grid, at::Tensor & out) {
  auto tmp_output = at::_ops::cudnn_grid_sampler::call(self, grid);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> cudnn_grid_sampler_backward_out(const at::Tensor & self, const at::Tensor & grid, const at::Tensor & grad_output, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::cudnn_grid_sampler_backward::call(self, grid, grad_output);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &> _ctc_loss_out(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool zero_infinity, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_ctc_loss::call(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &> _ctc_loss_Tensor_out(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool zero_infinity, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_ctc_loss_Tensor::call(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & _ctc_loss_backward_out(const at::Tensor & grad, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, const at::Tensor & neg_log_likelihood, const at::Tensor & log_alpha, int64_t blank, bool zero_infinity, at::Tensor & out) {
  auto tmp_output = at::_ops::_ctc_loss_backward::call(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & diag_embed_out(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
  auto tmp_output = at::_ops::diag_embed::call(self, offset, dim1, dim2);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & diagonal_backward_out_symint(const at::Tensor & grad_output, c10::SymIntArrayRef input_sizes, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
  auto tmp_output = at::_ops::diagonal_backward::call(grad_output, input_sizes, offset, dim1, dim2);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & div_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto tmp_output = at::_ops::div_Scalar::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & div_Scalar_mode_out(const at::Tensor & self, const at::Scalar & other, c10::optional<c10::string_view> rounding_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::div_Scalar_mode::call(self, other, rounding_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & embedding_out_symint(const at::Tensor & weight, const at::Tensor & indices, c10::SymInt padding_idx, bool scale_grad_by_freq, bool sparse, at::Tensor & out) {
  auto tmp_output = at::_ops::embedding::call(weight, indices, padding_idx, scale_grad_by_freq, sparse);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & embedding_dense_backward_out_symint(const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq, at::Tensor & out) {
  auto tmp_output = at::_ops::embedding_dense_backward::call(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & embedding_renorm_out(const at::Tensor & self, const at::Tensor & indices, double max_norm, double norm_type, at::Tensor & out) {
  auto tmp_output = at::_ops::embedding_renorm::call(self, indices, max_norm, norm_type);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _embedding_bag_forward_only_out(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3) {
  auto tmp_output = at::_ops::_embedding_bag_forward_only::call(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _embedding_bag_out(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3) {
  auto tmp_output = at::_ops::_embedding_bag::call(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3);
}

at::Tensor & _embedding_bag_dense_backward_out_symint(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx, at::Tensor & out) {
  auto tmp_output = at::_ops::_embedding_bag_dense_backward::call(grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _embedding_bag_per_sample_weights_backward_out(const at::Tensor & grad, const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, const at::Tensor & offset2bag, int64_t mode, int64_t padding_idx, at::Tensor & out) {
  auto tmp_output = at::_ops::_embedding_bag_per_sample_weights_backward::call(grad, weight, indices, offsets, offset2bag, mode, padding_idx);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & empty_names_out(at::IntArrayRef size, c10::optional<at::DimnameList> names, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::empty_names::call(size, names, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & empty_permuted_out_symint(c10::SymIntArrayRef size, at::IntArrayRef physical_layout, at::Tensor & out) {
  auto tmp_output = at::_ops::empty_permuted::call(size, physical_layout, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & new_empty_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
  auto tmp_output = at::_ops::new_empty::call(self, size, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & new_empty_strided_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, at::Tensor & out) {
  auto tmp_output = at::_ops::new_empty_strided::call(self, size, stride, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & new_full_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, const at::Scalar & fill_value, at::Tensor & out) {
  auto tmp_output = at::_ops::new_full::call(self, size, fill_value, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & new_zeros_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
  auto tmp_output = at::_ops::new_zeros::call(self, size, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & new_ones_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
  auto tmp_output = at::_ops::new_ones::call(self, size, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _empty_affine_quantized_out_symint(c10::SymIntArrayRef size, double scale, int64_t zero_point, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::_empty_affine_quantized::call(size, out.scalar_type(), out.layout(), out.device(), c10::nullopt, scale, zero_point, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _empty_per_channel_affine_quantized_out_symint(c10::SymIntArrayRef size, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::_empty_per_channel_affine_quantized::call(size, scales, zero_points, axis, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

const at::Tensor & resize_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format, const at::Tensor & out) {
  auto tmp_output = at::_ops::resize::call(self, size, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

const at::Tensor & _resize_output_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, at::Device device, const at::Tensor & out) {
  auto tmp_output = at::_ops::_resize_output::call(self, size, device);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & empty_quantized_out(at::IntArrayRef size, const at::Tensor & qtensor, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::empty_quantized::call(size, qtensor, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & empty_like_out(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::empty_like::call(self, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & empty_strided_out_symint(c10::SymIntArrayRef size, c10::SymIntArrayRef stride, at::Tensor & out) {
  auto tmp_output = at::_ops::empty_strided::call(size, stride, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & fill_Scalar_out(const at::Tensor & self, const at::Scalar & value, at::Tensor & out) {
  auto tmp_output = at::_ops::fill_Scalar::call(self, value);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & fill_Tensor_out(const at::Tensor & self, const at::Tensor & value, at::Tensor & out) {
  auto tmp_output = at::_ops::fill_Tensor::call(self, value);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & floor_divide_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto tmp_output = at::_ops::floor_divide_Scalar::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & full_names_out(at::IntArrayRef size, const at::Scalar & fill_value, c10::optional<at::DimnameList> names, at::Tensor & out) {
  auto tmp_output = at::_ops::full_names::call(size, fill_value, names, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & full_like_out(const at::Tensor & self, const at::Scalar & fill_value, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::full_like::call(self, fill_value, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & from_file_out(c10::string_view filename, c10::optional<bool> shared, c10::optional<int64_t> size, at::Tensor & out) {
  auto tmp_output = at::_ops::from_file::call(filename, shared, size, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & grid_sampler_2d_out(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, at::Tensor & out) {
  auto tmp_output = at::_ops::grid_sampler_2d::call(input, grid, interpolation_mode, padding_mode, align_corners);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> grid_sampler_2d_backward_out(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::grid_sampler_2d_backward::call(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & _grid_sampler_2d_cpu_fallback_out(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, at::Tensor & out) {
  auto tmp_output = at::_ops::_grid_sampler_2d_cpu_fallback::call(input, grid, interpolation_mode, padding_mode, align_corners);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & grid_sampler_3d_out(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, at::Tensor & out) {
  auto tmp_output = at::_ops::grid_sampler_3d::call(input, grid, interpolation_mode, padding_mode, align_corners);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> grid_sampler_3d_backward_out(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::grid_sampler_3d_backward::call(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & hann_window_out(int64_t window_length, at::Tensor & out) {
  auto tmp_output = at::_ops::hann_window::call(window_length, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & hann_window_periodic_out(int64_t window_length, bool periodic, at::Tensor & out) {
  auto tmp_output = at::_ops::hann_window_periodic::call(window_length, periodic, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & hamming_window_out(int64_t window_length, at::Tensor & out) {
  auto tmp_output = at::_ops::hamming_window::call(window_length, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & hamming_window_periodic_out(int64_t window_length, bool periodic, at::Tensor & out) {
  auto tmp_output = at::_ops::hamming_window_periodic::call(window_length, periodic, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & hamming_window_periodic_alpha_out(int64_t window_length, bool periodic, double alpha, at::Tensor & out) {
  auto tmp_output = at::_ops::hamming_window_periodic_alpha::call(window_length, periodic, alpha, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & hamming_window_periodic_alpha_beta_out(int64_t window_length, bool periodic, double alpha, double beta, at::Tensor & out) {
  auto tmp_output = at::_ops::hamming_window_periodic_alpha_beta::call(window_length, periodic, alpha, beta, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & kaiser_window_out(int64_t window_length, at::Tensor & out) {
  auto tmp_output = at::_ops::kaiser_window::call(window_length, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & kaiser_window_periodic_out(int64_t window_length, bool periodic, at::Tensor & out) {
  auto tmp_output = at::_ops::kaiser_window_periodic::call(window_length, periodic, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & kaiser_window_beta_out(int64_t window_length, bool periodic, double beta, at::Tensor & out) {
  auto tmp_output = at::_ops::kaiser_window_beta::call(window_length, periodic, beta, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> native_group_norm_out_symint(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, double eps, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::native_group_norm::call(input, weight, bias, N, C, HxW, group, eps);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> native_group_norm_backward_out_symint(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::native_group_norm_backward::call(grad_out, input, mean, rstd, weight, N, C, HxW, group, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & index_put_out(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, at::Tensor & out) {
  auto tmp_output = at::_ops::index_put::call(self, indices, values, accumulate);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _index_put_impl_out(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe, at::Tensor & out) {
  auto tmp_output = at::_ops::_index_put_impl::call(self, indices, values, accumulate, unsafe);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & isnan_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::isnan::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> native_layer_norm_out_symint(const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::native_layer_norm::call(input, normalized_shape, weight, bias, eps);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> native_layer_norm_backward_out_symint(const at::Tensor & grad_out, const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::native_layer_norm_backward::call(grad_out, input, normalized_shape, mean, rstd, weight, bias, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linear_backward_out(const at::Tensor & self, const at::Tensor & grad_output, const at::Tensor & weight, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::linear_backward::call(self, grad_output, weight, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & mkldnn_linear_out(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_linear::call(self, weight, bias);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & mkldnn_linear_backward_input_out(at::IntArrayRef input_size, const at::Tensor & grad_output, const at::Tensor & weight, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_linear_backward_input::call(input_size, grad_output, weight);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> mkldnn_linear_backward_weights_out(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, bool bias_defined, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::mkldnn_linear_backward_weights::call(grad_output, input, weight, bias_defined);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> mkldnn_linear_backward_out(const at::Tensor & self, const at::Tensor & grad_output, const at::Tensor & weight, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::mkldnn_linear_backward::call(self, grad_output, weight, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &> matmul_backward_out(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & other, ::std::array<bool,2> mask, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::matmul_backward::call(grad, self, other, mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &> _aminmax_out(const at::Tensor & self, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_aminmax::call(self);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &> _aminmax_dim_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_aminmax_dim::call(self, dim, keepdim);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & max_pool2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::max_pool2d_backward::call(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & mkldnn_max_pool2d_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_max_pool2d::call(self, kernel_size, stride, padding, dilation, ceil_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & mkldnn_max_pool2d_backward_out(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_max_pool2d_backward::call(grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & mkldnn_max_pool3d_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_max_pool3d::call(self, kernel_size, stride, padding, dilation, ceil_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & mkldnn_max_pool3d_backward_out(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & input, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_max_pool3d_backward::call(grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & quantized_max_pool1d_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::quantized_max_pool1d::call(self, kernel_size, stride, padding, dilation, ceil_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & quantized_max_pool2d_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::quantized_max_pool2d::call(self, kernel_size, stride, padding, dilation, ceil_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & quantized_max_pool3d_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::quantized_max_pool3d::call(self, kernel_size, stride, padding, dilation, ceil_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & median_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::median::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & nanmedian_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::nanmedian::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _mps_convolution_out_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
  auto tmp_output = at::_ops::_mps_convolution::call(self, weight, bias, padding, stride, dilation, groups);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> mps_convolution_backward_out_symint(const at::Tensor & self, const at::Tensor & grad_output, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::mps_convolution_backward::call(self, grad_output, weight, padding, stride, dilation, groups, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & mkldnn_convolution_out_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_convolution::call(self, weight, bias, padding, stride, dilation, groups);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> mkldnn_rnn_layer_out(const at::Tensor & input, const at::Tensor & weight0, const at::Tensor & weight1, const at::Tensor & weight2, const at::Tensor & weight3, const at::Tensor & hx_, const at::Tensor & cx_, bool reverse, at::IntArrayRef batch_sizes, int64_t mode, int64_t hidden_size, int64_t num_layers, bool has_biases, bool bidirectional, bool batch_first, bool train, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3) {
  auto tmp_output = at::_ops::mkldnn_rnn_layer::call(input, weight0, weight1, weight2, weight3, hx_, cx_, reverse, batch_sizes, mode, hidden_size, num_layers, has_biases, bidirectional, batch_first, train);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> mkldnn_rnn_layer_backward_out(const at::Tensor & input, const at::Tensor & weight1, const at::Tensor & weight2, const at::Tensor & weight3, const at::Tensor & weight4, const at::Tensor & hx_, const at::Tensor & cx_tmp, const at::Tensor & output, const at::Tensor & hy_, const at::Tensor & cy_, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, bool reverse, int64_t mode, int64_t hidden_size, int64_t num_layers, bool has_biases, bool train, bool bidirectional, at::IntArrayRef batch_sizes, bool batch_first, const at::Tensor & workspace, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3, at::Tensor & out4, at::Tensor & out5, at::Tensor & out6) {
  auto tmp_output = at::_ops::mkldnn_rnn_layer_backward::call(input, weight1, weight2, weight3, weight4, hx_, cx_tmp, output, hy_, cy_, grad_output, grad_hy, grad_cy, reverse, mode, hidden_size, num_layers, has_biases, train, bidirectional, batch_sizes, batch_first, workspace);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  resize_out_helper(out4, std::get<4>(tmp_output));
  copy_arg(out4, std::get<4>(tmp_output));
  resize_out_helper(out5, std::get<5>(tmp_output));
  copy_arg(out5, std::get<5>(tmp_output));
  resize_out_helper(out6, std::get<6>(tmp_output));
  copy_arg(out6, std::get<6>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3, out4, out5, out6);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> miopen_batch_norm_out(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::miopen_batch_norm::call(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> miopen_batch_norm_backward_out(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::miopen_batch_norm_backward::call(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & miopen_convolution_out_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, at::Tensor & out) {
  auto tmp_output = at::_ops::miopen_convolution::call(self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & miopen_convolution_transpose_out_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, at::Tensor & out) {
  auto tmp_output = at::_ops::miopen_convolution_transpose::call(self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & miopen_depthwise_convolution_out_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, at::Tensor & out) {
  auto tmp_output = at::_ops::miopen_depthwise_convolution::call(self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> miopen_rnn_out(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3, at::Tensor & out4) {
  auto tmp_output = at::_ops::miopen_rnn::call(input, weight, weight_stride0, hx, cx, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  resize_out_helper(out4, std::get<4>(tmp_output));
  copy_arg(out4, std::get<4>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3, out4);
}

void miopen_rnn_backward_out(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::TensorList out3) {
  auto tmp_output = at::_ops::miopen_rnn_backward::call(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  
}

at::Tensor & _sparse_sparse_matmul_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_sparse_matmul::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & mul_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto tmp_output = at::_ops::mul_Scalar::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _native_batch_norm_legit_no_training_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & running_mean, const at::Tensor & running_var, double momentum, double eps, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::_native_batch_norm_legit_no_training::call(input, weight, bias, running_mean, running_var, momentum, eps);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &> batch_norm_stats_out(const at::Tensor & input, double eps, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::batch_norm_stats::call(input, eps);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &> batch_norm_gather_stats_out(const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum, double eps, int64_t count, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::batch_norm_gather_stats::call(input, mean, invstd, running_mean, running_var, momentum, eps, count);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &> batch_norm_gather_stats_with_counts_out(const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum, double eps, const at::Tensor & counts, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::batch_norm_gather_stats_with_counts::call(input, mean, invstd, running_mean, running_var, momentum, eps, counts);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> native_batch_norm_backward_out(const at::Tensor & grad_out, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_invstd, bool train, double eps, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::native_batch_norm_backward::call(grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> batch_norm_backward_reduce_out(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, bool input_g, bool weight_g, bool bias_g, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3) {
  auto tmp_output = at::_ops::batch_norm_backward_reduce::call(grad_out, input, mean, invstd, weight, input_g, weight_g, bias_g);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3);
}

at::Tensor & batch_norm_backward_elemt_out(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, const at::Tensor & sum_dy, const at::Tensor & sum_dy_xmu, const at::Tensor & count, at::Tensor & out) {
  auto tmp_output = at::_ops::batch_norm_backward_elemt::call(grad_out, input, mean, invstd, weight, sum_dy, sum_dy_xmu, count);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> batch_norm_update_stats_out(const at::Tensor & input, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::batch_norm_update_stats::call(input, running_mean, running_var, momentum);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & _nnpack_spatial_convolution_out_symint(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, at::Tensor & out) {
  auto tmp_output = at::_ops::_nnpack_spatial_convolution::call(input, weight, bias, padding, stride);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & ones_names_out(at::IntArrayRef size, c10::optional<at::DimnameList> names, at::Tensor & out) {
  auto tmp_output = at::_ops::ones_names::call(size, names, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & ones_like_out(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::ones_like::call(self, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _euclidean_dist_out(const at::Tensor & x1, const at::Tensor & x2, at::Tensor & out) {
  auto tmp_output = at::_ops::_euclidean_dist::call(x1, x2);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _cdist_forward_out(const at::Tensor & x1, const at::Tensor & x2, double p, c10::optional<int64_t> compute_mode, at::Tensor & out) {
  auto tmp_output = at::_ops::_cdist_forward::call(x1, x2, p, compute_mode);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _cdist_backward_out(const at::Tensor & grad, const at::Tensor & x1, const at::Tensor & x2, double p, const at::Tensor & cdist, at::Tensor & out) {
  auto tmp_output = at::_ops::_cdist_backward::call(grad, x1, x2, p, cdist);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _pdist_forward_out(const at::Tensor & self, double p, at::Tensor & out) {
  auto tmp_output = at::_ops::_pdist_forward::call(self, p);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _pdist_backward_out(const at::Tensor & grad, const at::Tensor & self, double p, const at::Tensor & pdist, at::Tensor & out) {
  auto tmp_output = at::_ops::_pdist_backward::call(grad, self, p, pdist);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & pixel_shuffle_out(const at::Tensor & self, int64_t upscale_factor, at::Tensor & out) {
  auto tmp_output = at::_ops::pixel_shuffle::call(self, upscale_factor);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & pixel_unshuffle_out(const at::Tensor & self, int64_t downscale_factor, at::Tensor & out) {
  auto tmp_output = at::_ops::pixel_unshuffle::call(self, downscale_factor);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & channel_shuffle_out_symint(const at::Tensor & self, c10::SymInt groups, at::Tensor & out) {
  auto tmp_output = at::_ops::channel_shuffle::call(self, groups);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _pin_memory_out(const at::Tensor & self, c10::optional<at::Device> device, at::Tensor & out) {
  auto tmp_output = at::_ops::_pin_memory::call(self, device);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & scalar_tensor_out(const at::Scalar & s, at::Tensor & out) {
  auto tmp_output = at::_ops::scalar_tensor::call(s, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & rand_names_out_symint(c10::SymIntArrayRef size, c10::optional<at::DimnameList> names, at::Tensor & out) {
  auto tmp_output = at::_ops::rand_names::call(size, names, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & rand_generator_with_names_out_symint(c10::SymIntArrayRef size, c10::optional<at::Generator> generator, c10::optional<at::DimnameList> names, at::Tensor & out) {
  auto tmp_output = at::_ops::rand_generator_with_names::call(size, generator, names, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & rand_like_out(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::rand_like::call(self, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & randint_like_out_symint(const at::Tensor & self, c10::SymInt high, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::randint_like::call(self, high, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & randint_like_low_dtype_out_symint(const at::Tensor & self, c10::SymInt low, c10::SymInt high, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::randint_like_low_dtype::call(self, low, high, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & randn_names_out_symint(c10::SymIntArrayRef size, c10::optional<at::DimnameList> names, at::Tensor & out) {
  auto tmp_output = at::_ops::randn_names::call(size, names, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & randn_generator_with_names_out_symint(c10::SymIntArrayRef size, c10::optional<at::Generator> generator, c10::optional<at::DimnameList> names, at::Tensor & out) {
  auto tmp_output = at::_ops::randn_generator_with_names::call(size, generator, names, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & randn_like_out(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::randn_like::call(self, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & repeat_out_symint(const at::Tensor & self, c10::SymIntArrayRef repeats, at::Tensor & out) {
  auto tmp_output = at::_ops::repeat::call(self, repeats);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & repeat_interleave_Tensor_out_symint(const at::Tensor & repeats, c10::optional<c10::SymInt> output_size, at::Tensor & out) {
  auto tmp_output = at::_ops::repeat_interleave_Tensor::call(repeats, output_size);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _mkldnn_reshape_out(const at::Tensor & self, at::IntArrayRef shape, at::Tensor & out) {
  auto tmp_output = at::_ops::_mkldnn_reshape::call(self, shape);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & relu_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::relu::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & select_backward_out_symint(const at::Tensor & grad_output, c10::SymIntArrayRef input_sizes, int64_t dim, c10::SymInt index, at::Tensor & out) {
  auto tmp_output = at::_ops::select_backward::call(grad_output, input_sizes, dim, index);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & celu_out(const at::Tensor & self, const at::Scalar & alpha, at::Tensor & out) {
  auto tmp_output = at::_ops::celu::call(self, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & slice_backward_out_symint(const at::Tensor & grad_output, c10::SymIntArrayRef input_sizes, int64_t dim, c10::SymInt start, c10::SymInt end, c10::SymInt step, at::Tensor & out) {
  auto tmp_output = at::_ops::slice_backward::call(grad_output, input_sizes, dim, start, end, step);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & slice_scatter_out_symint(const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step, at::Tensor & out) {
  auto tmp_output = at::_ops::slice_scatter::call(self, src, dim, start, end, step);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & select_scatter_out_symint(const at::Tensor & self, const at::Tensor & src, int64_t dim, c10::SymInt index, at::Tensor & out) {
  auto tmp_output = at::_ops::select_scatter::call(self, src, dim, index);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & diagonal_scatter_out(const at::Tensor & self, const at::Tensor & src, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
  auto tmp_output = at::_ops::diagonal_scatter::call(self, src, offset, dim1, dim2);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & as_strided_scatter_out_symint(const at::Tensor & self, const at::Tensor & src, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset, at::Tensor & out) {
  auto tmp_output = at::_ops::as_strided_scatter::call(self, src, size, stride, storage_offset);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

void unsafe_split_Tensor_out_symint(const at::Tensor & self, c10::SymInt split_size, int64_t dim, at::TensorList out) {
  auto tmp_output = at::_ops::unsafe_split_Tensor::call(self, split_size, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void unsafe_split_with_sizes_out_symint(const at::Tensor & self, c10::SymIntArrayRef split_sizes, int64_t dim, at::TensorList out) {
  auto tmp_output = at::_ops::unsafe_split_with_sizes::call(self, split_sizes, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

at::Tensor & sum_out(const at::Tensor & self, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::sum::call(self, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> std_mean_correction_out(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::std_mean_correction::call(self, dim, correction, keepdim);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & prod_out(const at::Tensor & self, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::prod::call(self, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _mkldnn_transpose_out(const at::Tensor & self, int64_t dim0, int64_t dim1, at::Tensor & out) {
  auto tmp_output = at::_ops::_mkldnn_transpose::call(self, dim0, dim1);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & flip_out(const at::Tensor & self, at::IntArrayRef dims, at::Tensor & out) {
  auto tmp_output = at::_ops::flip::call(self, dims);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & roll_out_symint(const at::Tensor & self, c10::SymIntArrayRef shifts, at::IntArrayRef dims, at::Tensor & out) {
  auto tmp_output = at::_ops::roll::call(self, shifts, dims);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & rot90_out(const at::Tensor & self, int64_t k, at::IntArrayRef dims, at::Tensor & out) {
  auto tmp_output = at::_ops::rot90::call(self, k, dims);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _transform_bias_rescale_qkv_out(const at::Tensor & qkv, const at::Tensor & qkv_bias, int64_t num_heads, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::_transform_bias_rescale_qkv::call(qkv, qkv_bias, num_heads);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & _nested_tensor_from_mask_out(const at::Tensor & t, const at::Tensor & mask, bool mask_check, at::Tensor & out) {
  auto tmp_output = at::_ops::_nested_tensor_from_mask::call(t, mask, mask_check);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _nested_from_padded_out(const at::Tensor & padded, const at::Tensor & cpu_nested_shape_example, bool fuse_transform_0213, at::Tensor & out) {
  auto tmp_output = at::_ops::_nested_from_padded::call(padded, cpu_nested_shape_example, fuse_transform_0213);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _nested_tensor_size_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_nested_tensor_size::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _nested_tensor_strides_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_nested_tensor_strides::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _nested_tensor_storage_offsets_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_nested_tensor_storage_offsets::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _nested_from_padded_and_nested_example_out(const at::Tensor & padded, const at::Tensor & nt_example, at::Tensor & out) {
  auto tmp_output = at::_ops::_nested_from_padded_and_nested_example::call(padded, nt_example);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _nested_view_from_buffer_copy_out(const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets, at::Tensor & out) {
  auto tmp_output = at::_ops::_nested_view_from_buffer_copy::call(self, nested_size, nested_strides, offsets);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _trilinear_out(const at::Tensor & i1, const at::Tensor & i2, const at::Tensor & i3, at::IntArrayRef expand1, at::IntArrayRef expand2, at::IntArrayRef expand3, at::IntArrayRef sumdim, int64_t unroll_dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_trilinear::call(i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> _unique_out(const at::Tensor & self, bool sorted, bool return_inverse, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_unique::call(self, sorted, return_inverse);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> unique_dim_out(const at::Tensor & self, int64_t dim, bool sorted, bool return_inverse, bool return_counts, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::unique_dim::call(self, dim, sorted, return_inverse, return_counts);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> unique_consecutive_out(const at::Tensor & self, bool return_inverse, bool return_counts, c10::optional<int64_t> dim, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::unique_consecutive::call(self, return_inverse, return_counts, dim);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> unique_dim_consecutive_out(const at::Tensor & self, int64_t dim, bool return_inverse, bool return_counts, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::unique_dim_consecutive::call(self, dim, return_inverse, return_counts);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _unique2_out(const at::Tensor & self, bool sorted, bool return_inverse, bool return_counts, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::_unique2::call(self, sorted, return_inverse, return_counts);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & _unsafe_view_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
  auto tmp_output = at::_ops::_unsafe_view::call(self, size);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> var_mean_correction_out(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::var_mean_correction::call(self, dim, correction, keepdim);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &> _weight_norm_interface_out(const at::Tensor & v, const at::Tensor & g, int64_t dim, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_weight_norm_interface::call(v, g, dim);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &> _weight_norm_interface_backward_out(const at::Tensor & grad_w, const at::Tensor & saved_v, const at::Tensor & saved_g, const at::Tensor & saved_norms, int64_t dim, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_weight_norm_interface_backward::call(grad_w, saved_v, saved_g, saved_norms, dim);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & zeros_names_out(at::IntArrayRef size, c10::optional<at::DimnameList> names, at::Tensor & out) {
  auto tmp_output = at::_ops::zeros_names::call(size, names, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _efficientzerotensor_out_symint(c10::SymIntArrayRef size, at::Tensor & out) {
  auto tmp_output = at::_ops::_efficientzerotensor::call(size, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & zeros_like_out(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::zeros_like::call(self, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _standard_gamma_grad_out(const at::Tensor & self, const at::Tensor & output, at::Tensor & out) {
  auto tmp_output = at::_ops::_standard_gamma_grad::call(self, output);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _standard_gamma_out(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::_standard_gamma::call(self, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _dirichlet_grad_out(const at::Tensor & x, const at::Tensor & alpha, const at::Tensor & total, at::Tensor & out) {
  auto tmp_output = at::_ops::_dirichlet_grad::call(x, alpha, total);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sample_dirichlet_out(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::_sample_dirichlet::call(self, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & poisson_out(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::poisson::call(self, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & binomial_out(const at::Tensor & count, const at::Tensor & prob, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::binomial::call(count, prob, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & native_norm_out(const at::Tensor & self, const at::Scalar & p, at::Tensor & out) {
  auto tmp_output = at::_ops::native_norm::call(self, p);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & native_norm_ScalarOpt_dim_dtype_out(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::native_norm_ScalarOpt_dim_dtype::call(self, p, dim, keepdim, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_sum_dim_out(const at::Tensor & self, at::IntArrayRef dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_sum_dim::call(self, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_sum_backward_out(const at::Tensor & grad, const at::Tensor & self, at::IntArrayRef dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_sum_backward::call(grad, self, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_csr_sum_dim_dtype_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_csr_sum_dim_dtype::call(self, dim, keepdim, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_csr_prod_dim_dtype_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_csr_prod_dim_dtype::call(self, dim, keepdim, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_softmax_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_softmax::call(self, dim, half_to_float);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_softmax_backward_data_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_softmax_backward_data::call(grad_output, output, dim, self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_log_softmax_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_log_softmax::call(self, dim, half_to_float);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_log_softmax_backward_data_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_log_softmax_backward_data::call(grad_output, output, dim, self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _spdiags_out(const at::Tensor & diagonals, const at::Tensor & offsets, at::IntArrayRef shape, c10::optional<at::Layout> layout, at::Tensor & out) {
  auto tmp_output = at::_ops::_spdiags::call(diagonals, offsets, shape, layout);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & norm_ScalarOpt_dtype_out(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::ScalarType dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::norm_ScalarOpt_dtype::call(self, p, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & norm_Scalar_out(const at::Tensor & self, const at::Scalar & p, at::Tensor & out) {
  auto tmp_output = at::_ops::norm_Scalar::call(self, p);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & clone_out(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::clone::call(self, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

const at::Tensor & resize_as_out(const at::Tensor & self, const at::Tensor & the_template, c10::optional<at::MemoryFormat> memory_format, const at::Tensor & out) {
  auto tmp_output = at::_ops::resize_as::call(self, the_template, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

const at::Tensor & resize_as_sparse_out(const at::Tensor & self, const at::Tensor & the_template, const at::Tensor & out) {
  auto tmp_output = at::_ops::resize_as_sparse::call(self, the_template);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & zero_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::zero::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & sub_Scalar_out(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha, at::Tensor & out) {
  auto tmp_output = at::_ops::sub_Scalar::call(self, other, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & rsub_Tensor_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
  auto tmp_output = at::_ops::rsub_Tensor::call(self, other, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & rsub_Scalar_out(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha, at::Tensor & out) {
  auto tmp_output = at::_ops::rsub_Scalar::call(self, other, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_addmm_out(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_addmm::call(self, mat1, mat2, beta, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & sparse_coo_tensor_size_out(at::IntArrayRef size, at::Tensor & out) {
  auto tmp_output = at::_ops::sparse_coo_tensor_size::call(size, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_coo_tensor_with_dims_out(int64_t sparse_dim, int64_t dense_dim, at::IntArrayRef size, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_coo_tensor_with_dims::call(sparse_dim, dense_dim, size, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_coo_tensor_with_dims_and_tensors_out_symint(int64_t sparse_dim, int64_t dense_dim, c10::SymIntArrayRef size, const at::Tensor & indices, const at::Tensor & values, c10::optional<bool> is_coalesced, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_coo_tensor_with_dims_and_tensors::call(sparse_dim, dense_dim, size, indices, values, out.scalar_type(), out.layout(), out.device(), c10::nullopt, is_coalesced);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

const at::Tensor & sparse_resize_out(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim, const at::Tensor & out) {
  auto tmp_output = at::_ops::sparse_resize::call(self, size, sparse_dim, dense_dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

const at::Tensor & sparse_resize_and_clear_out(const at::Tensor & self, at::IntArrayRef size, int64_t sparse_dim, int64_t dense_dim, const at::Tensor & out) {
  auto tmp_output = at::_ops::sparse_resize_and_clear::call(self, size, sparse_dim, dense_dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & sparse_mask_out(const at::Tensor & self, const at::Tensor & mask, at::Tensor & out) {
  auto tmp_output = at::_ops::sparse_mask::call(self, mask);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_mask_projection_out(const at::Tensor & self, const at::Tensor & mask, bool accumulate_matches, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_mask_projection::call(self, mask, accumulate_matches);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _to_dense_out(const at::Tensor & self, c10::optional<at::ScalarType> dtype, c10::optional<bool> masked_grad, at::Tensor & out) {
  auto tmp_output = at::_ops::_to_dense::call(self, dtype, masked_grad);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _coalesce_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_coalesce::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _coalesced_out(const at::Tensor & self, bool coalesced, at::Tensor & out) {
  auto tmp_output = at::_ops::_coalesced::call(self, coalesced);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & copy_sparse_to_sparse_out(const at::Tensor & self, const at::Tensor & src, bool non_blocking, at::Tensor & out) {
  auto tmp_output = at::_ops::copy_sparse_to_sparse::call(self, src, non_blocking);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _to_sparse_sparse_dim_out(const at::Tensor & self, int64_t sparse_dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_to_sparse_sparse_dim::call(self, sparse_dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _to_sparse_out(const at::Tensor & self, c10::optional<at::Layout> layout, at::OptionalIntArrayRef blocksize, c10::optional<int64_t> dense_dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_to_sparse::call(self, layout, blocksize, dense_dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _to_sparse_csr_out(const at::Tensor & self, c10::optional<int64_t> dense_dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_to_sparse_csr::call(self, dense_dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _to_sparse_csc_out(const at::Tensor & self, c10::optional<int64_t> dense_dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_to_sparse_csc::call(self, dense_dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _to_sparse_bsr_out(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_to_sparse_bsr::call(self, blocksize, dense_dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _to_sparse_bsc_out(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_to_sparse_bsc::call(self, blocksize, dense_dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & to_mkldnn_out(const at::Tensor & self, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::to_mkldnn::call(self, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & mkldnn_reorder_conv2d_weight_out_symint(const at::Tensor & self, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::OptionalSymIntArrayRef input_size, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_reorder_conv2d_weight::call(self, padding, stride, dilation, groups, input_size);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & mkldnn_reorder_conv3d_weight_out_symint(const at::Tensor & self, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_reorder_conv3d_weight::call(self, padding, stride, dilation, groups);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & quantize_per_tensor_dynamic_out(const at::Tensor & self, at::ScalarType dtype, bool reduce_range, at::Tensor & out) {
  auto tmp_output = at::_ops::quantize_per_tensor_dynamic::call(self, dtype, reduce_range);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & quantize_per_tensor_out(const at::Tensor & self, double scale, int64_t zero_point, at::ScalarType dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::quantize_per_tensor::call(self, scale, zero_point, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & quantize_per_tensor_tensor_qparams_out(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, at::ScalarType dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::quantize_per_tensor_tensor_qparams::call(self, scale, zero_point, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

void quantize_per_tensor_tensors_out(at::TensorList tensors, const at::Tensor & scales, const at::Tensor & zero_points, at::ScalarType dtype, at::TensorList out) {
  auto tmp_output = at::_ops::quantize_per_tensor_tensors::call(tensors, scales, zero_points, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

at::Tensor & quantize_per_channel_out(const at::Tensor & self, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, at::ScalarType dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::quantize_per_channel::call(self, scales, zero_points, axis, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & dequantize_self_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::dequantize_self::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

void dequantize_tensors_out(at::TensorList tensors, at::TensorList out) {
  auto tmp_output = at::_ops::dequantize_tensors::call(tensors);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

at::Tensor & q_per_channel_scales_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::q_per_channel_scales::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & q_per_channel_zero_points_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::q_per_channel_zero_points::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & int_repr_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::int_repr::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _make_per_tensor_quantized_tensor_out(const at::Tensor & self, double scale, int64_t zero_point, at::Tensor & out) {
  auto tmp_output = at::_ops::_make_per_tensor_quantized_tensor::call(self, scale, zero_point);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _make_per_channel_quantized_tensor_out(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, at::Tensor & out) {
  auto tmp_output = at::_ops::_make_per_channel_quantized_tensor::call(self, scale, zero_point, axis);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> fake_quantize_per_tensor_affine_cachemask_out(const at::Tensor & self, double scale, int64_t zero_point, int64_t quant_min, int64_t quant_max, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::fake_quantize_per_tensor_affine_cachemask::call(self, scale, zero_point, quant_min, quant_max);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &> _fake_quantize_per_tensor_affine_cachemask_tensor_qparams_out(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, const at::Tensor & fake_quant_enabled, int64_t quant_min, int64_t quant_max, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_fake_quantize_per_tensor_affine_cachemask_tensor_qparams::call(self, scale, zero_point, fake_quant_enabled, quant_min, quant_max);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & _fake_quantize_learnable_per_tensor_affine_out(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t quant_min, int64_t quant_max, double grad_factor, at::Tensor & out) {
  auto tmp_output = at::_ops::_fake_quantize_learnable_per_tensor_affine::call(self, scale, zero_point, quant_min, quant_max, grad_factor);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> fake_quantize_per_channel_affine_cachemask_out(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::fake_quantize_per_channel_affine_cachemask::call(self, scale, zero_point, axis, quant_min, quant_max);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & _fake_quantize_learnable_per_channel_affine_out(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, double grad_factor, at::Tensor & out) {
  auto tmp_output = at::_ops::_fake_quantize_learnable_per_channel_affine::call(self, scale, zero_point, axis, quant_min, quant_max, grad_factor);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> _fused_moving_avg_obs_fq_helper_out(const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, at::Tensor & running_min, at::Tensor & running_max, at::Tensor & scale, at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_fused_moving_avg_obs_fq_helper_functional::call(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & _to_copy_out(const at::Tensor & self, bool non_blocking, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto tmp_output = at::_ops::_to_copy::call(self, out.scalar_type(), out.layout(), out.device(), c10::nullopt, non_blocking, memory_format);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _lstm_mps_out(const at::Tensor & input, at::TensorList hx, at::TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional, bool batch_first, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3, at::Tensor & out4, at::Tensor & out5) {
  auto tmp_output = at::_ops::_lstm_mps::call(input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  resize_out_helper(out4, std::get<4>(tmp_output));
  copy_arg(out4, std::get<4>(tmp_output));
  resize_out_helper(out5, std::get<5>(tmp_output));
  copy_arg(out5, std::get<5>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3, out4, out5);
}

void lstm_mps_backward_out(const c10::optional<at::Tensor> & grad_y, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, const at::Tensor & z_state, const at::Tensor & cell_state_fwd, const at::Tensor & input, const at::Tensor & layersOutputs, at::TensorList hx, at::TensorList params, bool has_biases, int64_t num_layers, double dropout, bool train, bool bidirectional, bool batch_first, at::Tensor & out0, at::TensorList out1, at::TensorList out2) {
  auto tmp_output = at::_ops::lstm_mps_backward::call(grad_y, grad_hy, grad_cy, z_state, cell_state_fwd, input, layersOutputs, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _thnn_fused_lstm_cell_out(const at::Tensor & input_gates, const at::Tensor & hidden_gates, const at::Tensor & cx, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::_thnn_fused_lstm_cell::call(input_gates, hidden_gates, cx, input_bias, hidden_bias);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _thnn_fused_lstm_cell_backward_impl_out(const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, const at::Tensor & cx, const at::Tensor & cy, const at::Tensor & workspace, bool has_bias, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::_thnn_fused_lstm_cell_backward_impl::call(grad_hy, grad_cy, cx, cy, workspace, has_bias);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

::std::tuple<at::Tensor &,at::Tensor &> _thnn_fused_gru_cell_out(const at::Tensor & input_gates, const at::Tensor & hidden_gates, const at::Tensor & hx, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_thnn_fused_gru_cell::call(input_gates, hidden_gates, hx, input_bias, hidden_bias);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _thnn_fused_gru_cell_backward_out(const at::Tensor & grad_hy, const at::Tensor & workspace, bool has_bias, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2, at::Tensor & out3, at::Tensor & out4) {
  auto tmp_output = at::_ops::_thnn_fused_gru_cell_backward::call(grad_hy, workspace, has_bias);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  resize_out_helper(out3, std::get<3>(tmp_output));
  copy_arg(out3, std::get<3>(tmp_output));
  resize_out_helper(out4, std::get<4>(tmp_output));
  copy_arg(out4, std::get<4>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2, out3, out4);
}

::std::tuple<at::Tensor &,at::Tensor &> _pack_padded_sequence_out(const at::Tensor & input, const at::Tensor & lengths, bool batch_first, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_pack_padded_sequence::call(input, lengths, batch_first);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & set_source_Storage_out(const at::Tensor & self, at::Storage source, at::Tensor & out) {
  auto tmp_output = at::_ops::set_source_Storage::call(self, source);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & set_source_Storage_storage_offset_out_symint(const at::Tensor & self, at::Storage source, c10::SymInt storage_offset, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, at::Tensor & out) {
  auto tmp_output = at::_ops::set_source_Storage_storage_offset::call(self, source, storage_offset, size, stride);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & set_source_Tensor_out(const at::Tensor & self, const at::Tensor & source, at::Tensor & out) {
  auto tmp_output = at::_ops::set_source_Tensor::call(self, source);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & set_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::set::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & lift_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::lift::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & lift_fresh_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::lift_fresh_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & masked_fill_Scalar_out(const at::Tensor & self, const at::Tensor & mask, const at::Scalar & value, at::Tensor & out) {
  auto tmp_output = at::_ops::masked_fill_Scalar::call(self, mask, value);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & masked_fill_Tensor_out(const at::Tensor & self, const at::Tensor & mask, const at::Tensor & value, at::Tensor & out) {
  auto tmp_output = at::_ops::masked_fill_Tensor::call(self, mask, value);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & masked_scatter_out(const at::Tensor & self, const at::Tensor & mask, const at::Tensor & source, at::Tensor & out) {
  auto tmp_output = at::_ops::masked_scatter::call(self, mask, source);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _masked_softmax_out(const at::Tensor & self, const at::Tensor & mask, c10::optional<int64_t> dim, c10::optional<int64_t> mask_type, at::Tensor & out) {
  auto tmp_output = at::_ops::_masked_softmax::call(self, mask, dim, mask_type);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _masked_softmax_backward_out(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & mask, c10::optional<int64_t> dim, at::Tensor & out) {
  auto tmp_output = at::_ops::_masked_softmax_backward::call(grad_output, output, mask, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & put_out(const at::Tensor & self, const at::Tensor & index, const at::Tensor & source, bool accumulate, at::Tensor & out) {
  auto tmp_output = at::_ops::put::call(self, index, source, accumulate);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & index_fill_int_Scalar_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, at::Tensor & out) {
  auto tmp_output = at::_ops::index_fill_int_Scalar::call(self, dim, index, value);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & index_fill_int_Tensor_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & value, at::Tensor & out) {
  auto tmp_output = at::_ops::index_fill_int_Tensor::call(self, dim, index, value);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bitwise_and_Scalar_Tensor_out(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::bitwise_and_Scalar_Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bitwise_or_Scalar_Tensor_out(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::bitwise_or_Scalar_Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bitwise_xor_Scalar_Tensor_out(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::bitwise_xor_Scalar_Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & __lshift___Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto tmp_output = at::_ops::__lshift___Scalar::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & __lshift___Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::__lshift___Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bitwise_left_shift_Scalar_Tensor_out(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::bitwise_left_shift_Scalar_Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & __rshift___Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto tmp_output = at::_ops::__rshift___Scalar::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & __rshift___Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::__rshift___Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & bitwise_right_shift_Scalar_Tensor_out(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::bitwise_right_shift_Scalar_Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & random_from_out(const at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::random_from::call(self, from, to, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & random_to_out(const at::Tensor & self, int64_t to, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::random_to::call(self, to, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & random_out(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::random::call(self, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & uniform_out(const at::Tensor & self, double from, double to, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::uniform::call(self, from, to, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & cauchy_out(const at::Tensor & self, double median, double sigma, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::cauchy::call(self, median, sigma, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & log_normal_out(const at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::log_normal::call(self, mean, std, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & exponential_out(const at::Tensor & self, double lambd, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::exponential::call(self, lambd, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & geometric_out(const at::Tensor & self, double p, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::geometric::call(self, p, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & tril_indices_out(int64_t row, int64_t col, int64_t offset, at::Tensor & out) {
  auto tmp_output = at::_ops::tril_indices::call(row, col, offset, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & triu_indices_out(int64_t row, int64_t col, int64_t offset, at::Tensor & out) {
  auto tmp_output = at::_ops::triu_indices::call(row, col, offset, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & trace_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::trace::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _cholesky_solve_helper_out(const at::Tensor & self, const at::Tensor & A, bool upper, at::Tensor & out) {
  auto tmp_output = at::_ops::_cholesky_solve_helper::call(self, A, upper);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & dist_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & p, at::Tensor & out) {
  auto tmp_output = at::_ops::dist::call(self, other, p);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

void _histogramdd_bin_edges_out(const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density, at::TensorList out) {
  auto tmp_output = at::_ops::_histogramdd_bin_edges::call(self, bins, range, weight, density);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

at::Tensor & _histogramdd_from_bin_cts_out(const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & out) {
  auto tmp_output = at::_ops::_histogramdd_from_bin_cts::call(self, bins, range, weight, density);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _histogramdd_from_bin_tensors_out(const at::Tensor & self, at::TensorList bins, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & out) {
  auto tmp_output = at::_ops::_histogramdd_from_bin_tensors::call(self, bins, weight, density);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & remainder_Scalar_Tensor_out(const at::Scalar & self, const at::Tensor & other, at::Tensor & out) {
  auto tmp_output = at::_ops::remainder_Scalar_Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & argsort_stable_out(const at::Tensor & self, bool stable, int64_t dim, bool descending, at::Tensor & out) {
  auto tmp_output = at::_ops::argsort_stable::call(self, stable, dim, descending);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & unfold_backward_out_symint(const at::Tensor & grad_in, c10::SymIntArrayRef input_sizes, int64_t dim, int64_t size, int64_t step, at::Tensor & out) {
  auto tmp_output = at::_ops::unfold_backward::call(grad_in, input_sizes, dim, size, step);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & normal_out(const at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto tmp_output = at::_ops::normal_functional::call(self, mean, std, generator);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

void _amp_foreach_non_finite_check_and_unscale_out(at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale, at::TensorList out) {
  auto tmp_output = at::_ops::_amp_foreach_non_finite_check_and_unscale::call(self, found_inf, inv_scale);
    resize_out_helper(out, std::get<0>(tmp_output));
  copy_arg(out, std::get<0>(tmp_output));
  
}

at::Tensor & _amp_update_scale_out(const at::Tensor & self, at::Tensor & growth_tracker, const at::Tensor & found_inf, double scale_growth_factor, double scale_backoff_factor, int64_t growth_interval, at::Tensor & out) {
  auto tmp_output = at::_ops::_amp_update_scale::call(self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
    resize_out_helper(out, std::get<0>(tmp_output));
  copy_arg(out, std::get<0>(tmp_output));
  return out;
}

void _foreach_add_Scalar_out(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_add_Scalar::call(self, scalar);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_add_List_out(at::TensorList self, at::TensorList other, const at::Scalar & alpha, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_add_List::call(self, other, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_add_ScalarList_out(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_add_ScalarList::call(self, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_add_Tensor_out(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_add_Tensor::call(self, other, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_sub_Scalar_out(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_sub_Scalar::call(self, scalar);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_sub_List_out(at::TensorList self, at::TensorList other, const at::Scalar & alpha, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_sub_List::call(self, other, alpha);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_sub_ScalarList_out(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_sub_ScalarList::call(self, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_mul_Scalar_out(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_mul_Scalar::call(self, scalar);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_mul_List_out(at::TensorList self, at::TensorList other, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_mul_List::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_mul_ScalarList_out(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_mul_ScalarList::call(self, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_mul_Tensor_out(at::TensorList self, const at::Tensor & other, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_mul_Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_div_Scalar_out(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_div_Scalar::call(self, scalar);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_div_List_out(at::TensorList self, at::TensorList other, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_div_List::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_div_ScalarList_out(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_div_ScalarList::call(self, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_div_Tensor_out(at::TensorList self, const at::Tensor & other, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_div_Tensor::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_clamp_max_Scalar_out(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_clamp_max_Scalar::call(self, scalar);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_clamp_max_List_out(at::TensorList self, at::TensorList other, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_clamp_max_List::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_clamp_max_ScalarList_out(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_clamp_max_ScalarList::call(self, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_clamp_min_Scalar_out(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_clamp_min_Scalar::call(self, scalar);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_clamp_min_List_out(at::TensorList self, at::TensorList other, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_clamp_min_List::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_clamp_min_ScalarList_out(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_clamp_min_ScalarList::call(self, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_maximum_Scalar_out(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_maximum_Scalar::call(self, scalar);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_maximum_List_out(at::TensorList self, at::TensorList other, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_maximum_List::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_maximum_ScalarList_out(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_maximum_ScalarList::call(self, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_minimum_Scalar_out(at::TensorList self, const at::Scalar & scalar, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_minimum_Scalar::call(self, scalar);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_minimum_List_out(at::TensorList self, at::TensorList other, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_minimum_List::call(self, other);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_minimum_ScalarList_out(at::TensorList self, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_minimum_ScalarList::call(self, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_addcdiv_Scalar_out(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_addcdiv_Scalar::call(self, tensor1, tensor2, value);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_addcdiv_ScalarList_out(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_addcdiv_ScalarList::call(self, tensor1, tensor2, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_addcdiv_Tensor_out(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_addcdiv_Tensor::call(self, tensor1, tensor2, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_addcmul_Scalar_out(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_addcmul_Scalar::call(self, tensor1, tensor2, value);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_addcmul_ScalarList_out(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_addcmul_ScalarList::call(self, tensor1, tensor2, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_addcmul_Tensor_out(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_addcmul_Tensor::call(self, tensor1, tensor2, scalars);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_abs_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_abs::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_acos_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_acos::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_asin_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_asin::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_atan_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_atan::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_ceil_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_ceil::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_cos_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_cos::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_cosh_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_cosh::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_erf_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_erf::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_erfc_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_erfc::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_exp_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_exp::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_expm1_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_expm1::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_floor_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_floor::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_frac_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_frac::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_lerp_List_out(at::TensorList self, at::TensorList tensors1, at::TensorList weights, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_lerp_List::call(self, tensors1, weights);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_lerp_Scalar_out(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_lerp_Scalar::call(self, tensors1, weight);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_lgamma_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_lgamma::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_log_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_log::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_log10_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_log10::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_log1p_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_log1p::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_log2_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_log2::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_neg_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_neg::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_norm_Scalar_out(at::TensorList self, const at::Scalar & ord, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_norm_Scalar::call(self, ord);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_pow_List_out(at::TensorList self, at::TensorList exponent, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_pow_List::call(self, exponent);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_pow_Scalar_out(at::TensorList self, const at::Scalar & exponent, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_pow_Scalar::call(self, exponent);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_pow_ScalarList_out(at::TensorList self, at::ArrayRef<at::Scalar> exponent, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_pow_ScalarList::call(self, exponent);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_reciprocal_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_reciprocal::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_round_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_round::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_sigmoid_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_sigmoid::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_sign_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_sign::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_sin_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_sin::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_sinh_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_sinh::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_sqrt_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_sqrt::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_tan_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_tan::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_tanh_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_tanh::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_trunc_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_trunc::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_zero_out(at::TensorList self, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_zero::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

void _foreach_copy_out(at::TensorList self, at::TensorList src, bool non_blocking, at::TensorList out) {
  auto tmp_output = at::_ops::_foreach_copy::call(self, src, non_blocking);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  
}

at::Tensor & bucketize_Scalar_out(const at::Scalar & self, const at::Tensor & boundaries, bool out_int32, bool right, at::Tensor & out) {
  auto tmp_output = at::_ops::bucketize_Scalar::call(self, boundaries, out_int32, right);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & glu_jvp_out(const at::Tensor & glu, const at::Tensor & x, const at::Tensor & dx, int64_t dim, at::Tensor & out) {
  auto tmp_output = at::_ops::glu_jvp::call(glu, x, dx, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & glu_backward_jvp_out(const at::Tensor & grad_x, const at::Tensor & grad_glu, const at::Tensor & x, const at::Tensor & dgrad_glu, const at::Tensor & dx, int64_t dim, at::Tensor & out) {
  auto tmp_output = at::_ops::glu_backward_jvp::call(grad_x, grad_glu, x, dgrad_glu, dx, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & hardswish_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::hardswish_backward::call(grad_output, self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & rrelu_with_noise_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, bool self_is_result, at::Tensor & out) {
  auto tmp_output = at::_ops::rrelu_with_noise_backward::call(grad_output, self, noise, lower, upper, training, self_is_result);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & mkldnn_adaptive_avg_pool2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::mkldnn_adaptive_avg_pool2d_backward::call(grad_output, self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _adaptive_avg_pool2d_out_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
  auto tmp_output = at::_ops::_adaptive_avg_pool2d::call(self, output_size);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _adaptive_avg_pool2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_adaptive_avg_pool2d_backward::call(grad_output, self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _adaptive_avg_pool3d_out_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
  auto tmp_output = at::_ops::_adaptive_avg_pool3d::call(self, output_size);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _adaptive_avg_pool3d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_adaptive_avg_pool3d_backward::call(grad_output, self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _slow_conv2d_backward_output_mask_out_symint(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, ::std::array<bool,3> output_mask, at::Tensor & out0, at::Tensor & out1, at::Tensor & out2) {
  auto tmp_output = at::_ops::_slow_conv2d_backward_output_mask::call(grad_output, self, weight, kernel_size, stride, padding, output_mask);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  resize_out_helper(out2, std::get<2>(tmp_output));
  copy_arg(out2, std::get<2>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out0, out1, out2);
}

at::Tensor & conv_depthwise3d_out_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
  auto tmp_output = at::_ops::conv_depthwise3d::call(self, weight, kernel_size, bias, stride, padding, dilation);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & slow_conv_dilated2d_out_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
  auto tmp_output = at::_ops::slow_conv_dilated2d::call(self, weight, kernel_size, bias, stride, padding, dilation);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & slow_conv_dilated3d_out_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
  auto tmp_output = at::_ops::slow_conv_dilated3d::call(self, weight, kernel_size, bias, stride, padding, dilation);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & isinf_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::isinf::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & linalg_matrix_exp_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::linalg_matrix_exp::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _test_optional_intlist_out(const at::Tensor & values, at::OptionalIntArrayRef addends, at::Tensor & out) {
  auto tmp_output = at::_ops::_test_optional_intlist::call(values, addends);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _test_optional_filled_intlist_out(const at::Tensor & values, at::OptionalIntArrayRef addends, at::Tensor & out) {
  auto tmp_output = at::_ops::_test_optional_filled_intlist::call(values, addends);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _test_optional_floatlist_out(const at::Tensor & values, c10::optional<at::ArrayRef<double>> addends, at::Tensor & out) {
  auto tmp_output = at::_ops::_test_optional_floatlist::call(values, addends);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _test_warn_in_autograd_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_test_warn_in_autograd::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _test_autograd_multiple_dispatch_fullcoverage_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_test_autograd_multiple_dispatch_fullcoverage::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _test_autograd_multiple_dispatch_view_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_test_autograd_multiple_dispatch_view_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & segment_reduce_out(const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & indices, const c10::optional<at::Tensor> & offsets, int64_t axis, bool unsafe, const c10::optional<at::Scalar> & initial, at::Tensor & out) {
  auto tmp_output = at::_ops::segment_reduce::call(data, reduce, lengths, indices, offsets, axis, unsafe, initial);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _segment_reduce_backward_out(const at::Tensor & grad, const at::Tensor & output, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & offsets, int64_t axis, const c10::optional<at::Scalar> & initial, at::Tensor & out) {
  auto tmp_output = at::_ops::_segment_reduce_backward::call(grad, output, data, reduce, lengths, offsets, axis, initial);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _nested_tensor_from_tensor_list_out(at::TensorList list, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, at::Tensor & out) {
  auto tmp_output = at::_ops::_nested_tensor_from_tensor_list::call(list, dtype, layout, device, pin_memory);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _fw_primal_copy_out(const at::Tensor & self, int64_t level, at::Tensor & out) {
  auto tmp_output = at::_ops::_fw_primal_copy::call(self, level);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _make_dual_copy_out(const at::Tensor & primal, const at::Tensor & tangent, int64_t level, at::Tensor & out) {
  auto tmp_output = at::_ops::_make_dual_copy::call(primal, tangent, level);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & view_as_real_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::view_as_real_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & view_as_complex_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::view_as_complex_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _conj_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_conj_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _neg_view_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_neg_view_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & as_strided_copy_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset, at::Tensor & out) {
  auto tmp_output = at::_ops::as_strided_copy::call(self, size, stride, storage_offset);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _sparse_broadcast_to_copy_out(const at::Tensor & self, at::IntArrayRef size, at::Tensor & out) {
  auto tmp_output = at::_ops::_sparse_broadcast_to_copy::call(self, size);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & diagonal_copy_out(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2, at::Tensor & out) {
  auto tmp_output = at::_ops::diagonal_copy::call(self, offset, dim1, dim2);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & expand_copy_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, bool implicit, at::Tensor & out) {
  auto tmp_output = at::_ops::expand_copy::call(self, size, implicit);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & permute_copy_out(const at::Tensor & self, at::IntArrayRef dims, at::Tensor & out) {
  auto tmp_output = at::_ops::permute_copy::call(self, dims);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _reshape_alias_copy_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, at::Tensor & out) {
  auto tmp_output = at::_ops::_reshape_alias_copy::call(self, size, stride);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & select_copy_int_out_symint(const at::Tensor & self, int64_t dim, c10::SymInt index, at::Tensor & out) {
  auto tmp_output = at::_ops::select_copy_int::call(self, dim, index);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & detach_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::detach_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & slice_copy_Tensor_out_symint(const at::Tensor & self, int64_t dim, c10::optional<c10::SymInt> start, c10::optional<c10::SymInt> end, c10::SymInt step, at::Tensor & out) {
  auto tmp_output = at::_ops::slice_copy_Tensor::call(self, dim, start, end, step);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & squeeze_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::squeeze_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & squeeze_copy_dim_out(const at::Tensor & self, int64_t dim, at::Tensor & out) {
  auto tmp_output = at::_ops::squeeze_copy_dim::call(self, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & squeeze_copy_dims_out(const at::Tensor & self, at::IntArrayRef dim, at::Tensor & out) {
  auto tmp_output = at::_ops::squeeze_copy_dims::call(self, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & t_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::t_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & transpose_copy_int_out(const at::Tensor & self, int64_t dim0, int64_t dim1, at::Tensor & out) {
  auto tmp_output = at::_ops::transpose_copy_int::call(self, dim0, dim1);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & unsqueeze_copy_out(const at::Tensor & self, int64_t dim, at::Tensor & out) {
  auto tmp_output = at::_ops::unsqueeze_copy::call(self, dim);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _indices_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_indices_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _values_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::_values_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & indices_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::indices_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & values_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::values_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & crow_indices_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::crow_indices_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & col_indices_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::col_indices_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & ccol_indices_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::ccol_indices_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & row_indices_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::row_indices_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & view_copy_out_symint(const at::Tensor & self, c10::SymIntArrayRef size, at::Tensor & out) {
  auto tmp_output = at::_ops::view_copy::call(self, size);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & view_copy_dtype_out(const at::Tensor & self, at::ScalarType dtype, at::Tensor & out) {
  auto tmp_output = at::_ops::view_copy_dtype::call(self, dtype);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & unfold_copy_out(const at::Tensor & self, int64_t dimension, int64_t size, int64_t step, at::Tensor & out) {
  auto tmp_output = at::_ops::unfold_copy::call(self, dimension, size, step);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & alias_copy_out(const at::Tensor & self, at::Tensor & out) {
  auto tmp_output = at::_ops::alias_copy::call(self);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & to_padded_tensor_out_symint(const at::Tensor & self, double padding, at::OptionalSymIntArrayRef output_size, at::Tensor & out) {
  auto tmp_output = at::_ops::to_padded_tensor::call(self, padding, output_size);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _transformer_encoder_layer_fwd_out(const at::Tensor & src, int64_t embed_dim, int64_t num_heads, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, bool use_gelu, bool norm_first, double eps, const at::Tensor & norm_weight_1, const at::Tensor & norm_bias_1, const at::Tensor & norm_weight_2, const at::Tensor & norm_bias_2, const at::Tensor & ffn_weight_1, const at::Tensor & ffn_bias_1, const at::Tensor & ffn_weight_2, const at::Tensor & ffn_bias_2, const c10::optional<at::Tensor> & mask, c10::optional<int64_t> mask_type, at::Tensor & out) {
  auto tmp_output = at::_ops::_transformer_encoder_layer_fwd::call(src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, mask_type);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

::std::tuple<at::Tensor &,at::Tensor &> _native_multi_head_attention_out(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, int64_t embed_dim, int64_t num_head, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, const c10::optional<at::Tensor> & mask, bool need_weights, bool average_attn_weights, c10::optional<int64_t> mask_type, at::Tensor & out0, at::Tensor & out1) {
  auto tmp_output = at::_ops::_native_multi_head_attention::call(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, need_weights, average_attn_weights, mask_type);
    resize_out_helper(out0, std::get<0>(tmp_output));
  copy_arg(out0, std::get<0>(tmp_output));
  resize_out_helper(out1, std::get<1>(tmp_output));
  copy_arg(out1, std::get<1>(tmp_output));
  return ::std::tuple<at::Tensor &,at::Tensor &>(out0, out1);
}

at::Tensor & _triton_scaled_dot_attention_out(const at::Tensor & q, const at::Tensor & k, const at::Tensor & v, double dropout_p, at::Tensor & out) {
  auto tmp_output = at::_ops::_triton_scaled_dot_attention::call(q, k, v, dropout_p);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _triton_multi_head_attention_out(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, int64_t embed_dim, int64_t num_head, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, const c10::optional<at::Tensor> & mask, at::Tensor & out) {
  auto tmp_output = at::_ops::_triton_multi_head_attention::call(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

at::Tensor & _foobar_out(const at::Tensor & self, bool arg1, bool arg2, bool arg3, at::Tensor & out) {
  auto tmp_output = at::_ops::_foobar::call(self, arg1, arg2, arg3);
    resize_out_helper(out, tmp_output);
  copy_arg(out, tmp_output);
  return out;
}

void _fused_adam_out(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, double lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf, at::TensorList out) {
  auto tmp_output = at::_ops::_fused_adam::call(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
    resize_out_helper(out, std::get<0>(tmp_output));
  copy_arg(out, std::get<0>(tmp_output));
  
}

void _fused_adam_tensor_lr_out(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, const at::Tensor & lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf, at::TensorList out) {
  auto tmp_output = at::_ops::_fused_adam_tensor_lr::call(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
    resize_out_helper(out, std::get<0>(tmp_output));
  copy_arg(out, std::get<0>(tmp_output));
  
}

void _fused_adamw_out(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, double lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf, at::TensorList out) {
  auto tmp_output = at::_ops::_fused_adamw::call(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
    resize_out_helper(out, std::get<0>(tmp_output));
  copy_arg(out, std::get<0>(tmp_output));
  
}

void _fused_adamw_tensor_lr_out(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, const at::Tensor & lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf, at::TensorList out) {
  auto tmp_output = at::_ops::_fused_adamw_tensor_lr::call(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
    resize_out_helper(out, std::get<0>(tmp_output));
  copy_arg(out, std::get<0>(tmp_output));
  
}

void _fused_sgd_out(at::TensorList self, at::TensorList grads, at::TensorList momentum_buffer_list, double weight_decay, double momentum, double lr, double dampening, bool nesterov, bool maximize, bool is_first_step, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf, at::TensorList out) {
  auto tmp_output = at::_ops::_fused_sgd::call(self, grads, momentum_buffer_list, weight_decay, momentum, lr, dampening, nesterov, maximize, is_first_step, grad_scale, found_inf);
    resize_out_helper(out, std::get<0>(tmp_output));
  copy_arg(out, std::get<0>(tmp_output));
  
}

void _fused_sgd_tensor_lr_out(at::TensorList self, at::TensorList grads, at::TensorList momentum_buffer_list, double weight_decay, double momentum, const at::Tensor & lr, double dampening, bool nesterov, bool maximize, bool is_first_step, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf, at::TensorList out) {
  auto tmp_output = at::_ops::_fused_sgd_tensor_lr::call(self, grads, momentum_buffer_list, weight_decay, momentum, lr, dampening, nesterov, maximize, is_first_step, grad_scale, found_inf);
    resize_out_helper(out, std::get<0>(tmp_output));
  copy_arg(out, std::get<0>(tmp_output));
  
}

} // namespace native
} // namespace at
