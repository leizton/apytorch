// required for old g++ to compile PRId64 macros, see
// https://github.com/pytorch/pytorch/issues/3571
// for context
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

// an external backend might generate file within its code tree
// and check all the source files within the tree with clang-format.
// so, disable it since the backend might have a different config.
// clang-format off

// NOTE: This condition is true for all PyTorch internal libraries, it
//       just excludes external projects such as torch_xla which
//       re-use some of the PyTorch codegen machinery.
#if defined(CAFFE2_BUILD_MAIN_LIB)        || \
    defined(TORCH_CUDA_BUILD_MAIN_LIB)    || \
    defined(TORCH_HIP_BUILD_MAIN_LIB)     || \
    defined(TORCH_CUDA_CU_BUILD_MAIN_LIB) || \
    defined(TORCH_CUDA_CPP_BUILD_MAIN_LIB)
#define TORCH_ASSERT_ONLY_METHOD_OPERATORS
#endif

// @generated by torchgen/gen.py from RegisterDispatchKey.cpp

#include <c10/core/TensorImpl.h>
#include <c10/core/Allocator.h>
#include <ATen/DeviceGuard.h>
#include <ATen/NamedTensorUtils.h>
#include <ATen/Utils.h>
#include <ATen/WrapDimUtils.h>
#include <ATen/Dispatch.h>
#include <c10/util/ExclusivelyOwned.h>
#include <c10/util/Half.h>
#include <c10/core/UndefinedTensorImpl.h>
#include <c10/util/Optional.h>
#include <ATen/Tensor.h>
#include <ATen/native/Resize.h>

#include <cstddef>
#include <functional>
#include <memory>
#include <utility>

#include <ATen/Config.h>
#include <ATen/core/op_registration/adaption.h>
#include <torch/library.h>
#include <c10/cuda/CUDAGuard.h>
#include <ATen/cuda/ATenCUDAGeneral.h>
#include <ATen/cuda/CUDADevice.h>
#include <ATen/cuda/CUDAContext.h>

#include <ATen/NativeFunctions.h>
#include <ATen/cuda/EmptyTensor.h>
#include <ATen/NativeFunctions.h>
#include <ATen/CUDAFunctions.h>

// See template file RegisterDispatchDefinitions.ini
namespace at {
// NB: TORCH_LIBRARY_IMPL must be in an anonymous namespace to avoid
// ambiguity with conflicting identifiers that may have been defined in
// at namespace already.
namespace {
Tensor create_out(IntArrayRef sizes, IntArrayRef strides, const TensorOptions &options) {
  if (strides.empty()) {
      return at::detail::empty_cuda(sizes, options);
  } else {
      return at::detail::empty_strided_cuda(sizes, strides, options);
  }
}
void resize_out(const Tensor &out, IntArrayRef sizes, IntArrayRef strides, const TensorOptions &options) {
  TORCH_CHECK(options.dtype() == out.dtype(),
      "Expected out tensor to have dtype ", options.dtype(), ", but got ", out.dtype(), " instead");
  TORCH_CHECK(options.device() == out.device(),
      "Expected out tensor to have device ", options.device(), ", but got ", out.device(), " instead");
  const bool resized = at::native::resize_output(out, sizes);
  // Only restride if a resize occurred; otherwise we ignore the (advisory)
  // strides from the meta function and directly use the output tensor's
  // preexisting strides
  if (resized) {
    if (!strides.empty()) {
      TORCH_INTERNAL_ASSERT(!options.memory_format_opt().has_value());
      // TODO: avoid the redispatch here
      out.as_strided_(sizes, strides);
    } else if (options.memory_format_opt().has_value()) {
      out.unsafeGetTensorImpl()->empty_tensor_restride(*options.memory_format_opt());
    }
  }
}
void check_inplace(const Tensor &self, IntArrayRef sizes, const TensorOptions &options) {
  // These checks are needed on those operators that:
  //   1) don't use 'TensorIterator' (e.g. 'addmm' and 'baddbmm')
  //   2) have particular typing rules (e.g. 'cumsum' and 'cumprod')
  // For other operators (e.g. 'add'), 'TensorIterator' already checks
  // these things separately.
  TORCH_CHECK(options.dtype() == self.dtype(),
      "Bad in-place call: ",
      "input tensor dtype ", self.dtype(), " and output tensor dtype ", options.dtype(), " should match");
  TORCH_CHECK(options.device() == self.device(),
      "Bad in-place call: ",
      "input tensor device ", self.device(), " and output tensor device ", options.device(), " should match");
  TORCH_CHECK(sizes == self.sizes(),
      "Bad in-place call: ",
      "input tensor size ", self.sizes(), " and output tensor size ", sizes, " should match");
}
c10::optional<Tensor> maybe_create_proxy(const Tensor &out, IntArrayRef sizes, IntArrayRef strides, const TensorOptions &options) {
  if (out.strides() != strides) {
    return at::detail::empty_strided_cuda(sizes, strides, options);
  }
  return c10::nullopt;
}
namespace {
void wrapper_CUDA___assert_async(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___assert_async", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_assert_async_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_msg__assert_async(const at::Tensor & self, c10::string_view assert_msg) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_msg__assert_async", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_assert_async_msg_cuda(self, assert_msg);
}
} // anonymous namespace
namespace {
bool wrapper_CUDA___use_cudnn_ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(log_probs));
  return at::native::_use_cudnn_ctc_loss(log_probs, targets, input_lengths, target_lengths, blank);
}
} // anonymous namespace
namespace {
bool wrapper_CUDA_Tensor__use_cudnn_ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(log_probs));
  return at::native::_use_cudnn_ctc_loss_tensor(log_probs, targets, input_lengths, target_lengths, blank);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___cudnn_ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool deterministic, bool zero_infinity) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(log_probs));
  return at::native::_cudnn_ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_Tensor__cudnn_ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool deterministic, bool zero_infinity) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(log_probs));
  return at::native::_cudnn_ctc_loss_tensor(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___cudnn_rnn_flatten_weight(at::TensorList weight_arr, int64_t weight_stride0, c10::SymInt input_size, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, bool bidirectional) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, weight_arr, "wrapper_CUDA___cudnn_rnn_flatten_weight", "weight_arr");
  const OptionalDeviceGuard device_guard(device_of(weight_arr));
  return at::native::_cudnn_rnn_flatten_weight(weight_arr, weight_stride0, input_size.guard_int(__FILE__, __LINE__), mode, hidden_size.guard_int(__FILE__, __LINE__), proj_size.guard_int(__FILE__, __LINE__), num_layers, batch_first, bidirectional);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___cudnn_rnn(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const c10::optional<at::Tensor> & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::_cudnn_rnn(input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size.guard_int(__FILE__, __LINE__), proj_size.guard_int(__FILE__, __LINE__), num_layers, batch_first, dropout, train, bidirectional, C10_AS_INTARRAYREF_SLOW(batch_sizes), dropout_state);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,::std::vector<at::Tensor>> wrapper_CUDA___cudnn_rnn_backward(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA___cudnn_rnn_backward", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___cudnn_rnn_backward", "weight");
  c10::impl::check_and_update_common_device(common_device, weight_buf, "wrapper_CUDA___cudnn_rnn_backward", "weight_buf");
  c10::impl::check_and_update_common_device(common_device, hx, "wrapper_CUDA___cudnn_rnn_backward", "hx");
  c10::impl::check_and_update_common_device(common_device, cx, "wrapper_CUDA___cudnn_rnn_backward", "cx");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA___cudnn_rnn_backward", "output");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA___cudnn_rnn_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, grad_hy, "wrapper_CUDA___cudnn_rnn_backward", "grad_hy");
  c10::impl::check_and_update_common_device(common_device, grad_cy, "wrapper_CUDA___cudnn_rnn_backward", "grad_cy");
  c10::impl::check_and_update_common_device(common_device, dropout_state, "wrapper_CUDA___cudnn_rnn_backward", "dropout_state");
  c10::impl::check_and_update_common_device(common_device, reserve, "wrapper_CUDA___cudnn_rnn_backward", "reserve");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::_cudnn_rnn_backward(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size.guard_int(__FILE__, __LINE__), proj_size.guard_int(__FILE__, __LINE__), num_layers, batch_first, dropout, train, bidirectional, C10_AS_INTARRAYREF_SLOW(batch_sizes), dropout_state, reserve, output_mask);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___cudnn_init_dropout_state(double dropout, bool train, int64_t dropout_seed, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  globalContext().lazyInitCUDA();
  const DeviceGuard device_guard(device_or_default(device));
  return at::native::_cudnn_init_dropout_state(dropout, train, dropout_seed, dtype, layout, device, pin_memory);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___fused_dropout(const at::Tensor & self, double p, c10::optional<at::Generator> generator) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fused_dropout", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::fused_dropout_cuda(self, p, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___masked_scale(const at::Tensor & self, const at::Tensor & mask, double scale) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___masked_scale", "self");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA___masked_scale", "mask");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::masked_scale_cuda(self, mask, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__native_dropout(const at::Tensor & input, double p, c10::optional<bool> train) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__native_dropout", "input");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::native_dropout_cuda(input, p, train);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__native_dropout_backward(const at::Tensor & grad_output, const at::Tensor & mask, double scale) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__native_dropout_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA__native_dropout_backward", "mask");
  const OptionalDeviceGuard device_guard(device_of(grad_output));
  return at::native::native_dropout_backward_cuda(grad_output, mask, scale);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_abs_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::abs_out(self, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__angle(const at::Tensor & self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::angle(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_angle_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::angle_out(self, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__view_as_real(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__view_as_real", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::view_as_real(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__view_as_complex(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__view_as_complex", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::view_as_complex(self);
}
} // anonymous namespace
struct structured_sgn_out_functional final : public at::native::structured_sgn_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sgn(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_sgn", "self");
structured_sgn_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sgn_out_out final : public at::native::structured_sgn_out {
    structured_sgn_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sgn_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_sgn_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_sgn_out_out", "self");
structured_sgn_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sgn_out_inplace final : public at::native::structured_sgn_out {
    structured_sgn_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sgn_(at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_sgn_", "self");
structured_sgn_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA_out_conj_physical_out(const at::Tensor & self, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_conj_physical_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_conj_physical_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::conj_physical_out(self, out);
}
} // anonymous namespace
struct structured_acos_out_functional final : public at::native::structured_acos_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_acos(const at::Tensor & self) {
  // No device check
structured_acos_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_acos_out_out final : public at::native::structured_acos_out {
    structured_acos_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_acos_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_acos_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_acos_out_inplace final : public at::native::structured_acos_out {
    structured_acos_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_acos_(at::Tensor & self) {
  // No device check
structured_acos_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_ufunc_add_CUDA_functional final : public at::native::structured_ufunc_add_CUDA {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CUDA::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CUDA::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_add_Tensor(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
  // No device check
structured_ufunc_add_CUDA_functional op;
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ufunc_add_CUDA_out final : public at::native::structured_ufunc_add_CUDA {
    structured_ufunc_add_CUDA_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CUDA::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CUDA::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_add_out_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
  // No device check
structured_ufunc_add_CUDA_out op(out);
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ufunc_add_CUDA_inplace final : public at::native::structured_ufunc_add_CUDA {
    structured_ufunc_add_CUDA_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CUDA::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CUDA::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_add__Tensor(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
  // No device check
structured_ufunc_add_CUDA_inplace op(self);
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_addmv_out_cuda_functional final : public at::native::structured_addmv_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_addmv(const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_addmv", "self");
  c10::impl::check_and_update_common_device(common_device, mat, "wrapper_CUDA_addmv", "mat");
  c10::impl::check_and_update_common_device(common_device, vec, "wrapper_CUDA_addmv", "vec");
structured_addmv_out_cuda_functional op;
op.meta(self, mat, vec, beta, alpha);
op.impl(self, mat, vec, beta, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addmv_out_cuda_out final : public at::native::structured_addmv_out_cuda {
    structured_addmv_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_addmv_out_out(const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_addmv_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_addmv_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, mat, "wrapper_CUDA_addmv_out_out", "mat");
  c10::impl::check_and_update_common_device(common_device, vec, "wrapper_CUDA_addmv_out_out", "vec");
structured_addmv_out_cuda_out op(out);
op.meta(self, mat, vec, beta, alpha);
op.impl(self, mat, vec, beta, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addmv_out_cuda_inplace final : public at::native::structured_addmv_out_cuda {
    structured_addmv_out_cuda_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_addmv_(at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_addmv_", "self");
  c10::impl::check_and_update_common_device(common_device, mat, "wrapper_CUDA_addmv_", "mat");
  c10::impl::check_and_update_common_device(common_device, vec, "wrapper_CUDA_addmv_", "vec");
structured_addmv_out_cuda_inplace op(self);
op.meta(self, mat, vec, beta, alpha);
op.impl(self, mat, vec, beta, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__addr(const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__addr", "self");
  c10::impl::check_and_update_common_device(common_device, vec1, "wrapper_CUDA__addr", "vec1");
  c10::impl::check_and_update_common_device(common_device, vec2, "wrapper_CUDA__addr", "vec2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::addr(self, vec1, vec2, beta, alpha);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_addr_out(const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_addr_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_addr_out", "self");
  c10::impl::check_and_update_common_device(common_device, vec1, "wrapper_CUDA_out_addr_out", "vec1");
  c10::impl::check_and_update_common_device(common_device, vec2, "wrapper_CUDA_out_addr_out", "vec2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::addr_out(self, vec1, vec2, beta, alpha, out);
}
} // anonymous namespace
struct structured_all_out_functional final : public at::native::structured_all_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_all_dim(const at::Tensor & self, int64_t dim, bool keepdim) {
  // No device check
structured_all_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_all_out_out final : public at::native::structured_all_out {
    structured_all_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_all_out_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
  // No device check
structured_all_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_all_dims_out_functional final : public at::native::structured_all_dims_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_all_dims(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
  // No device check
structured_all_dims_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_all_dims_out_out final : public at::native::structured_all_dims_out {
    structured_all_dims_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_all_out_dims_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
  // No device check
structured_all_dims_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_any_out_functional final : public at::native::structured_any_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_any_dim(const at::Tensor & self, int64_t dim, bool keepdim) {
  // No device check
structured_any_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_any_out_out final : public at::native::structured_any_out {
    structured_any_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_any_out_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
  // No device check
structured_any_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_any_dims_out_functional final : public at::native::structured_any_dims_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_any_dims(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
  // No device check
structured_any_dims_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_any_dims_out_out final : public at::native::structured_any_dims_out {
    structured_any_dims_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_any_out_dims_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
  // No device check
structured_any_dims_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor & wrapper_CUDA_start_out_arange_out(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_start_out_arange_out", "out");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::arange_cuda_out(start, end, step, out);
}
} // anonymous namespace
struct structured_argmax_out_functional final : public at::native::structured_argmax_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_argmax(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
  // No device check
structured_argmax_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_argmax_out_out final : public at::native::structured_argmax_out {
    structured_argmax_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_argmax_out_out(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_argmax_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_argmax_out_out", "self");
structured_argmax_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_argmin_out_functional final : public at::native::structured_argmin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_argmin(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
  // No device check
structured_argmin_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_argmin_out_out final : public at::native::structured_argmin_out {
    structured_argmin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_argmin_out_out(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_argmin_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_argmin_out_out", "self");
structured_argmin_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_acosh_out_functional final : public at::native::structured_acosh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_acosh(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_acosh", "self");
structured_acosh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_acosh_out_out final : public at::native::structured_acosh_out {
    structured_acosh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_acosh_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_acosh_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_acosh_out_out", "self");
structured_acosh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_acosh_out_inplace final : public at::native::structured_acosh_out {
    structured_acosh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_acosh_(at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_acosh_", "self");
structured_acosh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_asinh_out_functional final : public at::native::structured_asinh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_asinh(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_asinh", "self");
structured_asinh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_asinh_out_out final : public at::native::structured_asinh_out {
    structured_asinh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_asinh_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_asinh_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_asinh_out_out", "self");
structured_asinh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_asinh_out_inplace final : public at::native::structured_asinh_out {
    structured_asinh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_asinh_(at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_asinh_", "self");
structured_asinh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_atanh_out_functional final : public at::native::structured_atanh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_atanh(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_atanh", "self");
structured_atanh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_atanh_out_out final : public at::native::structured_atanh_out {
    structured_atanh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_atanh_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_atanh_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_atanh_out_out", "self");
structured_atanh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_atanh_out_inplace final : public at::native::structured_atanh_out {
    structured_atanh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_atanh_(at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_atanh_", "self");
structured_atanh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__as_strided(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    // No device check
  // DeviceGuard omitted
  return at::native::as_strided_tensorimpl(self, C10_AS_INTARRAYREF_SLOW(size), C10_AS_INTARRAYREF_SLOW(stride), storage_offset.has_value() ? c10::make_optional(storage_offset->guard_int(__FILE__, __LINE__)) : c10::nullopt);
}
} // anonymous namespace
struct structured_asin_out_functional final : public at::native::structured_asin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_asin(const at::Tensor & self) {
  // No device check
structured_asin_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_asin_out_out final : public at::native::structured_asin_out {
    structured_asin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_asin_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_asin_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_asin_out_inplace final : public at::native::structured_asin_out {
    structured_asin_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_asin_(at::Tensor & self) {
  // No device check
structured_asin_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_atan_out_functional final : public at::native::structured_atan_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_atan(const at::Tensor & self) {
  // No device check
structured_atan_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_atan_out_out final : public at::native::structured_atan_out {
    structured_atan_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_atan_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_atan_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_atan_out_inplace final : public at::native::structured_atan_out {
    structured_atan_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_atan_(at::Tensor & self) {
  // No device check
structured_atan_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_baddbmm_out_cuda_functional final : public at::native::structured_baddbmm_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_baddbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_baddbmm", "self");
  c10::impl::check_and_update_common_device(common_device, batch1, "wrapper_CUDA_baddbmm", "batch1");
  c10::impl::check_and_update_common_device(common_device, batch2, "wrapper_CUDA_baddbmm", "batch2");
structured_baddbmm_out_cuda_functional op;
op.meta(self, batch1, batch2, beta, alpha);
op.impl(self, batch1, batch2, beta, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_baddbmm_out_cuda_out final : public at::native::structured_baddbmm_out_cuda {
    structured_baddbmm_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_baddbmm_out_out(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_baddbmm_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_baddbmm_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, batch1, "wrapper_CUDA_baddbmm_out_out", "batch1");
  c10::impl::check_and_update_common_device(common_device, batch2, "wrapper_CUDA_baddbmm_out_out", "batch2");
structured_baddbmm_out_cuda_out op(out);
op.meta(self, batch1, batch2, beta, alpha);
op.impl(self, batch1, batch2, beta, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_baddbmm_out_cuda_inplace final : public at::native::structured_baddbmm_out_cuda {
    structured_baddbmm_out_cuda_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_baddbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_baddbmm_", "self");
  c10::impl::check_and_update_common_device(common_device, batch1, "wrapper_CUDA_baddbmm_", "batch1");
  c10::impl::check_and_update_common_device(common_device, batch2, "wrapper_CUDA_baddbmm_", "batch2");
structured_baddbmm_out_cuda_inplace op(self);
op.meta(self, batch1, batch2, beta, alpha);
op.impl(self, batch1, batch2, beta, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA_out_bernoulli_out(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::bernoulli_out(self, generator, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor_bernoulli_(at::Tensor & self, const at::Tensor & p, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::bernoulli_(self, p, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_float_bernoulli_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::bernoulli_(self, p, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__binary_cross_entropy(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::binary_cross_entropy_cuda(self, target, weight, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_binary_cross_entropy_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::binary_cross_entropy_out_cuda(self, target, weight, reduction, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__binary_cross_entropy_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__binary_cross_entropy_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__binary_cross_entropy_backward", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA__binary_cross_entropy_backward", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__binary_cross_entropy_backward", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::binary_cross_entropy_backward_cuda(grad_output, self, target, weight, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_binary_cross_entropy_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_binary_cross_entropy_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_binary_cross_entropy_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_binary_cross_entropy_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_grad_input_binary_cross_entropy_backward_out", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_grad_input_binary_cross_entropy_backward_out", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::binary_cross_entropy_backward_out_cuda(grad_output, self, target, weight, reduction, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__bincount(const at::Tensor & self, const c10::optional<at::Tensor> & weights, int64_t minlength) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__bincount", "self");
  c10::impl::check_and_update_common_device(common_device, weights, "wrapper_CUDA__bincount", "weights");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_bincount_cuda(self, weights, minlength);
}
} // anonymous namespace
struct structured_bitwise_not_out_functional final : public at::native::structured_bitwise_not_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_bitwise_not(const at::Tensor & self) {
  // No device check
structured_bitwise_not_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_not_out_out final : public at::native::structured_bitwise_not_out {
    structured_bitwise_not_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_not_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_bitwise_not_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_not_out_inplace final : public at::native::structured_bitwise_not_out {
    structured_bitwise_not_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_not_(at::Tensor & self) {
  // No device check
structured_bitwise_not_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_copysign_out_functional final : public at::native::structured_copysign_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_copysign_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_copysign_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_copysign_out_out final : public at::native::structured_copysign_out {
    structured_copysign_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_copysign_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_copysign_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_copysign_out_inplace final : public at::native::structured_copysign_out {
    structured_copysign_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_copysign__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_copysign_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA_out_logical_not_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::logical_not_out(self, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_logical_xor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::logical_xor_out(self, other, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_logical_and_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::logical_and_out(self, other, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_logical_or_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::logical_or_out(self, other, out);
}
} // anonymous namespace
struct structured_bmm_out_cuda_functional final : public at::native::structured_bmm_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_bmm(const at::Tensor & self, const at::Tensor & mat2) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_bmm", "self");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_bmm", "mat2");
structured_bmm_out_cuda_functional op;
op.meta(self, mat2);
op.impl(self, mat2, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bmm_out_cuda_out final : public at::native::structured_bmm_out_cuda {
    structured_bmm_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bmm_out_out(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_bmm_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_bmm_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_bmm_out_out", "mat2");
structured_bmm_out_cuda_out op(out);
op.meta(self, mat2);
op.impl(self, mat2, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cat_out_cuda_functional final : public at::native::structured_cat_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_cat(const at::ITensorListRef & tensors, int64_t dim) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, tensors, "wrapper_CUDA_cat", "tensors");
structured_cat_out_cuda_functional op;
auto precompute = op.meta(tensors, dim);
(void)precompute;
op.impl(tensors, precompute.dim, precompute.valid, precompute.all_contiguous, precompute.all_same_dtype, precompute.all_same_sizes_and_stride, precompute.memory_format, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cat_out_cuda_out final : public at::native::structured_cat_out_cuda {
    structured_cat_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_cat_out_out(const at::ITensorListRef & tensors, int64_t dim, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_cat_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, tensors, "wrapper_CUDA_cat_out_out", "tensors");
structured_cat_out_cuda_out op(out);
auto precompute = op.meta(tensors, dim);
(void)precompute;
op.impl(tensors, precompute.dim, precompute.valid, precompute.all_contiguous, precompute.all_same_dtype, precompute.all_same_sizes_and_stride, precompute.memory_format, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ceil_out_functional final : public at::native::structured_ceil_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_ceil(const at::Tensor & self) {
  // No device check
structured_ceil_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ceil_out_out final : public at::native::structured_ceil_out {
    structured_ceil_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ceil_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_ceil_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ceil_out_inplace final : public at::native::structured_ceil_out {
    structured_ceil_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ceil_(at::Tensor & self) {
  // No device check
structured_ceil_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_out_functional final : public at::native::structured_clamp_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_clamp(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
  // No device check
structured_clamp_out_functional op;
op.meta(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()));
op.impl(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()), op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_out_out final : public at::native::structured_clamp_out {
    structured_clamp_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_out_out(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max, at::Tensor & out) {
  // No device check
structured_clamp_out_out op(out);
op.meta(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()));
op.impl(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()), op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_out_inplace final : public at::native::structured_clamp_out {
    structured_clamp_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_(at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
  // No device check
structured_clamp_out_inplace op(self);
op.meta(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()));
op.impl(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()), op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_Tensor_out_functional final : public at::native::structured_clamp_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_clamp_Tensor(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_clamp_Tensor", "self");
  c10::impl::check_and_update_common_device(common_device, min, "wrapper_CUDA_clamp_Tensor", "min");
  c10::impl::check_and_update_common_device(common_device, max, "wrapper_CUDA_clamp_Tensor", "max");
structured_clamp_Tensor_out_functional op;
op.meta(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()));
op.impl(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()), op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_Tensor_out_out final : public at::native::structured_clamp_Tensor_out {
    structured_clamp_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_out_Tensor_out(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max, at::Tensor & out) {
  // No device check
structured_clamp_Tensor_out_out op(out);
op.meta(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()));
op.impl(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()), op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_Tensor_out_inplace final : public at::native::structured_clamp_Tensor_out {
    structured_clamp_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp__Tensor(at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_clamp__Tensor", "self");
  c10::impl::check_and_update_common_device(common_device, min, "wrapper_CUDA_clamp__Tensor", "min");
  c10::impl::check_and_update_common_device(common_device, max, "wrapper_CUDA_clamp__Tensor", "max");
structured_clamp_Tensor_out_inplace op(self);
op.meta(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()));
op.impl(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()), op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_max_out_functional final : public at::native::structured_clamp_max_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_clamp_max(const at::Tensor & self, const at::Scalar & max) {
  // No device check
structured_clamp_max_out_functional op;
op.meta(self, max);
op.impl(self, max, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_max_out_out final : public at::native::structured_clamp_max_out {
    structured_clamp_max_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_max_out_out(const at::Tensor & self, const at::Scalar & max, at::Tensor & out) {
  // No device check
structured_clamp_max_out_out op(out);
op.meta(self, max);
op.impl(self, max, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_max_out_inplace final : public at::native::structured_clamp_max_out {
    structured_clamp_max_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_max_(at::Tensor & self, const at::Scalar & max) {
  // No device check
structured_clamp_max_out_inplace op(self);
op.meta(self, max);
op.impl(self, max, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_max_Tensor_out_functional final : public at::native::structured_clamp_max_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_clamp_max_Tensor(const at::Tensor & self, const at::Tensor & max) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_clamp_max_Tensor", "self");
  c10::impl::check_and_update_common_device(common_device, max, "wrapper_CUDA_clamp_max_Tensor", "max");
structured_clamp_max_Tensor_out_functional op;
op.meta(self, max);
op.impl(self, max, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_max_Tensor_out_out final : public at::native::structured_clamp_max_Tensor_out {
    structured_clamp_max_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_max_out_Tensor_out(const at::Tensor & self, const at::Tensor & max, at::Tensor & out) {
  // No device check
structured_clamp_max_Tensor_out_out op(out);
op.meta(self, max);
op.impl(self, max, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_max_Tensor_out_inplace final : public at::native::structured_clamp_max_Tensor_out {
    structured_clamp_max_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_max__Tensor(at::Tensor & self, const at::Tensor & max) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_clamp_max__Tensor", "self");
  c10::impl::check_and_update_common_device(common_device, max, "wrapper_CUDA_clamp_max__Tensor", "max");
structured_clamp_max_Tensor_out_inplace op(self);
op.meta(self, max);
op.impl(self, max, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_min_out_functional final : public at::native::structured_clamp_min_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_clamp_min(const at::Tensor & self, const at::Scalar & min) {
  // No device check
structured_clamp_min_out_functional op;
op.meta(self, min);
op.impl(self, min, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_min_out_out final : public at::native::structured_clamp_min_out {
    structured_clamp_min_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_min_out_out(const at::Tensor & self, const at::Scalar & min, at::Tensor & out) {
  // No device check
structured_clamp_min_out_out op(out);
op.meta(self, min);
op.impl(self, min, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_min_out_inplace final : public at::native::structured_clamp_min_out {
    structured_clamp_min_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_min_(at::Tensor & self, const at::Scalar & min) {
  // No device check
structured_clamp_min_out_inplace op(self);
op.meta(self, min);
op.impl(self, min, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_min_Tensor_out_functional final : public at::native::structured_clamp_min_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_clamp_min_Tensor(const at::Tensor & self, const at::Tensor & min) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_clamp_min_Tensor", "self");
  c10::impl::check_and_update_common_device(common_device, min, "wrapper_CUDA_clamp_min_Tensor", "min");
structured_clamp_min_Tensor_out_functional op;
op.meta(self, min);
op.impl(self, min, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_min_Tensor_out_out final : public at::native::structured_clamp_min_Tensor_out {
    structured_clamp_min_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_min_out_Tensor_out(const at::Tensor & self, const at::Tensor & min, at::Tensor & out) {
  // No device check
structured_clamp_min_Tensor_out_out op(out);
op.meta(self, min);
op.impl(self, min, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_min_Tensor_out_inplace final : public at::native::structured_clamp_min_Tensor_out {
    structured_clamp_min_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_clamp_min__Tensor(at::Tensor & self, const at::Tensor & min) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_clamp_min__Tensor", "self");
  c10::impl::check_and_update_common_device(common_device, min, "wrapper_CUDA_clamp_min__Tensor", "min");
structured_clamp_min_Tensor_out_inplace op(self);
op.meta(self, min);
op.impl(self, min, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA_out_complex_out(const at::Tensor & real, const at::Tensor & imag, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_complex_out", "out");
  c10::impl::check_and_update_common_device(common_device, real, "wrapper_CUDA_out_complex_out", "real");
  c10::impl::check_and_update_common_device(common_device, imag, "wrapper_CUDA_out_complex_out", "imag");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::complex_out(real, imag, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_polar_out(const at::Tensor & abs, const at::Tensor & angle, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_polar_out", "out");
  c10::impl::check_and_update_common_device(common_device, abs, "wrapper_CUDA_out_polar_out", "abs");
  c10::impl::check_and_update_common_device(common_device, angle, "wrapper_CUDA_out_polar_out", "angle");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::polar_out(abs, angle, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__convolution_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalSymIntArrayRef bias_sizes, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__convolution_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__convolution_backward", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__convolution_backward", "weight");
  const OptionalDeviceGuard device_guard(device_of(grad_output));
  return at::native::convolution_backward(grad_output, input, weight, bias_sizes.has_value() ? c10::make_optional(C10_AS_INTARRAYREF_SLOW(*bias_sizes)) : c10::nullopt, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation), transposed, C10_AS_INTARRAYREF_SLOW(output_padding), groups.guard_int(__FILE__, __LINE__), output_mask);
}
} // anonymous namespace
struct structured_cos_out_functional final : public at::native::structured_cos_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_cos(const at::Tensor & self) {
  // No device check
structured_cos_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cos_out_out final : public at::native::structured_cos_out {
    structured_cos_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_cos_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_cos_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cos_out_inplace final : public at::native::structured_cos_out {
    structured_cos_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_cos_(at::Tensor & self) {
  // No device check
structured_cos_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_cosh_out_functional final : public at::native::structured_cosh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_cosh(const at::Tensor & self) {
  // No device check
structured_cosh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cosh_out_out final : public at::native::structured_cosh_out {
    structured_cosh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_cosh_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_cosh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cosh_out_inplace final : public at::native::structured_cosh_out {
    structured_cosh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_cosh_(at::Tensor & self) {
  // No device check
structured_cosh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA_dim_IntList_count_nonzero(const at::Tensor & self, at::IntArrayRef dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_dim_IntList_count_nonzero", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::count_nonzero_cuda(self, dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__cudnn_affine_grid_generator(const at::Tensor & theta, int64_t N, int64_t C, int64_t H, int64_t W) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, theta, "wrapper_CUDA__cudnn_affine_grid_generator", "theta");
  const OptionalDeviceGuard device_guard(device_of(theta));
  return at::native::cudnn_affine_grid_generator_forward(theta, N, C, H, W);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__cudnn_affine_grid_generator_backward(const at::Tensor & grad, int64_t N, int64_t C, int64_t H, int64_t W) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA__cudnn_affine_grid_generator_backward", "grad");
  const OptionalDeviceGuard device_guard(device_of(grad));
  return at::native::cudnn_affine_grid_generator_backward(grad, N, C, H, W);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__cudnn_batch_norm(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__cudnn_batch_norm", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__cudnn_batch_norm", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__cudnn_batch_norm", "bias");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA__cudnn_batch_norm", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA__cudnn_batch_norm", "running_var");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::cudnn_batch_norm(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__cudnn_batch_norm_backward(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, const at::Tensor & reserveSpace) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__cudnn_batch_norm_backward", "input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__cudnn_batch_norm_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__cudnn_batch_norm_backward", "weight");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA__cudnn_batch_norm_backward", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA__cudnn_batch_norm_backward", "running_var");
  c10::impl::check_and_update_common_device(common_device, save_mean, "wrapper_CUDA__cudnn_batch_norm_backward", "save_mean");
  c10::impl::check_and_update_common_device(common_device, save_var, "wrapper_CUDA__cudnn_batch_norm_backward", "save_var");
  c10::impl::check_and_update_common_device(common_device, reserveSpace, "wrapper_CUDA__cudnn_batch_norm_backward", "reserveSpace");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::cudnn_batch_norm_backward(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__cudnn_convolution(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__cudnn_convolution", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__cudnn_convolution", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cudnn_convolution(self, weight, C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__), benchmark, deterministic, allow_tf32);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_cudnn_convolution_out(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_cudnn_convolution_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_cudnn_convolution_out", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_out_cudnn_convolution_out", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cudnn_convolution_out(self, weight, C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__), benchmark, deterministic, allow_tf32, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__cudnn_convolution_transpose(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__cudnn_convolution_transpose", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__cudnn_convolution_transpose", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cudnn_convolution_transpose(self, weight, C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__), benchmark, deterministic, allow_tf32);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__cudnn_convolution_relu(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__cudnn_convolution_relu", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__cudnn_convolution_relu", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__cudnn_convolution_relu", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cudnn_convolution_relu(self, weight, bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__cudnn_convolution_add_relu(const at::Tensor & self, const at::Tensor & weight, const at::Tensor & z, const c10::optional<at::Scalar> & alpha, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__cudnn_convolution_add_relu", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__cudnn_convolution_add_relu", "weight");
  c10::impl::check_and_update_common_device(common_device, z, "wrapper_CUDA__cudnn_convolution_add_relu", "z");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__cudnn_convolution_add_relu", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cudnn_convolution_add_relu(self, weight, z, alpha, bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__cudnn_grid_sampler(const at::Tensor & self, const at::Tensor & grid) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__cudnn_grid_sampler", "self");
  c10::impl::check_and_update_common_device(common_device, grid, "wrapper_CUDA__cudnn_grid_sampler", "grid");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cudnn_grid_sampler_forward(self, grid);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__cudnn_grid_sampler_backward(const at::Tensor & self, const at::Tensor & grid, const at::Tensor & grad_output) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__cudnn_grid_sampler_backward", "self");
  c10::impl::check_and_update_common_device(common_device, grid, "wrapper_CUDA__cudnn_grid_sampler_backward", "grid");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__cudnn_grid_sampler_backward", "grad_output");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cudnn_grid_sampler_backward(self, grid, grad_output);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___cummax_helper(const at::Tensor & self, at::Tensor & values, at::Tensor & indices, int64_t dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___cummax_helper", "self");
  c10::impl::check_and_update_common_device(common_device, values, "wrapper_CUDA___cummax_helper", "values");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA___cummax_helper", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cummax_helper_cuda(self, values, indices, dim);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___cummin_helper(const at::Tensor & self, at::Tensor & values, at::Tensor & indices, int64_t dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___cummin_helper", "self");
  c10::impl::check_and_update_common_device(common_device, values, "wrapper_CUDA___cummin_helper", "values");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA___cummin_helper", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cummin_helper_cuda(self, values, indices, dim);
}
} // anonymous namespace
struct structured_cumprod_out_functional final : public at::native::structured_cumprod_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_cumprod(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
  // No device check
structured_cumprod_out_functional op;
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cumprod_out_out final : public at::native::structured_cumprod_out {
    structured_cumprod_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_cumprod_out_out(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  // No device check
structured_cumprod_out_out op(out);
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cumprod_out_inplace final : public at::native::structured_cumprod_out {
    structured_cumprod_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_cumprod_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_cumprod_", "self");
structured_cumprod_out_inplace op(self);
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_cumsum_out_functional final : public at::native::structured_cumsum_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_cumsum(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
  // No device check
structured_cumsum_out_functional op;
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cumsum_out_out final : public at::native::structured_cumsum_out {
    structured_cumsum_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_cumsum_out_out(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  // No device check
structured_cumsum_out_out op(out);
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cumsum_out_inplace final : public at::native::structured_cumsum_out {
    structured_cumsum_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_cumsum_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_cumsum_", "self");
structured_cumsum_out_inplace op(self);
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool zero_infinity) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, log_probs, "wrapper_CUDA___ctc_loss", "log_probs");
  c10::impl::check_and_update_common_device(common_device, targets, "wrapper_CUDA___ctc_loss", "targets");
  const OptionalDeviceGuard device_guard(device_of(log_probs));
  return at::native::ctc_loss_gpu(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_Tensor__ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool zero_infinity) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, log_probs, "wrapper_CUDA_Tensor__ctc_loss", "log_probs");
  c10::impl::check_and_update_common_device(common_device, targets, "wrapper_CUDA_Tensor__ctc_loss", "targets");
  c10::impl::check_and_update_common_device(common_device, input_lengths, "wrapper_CUDA_Tensor__ctc_loss", "input_lengths");
  c10::impl::check_and_update_common_device(common_device, target_lengths, "wrapper_CUDA_Tensor__ctc_loss", "target_lengths");
  const OptionalDeviceGuard device_guard(device_of(log_probs));
  return at::native::ctc_loss_tensor(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___ctc_loss_backward(const at::Tensor & grad, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, const at::Tensor & neg_log_likelihood, const at::Tensor & log_alpha, int64_t blank, bool zero_infinity) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA___ctc_loss_backward", "grad");
  c10::impl::check_and_update_common_device(common_device, log_probs, "wrapper_CUDA___ctc_loss_backward", "log_probs");
  c10::impl::check_and_update_common_device(common_device, targets, "wrapper_CUDA___ctc_loss_backward", "targets");
  c10::impl::check_and_update_common_device(common_device, neg_log_likelihood, "wrapper_CUDA___ctc_loss_backward", "neg_log_likelihood");
  c10::impl::check_and_update_common_device(common_device, log_alpha, "wrapper_CUDA___ctc_loss_backward", "log_alpha");
  const OptionalDeviceGuard device_guard(device_of(grad));
  return at::native::ctc_loss_backward_gpu(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_Tensor__ctc_loss_backward(const at::Tensor & grad, const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, const at::Tensor & neg_log_likelihood, const at::Tensor & log_alpha, int64_t blank, bool zero_infinity) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA_Tensor__ctc_loss_backward", "grad");
  c10::impl::check_and_update_common_device(common_device, log_probs, "wrapper_CUDA_Tensor__ctc_loss_backward", "log_probs");
  c10::impl::check_and_update_common_device(common_device, targets, "wrapper_CUDA_Tensor__ctc_loss_backward", "targets");
  c10::impl::check_and_update_common_device(common_device, input_lengths, "wrapper_CUDA_Tensor__ctc_loss_backward", "input_lengths");
  c10::impl::check_and_update_common_device(common_device, target_lengths, "wrapper_CUDA_Tensor__ctc_loss_backward", "target_lengths");
  c10::impl::check_and_update_common_device(common_device, neg_log_likelihood, "wrapper_CUDA_Tensor__ctc_loss_backward", "neg_log_likelihood");
  c10::impl::check_and_update_common_device(common_device, log_alpha, "wrapper_CUDA_Tensor__ctc_loss_backward", "log_alpha");
  const OptionalDeviceGuard device_guard(device_of(grad));
  return at::native::ctc_loss_backward_tensor(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity);
}
} // anonymous namespace
struct structured_div_out_functional final : public at::native::structured_div_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_div_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_div_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_div_out_out final : public at::native::structured_div_out {
    structured_div_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_div_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_div_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_div_out_inplace final : public at::native::structured_div_out {
    structured_div_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_div__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_div_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_div_out_mode_functional final : public at::native::structured_div_out_mode {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_div_Tensor_mode(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
  // No device check
structured_div_out_mode_functional op;
op.meta(self, other, rounding_mode);
op.impl(self, other, rounding_mode, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_div_out_mode_out final : public at::native::structured_div_out_mode {
    structured_div_out_mode_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_div_out_out_mode(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode, at::Tensor & out) {
  // No device check
structured_div_out_mode_out op(out);
op.meta(self, other, rounding_mode);
op.impl(self, other, rounding_mode, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_div_out_mode_inplace final : public at::native::structured_div_out_mode {
    structured_div_out_mode_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_div__Tensor_mode(at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
  // No device check
structured_div_out_mode_inplace op(self);
op.meta(self, other, rounding_mode);
op.impl(self, other, rounding_mode, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__dot(const at::Tensor & self, const at::Tensor & tensor) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__dot", "self");
  c10::impl::check_and_update_common_device(common_device, tensor, "wrapper_CUDA__dot", "tensor");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::dot_cuda(self, tensor);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__vdot(const at::Tensor & self, const at::Tensor & other) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__vdot", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA__vdot", "other");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::vdot_cuda(self, other);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__embedding_dense_backward(const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__embedding_dense_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA__embedding_dense_backward", "indices");
  const OptionalDeviceGuard device_guard(device_of(grad_output));
  return at::native::embedding_dense_backward_cuda(grad_output, indices, num_weights.guard_int(__FILE__, __LINE__), padding_idx.guard_int(__FILE__, __LINE__), scale_grad_by_freq);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__embedding_renorm_(at::Tensor & self, const at::Tensor & indices, double max_norm, double norm_type) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__embedding_renorm_", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA__embedding_renorm_", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::embedding_renorm_cuda_(self, indices, max_norm, norm_type);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___embedding_bag_forward_only(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___embedding_bag_forward_only", "weight");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA___embedding_bag_forward_only", "indices");
  c10::impl::check_and_update_common_device(common_device, offsets, "wrapper_CUDA___embedding_bag_forward_only", "offsets");
  c10::impl::check_and_update_common_device(common_device, per_sample_weights, "wrapper_CUDA___embedding_bag_forward_only", "per_sample_weights");
  const OptionalDeviceGuard device_guard(device_of(weight));
  return at::native::_embedding_bag_forward_only_cuda(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___embedding_bag(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___embedding_bag", "weight");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA___embedding_bag", "indices");
  c10::impl::check_and_update_common_device(common_device, offsets, "wrapper_CUDA___embedding_bag", "offsets");
  c10::impl::check_and_update_common_device(common_device, per_sample_weights, "wrapper_CUDA___embedding_bag", "per_sample_weights");
  const OptionalDeviceGuard device_guard(device_of(weight));
  return at::native::_embedding_bag_cuda(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___embedding_bag_dense_backward(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA___embedding_bag_dense_backward", "grad");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA___embedding_bag_dense_backward", "indices");
  c10::impl::check_and_update_common_device(common_device, offset2bag, "wrapper_CUDA___embedding_bag_dense_backward", "offset2bag");
  c10::impl::check_and_update_common_device(common_device, bag_size, "wrapper_CUDA___embedding_bag_dense_backward", "bag_size");
  c10::impl::check_and_update_common_device(common_device, maximum_indices, "wrapper_CUDA___embedding_bag_dense_backward", "maximum_indices");
  c10::impl::check_and_update_common_device(common_device, per_sample_weights, "wrapper_CUDA___embedding_bag_dense_backward", "per_sample_weights");
  const OptionalDeviceGuard device_guard(device_of(grad));
  return at::native::_embedding_bag_dense_backward_cuda(grad, indices, offset2bag, bag_size, maximum_indices, num_weights.guard_int(__FILE__, __LINE__), scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___embedding_bag_per_sample_weights_backward(const at::Tensor & grad, const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, const at::Tensor & offset2bag, int64_t mode, int64_t padding_idx) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA___embedding_bag_per_sample_weights_backward", "grad");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___embedding_bag_per_sample_weights_backward", "weight");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA___embedding_bag_per_sample_weights_backward", "indices");
  c10::impl::check_and_update_common_device(common_device, offsets, "wrapper_CUDA___embedding_bag_per_sample_weights_backward", "offsets");
  c10::impl::check_and_update_common_device(common_device, offset2bag, "wrapper_CUDA___embedding_bag_per_sample_weights_backward", "offset2bag");
  const OptionalDeviceGuard device_guard(device_of(grad));
  return at::native::_embedding_bag_per_sample_weights_backward_cuda(grad, weight, indices, offsets, offset2bag, mode, padding_idx);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_memory_format_empty(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  globalContext().lazyInitCUDA();
  const DeviceGuard device_guard(device_or_default(device));
  return at::native::empty_cuda(C10_AS_INTARRAYREF_SLOW(size), dtype, layout, device, pin_memory, memory_format);
}
} // anonymous namespace
namespace {
const at::Tensor & wrapper_CUDA__resize_(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
    // No device check
  // DeviceGuard omitted
  return at::native::resize_cuda_(self, C10_AS_INTARRAYREF_SLOW(size), memory_format);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__empty_strided(c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  globalContext().lazyInitCUDA();
  const DeviceGuard device_guard(device_or_default(device));
  return at::native::empty_strided_cuda(C10_AS_INTARRAYREF_SLOW(size), C10_AS_INTARRAYREF_SLOW(stride), dtype, layout, device, pin_memory);
}
} // anonymous namespace
struct structured_erf_out_functional final : public at::native::structured_erf_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_erf(const at::Tensor & self) {
  // No device check
structured_erf_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_erf_out_out final : public at::native::structured_erf_out {
    structured_erf_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_erf_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_erf_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_erf_out_inplace final : public at::native::structured_erf_out {
    structured_erf_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_erf_(at::Tensor & self) {
  // No device check
structured_erf_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_erfc_out_functional final : public at::native::structured_erfc_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_erfc(const at::Tensor & self) {
  // No device check
structured_erfc_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_erfc_out_out final : public at::native::structured_erfc_out {
    structured_erfc_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_erfc_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_erfc_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_erfc_out_inplace final : public at::native::structured_erfc_out {
    structured_erfc_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_erfc_(at::Tensor & self) {
  // No device check
structured_erfc_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_exp_out_functional final : public at::native::structured_exp_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_exp(const at::Tensor & self) {
  // No device check
structured_exp_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_exp_out_out final : public at::native::structured_exp_out {
    structured_exp_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_exp_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_exp_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_exp_out_inplace final : public at::native::structured_exp_out {
    structured_exp_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_exp_(at::Tensor & self) {
  // No device check
structured_exp_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_exp2_out_functional final : public at::native::structured_exp2_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_exp2(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_exp2", "self");
structured_exp2_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_exp2_out_out final : public at::native::structured_exp2_out {
    structured_exp2_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_exp2_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_exp2_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_exp2_out_out", "self");
structured_exp2_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_exp2_out_inplace final : public at::native::structured_exp2_out {
    structured_exp2_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_exp2_(at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_exp2_", "self");
structured_exp2_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_expm1_out_functional final : public at::native::structured_expm1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_expm1(const at::Tensor & self) {
  // No device check
structured_expm1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_expm1_out_out final : public at::native::structured_expm1_out {
    structured_expm1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_expm1_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_expm1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_expm1_out_inplace final : public at::native::structured_expm1_out {
    structured_expm1_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_expm1_(at::Tensor & self) {
  // No device check
structured_expm1_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA_out_eye_out(c10::SymInt n, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_eye_out", "out");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::eye_out_cuda(n.guard_int(__FILE__, __LINE__), out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_m_out_eye_out(c10::SymInt n, c10::SymInt m, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_m_out_eye_out", "out");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::eye_out_cuda(n.guard_int(__FILE__, __LINE__), m.guard_int(__FILE__, __LINE__), out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Scalar_fill_(at::Tensor & self, const at::Scalar & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::fill_(self, value);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor_fill_(at::Tensor & self, const at::Tensor & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::fill_(self, value);
}
} // anonymous namespace
struct structured_floor_out_functional final : public at::native::structured_floor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_floor(const at::Tensor & self) {
  // No device check
structured_floor_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_floor_out_out final : public at::native::structured_floor_out {
    structured_floor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_floor_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_floor_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_floor_out_inplace final : public at::native::structured_floor_out {
    structured_floor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_floor_(at::Tensor & self) {
  // No device check
structured_floor_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__floor_divide(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::floor_divide(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_floor_divide_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::floor_divide_out(self, other, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor_floor_divide_(at::Tensor & self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::floor_divide_(self, other);
}
} // anonymous namespace
struct structured_frac_out_functional final : public at::native::structured_frac_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_frac(const at::Tensor & self) {
  // No device check
structured_frac_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_frac_out_out final : public at::native::structured_frac_out {
    structured_frac_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_frac_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_frac_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_frac_out_inplace final : public at::native::structured_frac_out {
    structured_frac_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_frac_(at::Tensor & self) {
  // No device check
structured_frac_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_gcd_out_functional final : public at::native::structured_gcd_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_gcd(const at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_gcd", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_gcd", "other");
structured_gcd_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gcd_out_out final : public at::native::structured_gcd_out {
    structured_gcd_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gcd_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_gcd_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_gcd_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_gcd_out_out", "other");
structured_gcd_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_gcd_out_inplace final : public at::native::structured_gcd_out {
    structured_gcd_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gcd_(at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_gcd_", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_gcd_", "other");
structured_gcd_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lcm_out_functional final : public at::native::structured_lcm_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_lcm(const at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_lcm", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_lcm", "other");
structured_lcm_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lcm_out_out final : public at::native::structured_lcm_out {
    structured_lcm_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lcm_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_lcm_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_lcm_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_lcm_out_out", "other");
structured_lcm_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lcm_out_inplace final : public at::native::structured_lcm_out {
    structured_lcm_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lcm_(at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_lcm_", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_lcm_", "other");
structured_lcm_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__grid_sampler_2d(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__grid_sampler_2d", "input");
  c10::impl::check_and_update_common_device(common_device, grid, "wrapper_CUDA__grid_sampler_2d", "grid");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::grid_sampler_2d_cuda(input, grid, interpolation_mode, padding_mode, align_corners);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__grid_sampler_2d_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__grid_sampler_2d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__grid_sampler_2d_backward", "input");
  c10::impl::check_and_update_common_device(common_device, grid, "wrapper_CUDA__grid_sampler_2d_backward", "grid");
  const OptionalDeviceGuard device_guard(device_of(grad_output));
  return at::native::grid_sampler_2d_backward_cuda(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__grid_sampler_3d(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__grid_sampler_3d", "input");
  c10::impl::check_and_update_common_device(common_device, grid, "wrapper_CUDA__grid_sampler_3d", "grid");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::grid_sampler_3d_cuda(input, grid, interpolation_mode, padding_mode, align_corners);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__grid_sampler_3d_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__grid_sampler_3d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__grid_sampler_3d_backward", "input");
  c10::impl::check_and_update_common_device(common_device, grid, "wrapper_CUDA__grid_sampler_3d_backward", "grid");
  const OptionalDeviceGuard device_guard(device_of(grad_output));
  return at::native::grid_sampler_3d_backward_cuda(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__native_group_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, double eps) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__native_group_norm", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__native_group_norm", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__native_group_norm", "bias");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::native_group_norm(input, weight, bias, N.guard_int(__FILE__, __LINE__), C.guard_int(__FILE__, __LINE__), HxW.guard_int(__FILE__, __LINE__), group, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__native_group_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, ::std::array<bool,3> output_mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_out, "wrapper_CUDA__native_group_norm_backward", "grad_out");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__native_group_norm_backward", "input");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA__native_group_norm_backward", "mean");
  c10::impl::check_and_update_common_device(common_device, rstd, "wrapper_CUDA__native_group_norm_backward", "rstd");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__native_group_norm_backward", "weight");
  const OptionalDeviceGuard device_guard(device_of(grad_out));
  return at::native::native_group_norm_backward(grad_out, input, mean, rstd, weight, N.guard_int(__FILE__, __LINE__), C.guard_int(__FILE__, __LINE__), HxW.guard_int(__FILE__, __LINE__), group, output_mask);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___fft_r2c(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fft_r2c", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fft_r2c_cufft(self, dim, normalization, onesided);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out__fft_r2c_out(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out__fft_r2c_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out__fft_r2c_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fft_r2c_cufft_out(self, dim, normalization, onesided, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___fft_c2r(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fft_c2r", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fft_c2r_cufft(self, dim, normalization, last_dim_size.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out__fft_c2r_out(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out__fft_c2r_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out__fft_c2r_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fft_c2r_cufft_out(self, dim, normalization, last_dim_size.guard_int(__FILE__, __LINE__), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___fft_c2c(const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fft_c2c", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fft_c2c_cufft(self, C10_AS_INTARRAYREF_SLOW(dim), normalization, forward);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out__fft_c2c_out(const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out__fft_c2c_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out__fft_c2c_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fft_c2c_cufft_out(self, C10_AS_INTARRAYREF_SLOW(dim), normalization, forward, out);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___validate_compressed_sparse_indices(bool is_crow, const at::Tensor & compressed_idx, const at::Tensor & plain_idx, int64_t cdim, int64_t dim, int64_t nnz) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(compressed_idx));
  return at::native::_validate_compressed_sparse_indices_cuda(is_crow, compressed_idx, plain_idx, cdim, dim, nnz);
}
} // anonymous namespace
struct structured_index_out_functional final : public at::native::structured_index_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_index_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_index_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_index_Tensor(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices) {
  // No device check
structured_index_out_functional op;
auto precompute = op.meta(self, at::IOptTensorListRef(indices));
(void)precompute;
op.impl(self, precompute.sizes, precompute.strides, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_index_out_out final : public at::native::structured_index_out {
    structured_index_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_index_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_index_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_index_out_Tensor_out(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, at::Tensor & out) {
  // No device check
structured_index_out_out op(out);
auto precompute = op.meta(self, at::IOptTensorListRef(indices));
(void)precompute;
op.impl(self, precompute.sizes, precompute.strides, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_index_copy_out_functional final : public at::native::structured_index_copy_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_index_copy(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_index_copy", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_index_copy", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA_index_copy", "source");
structured_index_copy_out_functional op;
auto precompute = op.meta(self, dim, index, source);
(void)precompute;
op.impl(self, precompute.dim, index, source, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_index_copy_out_out final : public at::native::structured_index_copy_out {
    structured_index_copy_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_index_copy_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_index_copy_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_index_copy_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_index_copy_out_out", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA_index_copy_out_out", "source");
structured_index_copy_out_out op(out);
auto precompute = op.meta(self, dim, index, source);
(void)precompute;
op.impl(self, precompute.dim, index, source, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_index_copy_out_inplace final : public at::native::structured_index_copy_out {
    structured_index_copy_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_index_copy_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_index_copy_", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_index_copy_", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA_index_copy_", "source");
structured_index_copy_out_inplace op(self);
auto precompute = op.meta(self, dim, index, source);
(void)precompute;
op.impl(self, precompute.dim, index, source, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA___index_put_impl_(at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_index_put_impl_(self, indices, values, accumulate, unsafe);
}
} // anonymous namespace
struct structured_isin_Tensor_Tensor_out_functional final : public at::native::structured_isin_Tensor_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_isin_Tensor_Tensor(const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, elements, "wrapper_CUDA_isin_Tensor_Tensor", "elements");
  c10::impl::check_and_update_common_device(common_device, test_elements, "wrapper_CUDA_isin_Tensor_Tensor", "test_elements");
structured_isin_Tensor_Tensor_out_functional op;
op.meta(elements, test_elements, assume_unique, invert);
op.impl(elements, test_elements, assume_unique, invert, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isin_Tensor_Tensor_out_out final : public at::native::structured_isin_Tensor_Tensor_out {
    structured_isin_Tensor_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_isin_out_Tensor_Tensor_out(const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_isin_out_Tensor_Tensor_out", "out");
  c10::impl::check_and_update_common_device(common_device, elements, "wrapper_CUDA_isin_out_Tensor_Tensor_out", "elements");
  c10::impl::check_and_update_common_device(common_device, test_elements, "wrapper_CUDA_isin_out_Tensor_Tensor_out", "test_elements");
structured_isin_Tensor_Tensor_out_out op(out);
op.meta(elements, test_elements, assume_unique, invert);
op.impl(elements, test_elements, assume_unique, invert, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_isin_Tensor_Scalar_out_functional final : public at::native::structured_isin_Tensor_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_isin_Tensor_Scalar(const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, elements, "wrapper_CUDA_isin_Tensor_Scalar", "elements");
structured_isin_Tensor_Scalar_out_functional op;
op.meta(elements, test_element, assume_unique, invert);
op.impl(elements, test_element, assume_unique, invert, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isin_Tensor_Scalar_out_out final : public at::native::structured_isin_Tensor_Scalar_out {
    structured_isin_Tensor_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_isin_out_Tensor_Scalar_out(const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_isin_out_Tensor_Scalar_out", "out");
  c10::impl::check_and_update_common_device(common_device, elements, "wrapper_CUDA_isin_out_Tensor_Scalar_out", "elements");
structured_isin_Tensor_Scalar_out_out op(out);
op.meta(elements, test_element, assume_unique, invert);
op.impl(elements, test_element, assume_unique, invert, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_isin_Scalar_Tensor_out_functional final : public at::native::structured_isin_Scalar_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_isin_Scalar_Tensor(const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, test_elements, "wrapper_CUDA_isin_Scalar_Tensor", "test_elements");
structured_isin_Scalar_Tensor_out_functional op;
op.meta(element, test_elements, assume_unique, invert);
op.impl(element, test_elements, assume_unique, invert, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isin_Scalar_Tensor_out_out final : public at::native::structured_isin_Scalar_Tensor_out {
    structured_isin_Scalar_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_isin_out_Scalar_Tensor_out(const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_isin_out_Scalar_Tensor_out", "out");
  c10::impl::check_and_update_common_device(common_device, test_elements, "wrapper_CUDA_isin_out_Scalar_Tensor_out", "test_elements");
structured_isin_Scalar_Tensor_out_out op(out);
op.meta(element, test_elements, assume_unique, invert);
op.impl(element, test_elements, assume_unique, invert, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA__isnan(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::isnan(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_values_kthvalue_out(const at::Tensor & self, int64_t k, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, values, "wrapper_CUDA_values_kthvalue_out", "values");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_values_kthvalue_out", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_values_kthvalue_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::kthvalue_out_cuda(self, k, dim, keepdim, values, indices);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__native_layer_norm(const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__native_layer_norm", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__native_layer_norm", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__native_layer_norm", "bias");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::layer_norm_cuda(input, C10_AS_INTARRAYREF_SLOW(normalized_shape), weight, bias, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__native_layer_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, ::std::array<bool,3> output_mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_out, "wrapper_CUDA__native_layer_norm_backward", "grad_out");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__native_layer_norm_backward", "input");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA__native_layer_norm_backward", "mean");
  c10::impl::check_and_update_common_device(common_device, rstd, "wrapper_CUDA__native_layer_norm_backward", "rstd");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__native_layer_norm_backward", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__native_layer_norm_backward", "bias");
  const OptionalDeviceGuard device_guard(device_of(grad_out));
  return at::native::layer_norm_backward_cuda(grad_out, input, C10_AS_INTARRAYREF_SLOW(normalized_shape), mean, rstd, weight, bias, output_mask);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_nan_to_num_out(const at::Tensor & self, c10::optional<double> nan, c10::optional<double> posinf, c10::optional<double> neginf, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_nan_to_num_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_nan_to_num_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nan_to_num_out(self, nan, posinf, neginf, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___cslt_compress(const at::Tensor & input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA___cslt_compress", "input");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::_cslt_compress(input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___cslt_sparse_mm(const at::Tensor & compressed_A, const at::Tensor & dense_B, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & alpha, c10::optional<at::ScalarType> out_dtype, bool transpose_result, int64_t alg_id) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, compressed_A, "wrapper_CUDA___cslt_sparse_mm", "compressed_A");
  c10::impl::check_and_update_common_device(common_device, dense_B, "wrapper_CUDA___cslt_sparse_mm", "dense_B");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA___cslt_sparse_mm", "bias");
  c10::impl::check_and_update_common_device(common_device, alpha, "wrapper_CUDA___cslt_sparse_mm", "alpha");
  const OptionalDeviceGuard device_guard(device_of(compressed_A));
  return at::native::_cslt_sparse_mm(compressed_A, dense_B, bias, alpha, out_dtype, transpose_result, alg_id);
}
} // anonymous namespace
namespace {
int64_t wrapper_CUDA___cslt_sparse_mm_search(const at::Tensor & compressed_A, const at::Tensor & dense_B, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & alpha, c10::optional<at::ScalarType> out_dtype, bool transpose_result) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, compressed_A, "wrapper_CUDA___cslt_sparse_mm_search", "compressed_A");
  c10::impl::check_and_update_common_device(common_device, dense_B, "wrapper_CUDA___cslt_sparse_mm_search", "dense_B");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA___cslt_sparse_mm_search", "bias");
  c10::impl::check_and_update_common_device(common_device, alpha, "wrapper_CUDA___cslt_sparse_mm_search", "alpha");
  const OptionalDeviceGuard device_guard(device_of(compressed_A));
  return at::native::_cslt_sparse_mm_search(compressed_A, dense_B, bias, alpha, out_dtype, transpose_result);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___sparse_semi_structured_linear(const at::Tensor & input, const at::Tensor & weight, const at::Tensor & meta, const c10::optional<at::Tensor> & bias, c10::optional<c10::string_view> activation, c10::optional<at::ScalarType> out_dtype) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA___sparse_semi_structured_linear", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___sparse_semi_structured_linear", "weight");
  c10::impl::check_and_update_common_device(common_device, meta, "wrapper_CUDA___sparse_semi_structured_linear", "meta");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::_sparse_semi_structured_linear(input, weight, meta, bias, activation, out_dtype);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___mixed_dtypes_linear(const at::Tensor & input, const at::Tensor & weight, const at::Tensor & scale, const c10::optional<at::Tensor> & bias, c10::optional<c10::string_view> activation) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA___mixed_dtypes_linear", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___mixed_dtypes_linear", "weight");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA___mixed_dtypes_linear", "scale");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::_mixed_dtypes_linear(input, weight, scale, bias, activation);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_linspace_out(const at::Scalar & start, const at::Scalar & end, int64_t steps, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_linspace_out", "out");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::linspace_cuda_out(start, end, steps, out);
}
} // anonymous namespace
struct structured_log_out_functional final : public at::native::structured_log_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_log(const at::Tensor & self) {
  // No device check
structured_log_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log_out_out final : public at::native::structured_log_out {
    structured_log_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_log_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_log_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log_out_inplace final : public at::native::structured_log_out {
    structured_log_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_log_(at::Tensor & self) {
  // No device check
structured_log_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_log10_out_functional final : public at::native::structured_log10_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_log10(const at::Tensor & self) {
  // No device check
structured_log10_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log10_out_out final : public at::native::structured_log10_out {
    structured_log10_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_log10_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_log10_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log10_out_inplace final : public at::native::structured_log10_out {
    structured_log10_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_log10_(at::Tensor & self) {
  // No device check
structured_log10_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_log1p_out_functional final : public at::native::structured_log1p_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_log1p(const at::Tensor & self) {
  // No device check
structured_log1p_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log1p_out_out final : public at::native::structured_log1p_out {
    structured_log1p_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_log1p_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_log1p_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log1p_out_inplace final : public at::native::structured_log1p_out {
    structured_log1p_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_log1p_(at::Tensor & self) {
  // No device check
structured_log1p_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_log2_out_functional final : public at::native::structured_log2_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_log2(const at::Tensor & self) {
  // No device check
structured_log2_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log2_out_out final : public at::native::structured_log2_out {
    structured_log2_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_log2_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_log2_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log2_out_inplace final : public at::native::structured_log2_out {
    structured_log2_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_log2_(at::Tensor & self) {
  // No device check
structured_log2_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_logaddexp_out_functional final : public at::native::structured_logaddexp_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_logaddexp(const at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_logaddexp", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_logaddexp", "other");
structured_logaddexp_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_logaddexp_out_out final : public at::native::structured_logaddexp_out {
    structured_logaddexp_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_logaddexp_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_logaddexp_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_logaddexp_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_logaddexp_out_out", "other");
structured_logaddexp_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_logaddexp2_out_functional final : public at::native::structured_logaddexp2_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_logaddexp2(const at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_logaddexp2", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_logaddexp2", "other");
structured_logaddexp2_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_logaddexp2_out_out final : public at::native::structured_logaddexp2_out {
    structured_logaddexp2_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_logaddexp2_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_logaddexp2_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_logaddexp2_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_logaddexp2_out_out", "other");
structured_logaddexp2_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_xlogy_out_functional final : public at::native::structured_xlogy_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_xlogy_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_xlogy_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_xlogy_out_out final : public at::native::structured_xlogy_out {
    structured_xlogy_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_xlogy_out_OutTensor(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_xlogy_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_xlogy_out_inplace final : public at::native::structured_xlogy_out {
    structured_xlogy_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_xlogy__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_xlogy_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA_out_logspace_out(const at::Scalar & start, const at::Scalar & end, int64_t steps, double base, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_logspace_out", "out");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::logspace_cuda_out(start, end, steps, base, out);
}
} // anonymous namespace
struct structured_log_softmax_cuda_out_functional final : public at::native::structured_log_softmax_cuda_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__log_softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__log_softmax", "self");
structured_log_softmax_cuda_out_functional op;
op.meta(self, dim, half_to_float);
op.impl(self, dim, half_to_float, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log_softmax_cuda_out_out final : public at::native::structured_log_softmax_cuda_out {
    structured_log_softmax_cuda_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__log_softmax_out_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__log_softmax_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__log_softmax_out_out", "self");
structured_log_softmax_cuda_out_out op(out);
op.meta(self, dim, half_to_float);
op.impl(self, dim, half_to_float, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log_softmax_backward_cuda_out_functional final : public at::native::structured_log_softmax_backward_cuda_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__log_softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__log_softmax_backward_data", "grad_output");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA__log_softmax_backward_data", "output");
structured_log_softmax_backward_cuda_out_functional op;
op.meta(grad_output, output, dim, input_dtype);
op.impl(grad_output, output, dim, input_dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log_softmax_backward_cuda_out_out final : public at::native::structured_log_softmax_backward_cuda_out {
    structured_log_softmax_backward_cuda_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__log_softmax_backward_data_out_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__log_softmax_backward_data_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__log_softmax_backward_data_out_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA__log_softmax_backward_data_out_out", "output");
structured_log_softmax_backward_cuda_out_out op(out);
op.meta(grad_output, output, dim, input_dtype);
op.impl(grad_output, output, dim, input_dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA___logcumsumexp(const at::Tensor & self, int64_t dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___logcumsumexp", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_logcumsumexp_cuda(self, dim);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out__logcumsumexp_out(const at::Tensor & self, int64_t dim, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out__logcumsumexp_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out__logcumsumexp_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_logcumsumexp_out_cuda(self, dim, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___aminmax(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___aminmax", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_aminmax_all(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_dim__aminmax(const at::Tensor & self, int64_t dim, bool keepdim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_dim__aminmax", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_aminmax(self, dim, keepdim);
}
} // anonymous namespace
struct structured_aminmax_out_functional final : public at::native::structured_aminmax_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_aminmax(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
  // No device check
structured_aminmax_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_aminmax_out_out final : public at::native::structured_aminmax_out {
    structured_aminmax_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_aminmax_out_out(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & min, at::Tensor & max) {
  // No device check
structured_aminmax_out_out op(min, max);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(min, max);
}
namespace {
at::Tensor wrapper_CUDA___compute_linear_combination(const at::Tensor & input, const at::Tensor & coefficients) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA___compute_linear_combination", "input");
  c10::impl::check_and_update_common_device(common_device, coefficients, "wrapper_CUDA___compute_linear_combination", "coefficients");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::_compute_linear_combination(input, coefficients);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out__compute_linear_combination_out(const at::Tensor & input, const at::Tensor & coefficients, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out__compute_linear_combination_out", "out");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA_out__compute_linear_combination_out", "input");
  c10::impl::check_and_update_common_device(common_device, coefficients, "wrapper_CUDA_out__compute_linear_combination_out", "coefficients");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::_compute_linear_combination_out(input, coefficients, out);
}
} // anonymous namespace
struct structured_max_out_functional final : public at::native::structured_max_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_max_dim(const at::Tensor & self, int64_t dim, bool keepdim) {
  // No device check
structured_max_out_functional op;
auto precompute = op.meta(self, dim, keepdim);
(void)precompute;
op.impl(self, precompute.dim, keepdim, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_max_out_out final : public at::native::structured_max_out {
    structured_max_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_max_out_dim_max(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
  // No device check
structured_max_out_out op(max, max_values);
auto precompute = op.meta(self, dim, keepdim);
(void)precompute;
op.impl(self, precompute.dim, keepdim, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(max, max_values);
}
struct structured_amax_out_functional final : public at::native::structured_amax_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_amax(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_amax", "self");
structured_amax_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_amax_out_out final : public at::native::structured_amax_out {
    structured_amax_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_amax_out_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_amax_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_amax_out_out", "self");
structured_amax_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_mean_out_functional final : public at::native::structured_mean_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_mean_dim(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
  // No device check
structured_mean_out_functional op;
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mean_out_out final : public at::native::structured_mean_out {
    structured_mean_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_mean_out_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  // No device check
structured_mean_out_out op(out);
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA__median(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__median", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::median_cuda(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_dim_values_median_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, values, "wrapper_CUDA_dim_values_median_out", "values");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_dim_values_median_out", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_dim_values_median_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::median_out_cuda(self, dim, keepdim, values, indices);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__nanmedian(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__nanmedian", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nanmedian_cuda(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_dim_values_nanmedian_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, values, "wrapper_CUDA_dim_values_nanmedian_out", "values");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_dim_values_nanmedian_out", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_dim_values_nanmedian_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nanmedian_out_cuda(self, dim, keepdim, values, indices);
}
} // anonymous namespace
struct structured_min_out_functional final : public at::native::structured_min_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_min_dim(const at::Tensor & self, int64_t dim, bool keepdim) {
  // No device check
structured_min_out_functional op;
auto precompute = op.meta(self, dim, keepdim);
(void)precompute;
op.impl(self, precompute.dim, keepdim, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_min_out_out final : public at::native::structured_min_out {
    structured_min_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_min_out_dim_min(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & min, at::Tensor & min_indices) {
  // No device check
structured_min_out_out op(min, min_indices);
auto precompute = op.meta(self, dim, keepdim);
(void)precompute;
op.impl(self, precompute.dim, keepdim, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(min, min_indices);
}
struct structured_amin_out_functional final : public at::native::structured_amin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_amin(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_amin", "self");
structured_amin_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_amin_out_out final : public at::native::structured_amin_out {
    structured_amin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_amin_out_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_amin_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_amin_out_out", "self");
structured_amin_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__miopen_batch_norm(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__miopen_batch_norm", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__miopen_batch_norm", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__miopen_batch_norm", "bias");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA__miopen_batch_norm", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA__miopen_batch_norm", "running_var");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::miopen_batch_norm(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__miopen_batch_norm_backward(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__miopen_batch_norm_backward", "input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__miopen_batch_norm_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__miopen_batch_norm_backward", "weight");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA__miopen_batch_norm_backward", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA__miopen_batch_norm_backward", "running_var");
  c10::impl::check_and_update_common_device(common_device, save_mean, "wrapper_CUDA__miopen_batch_norm_backward", "save_mean");
  c10::impl::check_and_update_common_device(common_device, save_var, "wrapper_CUDA__miopen_batch_norm_backward", "save_var");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::miopen_batch_norm_backward(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__miopen_convolution(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__miopen_convolution", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__miopen_convolution", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__miopen_convolution", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::miopen_convolution(self, weight, bias, C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__), benchmark, deterministic);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__miopen_convolution_transpose(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__miopen_convolution_transpose", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__miopen_convolution_transpose", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__miopen_convolution_transpose", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::miopen_convolution_transpose(self, weight, bias, C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__), benchmark, deterministic);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__miopen_depthwise_convolution(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__miopen_depthwise_convolution", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__miopen_depthwise_convolution", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__miopen_depthwise_convolution", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::miopen_depthwise_convolution(self, weight, bias, C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__), benchmark, deterministic);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__miopen_convolution_relu(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__miopen_convolution_relu", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__miopen_convolution_relu", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__miopen_convolution_relu", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::miopen_convolution_relu(self, weight, bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__miopen_convolution_add_relu(const at::Tensor & self, const at::Tensor & weight, const at::Tensor & z, const c10::optional<at::Scalar> & alpha, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__miopen_convolution_add_relu", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__miopen_convolution_add_relu", "weight");
  c10::impl::check_and_update_common_device(common_device, z, "wrapper_CUDA__miopen_convolution_add_relu", "z");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__miopen_convolution_add_relu", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::miopen_convolution_add_relu(self, weight, z, alpha, bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation), groups.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__miopen_rnn(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__miopen_rnn", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__miopen_rnn", "weight");
  c10::impl::check_and_update_common_device(common_device, hx, "wrapper_CUDA__miopen_rnn", "hx");
  c10::impl::check_and_update_common_device(common_device, cx, "wrapper_CUDA__miopen_rnn", "cx");
  c10::impl::check_and_update_common_device(common_device, dropout_state, "wrapper_CUDA__miopen_rnn", "dropout_state");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::miopen_rnn(input, weight, weight_stride0, hx, cx, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,::std::vector<at::Tensor>> wrapper_CUDA__miopen_rnn_backward(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__miopen_rnn_backward", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__miopen_rnn_backward", "weight");
  c10::impl::check_and_update_common_device(common_device, weight_buf, "wrapper_CUDA__miopen_rnn_backward", "weight_buf");
  c10::impl::check_and_update_common_device(common_device, hx, "wrapper_CUDA__miopen_rnn_backward", "hx");
  c10::impl::check_and_update_common_device(common_device, cx, "wrapper_CUDA__miopen_rnn_backward", "cx");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA__miopen_rnn_backward", "output");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__miopen_rnn_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, grad_hy, "wrapper_CUDA__miopen_rnn_backward", "grad_hy");
  c10::impl::check_and_update_common_device(common_device, grad_cy, "wrapper_CUDA__miopen_rnn_backward", "grad_cy");
  c10::impl::check_and_update_common_device(common_device, dropout_state, "wrapper_CUDA__miopen_rnn_backward", "dropout_state");
  c10::impl::check_and_update_common_device(common_device, reserve, "wrapper_CUDA__miopen_rnn_backward", "reserve");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::miopen_rnn_backward(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask);
}
} // anonymous namespace
struct structured_mm_out_cuda_functional final : public at::native::structured_mm_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_mm(const at::Tensor & self, const at::Tensor & mat2) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_mm", "self");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_mm", "mat2");
structured_mm_out_cuda_functional op;
op.meta(self, mat2);
op.impl(self, mat2, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mm_out_cuda_out final : public at::native::structured_mm_out_cuda {
    structured_mm_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_mm_out_out(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_mm_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_mm_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_mm_out_out", "mat2");
structured_mm_out_cuda_out op(out);
op.meta(self, mat2);
op.impl(self, mat2, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA___int_mm(const at::Tensor & self, const at::Tensor & mat2) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___int_mm", "self");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA___int_mm", "mat2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_int_mm_cuda(self, mat2);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out__int_mm_out(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out__int_mm_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out__int_mm_out", "self");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_out__int_mm_out", "mat2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_int_mm_out_cuda(self, mat2, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___convert_weight_to_int4pack(const at::Tensor & self, int64_t innerKTiles) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___convert_weight_to_int4pack", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_convert_weight_to_int4pack_cuda(self, innerKTiles);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___weight_int4pack_mm(const at::Tensor & self, const at::Tensor & mat2, int64_t qGroupSize, const at::Tensor & qScaleAndZeros) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___weight_int4pack_mm", "self");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA___weight_int4pack_mm", "mat2");
  c10::impl::check_and_update_common_device(common_device, qScaleAndZeros, "wrapper_CUDA___weight_int4pack_mm", "qScaleAndZeros");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_weight_int4pack_mm_cuda(self, mat2, qGroupSize, qScaleAndZeros);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__mode(const at::Tensor & self, int64_t dim, bool keepdim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__mode", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::mode(self, dim, keepdim);
}
} // anonymous namespace
struct structured_mul_out_functional final : public at::native::structured_mul_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_mul_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_mul_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mul_out_out final : public at::native::structured_mul_out {
    structured_mul_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_mul_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_mul_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_mul_out_inplace final : public at::native::structured_mul_out {
    structured_mul_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_mul__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_mul_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA_out_mvlgamma_out(const at::Tensor & self, int64_t p, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_mvlgamma_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_mvlgamma_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::mvlgamma_out(self, p, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__native_batch_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__native_batch_norm", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__native_batch_norm", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__native_batch_norm", "bias");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA__native_batch_norm", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA__native_batch_norm", "running_var");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::batch_norm_cuda(input, weight, bias, running_mean, running_var, training, momentum, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA_out_native_batch_norm_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_native_batch_norm_out", "out");
  c10::impl::check_and_update_common_device(common_device, save_mean, "wrapper_CUDA_out_native_batch_norm_out", "save_mean");
  c10::impl::check_and_update_common_device(common_device, save_invstd, "wrapper_CUDA_out_native_batch_norm_out", "save_invstd");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA_out_native_batch_norm_out", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_out_native_batch_norm_out", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_out_native_batch_norm_out", "bias");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA_out_native_batch_norm_out", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA_out_native_batch_norm_out", "running_var");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::batch_norm_cuda_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA_out__native_batch_norm_legit_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out__native_batch_norm_legit_out", "out");
  c10::impl::check_and_update_common_device(common_device, save_mean, "wrapper_CUDA_out__native_batch_norm_legit_out", "save_mean");
  c10::impl::check_and_update_common_device(common_device, save_invstd, "wrapper_CUDA_out__native_batch_norm_legit_out", "save_invstd");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA_out__native_batch_norm_legit_out", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_out__native_batch_norm_legit_out", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_out__native_batch_norm_legit_out", "bias");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA_out__native_batch_norm_legit_out", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA_out__native_batch_norm_legit_out", "running_var");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::_batch_norm_legit_cuda_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___native_batch_norm_legit(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA___native_batch_norm_legit", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___native_batch_norm_legit", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA___native_batch_norm_legit", "bias");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA___native_batch_norm_legit", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA___native_batch_norm_legit", "running_var");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::_batch_norm_legit_cuda(input, weight, bias, running_mean, running_var, training, momentum, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA_no_stats__native_batch_norm_legit(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA_no_stats__native_batch_norm_legit", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_no_stats__native_batch_norm_legit", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_no_stats__native_batch_norm_legit", "bias");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::_batch_norm_legit_no_stats_cuda(input, weight, bias, training, momentum, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA_no_stats_out__native_batch_norm_legit_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_no_stats_out__native_batch_norm_legit_out", "out");
  c10::impl::check_and_update_common_device(common_device, save_mean, "wrapper_CUDA_no_stats_out__native_batch_norm_legit_out", "save_mean");
  c10::impl::check_and_update_common_device(common_device, save_invstd, "wrapper_CUDA_no_stats_out__native_batch_norm_legit_out", "save_invstd");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA_no_stats_out__native_batch_norm_legit_out", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_no_stats_out__native_batch_norm_legit_out", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_no_stats_out__native_batch_norm_legit_out", "bias");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::_batch_norm_legit_no_stats_cuda_out(input, weight, bias, training, momentum, eps, out, save_mean, save_invstd);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__batch_norm_stats(const at::Tensor & input, double eps) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__batch_norm_stats", "input");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::batch_norm_stats_cuda(input, eps);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__batch_norm_elemt(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & invstd, double eps) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__batch_norm_elemt", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__batch_norm_elemt", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__batch_norm_elemt", "bias");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA__batch_norm_elemt", "mean");
  c10::impl::check_and_update_common_device(common_device, invstd, "wrapper_CUDA__batch_norm_elemt", "invstd");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::batch_norm_elemt_cuda(input, weight, bias, mean, invstd, eps);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_batch_norm_elemt_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & invstd, double eps, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_batch_norm_elemt_out", "out");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA_out_batch_norm_elemt_out", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_out_batch_norm_elemt_out", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_out_batch_norm_elemt_out", "bias");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA_out_batch_norm_elemt_out", "mean");
  c10::impl::check_and_update_common_device(common_device, invstd, "wrapper_CUDA_out_batch_norm_elemt_out", "invstd");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::batch_norm_elemt_cuda_out(input, weight, bias, mean, invstd, eps, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__batch_norm_gather_stats(const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum, double eps, int64_t count) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__batch_norm_gather_stats", "input");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA__batch_norm_gather_stats", "mean");
  c10::impl::check_and_update_common_device(common_device, invstd, "wrapper_CUDA__batch_norm_gather_stats", "invstd");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA__batch_norm_gather_stats", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA__batch_norm_gather_stats", "running_var");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::batch_norm_gather_stats_cuda(input, mean, invstd, running_mean, running_var, momentum, eps, count);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__batch_norm_gather_stats_with_counts(const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum, double eps, const at::Tensor & counts) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__batch_norm_gather_stats_with_counts", "input");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA__batch_norm_gather_stats_with_counts", "mean");
  c10::impl::check_and_update_common_device(common_device, invstd, "wrapper_CUDA__batch_norm_gather_stats_with_counts", "invstd");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA__batch_norm_gather_stats_with_counts", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA__batch_norm_gather_stats_with_counts", "running_var");
  c10::impl::check_and_update_common_device(common_device, counts, "wrapper_CUDA__batch_norm_gather_stats_with_counts", "counts");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::batch_norm_gather_stats_with_counts_cuda(input, mean, invstd, running_mean, running_var, momentum, eps, counts);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__native_batch_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_invstd, bool train, double eps, ::std::array<bool,3> output_mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_out, "wrapper_CUDA__native_batch_norm_backward", "grad_out");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__native_batch_norm_backward", "input");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__native_batch_norm_backward", "weight");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA__native_batch_norm_backward", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA__native_batch_norm_backward", "running_var");
  c10::impl::check_and_update_common_device(common_device, save_mean, "wrapper_CUDA__native_batch_norm_backward", "save_mean");
  c10::impl::check_and_update_common_device(common_device, save_invstd, "wrapper_CUDA__native_batch_norm_backward", "save_invstd");
  const OptionalDeviceGuard device_guard(device_of(grad_out));
  return at::native::batch_norm_backward_cuda(grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__batch_norm_backward_reduce(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, bool input_g, bool weight_g, bool bias_g) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_out, "wrapper_CUDA__batch_norm_backward_reduce", "grad_out");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__batch_norm_backward_reduce", "input");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA__batch_norm_backward_reduce", "mean");
  c10::impl::check_and_update_common_device(common_device, invstd, "wrapper_CUDA__batch_norm_backward_reduce", "invstd");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__batch_norm_backward_reduce", "weight");
  const OptionalDeviceGuard device_guard(device_of(grad_out));
  return at::native::batch_norm_backward_reduce_cuda(grad_out, input, mean, invstd, weight, input_g, weight_g, bias_g);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__batch_norm_backward_elemt(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, const at::Tensor & sum_dy, const at::Tensor & sum_dy_xmu, const at::Tensor & count) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_out, "wrapper_CUDA__batch_norm_backward_elemt", "grad_out");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__batch_norm_backward_elemt", "input");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA__batch_norm_backward_elemt", "mean");
  c10::impl::check_and_update_common_device(common_device, invstd, "wrapper_CUDA__batch_norm_backward_elemt", "invstd");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__batch_norm_backward_elemt", "weight");
  c10::impl::check_and_update_common_device(common_device, sum_dy, "wrapper_CUDA__batch_norm_backward_elemt", "sum_dy");
  c10::impl::check_and_update_common_device(common_device, sum_dy_xmu, "wrapper_CUDA__batch_norm_backward_elemt", "sum_dy_xmu");
  c10::impl::check_and_update_common_device(common_device, count, "wrapper_CUDA__batch_norm_backward_elemt", "count");
  const OptionalDeviceGuard device_guard(device_of(grad_out));
  return at::native::batch_norm_backward_elemt_cuda(grad_out, input, mean, invstd, weight, sum_dy, sum_dy_xmu, count);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__batch_norm_update_stats(const at::Tensor & input, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__batch_norm_update_stats", "input");
  c10::impl::check_and_update_common_device(common_device, running_mean, "wrapper_CUDA__batch_norm_update_stats", "running_mean");
  c10::impl::check_and_update_common_device(common_device, running_var, "wrapper_CUDA__batch_norm_update_stats", "running_var");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::batch_norm_update_stats_cuda(input, running_mean, running_var, momentum);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___cdist_forward(const at::Tensor & x1, const at::Tensor & x2, double p, c10::optional<int64_t> compute_mode) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, x1, "wrapper_CUDA___cdist_forward", "x1");
  c10::impl::check_and_update_common_device(common_device, x2, "wrapper_CUDA___cdist_forward", "x2");
  const OptionalDeviceGuard device_guard(device_of(x1));
  return at::native::_cdist_forward(x1, x2, p, compute_mode);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___cdist_backward(const at::Tensor & grad, const at::Tensor & x1, const at::Tensor & x2, double p, const at::Tensor & cdist) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA___cdist_backward", "grad");
  c10::impl::check_and_update_common_device(common_device, x1, "wrapper_CUDA___cdist_backward", "x1");
  c10::impl::check_and_update_common_device(common_device, x2, "wrapper_CUDA___cdist_backward", "x2");
  c10::impl::check_and_update_common_device(common_device, cdist, "wrapper_CUDA___cdist_backward", "cdist");
  const OptionalDeviceGuard device_guard(device_of(grad));
  return at::native::_cdist_backward(grad, x1, x2, p, cdist);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___pdist_forward(const at::Tensor & self, double p) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___pdist_forward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_pdist_forward(self, p);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___pdist_backward(const at::Tensor & grad, const at::Tensor & self, double p, const at::Tensor & pdist) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA___pdist_backward", "grad");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___pdist_backward", "self");
  c10::impl::check_and_update_common_device(common_device, pdist, "wrapper_CUDA___pdist_backward", "pdist");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_pdist_backward(grad, self, p, pdist);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__channel_shuffle(const at::Tensor & self, c10::SymInt groups) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__channel_shuffle", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::channel_shuffle(self, groups.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
bool wrapper_CUDA__is_pinned(const at::Tensor & self, c10::optional<at::Device> device) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__is_pinned", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::is_pinned_cuda(self, device);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___pin_memory(const at::Tensor & self, c10::optional<at::Device> device) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___pin_memory", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_pin_memory_cuda(self, device);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_generator_out_randperm_out(c10::SymInt n, c10::optional<at::Generator> generator, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_generator_out_randperm_out", "out");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::randperm_out_cuda(n.guard_int(__FILE__, __LINE__), generator, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_range_out(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_range_out", "out");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::range_cuda_out(start, end, step, out);
}
} // anonymous namespace
struct structured_reciprocal_out_functional final : public at::native::structured_reciprocal_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_reciprocal(const at::Tensor & self) {
  // No device check
structured_reciprocal_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reciprocal_out_out final : public at::native::structured_reciprocal_out {
    structured_reciprocal_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_reciprocal_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_reciprocal_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_reciprocal_out_inplace final : public at::native::structured_reciprocal_out {
    structured_reciprocal_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_reciprocal_(at::Tensor & self) {
  // No device check
structured_reciprocal_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_neg_out_functional final : public at::native::structured_neg_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_neg(const at::Tensor & self) {
  // No device check
structured_neg_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_neg_out_out final : public at::native::structured_neg_out {
    structured_neg_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_neg_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_neg_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_neg_out_inplace final : public at::native::structured_neg_out {
    structured_neg_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_neg_(at::Tensor & self) {
  // No device check
structured_neg_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA_Tensor_repeat_interleave(const at::Tensor & repeats, c10::optional<c10::SymInt> output_size) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, repeats, "wrapper_CUDA_Tensor_repeat_interleave", "repeats");
  const OptionalDeviceGuard device_guard(device_of(repeats));
  return at::native::repeat_interleave_cuda(repeats, output_size.has_value() ? c10::make_optional(output_size->guard_int(__FILE__, __LINE__)) : c10::nullopt);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___reshape_alias(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
    // No device check
  // DeviceGuard omitted
  return at::native::_reshape_alias(self, C10_AS_INTARRAYREF_SLOW(size), C10_AS_INTARRAYREF_SLOW(stride));
}
} // anonymous namespace
struct structured_round_out_functional final : public at::native::structured_round_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_round(const at::Tensor & self) {
  // No device check
structured_round_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_round_out_out final : public at::native::structured_round_out {
    structured_round_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_round_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_round_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_round_out_inplace final : public at::native::structured_round_out {
    structured_round_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_round_(at::Tensor & self) {
  // No device check
structured_round_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_round_decimals_out_functional final : public at::native::structured_round_decimals_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_round_decimals(const at::Tensor & self, int64_t decimals) {
  // No device check
structured_round_decimals_out_functional op;
op.meta(self, decimals);
op.impl(self, decimals, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_round_decimals_out_out final : public at::native::structured_round_decimals_out {
    structured_round_decimals_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_round_out_decimals_out(const at::Tensor & self, int64_t decimals, at::Tensor & out) {
  // No device check
structured_round_decimals_out_out op(out);
op.meta(self, decimals);
op.impl(self, decimals, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_round_decimals_out_inplace final : public at::native::structured_round_decimals_out {
    structured_round_decimals_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_round__decimals(at::Tensor & self, int64_t decimals) {
  // No device check
structured_round_decimals_out_inplace op(self);
op.meta(self, decimals);
op.impl(self, decimals, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__relu(const at::Tensor & self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::relu(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__relu_(at::Tensor & self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::relu_(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___prelu_kernel(const at::Tensor & self, const at::Tensor & weight) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___prelu_kernel", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___prelu_kernel", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_prelu_kernel(self, weight);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___prelu_kernel_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA___prelu_kernel_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___prelu_kernel_backward", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___prelu_kernel_backward", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_prelu_kernel_backward(grad_output, self, weight);
}
} // anonymous namespace
struct structured_gelu_out_cuda_functional final : public at::native::structured_gelu_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_gelu(const at::Tensor & self, c10::string_view approximate) {
  // No device check
structured_gelu_out_cuda_functional op;
op.meta(self, approximate);
op.impl(self, approximate, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gelu_out_cuda_out final : public at::native::structured_gelu_out_cuda {
    structured_gelu_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gelu_out_out(const at::Tensor & self, c10::string_view approximate, at::Tensor & out) {
  // No device check
structured_gelu_out_cuda_out op(out);
op.meta(self, approximate);
op.impl(self, approximate, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_gelu_out_cuda_inplace final : public at::native::structured_gelu_out_cuda {
    structured_gelu_out_cuda_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gelu_(at::Tensor & self, c10::string_view approximate) {
  // No device check
structured_gelu_out_cuda_inplace op(self);
op.meta(self, approximate);
op.impl(self, approximate, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_gelu_backward_out_cuda_functional final : public at::native::structured_gelu_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_backward_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_backward_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_gelu_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_gelu_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_gelu_backward", "self");
structured_gelu_backward_out_cuda_functional op;
op.meta(grad_output, self, approximate);
op.impl(grad_output, self, approximate, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gelu_backward_out_cuda_out final : public at::native::structured_gelu_backward_out_cuda {
    structured_gelu_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_backward_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_backward_out_cuda::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gelu_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_gelu_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_gelu_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_gelu_backward_out_grad_input", "self");
structured_gelu_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, approximate);
op.impl(grad_output, self, approximate, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_hardshrink_out_functional final : public at::native::structured_hardshrink_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_hardshrink(const at::Tensor & self, const at::Scalar & lambd) {
  // No device check
structured_hardshrink_out_functional op;
op.meta(self, lambd);
op.impl(self, lambd, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hardshrink_out_out final : public at::native::structured_hardshrink_out {
    structured_hardshrink_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_hardshrink_out_out(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
  // No device check
structured_hardshrink_out_out op(out);
op.meta(self, lambd);
op.impl(self, lambd, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_hardshrink_backward_out_functional final : public at::native::structured_hardshrink_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_hardshrink_backward(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_out, "wrapper_CUDA_hardshrink_backward", "grad_out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_hardshrink_backward", "self");
structured_hardshrink_backward_out_functional op;
op.meta(grad_out, self, lambd);
op.impl(grad_out, self, lambd, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hardshrink_backward_out_out final : public at::native::structured_hardshrink_backward_out {
    structured_hardshrink_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_hardshrink_backward_out_grad_input(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_hardshrink_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_out, "wrapper_CUDA_hardshrink_backward_out_grad_input", "grad_out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_hardshrink_backward_out_grad_input", "self");
structured_hardshrink_backward_out_out op(grad_input);
op.meta(grad_out, self, lambd);
op.impl(grad_out, self, lambd, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_rsqrt_out_functional final : public at::native::structured_rsqrt_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_rsqrt(const at::Tensor & self) {
  // No device check
structured_rsqrt_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_rsqrt_out_out final : public at::native::structured_rsqrt_out {
    structured_rsqrt_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_rsqrt_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_rsqrt_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_rsqrt_out_inplace final : public at::native::structured_rsqrt_out {
    structured_rsqrt_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_rsqrt_(at::Tensor & self) {
  // No device check
structured_rsqrt_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_silu_out_functional final : public at::native::structured_silu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_silu(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_silu", "self");
structured_silu_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_silu_out_out final : public at::native::structured_silu_out {
    structured_silu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_silu_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_silu_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_silu_out_out", "self");
structured_silu_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_silu_out_inplace final : public at::native::structured_silu_out {
    structured_silu_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_silu_(at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_silu_", "self");
structured_silu_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_silu_backward_out_functional final : public at::native::structured_silu_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_silu_backward(const at::Tensor & grad_output, const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_silu_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_silu_backward", "self");
structured_silu_backward_out_functional op;
op.meta(grad_output, self);
op.impl(grad_output, self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_silu_backward_out_out final : public at::native::structured_silu_backward_out {
    structured_silu_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_silu_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_silu_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_silu_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_silu_backward_out_grad_input", "self");
structured_silu_backward_out_out op(grad_input);
op.meta(grad_output, self);
op.impl(grad_output, self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_mish_out_functional final : public at::native::structured_mish_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_mish(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_mish", "self");
structured_mish_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mish_out_out final : public at::native::structured_mish_out {
    structured_mish_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_mish_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_mish_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_mish_out_out", "self");
structured_mish_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_mish_out_inplace final : public at::native::structured_mish_out {
    structured_mish_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_mish_(at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_mish_", "self");
structured_mish_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__mish_backward(const at::Tensor & grad_output, const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__mish_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__mish_backward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::mish_backward(grad_output, self);
}
} // anonymous namespace
struct structured_sigmoid_out_functional final : public at::native::structured_sigmoid_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sigmoid(const at::Tensor & self) {
  // No device check
structured_sigmoid_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sigmoid_out_out final : public at::native::structured_sigmoid_out {
    structured_sigmoid_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sigmoid_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_sigmoid_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sigmoid_out_inplace final : public at::native::structured_sigmoid_out {
    structured_sigmoid_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sigmoid_(at::Tensor & self) {
  // No device check
structured_sigmoid_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__logit(const at::Tensor & self, c10::optional<double> eps) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__logit", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::logit(self, eps);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_logit_out(const at::Tensor & self, c10::optional<double> eps, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_logit_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_logit_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::logit_out(self, eps, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__logit_(at::Tensor & self, c10::optional<double> eps) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__logit_", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::logit_(self, eps);
}
} // anonymous namespace
struct structured_sin_out_functional final : public at::native::structured_sin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sin(const at::Tensor & self) {
  // No device check
structured_sin_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sin_out_out final : public at::native::structured_sin_out {
    structured_sin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sin_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_sin_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sin_out_inplace final : public at::native::structured_sin_out {
    structured_sin_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sin_(at::Tensor & self) {
  // No device check
structured_sin_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_sinc_out_functional final : public at::native::structured_sinc_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sinc(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_sinc", "self");
structured_sinc_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sinc_out_out final : public at::native::structured_sinc_out {
    structured_sinc_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sinc_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_sinc_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_sinc_out_out", "self");
structured_sinc_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sinc_out_inplace final : public at::native::structured_sinc_out {
    structured_sinc_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sinc_(at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_sinc_", "self");
structured_sinc_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_sinh_out_functional final : public at::native::structured_sinh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sinh(const at::Tensor & self) {
  // No device check
structured_sinh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sinh_out_out final : public at::native::structured_sinh_out {
    structured_sinh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sinh_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_sinh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sinh_out_inplace final : public at::native::structured_sinh_out {
    structured_sinh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sinh_(at::Tensor & self) {
  // No device check
structured_sinh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_softmax_cuda_out_functional final : public at::native::structured_softmax_cuda_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__softmax", "self");
structured_softmax_cuda_out_functional op;
op.meta(self, dim, half_to_float);
op.impl(self, dim, half_to_float, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softmax_cuda_out_out final : public at::native::structured_softmax_cuda_out {
    structured_softmax_cuda_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__softmax_out_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__softmax_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__softmax_out_out", "self");
structured_softmax_cuda_out_out op(out);
op.meta(self, dim, half_to_float);
op.impl(self, dim, half_to_float, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_softmax_backward_cuda_out_functional final : public at::native::structured_softmax_backward_cuda_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__softmax_backward_data", "grad_output");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA__softmax_backward_data", "output");
structured_softmax_backward_cuda_out_functional op;
op.meta(grad_output, output, dim, input_dtype);
op.impl(grad_output, output, dim, input_dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softmax_backward_cuda_out_out final : public at::native::structured_softmax_backward_cuda_out {
    structured_softmax_backward_cuda_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__softmax_backward_data_out_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA__softmax_backward_data_out_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__softmax_backward_data_out_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA__softmax_backward_data_out_out", "output");
structured_softmax_backward_cuda_out_out op(grad_input);
op.meta(grad_output, output, dim, input_dtype);
op.impl(grad_output, output, dim, input_dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor & wrapper_CUDA_out_sspaddmm_out(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_sspaddmm_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_sspaddmm_out", "self");
  c10::impl::check_and_update_common_device(common_device, mat1, "wrapper_CUDA_out_sspaddmm_out", "mat1");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_out_sspaddmm_out", "mat2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_sspaddmm_out_only_sparse_cuda(self, mat1, mat2, beta, alpha, out);
}
} // anonymous namespace
struct structured_sum_out_functional final : public at::native::structured_sum_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sum_dim_IntList(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
  // No device check
structured_sum_out_functional op;
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sum_out_out final : public at::native::structured_sum_out {
    structured_sum_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sum_out_IntList_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  // No device check
structured_sum_out_out op(out);
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA__nansum(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__nansum", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nansum(self, dim, keepdim, dtype);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_nansum_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_nansum_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_nansum_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nansum_out(self, dim, keepdim, dtype, out);
}
} // anonymous namespace
struct structured_sqrt_out_functional final : public at::native::structured_sqrt_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sqrt(const at::Tensor & self) {
  // No device check
structured_sqrt_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sqrt_out_out final : public at::native::structured_sqrt_out {
    structured_sqrt_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sqrt_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_sqrt_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sqrt_out_inplace final : public at::native::structured_sqrt_out {
    structured_sqrt_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sqrt_(at::Tensor & self) {
  // No device check
structured_sqrt_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA_correction_std(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::std(self, dim, correction, keepdim);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_correction_out_std_out(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::std_out(self, dim, correction, keepdim, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_correction_std_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::std_mean(self, dim, correction, keepdim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__prod(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::prod(self, dtype);
}
} // anonymous namespace
struct structured_prod_out_functional final : public at::native::structured_prod_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_prod_dim_int(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
  // No device check
structured_prod_out_functional op;
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_prod_out_out final : public at::native::structured_prod_out {
    structured_prod_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_prod_out_int_out(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  // No device check
structured_prod_out_out op(out);
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_tan_out_functional final : public at::native::structured_tan_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_tan(const at::Tensor & self) {
  // No device check
structured_tan_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_tan_out_out final : public at::native::structured_tan_out {
    structured_tan_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_tan_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_tan_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_tan_out_inplace final : public at::native::structured_tan_out {
    structured_tan_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_tan_(at::Tensor & self) {
  // No device check
structured_tan_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_tanh_out_functional final : public at::native::structured_tanh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_tanh(const at::Tensor & self) {
  // No device check
structured_tanh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_tanh_out_out final : public at::native::structured_tanh_out {
    structured_tanh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_tanh_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_tanh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_tanh_out_inplace final : public at::native::structured_tanh_out {
    structured_tanh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_tanh_(at::Tensor & self) {
  // No device check
structured_tanh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_threshold_out_functional final : public at::native::structured_threshold_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_threshold(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
  // No device check
structured_threshold_out_functional op;
op.meta(self, threshold, value);
op.impl(self, threshold, value, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_threshold_out_out final : public at::native::structured_threshold_out {
    structured_threshold_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_threshold_out_out(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value, at::Tensor & out) {
  // No device check
structured_threshold_out_out op(out);
op.meta(self, threshold, value);
op.impl(self, threshold, value, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_threshold_out_inplace final : public at::native::structured_threshold_out {
    structured_threshold_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_threshold_(at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
  // No device check
structured_threshold_out_inplace op(self);
op.meta(self, threshold, value);
op.impl(self, threshold, value, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_threshold_backward_out_functional final : public at::native::structured_threshold_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_threshold_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_threshold_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_threshold_backward", "self");
structured_threshold_backward_out_functional op;
op.meta(grad_output, self, threshold);
op.impl(grad_output, self, threshold, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_threshold_backward_out_out final : public at::native::structured_threshold_backward_out {
    structured_threshold_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_threshold_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_threshold_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_threshold_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_threshold_backward_out_grad_input", "self");
structured_threshold_backward_out_out op(grad_input);
op.meta(grad_output, self, threshold);
op.impl(grad_output, self, threshold, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor wrapper_CUDA__flip(const at::Tensor & self, at::IntArrayRef dims) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__flip", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::flip(self, dims);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__roll(const at::Tensor & self, c10::SymIntArrayRef shifts, at::IntArrayRef dims) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__roll", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::roll_cuda(self, C10_AS_INTARRAYREF_SLOW(shifts), dims);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___transform_bias_rescale_qkv(const at::Tensor & qkv, const at::Tensor & qkv_bias, int64_t num_heads) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, qkv, "wrapper_CUDA___transform_bias_rescale_qkv", "qkv");
  c10::impl::check_and_update_common_device(common_device, qkv_bias, "wrapper_CUDA___transform_bias_rescale_qkv", "qkv_bias");
  const OptionalDeviceGuard device_guard(device_of(qkv));
  return at::native::transform_bias_rescale_qkv_cuda(qkv, qkv_bias, num_heads);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___nested_tensor_from_mask(const at::Tensor & t, const at::Tensor & mask, bool mask_check) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, t, "wrapper_CUDA___nested_tensor_from_mask", "t");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA___nested_tensor_from_mask", "mask");
  const OptionalDeviceGuard device_guard(device_of(t));
  return at::native::NestedTensor_nested_tensor_from_mask(t, mask, mask_check);
}
} // anonymous namespace
namespace {
bool wrapper_CUDA___nested_tensor_from_mask_left_aligned(const at::Tensor & t, const at::Tensor & mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, t, "wrapper_CUDA___nested_tensor_from_mask_left_aligned", "t");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA___nested_tensor_from_mask_left_aligned", "mask");
  const OptionalDeviceGuard device_guard(device_of(t));
  return at::native::NestedTensor_nested_tensor_from_mask_left_aligned(t, mask);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___nested_from_padded(const at::Tensor & padded, const at::Tensor & cpu_nested_shape_example, bool fuse_transform_0213) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(padded));
  return at::native::nested_from_padded_cuda(padded, cpu_nested_shape_example, fuse_transform_0213);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___nested_view_from_buffer(const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_nested_view_from_buffer(self, nested_size, nested_strides, offsets);
}
} // anonymous namespace
struct structured_trunc_out_functional final : public at::native::structured_trunc_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_trunc(const at::Tensor & self) {
  // No device check
structured_trunc_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_trunc_out_out final : public at::native::structured_trunc_out {
    structured_trunc_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_trunc_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_trunc_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_trunc_out_inplace final : public at::native::structured_trunc_out {
    structured_trunc_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_trunc_(at::Tensor & self) {
  // No device check
structured_trunc_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___unique(const at::Tensor & self, bool sorted, bool return_inverse) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___unique", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_unique_cuda(self, sorted, return_inverse);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__unique_dim(const at::Tensor & self, int64_t dim, bool sorted, bool return_inverse, bool return_counts) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__unique_dim", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::unique_dim_cuda(self, dim, sorted, return_inverse, return_counts);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__unique_consecutive(const at::Tensor & self, bool return_inverse, bool return_counts, c10::optional<int64_t> dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__unique_consecutive", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::unique_consecutive_cuda(self, return_inverse, return_counts, dim);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__unique_dim_consecutive(const at::Tensor & self, int64_t dim, bool return_inverse, bool return_counts) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__unique_dim_consecutive", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::unique_dim_consecutive_cuda(self, dim, return_inverse, return_counts);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___unique2(const at::Tensor & self, bool sorted, bool return_inverse, bool return_counts) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___unique2", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_unique2_cuda(self, sorted, return_inverse, return_counts);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_correction_var(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::var(self, dim, correction, keepdim);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_correction_out_var_out(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::var_out(self, dim, correction, keepdim, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_correction_var_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::var_mean(self, dim, correction, keepdim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_self_where(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::where(condition, self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_self_out_where_out(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::where_self_out(condition, self, other, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___weight_norm_interface(const at::Tensor & v, const at::Tensor & g, int64_t dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, v, "wrapper_CUDA___weight_norm_interface", "v");
  c10::impl::check_and_update_common_device(common_device, g, "wrapper_CUDA___weight_norm_interface", "g");
  const OptionalDeviceGuard device_guard(device_of(v));
  return at::native::weight_norm_cuda(v, g, dim);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___weight_norm_interface_backward(const at::Tensor & grad_w, const at::Tensor & saved_v, const at::Tensor & saved_g, const at::Tensor & saved_norms, int64_t dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_w, "wrapper_CUDA___weight_norm_interface_backward", "grad_w");
  c10::impl::check_and_update_common_device(common_device, saved_v, "wrapper_CUDA___weight_norm_interface_backward", "saved_v");
  c10::impl::check_and_update_common_device(common_device, saved_g, "wrapper_CUDA___weight_norm_interface_backward", "saved_g");
  c10::impl::check_and_update_common_device(common_device, saved_norms, "wrapper_CUDA___weight_norm_interface_backward", "saved_norms");
  const OptionalDeviceGuard device_guard(device_of(grad_w));
  return at::native::weight_norm_backward_cuda(grad_w, saved_v, saved_g, saved_norms, dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___efficientzerotensor(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  globalContext().lazyInitCUDA();
  const DeviceGuard device_guard(device_or_default(device));
  return at::native::_efficientzerotensor_cuda(C10_AS_INTARRAYREF_SLOW(size), dtype, layout, device, pin_memory);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___standard_gamma_grad(const at::Tensor & self, const at::Tensor & output) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___standard_gamma_grad", "self");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA___standard_gamma_grad", "output");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_standard_gamma_grad_cuda(self, output);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___standard_gamma(const at::Tensor & self, c10::optional<at::Generator> generator) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___standard_gamma", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_s_gamma_cuda(self, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___dirichlet_grad(const at::Tensor & x, const at::Tensor & alpha, const at::Tensor & total) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA___dirichlet_grad", "x");
  c10::impl::check_and_update_common_device(common_device, alpha, "wrapper_CUDA___dirichlet_grad", "alpha");
  c10::impl::check_and_update_common_device(common_device, total, "wrapper_CUDA___dirichlet_grad", "total");
  const OptionalDeviceGuard device_guard(device_of(x));
  return at::native::_dirichlet_grad_cuda(x, alpha, total);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___sample_dirichlet(const at::Tensor & self, c10::optional<at::Generator> generator) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___sample_dirichlet", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_s_dirichlet_cuda(self, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__poisson(const at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_s_poisson_cuda(self, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__binomial(const at::Tensor & count, const at::Tensor & prob, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(count));
  return at::native::_s_binomial_cuda(count, prob, generator);
}
} // anonymous namespace
struct structured_norm_dtype_out_functional final : public at::native::structured_norm_dtype_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_norm_ScalarOpt_dim_dtype(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype) {
  // No device check
structured_norm_dtype_out_functional op;
op.meta(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, dtype);
op.impl(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_norm_dtype_out_out final : public at::native::structured_norm_dtype_out {
    structured_norm_dtype_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_norm_out_dtype_out(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype, at::Tensor & out) {
  // No device check
structured_norm_dtype_out_out op(out);
op.meta(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, dtype);
op.impl(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_norm_out_functional final : public at::native::structured_norm_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_norm_ScalarOpt_dim(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim) {
  // No device check
structured_norm_out_functional op;
op.meta(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim);
op.impl(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_norm_out_out final : public at::native::structured_norm_out {
    structured_norm_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_norm_out_out(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
  // No device check
structured_norm_out_out op(out);
op.meta(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim);
op.impl(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_Tensor_out_frexp_out(const at::Tensor & self, at::Tensor & mantissa, at::Tensor & exponent) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, mantissa, "wrapper_CUDA_Tensor_out_frexp_out", "mantissa");
  c10::impl::check_and_update_common_device(common_device, exponent, "wrapper_CUDA_Tensor_out_frexp_out", "exponent");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_Tensor_out_frexp_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::frexp_out(self, mantissa, exponent);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__zero_(at::Tensor & self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::zero_(self);
}
} // anonymous namespace
struct structured_sub_out_functional final : public at::native::structured_sub_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sub_Tensor(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
  // No device check
structured_sub_out_functional op;
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sub_out_out final : public at::native::structured_sub_out {
    structured_sub_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sub_out_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
  // No device check
structured_sub_out_out op(out);
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sub_out_inplace final : public at::native::structured_sub_out {
    structured_sub_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sub__Tensor(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
  // No device check
structured_sub_out_inplace op(self);
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA_Tensor_rsub(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::rsub(self, other, alpha);
}
} // anonymous namespace
struct structured_heaviside_out_functional final : public at::native::structured_heaviside_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_heaviside(const at::Tensor & self, const at::Tensor & values) {
  // No device check
structured_heaviside_out_functional op;
op.meta(self, values);
op.impl(self, values, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_heaviside_out_out final : public at::native::structured_heaviside_out {
    structured_heaviside_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_heaviside_out_out(const at::Tensor & self, const at::Tensor & values, at::Tensor & out) {
  // No device check
structured_heaviside_out_out op(out);
op.meta(self, values);
op.impl(self, values, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_heaviside_out_inplace final : public at::native::structured_heaviside_out {
    structured_heaviside_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_heaviside_(at::Tensor & self, const at::Tensor & values) {
  // No device check
structured_heaviside_out_inplace op(self);
op.meta(self, values);
op.impl(self, values, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_addmm_out_cuda_functional final : public at::native::structured_addmm_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_addmm(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_addmm", "self");
  c10::impl::check_and_update_common_device(common_device, mat1, "wrapper_CUDA_addmm", "mat1");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_addmm", "mat2");
structured_addmm_out_cuda_functional op;
op.meta(self, mat1, mat2, beta, alpha);
op.impl(self, mat1, mat2, beta, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addmm_out_cuda_out final : public at::native::structured_addmm_out_cuda {
    structured_addmm_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_addmm_out_out(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_addmm_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_addmm_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, mat1, "wrapper_CUDA_addmm_out_out", "mat1");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_addmm_out_out", "mat2");
structured_addmm_out_cuda_out op(out);
op.meta(self, mat1, mat2, beta, alpha);
op.impl(self, mat1, mat2, beta, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addmm_out_cuda_inplace final : public at::native::structured_addmm_out_cuda {
    structured_addmm_out_cuda_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_addmm_(at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_addmm_", "self");
  c10::impl::check_and_update_common_device(common_device, mat1, "wrapper_CUDA_addmm_", "mat1");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_addmm_", "mat2");
structured_addmm_out_cuda_inplace op(self);
op.meta(self, mat1, mat2, beta, alpha);
op.impl(self, mat1, mat2, beta, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_addmm_activation_out_cuda_functional final : public at::native::structured_addmm_activation_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__addmm_activation(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__addmm_activation", "self");
  c10::impl::check_and_update_common_device(common_device, mat1, "wrapper_CUDA__addmm_activation", "mat1");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA__addmm_activation", "mat2");
structured_addmm_activation_out_cuda_functional op;
op.meta(self, mat1, mat2, beta, alpha, use_gelu);
op.impl(self, mat1, mat2, beta, alpha, use_gelu, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addmm_activation_out_cuda_out final : public at::native::structured_addmm_activation_out_cuda {
    structured_addmm_activation_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__addmm_activation_out_out(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__addmm_activation_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__addmm_activation_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, mat1, "wrapper_CUDA__addmm_activation_out_out", "mat1");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA__addmm_activation_out_out", "mat2");
structured_addmm_activation_out_cuda_out op(out);
op.meta(self, mat1, mat2, beta, alpha, use_gelu);
op.impl(self, mat1, mat2, beta, alpha, use_gelu, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___scaled_mm(const at::Tensor & self, const at::Tensor & mat2, const c10::optional<at::Tensor> & bias, c10::optional<at::ScalarType> out_dtype, const c10::optional<at::Tensor> & scale_a, const c10::optional<at::Tensor> & scale_b, const c10::optional<at::Tensor> & scale_result, bool use_fast_accum) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___scaled_mm", "self");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA___scaled_mm", "mat2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_scaled_mm_cuda(self, mat2, bias, out_dtype, scale_a, scale_b, scale_result, use_fast_accum);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_out__scaled_mm_out(const at::Tensor & self, const at::Tensor & mat2, const c10::optional<at::Tensor> & bias, c10::optional<at::ScalarType> out_dtype, const c10::optional<at::Tensor> & scale_a, const c10::optional<at::Tensor> & scale_b, const c10::optional<at::Tensor> & scale_result, bool use_fast_accum, at::Tensor & out, at::Tensor & out_amax) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out__scaled_mm_out", "out");
  c10::impl::check_and_update_common_device(common_device, out_amax, "wrapper_CUDA_out__scaled_mm_out", "out_amax");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out__scaled_mm_out", "self");
  c10::impl::check_and_update_common_device(common_device, mat2, "wrapper_CUDA_out__scaled_mm_out", "mat2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_scaled_mm_out_cuda(self, mat2, bias, out_dtype, scale_a, scale_b, scale_result, use_fast_accum, out, out_amax);
}
} // anonymous namespace
namespace {
int64_t wrapper_CUDA__sparse_dim(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::sparse_dim_strided(self);
}
} // anonymous namespace
namespace {
int64_t wrapper_CUDA__dense_dim(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::dense_dim_strided(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_sparse_dim__to_sparse(const at::Tensor & self, int64_t sparse_dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_sparse_dim__to_sparse", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::dense_to_sparse(self, sparse_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___to_sparse(const at::Tensor & self, c10::optional<at::Layout> layout, at::OptionalIntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___to_sparse", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::dense_to_sparse(self, layout, blocksize, dense_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___to_sparse_csr(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___to_sparse_csr", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::dense_to_sparse_csr(self, dense_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___to_sparse_csc(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___to_sparse_csc", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::dense_to_sparse_csc(self, dense_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___to_sparse_bsr(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___to_sparse_bsr", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::dense_to_sparse_bsr(self, blocksize, dense_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___to_sparse_bsc(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___to_sparse_bsc", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::dense_to_sparse_bsc(self, blocksize, dense_dim);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___to_sparse_semi_structured(const at::Tensor & dense) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, dense, "wrapper_CUDA___to_sparse_semi_structured", "dense");
  const OptionalDeviceGuard device_guard(device_of(dense));
  return at::native::_to_sparse_semi_structured(dense);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__quantize_per_tensor_dynamic(const at::Tensor & self, at::ScalarType dtype, bool reduce_range) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__quantize_per_tensor_dynamic", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::quantize_per_tensor_dynamic(self, dtype, reduce_range);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__quantize_per_tensor(const at::Tensor & self, double scale, int64_t zero_point, at::ScalarType dtype) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__quantize_per_tensor", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::quantize_per_tensor(self, scale, zero_point, dtype);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_tensor_qparams_quantize_per_tensor(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, at::ScalarType dtype) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_tensor_qparams_quantize_per_tensor", "self");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA_tensor_qparams_quantize_per_tensor", "scale");
  c10::impl::check_and_update_common_device(common_device, zero_point, "wrapper_CUDA_tensor_qparams_quantize_per_tensor", "zero_point");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::quantize_per_tensor_tensor_qparams(self, scale, zero_point, dtype);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__quantize_per_channel(const at::Tensor & self, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, at::ScalarType dtype) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__quantize_per_channel", "self");
  c10::impl::check_and_update_common_device(common_device, scales, "wrapper_CUDA__quantize_per_channel", "scales");
  c10::impl::check_and_update_common_device(common_device, zero_points, "wrapper_CUDA__quantize_per_channel", "zero_points");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::quantize_per_channel(self, scales, zero_points, axis, dtype);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_self_dequantize(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_self_dequantize", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::dequantize_cpu_or_cuda(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___make_per_tensor_quantized_tensor(const at::Tensor & self, double scale, int64_t zero_point) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___make_per_tensor_quantized_tensor", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::make_per_tensor_quantized_tensor_cuda(self, scale, zero_point);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___make_per_channel_quantized_tensor(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___make_per_channel_quantized_tensor", "self");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA___make_per_channel_quantized_tensor", "scale");
  c10::impl::check_and_update_common_device(common_device, zero_point, "wrapper_CUDA___make_per_channel_quantized_tensor", "zero_point");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::make_per_channel_quantized_tensor_cuda(self, scale, zero_point, axis);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__fake_quantize_per_tensor_affine_cachemask(const at::Tensor & self, double scale, int64_t zero_point, int64_t quant_min, int64_t quant_max) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__fake_quantize_per_tensor_affine_cachemask", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::fake_quantize_per_tensor_affine_cachemask(self, scale, zero_point, quant_min, quant_max);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___fake_quantize_per_tensor_affine_cachemask_tensor_qparams(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, const at::Tensor & fake_quant_enabled, int64_t quant_min, int64_t quant_max) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fake_quantize_per_tensor_affine_cachemask_tensor_qparams", "self");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA___fake_quantize_per_tensor_affine_cachemask_tensor_qparams", "scale");
  c10::impl::check_and_update_common_device(common_device, zero_point, "wrapper_CUDA___fake_quantize_per_tensor_affine_cachemask_tensor_qparams", "zero_point");
  c10::impl::check_and_update_common_device(common_device, fake_quant_enabled, "wrapper_CUDA___fake_quantize_per_tensor_affine_cachemask_tensor_qparams", "fake_quant_enabled");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fake_quantize_per_tensor_affine_cachemask_tensor_qparams(self, scale, zero_point, fake_quant_enabled, quant_min, quant_max);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___fake_quantize_learnable_per_tensor_affine(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t quant_min, int64_t quant_max, double grad_factor) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fake_quantize_learnable_per_tensor_affine", "self");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA___fake_quantize_learnable_per_tensor_affine", "scale");
  c10::impl::check_and_update_common_device(common_device, zero_point, "wrapper_CUDA___fake_quantize_learnable_per_tensor_affine", "zero_point");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fake_quantize_learnable_per_tensor_affine(self, scale, zero_point, quant_min, quant_max, grad_factor);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___fake_quantize_learnable_per_tensor_affine_backward(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t quant_min, int64_t quant_max, double grad_factor) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA___fake_quantize_learnable_per_tensor_affine_backward", "grad");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fake_quantize_learnable_per_tensor_affine_backward", "self");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA___fake_quantize_learnable_per_tensor_affine_backward", "scale");
  c10::impl::check_and_update_common_device(common_device, zero_point, "wrapper_CUDA___fake_quantize_learnable_per_tensor_affine_backward", "zero_point");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fake_quantize_learnable_per_tensor_affine_backward(grad, self, scale, zero_point, quant_min, quant_max, grad_factor);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__fake_quantize_per_channel_affine_cachemask(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__fake_quantize_per_channel_affine_cachemask", "self");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA__fake_quantize_per_channel_affine_cachemask", "scale");
  c10::impl::check_and_update_common_device(common_device, zero_point, "wrapper_CUDA__fake_quantize_per_channel_affine_cachemask", "zero_point");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::fake_quantize_per_channel_affine_cachemask(self, scale, zero_point, axis, quant_min, quant_max);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___fake_quantize_learnable_per_channel_affine(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, double grad_factor) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fake_quantize_learnable_per_channel_affine", "self");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA___fake_quantize_learnable_per_channel_affine", "scale");
  c10::impl::check_and_update_common_device(common_device, zero_point, "wrapper_CUDA___fake_quantize_learnable_per_channel_affine", "zero_point");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fake_quantize_learnable_per_channel_affine(self, scale, zero_point, axis, quant_min, quant_max, grad_factor);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___fake_quantize_learnable_per_channel_affine_backward(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, double grad_factor) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA___fake_quantize_learnable_per_channel_affine_backward", "grad");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fake_quantize_learnable_per_channel_affine_backward", "self");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA___fake_quantize_learnable_per_channel_affine_backward", "scale");
  c10::impl::check_and_update_common_device(common_device, zero_point, "wrapper_CUDA___fake_quantize_learnable_per_channel_affine_backward", "zero_point");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fake_quantize_learnable_per_channel_affine_backward(grad, self, scale, zero_point, axis, quant_min, quant_max, grad_factor);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___fused_moving_avg_obs_fq_helper(const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, at::Tensor & running_min, at::Tensor & running_max, at::Tensor & scale, at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fused_moving_avg_obs_fq_helper", "self");
  c10::impl::check_and_update_common_device(common_device, observer_on, "wrapper_CUDA___fused_moving_avg_obs_fq_helper", "observer_on");
  c10::impl::check_and_update_common_device(common_device, fake_quant_on, "wrapper_CUDA___fused_moving_avg_obs_fq_helper", "fake_quant_on");
  c10::impl::check_and_update_common_device(common_device, running_min, "wrapper_CUDA___fused_moving_avg_obs_fq_helper", "running_min");
  c10::impl::check_and_update_common_device(common_device, running_max, "wrapper_CUDA___fused_moving_avg_obs_fq_helper", "running_max");
  c10::impl::check_and_update_common_device(common_device, scale, "wrapper_CUDA___fused_moving_avg_obs_fq_helper", "scale");
  c10::impl::check_and_update_common_device(common_device, zero_point, "wrapper_CUDA___fused_moving_avg_obs_fq_helper", "zero_point");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::fused_moving_avg_obs_fake_quant_cuda(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
}
} // anonymous namespace
namespace {
at::Scalar wrapper_CUDA___local_scalar_dense(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___local_scalar_dense", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_local_scalar_dense_cuda(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___thnn_fused_lstm_cell(const at::Tensor & input_gates, const at::Tensor & hidden_gates, const at::Tensor & cx, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input_gates, "wrapper_CUDA___thnn_fused_lstm_cell", "input_gates");
  c10::impl::check_and_update_common_device(common_device, hidden_gates, "wrapper_CUDA___thnn_fused_lstm_cell", "hidden_gates");
  c10::impl::check_and_update_common_device(common_device, cx, "wrapper_CUDA___thnn_fused_lstm_cell", "cx");
  c10::impl::check_and_update_common_device(common_device, input_bias, "wrapper_CUDA___thnn_fused_lstm_cell", "input_bias");
  c10::impl::check_and_update_common_device(common_device, hidden_bias, "wrapper_CUDA___thnn_fused_lstm_cell", "hidden_bias");
  const OptionalDeviceGuard device_guard(device_of(input_gates));
  return at::native::_thnn_fused_lstm_cell_cuda(input_gates, hidden_gates, cx, input_bias, hidden_bias);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___thnn_fused_lstm_cell_backward_impl(const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, const at::Tensor & cx, const at::Tensor & cy, const at::Tensor & workspace, bool has_bias) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_hy, "wrapper_CUDA___thnn_fused_lstm_cell_backward_impl", "grad_hy");
  c10::impl::check_and_update_common_device(common_device, grad_cy, "wrapper_CUDA___thnn_fused_lstm_cell_backward_impl", "grad_cy");
  c10::impl::check_and_update_common_device(common_device, cx, "wrapper_CUDA___thnn_fused_lstm_cell_backward_impl", "cx");
  c10::impl::check_and_update_common_device(common_device, cy, "wrapper_CUDA___thnn_fused_lstm_cell_backward_impl", "cy");
  c10::impl::check_and_update_common_device(common_device, workspace, "wrapper_CUDA___thnn_fused_lstm_cell_backward_impl", "workspace");
  const OptionalDeviceGuard device_guard(device_of(grad_hy));
  return at::native::_thnn_fused_lstm_cell_backward_impl_cuda(grad_hy, grad_cy, cx, cy, workspace, has_bias);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___thnn_fused_gru_cell(const at::Tensor & input_gates, const at::Tensor & hidden_gates, const at::Tensor & hx, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input_gates, "wrapper_CUDA___thnn_fused_gru_cell", "input_gates");
  c10::impl::check_and_update_common_device(common_device, hidden_gates, "wrapper_CUDA___thnn_fused_gru_cell", "hidden_gates");
  c10::impl::check_and_update_common_device(common_device, hx, "wrapper_CUDA___thnn_fused_gru_cell", "hx");
  c10::impl::check_and_update_common_device(common_device, input_bias, "wrapper_CUDA___thnn_fused_gru_cell", "input_bias");
  c10::impl::check_and_update_common_device(common_device, hidden_bias, "wrapper_CUDA___thnn_fused_gru_cell", "hidden_bias");
  const OptionalDeviceGuard device_guard(device_of(input_gates));
  return at::native::_thnn_fused_gru_cell_cuda(input_gates, hidden_gates, hx, input_bias, hidden_bias);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___thnn_fused_gru_cell_backward(const at::Tensor & grad_hy, const at::Tensor & workspace, bool has_bias) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_hy, "wrapper_CUDA___thnn_fused_gru_cell_backward", "grad_hy");
  c10::impl::check_and_update_common_device(common_device, workspace, "wrapper_CUDA___thnn_fused_gru_cell_backward", "workspace");
  const OptionalDeviceGuard device_guard(device_of(grad_hy));
  return at::native::_thnn_fused_gru_cell_backward_cuda(grad_hy, workspace, has_bias);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_source_Storage_set_(at::Tensor & self, at::Storage source) {
    // No device check
  // DeviceGuard omitted
  return at::native::set_(self, source);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_source_Storage_storage_offset_set_(at::Tensor & self, at::Storage source, c10::SymInt storage_offset, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
    // No device check
  // DeviceGuard omitted
  return at::native::set_storage_cuda_(self, source, storage_offset.guard_int(__FILE__, __LINE__), C10_AS_INTARRAYREF_SLOW(size), C10_AS_INTARRAYREF_SLOW(stride));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_source_Tensor_set_(at::Tensor & self, const at::Tensor & source) {
    // No device check
  // DeviceGuard omitted
  return at::native::set_tensor_(self, source);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__set_(at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__set_", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::set_cuda_(self);
}
} // anonymous namespace
namespace {
bool wrapper_CUDA__is_set_to(const at::Tensor & self, const at::Tensor & tensor) {
    // No device check
  // DeviceGuard omitted
  return at::native::is_set_to(self, tensor);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Scalar_masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::masked_fill__cuda(self, mask, value);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor_masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::masked_fill__cuda(self, mask, value);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__masked_scatter_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & source) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__masked_scatter_", "self");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA__masked_scatter_", "mask");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA__masked_scatter_", "source");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::masked_scatter__cuda(self, mask, source);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___masked_softmax(const at::Tensor & self, const at::Tensor & mask, c10::optional<int64_t> dim, c10::optional<int64_t> mask_type) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___masked_softmax", "self");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA___masked_softmax", "mask");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::masked_softmax_cuda(self, mask, dim, mask_type);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___masked_softmax_backward(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & mask, c10::optional<int64_t> dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA___masked_softmax_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA___masked_softmax_backward", "output");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA___masked_softmax_backward", "mask");
  const OptionalDeviceGuard device_guard(device_of(grad_output));
  return at::native::masked_softmax_backward_cuda(grad_output, output, mask, dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__view(const at::Tensor & self, c10::SymIntArrayRef size) {
    // No device check
  // DeviceGuard omitted
  return at::native::view(self, C10_AS_INTARRAYREF_SLOW(size));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__put_(at::Tensor & self, const at::Tensor & index, const at::Tensor & source, bool accumulate) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__put_", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA__put_", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA__put_", "source");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::put_(self, index, source, accumulate);
}
} // anonymous namespace
struct structured_index_add_cuda_out_functional final : public at::native::structured_index_add_cuda_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_index_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_index_add", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_index_add", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA_index_add", "source");
structured_index_add_cuda_out_functional op;
auto precompute = op.meta(self, dim, index, source, alpha);
(void)precompute;
op.impl(self, precompute.dim, index, source, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_index_add_cuda_out_out final : public at::native::structured_index_add_cuda_out {
    structured_index_add_cuda_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_index_add_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_index_add_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_index_add_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_index_add_out_out", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA_index_add_out_out", "source");
structured_index_add_cuda_out_out op(out);
auto precompute = op.meta(self, dim, index, source, alpha);
(void)precompute;
op.impl(self, precompute.dim, index, source, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_index_add_cuda_out_inplace final : public at::native::structured_index_add_cuda_out {
    structured_index_add_cuda_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_index_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_index_add_", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_index_add_", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA_index_add_", "source");
structured_index_add_cuda_out_inplace op(self);
auto precompute = op.meta(self, dim, index, source, alpha);
(void)precompute;
op.impl(self, precompute.dim, index, source, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_index_reduce_cuda_out_functional final : public at::native::structured_index_reduce_cuda_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_index_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_index_reduce", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_index_reduce", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA_index_reduce", "source");
structured_index_reduce_cuda_out_functional op;
auto precompute = op.meta(self, dim, index, source, reduce, include_self);
(void)precompute;
op.impl(self, precompute.dim, index, source, reduce, include_self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_index_reduce_cuda_out_out final : public at::native::structured_index_reduce_cuda_out {
    structured_index_reduce_cuda_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_index_reduce_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_index_reduce_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_index_reduce_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_index_reduce_out_out", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA_index_reduce_out_out", "source");
structured_index_reduce_cuda_out_out op(out);
auto precompute = op.meta(self, dim, index, source, reduce, include_self);
(void)precompute;
op.impl(self, precompute.dim, index, source, reduce, include_self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_index_reduce_cuda_out_inplace final : public at::native::structured_index_reduce_cuda_out {
    structured_index_reduce_cuda_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_index_reduce_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_index_reduce_", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_index_reduce_", "index");
  c10::impl::check_and_update_common_device(common_device, source, "wrapper_CUDA_index_reduce_", "source");
structured_index_reduce_cuda_out_inplace op(self);
auto precompute = op.meta(self, dim, index, source, reduce, include_self);
(void)precompute;
op.impl(self, precompute.dim, index, source, reduce, include_self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA_int_Scalar_index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::index_fill_(self, dim, index, value);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_int_Tensor_index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::index_fill_(self, dim, index, value);
}
} // anonymous namespace
struct structured_scatter_src_out_functional final : public at::native::structured_scatter_src_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_scatter_src(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_src", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_src", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_src", "src");
structured_scatter_src_out_functional op;
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_src_out_out final : public at::native::structured_scatter_src_out {
    structured_scatter_src_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter_out_src_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_scatter_out_src_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_out_src_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_out_src_out", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_out_src_out", "src");
structured_scatter_src_out_out op(out);
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_src_out_inplace final : public at::native::structured_scatter_src_out {
    structured_scatter_src_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter__src(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter__src", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter__src", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter__src", "src");
structured_scatter_src_out_inplace op(self);
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_value_out_functional final : public at::native::structured_scatter_value_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_scatter_value(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_value", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_value", "index");
structured_scatter_value_out_functional op;
op.meta(self, dim, index, value);
op.impl(self, dim, index, value, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_value_out_out final : public at::native::structured_scatter_value_out {
    structured_scatter_value_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter_out_value_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_scatter_out_value_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_out_value_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_out_value_out", "index");
structured_scatter_value_out_out op(out);
op.meta(self, dim, index, value);
op.impl(self, dim, index, value, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_value_out_inplace final : public at::native::structured_scatter_value_out {
    structured_scatter_value_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter__value(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter__value", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter__value", "index");
structured_scatter_value_out_inplace op(self);
op.meta(self, dim, index, value);
op.impl(self, dim, index, value, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_reduce_out_functional final : public at::native::structured_scatter_reduce_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_scatter_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_reduce", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_reduce", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_reduce", "src");
structured_scatter_reduce_out_functional op;
op.meta(self, dim, index, src, reduce);
op.impl(self, dim, index, src, reduce, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_reduce_out_out final : public at::native::structured_scatter_reduce_out {
    structured_scatter_reduce_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter_out_reduce_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_scatter_out_reduce_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_out_reduce_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_out_reduce_out", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_out_reduce_out", "src");
structured_scatter_reduce_out_out op(out);
op.meta(self, dim, index, src, reduce);
op.impl(self, dim, index, src, reduce, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_reduce_out_inplace final : public at::native::structured_scatter_reduce_out {
    structured_scatter_reduce_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter__reduce(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter__reduce", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter__reduce", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter__reduce", "src");
structured_scatter_reduce_out_inplace op(self);
op.meta(self, dim, index, src, reduce);
op.impl(self, dim, index, src, reduce, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_value_reduce_out_functional final : public at::native::structured_scatter_value_reduce_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_scatter_value_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_value_reduce", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_value_reduce", "index");
structured_scatter_value_reduce_out_functional op;
op.meta(self, dim, index, value, reduce);
op.impl(self, dim, index, value, reduce, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_value_reduce_out_out final : public at::native::structured_scatter_value_reduce_out {
    structured_scatter_value_reduce_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter_out_value_reduce_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_scatter_out_value_reduce_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_out_value_reduce_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_out_value_reduce_out", "index");
structured_scatter_value_reduce_out_out op(out);
op.meta(self, dim, index, value, reduce);
op.impl(self, dim, index, value, reduce, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_value_reduce_out_inplace final : public at::native::structured_scatter_value_reduce_out {
    structured_scatter_value_reduce_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter__value_reduce(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter__value_reduce", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter__value_reduce", "index");
structured_scatter_value_reduce_out_inplace op(self);
op.meta(self, dim, index, value, reduce);
op.impl(self, dim, index, value, reduce, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_add_functional final : public at::native::structured_scatter_add {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_scatter_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_add", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_add", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_add", "src");
structured_scatter_add_functional op;
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_add_out final : public at::native::structured_scatter_add {
    structured_scatter_add_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter_add_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_scatter_add_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_add_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_add_out_out", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_add_out_out", "src");
structured_scatter_add_out op(out);
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_add_inplace final : public at::native::structured_scatter_add {
    structured_scatter_add_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_add_", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_add_", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_add_", "src");
structured_scatter_add_inplace op(self);
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_reduce_two_functional final : public at::native::structured_scatter_reduce_two {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_scatter_reduce_two(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_reduce_two", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_reduce_two", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_reduce_two", "src");
structured_scatter_reduce_two_functional op;
op.meta(self, dim, index, src, reduce, include_self);
op.impl(self, dim, index, src, reduce, include_self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_reduce_two_out final : public at::native::structured_scatter_reduce_two {
    structured_scatter_reduce_two_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter_reduce_out_two_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_scatter_reduce_out_two_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_reduce_out_two_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_reduce_out_two_out", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_reduce_out_two_out", "src");
structured_scatter_reduce_two_out op(out);
op.meta(self, dim, index, src, reduce, include_self);
op.impl(self, dim, index, src, reduce, include_self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_reduce_two_inplace final : public at::native::structured_scatter_reduce_two {
    structured_scatter_reduce_two_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_scatter_reduce__two(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_scatter_reduce__two", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_scatter_reduce__two", "index");
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA_scatter_reduce__two", "src");
structured_scatter_reduce_two_inplace op(self);
op.meta(self, dim, index, src, reduce, include_self);
op.impl(self, dim, index, src, reduce, include_self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_eq_Scalar_out_functional final : public at::native::structured_eq_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_eq_Scalar(const at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_eq_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_eq_Scalar_out_out final : public at::native::structured_eq_Scalar_out {
    structured_eq_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_eq_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  // No device check
structured_eq_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_eq_Scalar_out_inplace final : public at::native::structured_eq_Scalar_out {
    structured_eq_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_eq__Scalar(at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_eq_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_eq_Tensor_out_functional final : public at::native::structured_eq_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_eq_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_eq_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_eq_Tensor_out_out final : public at::native::structured_eq_Tensor_out {
    structured_eq_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_eq_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_eq_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_eq_Tensor_out_inplace final : public at::native::structured_eq_Tensor_out {
    structured_eq_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_eq__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_eq_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_bitwise_and_out_functional final : public at::native::structured_bitwise_and_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_bitwise_and_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_and_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_and_out_out final : public at::native::structured_bitwise_and_out {
    structured_bitwise_and_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_and_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_bitwise_and_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_and_out_inplace final : public at::native::structured_bitwise_and_out {
    structured_bitwise_and_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_and__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_and_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_bitwise_or_out_functional final : public at::native::structured_bitwise_or_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_bitwise_or_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_or_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_or_out_out final : public at::native::structured_bitwise_or_out {
    structured_bitwise_or_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_or_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_bitwise_or_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_or_out_inplace final : public at::native::structured_bitwise_or_out {
    structured_bitwise_or_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_or__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_or_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_bitwise_xor_out_functional final : public at::native::structured_bitwise_xor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_bitwise_xor_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_xor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_xor_out_out final : public at::native::structured_bitwise_xor_out {
    structured_bitwise_xor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_xor_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_bitwise_xor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_xor_out_inplace final : public at::native::structured_bitwise_xor_out {
    structured_bitwise_xor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_xor__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_xor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA_Scalar___lshift__(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::__lshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Scalar___ilshift__(at::Tensor & self, const at::Scalar & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::__ilshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_Tensor___lshift__(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::__lshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor___ilshift__(at::Tensor & self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::__ilshift__(self, other);
}
} // anonymous namespace
struct structured_bitwise_left_shift_out_functional final : public at::native::structured_bitwise_left_shift_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_bitwise_left_shift_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_left_shift_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_left_shift_out_out final : public at::native::structured_bitwise_left_shift_out {
    structured_bitwise_left_shift_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_left_shift_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_bitwise_left_shift_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_left_shift_out_inplace final : public at::native::structured_bitwise_left_shift_out {
    structured_bitwise_left_shift_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_left_shift__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_left_shift_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA_Scalar___rshift__(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::__rshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Scalar___irshift__(at::Tensor & self, const at::Scalar & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::__irshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_Tensor___rshift__(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::__rshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor___irshift__(at::Tensor & self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::__irshift__(self, other);
}
} // anonymous namespace
struct structured_bitwise_right_shift_out_functional final : public at::native::structured_bitwise_right_shift_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_bitwise_right_shift_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_right_shift_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_right_shift_out_out final : public at::native::structured_bitwise_right_shift_out {
    structured_bitwise_right_shift_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_right_shift_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_bitwise_right_shift_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_right_shift_out_inplace final : public at::native::structured_bitwise_right_shift_out {
    structured_bitwise_right_shift_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_bitwise_right_shift__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_bitwise_right_shift_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_tril_cuda_functional final : public at::native::structured_tril_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_tril(const at::Tensor & self, int64_t diagonal) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_tril", "self");
structured_tril_cuda_functional op;
op.meta(self, diagonal);
op.impl(self, diagonal, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_tril_cuda_out final : public at::native::structured_tril_cuda {
    structured_tril_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_tril_out_out(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_tril_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_tril_out_out", "self");
structured_tril_cuda_out op(out);
op.meta(self, diagonal);
op.impl(self, diagonal, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_tril_cuda_inplace final : public at::native::structured_tril_cuda {
    structured_tril_cuda_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_tril_(at::Tensor & self, int64_t diagonal) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_tril_", "self");
structured_tril_cuda_inplace op(self);
op.meta(self, diagonal);
op.impl(self, diagonal, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_triu_cuda_functional final : public at::native::structured_triu_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_triu(const at::Tensor & self, int64_t diagonal) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_triu", "self");
structured_triu_cuda_functional op;
op.meta(self, diagonal);
op.impl(self, diagonal, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_triu_cuda_out final : public at::native::structured_triu_cuda {
    structured_triu_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_triu_out_out(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_triu_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_triu_out_out", "self");
structured_triu_cuda_out op(out);
op.meta(self, diagonal);
op.impl(self, diagonal, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_triu_cuda_inplace final : public at::native::structured_triu_cuda {
    structured_triu_cuda_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_triu_(at::Tensor & self, int64_t diagonal) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_triu_", "self");
structured_triu_cuda_inplace op(self);
op.meta(self, diagonal);
op.impl(self, diagonal, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_digamma_out_functional final : public at::native::structured_digamma_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_digamma(const at::Tensor & self) {
  // No device check
structured_digamma_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_digamma_out_out final : public at::native::structured_digamma_out {
    structured_digamma_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_digamma_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_digamma_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_digamma_out_inplace final : public at::native::structured_digamma_out {
    structured_digamma_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_digamma_(at::Tensor & self) {
  // No device check
structured_digamma_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lerp_Scalar_functional final : public at::native::structured_lerp_Scalar {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_lerp_Scalar(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
  // No device check
structured_lerp_Scalar_functional op;
op.meta(self, end, weight);
op.impl(self, end, weight, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lerp_Scalar_out final : public at::native::structured_lerp_Scalar {
    structured_lerp_Scalar_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lerp_out_Scalar_out(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight, at::Tensor & out) {
  // No device check
structured_lerp_Scalar_out op(out);
op.meta(self, end, weight);
op.impl(self, end, weight, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lerp_Scalar_inplace final : public at::native::structured_lerp_Scalar {
    structured_lerp_Scalar_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lerp__Scalar(at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
  // No device check
structured_lerp_Scalar_inplace op(self);
op.meta(self, end, weight);
op.impl(self, end, weight, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lerp_Tensor_functional final : public at::native::structured_lerp_Tensor {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_lerp_Tensor(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
  // No device check
structured_lerp_Tensor_functional op;
op.meta(self, end, weight);
op.impl(self, end, weight, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lerp_Tensor_out final : public at::native::structured_lerp_Tensor {
    structured_lerp_Tensor_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lerp_out_Tensor_out(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight, at::Tensor & out) {
  // No device check
structured_lerp_Tensor_out op(out);
op.meta(self, end, weight);
op.impl(self, end, weight, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lerp_Tensor_inplace final : public at::native::structured_lerp_Tensor {
    structured_lerp_Tensor_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lerp__Tensor(at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
  // No device check
structured_lerp_Tensor_inplace op(self);
op.meta(self, end, weight);
op.impl(self, end, weight, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__addbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__addbmm", "self");
  c10::impl::check_and_update_common_device(common_device, batch1, "wrapper_CUDA__addbmm", "batch1");
  c10::impl::check_and_update_common_device(common_device, batch2, "wrapper_CUDA__addbmm", "batch2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::addbmm(self, batch1, batch2, beta, alpha);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_addbmm_out(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_addbmm_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_addbmm_out", "self");
  c10::impl::check_and_update_common_device(common_device, batch1, "wrapper_CUDA_out_addbmm_out", "batch1");
  c10::impl::check_and_update_common_device(common_device, batch2, "wrapper_CUDA_out_addbmm_out", "batch2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::addbmm_out(self, batch1, batch2, beta, alpha, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__addbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__addbmm_", "self");
  c10::impl::check_and_update_common_device(common_device, batch1, "wrapper_CUDA__addbmm_", "batch1");
  c10::impl::check_and_update_common_device(common_device, batch2, "wrapper_CUDA__addbmm_", "batch2");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::addbmm_(self, batch1, batch2, beta, alpha);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_from_random_(at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::random_(self, from, to, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_to_random_(at::Tensor & self, int64_t to, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::random_(self, to, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__random_(at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::random_(self, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__uniform_(at::Tensor & self, double from, double to, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::uniform_(self, from, to, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__cauchy_(at::Tensor & self, double median, double sigma, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cauchy_(self, median, sigma, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__log_normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::log_normal_(self, mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__exponential_(at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::exponential_(self, lambd, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__geometric_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::geometric_(self, p, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__tril_indices(int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  globalContext().lazyInitCUDA();
  const DeviceGuard device_guard(device_or_default(device));
  return at::native::tril_indices_cuda(row, col, offset, dtype, layout, device, pin_memory);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__triu_indices(int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  globalContext().lazyInitCUDA();
  const DeviceGuard device_guard(device_or_default(device));
  return at::native::triu_indices_cuda(row, col, offset, dtype, layout, device, pin_memory);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__trace(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__trace", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::trace_cuda(self);
}
} // anonymous namespace
struct structured_ne_Scalar_out_functional final : public at::native::structured_ne_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_ne_Scalar(const at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_ne_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ne_Scalar_out_out final : public at::native::structured_ne_Scalar_out {
    structured_ne_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ne_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  // No device check
structured_ne_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ne_Scalar_out_inplace final : public at::native::structured_ne_Scalar_out {
    structured_ne_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ne__Scalar(at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_ne_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_ne_Tensor_out_functional final : public at::native::structured_ne_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_ne_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_ne_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ne_Tensor_out_out final : public at::native::structured_ne_Tensor_out {
    structured_ne_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ne_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_ne_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ne_Tensor_out_inplace final : public at::native::structured_ne_Tensor_out {
    structured_ne_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ne__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_ne_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_ge_Scalar_out_functional final : public at::native::structured_ge_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_ge_Scalar(const at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_ge_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ge_Scalar_out_out final : public at::native::structured_ge_Scalar_out {
    structured_ge_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ge_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  // No device check
structured_ge_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ge_Scalar_out_inplace final : public at::native::structured_ge_Scalar_out {
    structured_ge_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ge__Scalar(at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_ge_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_ge_Tensor_out_functional final : public at::native::structured_ge_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_ge_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_ge_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ge_Tensor_out_out final : public at::native::structured_ge_Tensor_out {
    structured_ge_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ge_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_ge_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ge_Tensor_out_inplace final : public at::native::structured_ge_Tensor_out {
    structured_ge_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_ge__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_ge_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_le_Scalar_out_functional final : public at::native::structured_le_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_le_Scalar(const at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_le_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_le_Scalar_out_out final : public at::native::structured_le_Scalar_out {
    structured_le_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_le_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  // No device check
structured_le_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_le_Scalar_out_inplace final : public at::native::structured_le_Scalar_out {
    structured_le_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_le__Scalar(at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_le_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_le_Tensor_out_functional final : public at::native::structured_le_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_le_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_le_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_le_Tensor_out_out final : public at::native::structured_le_Tensor_out {
    structured_le_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_le_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_le_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_le_Tensor_out_inplace final : public at::native::structured_le_Tensor_out {
    structured_le_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_le__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_le_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_gt_Scalar_out_functional final : public at::native::structured_gt_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_gt_Scalar(const at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_gt_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gt_Scalar_out_out final : public at::native::structured_gt_Scalar_out {
    structured_gt_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gt_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  // No device check
structured_gt_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_gt_Scalar_out_inplace final : public at::native::structured_gt_Scalar_out {
    structured_gt_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gt__Scalar(at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_gt_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_gt_Tensor_out_functional final : public at::native::structured_gt_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_gt_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_gt_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gt_Tensor_out_out final : public at::native::structured_gt_Tensor_out {
    structured_gt_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gt_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_gt_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_gt_Tensor_out_inplace final : public at::native::structured_gt_Tensor_out {
    structured_gt_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gt__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_gt_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lt_Scalar_out_functional final : public at::native::structured_lt_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_lt_Scalar(const at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_lt_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lt_Scalar_out_out final : public at::native::structured_lt_Scalar_out {
    structured_lt_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lt_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  // No device check
structured_lt_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lt_Scalar_out_inplace final : public at::native::structured_lt_Scalar_out {
    structured_lt_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lt__Scalar(at::Tensor & self, const at::Scalar & other) {
  // No device check
structured_lt_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lt_Tensor_out_functional final : public at::native::structured_lt_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_lt_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_lt_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lt_Tensor_out_out final : public at::native::structured_lt_Tensor_out {
    structured_lt_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lt_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_lt_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lt_Tensor_out_inplace final : public at::native::structured_lt_Tensor_out {
    structured_lt_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lt__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_lt_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__take(const at::Tensor & self, const at::Tensor & index) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__take", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA__take", "index");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::take(self, index);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_take_out(const at::Tensor & self, const at::Tensor & index, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_take_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_take_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_out_take_out", "index");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::take_out(self, index, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__index_select(const at::Tensor & self, int64_t dim, const at::Tensor & index) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__index_select", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA__index_select", "index");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::index_select_cuda(self, dim, index);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_index_select_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_index_select_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_index_select_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_out_index_select_out", "index");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::index_select_out_cuda(self, dim, index, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__masked_select(const at::Tensor & self, const at::Tensor & mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__masked_select", "self");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA__masked_select", "mask");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::masked_select_cuda(self, mask);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_masked_select_out(const at::Tensor & self, const at::Tensor & mask, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_masked_select_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_masked_select_out", "self");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA_out_masked_select_out", "mask");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::masked_select_out_cuda(self, mask, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__nonzero(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__nonzero", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nonzero_cuda(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_nonzero_out(const at::Tensor & self, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_nonzero_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_nonzero_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nonzero_out_cuda(self, out);
}
} // anonymous namespace
struct structured_gather_out_functional final : public at::native::structured_gather_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_gather(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_gather", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_gather", "index");
structured_gather_out_functional op;
op.meta(self, dim, index, sparse_grad);
op.impl(self, dim, index, sparse_grad, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gather_out_out final : public at::native::structured_gather_out {
    structured_gather_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_gather_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_gather_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_gather_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, index, "wrapper_CUDA_gather_out_out", "index");
structured_gather_out_out op(out);
op.meta(self, dim, index, sparse_grad);
op.impl(self, dim, index, sparse_grad, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addcmul_out_functional final : public at::native::structured_addcmul_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_addcmul(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
  // No device check
structured_addcmul_out_functional op;
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addcmul_out_out final : public at::native::structured_addcmul_out {
    structured_addcmul_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_addcmul_out_out(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
  // No device check
structured_addcmul_out_out op(out);
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addcmul_out_inplace final : public at::native::structured_addcmul_out {
    structured_addcmul_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_addcmul_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
  // No device check
structured_addcmul_out_inplace op(self);
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_addcdiv_out_functional final : public at::native::structured_addcdiv_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_addcdiv(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
  // No device check
structured_addcdiv_out_functional op;
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addcdiv_out_out final : public at::native::structured_addcdiv_out {
    structured_addcdiv_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_addcdiv_out_out(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
  // No device check
structured_addcdiv_out_out op(out);
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addcdiv_out_inplace final : public at::native::structured_addcdiv_out {
    structured_addcdiv_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_addcdiv_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
  // No device check
structured_addcdiv_out_inplace op(self);
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_triangular_solve_out_functional final : public at::native::structured_triangular_solve_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_triangular_solve(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_triangular_solve", "self");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_triangular_solve", "A");
structured_triangular_solve_out_functional op;
op.meta(self, A, upper, transpose, unitriangular);
op.impl(self, A, upper, transpose, unitriangular, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_triangular_solve_out_out final : public at::native::structured_triangular_solve_out {
    structured_triangular_solve_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_triangular_solve_out_X(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular, at::Tensor & X, at::Tensor & M) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, X, "wrapper_CUDA_triangular_solve_out_X", "X");
  c10::impl::check_and_update_common_device(common_device, M, "wrapper_CUDA_triangular_solve_out_X", "M");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_triangular_solve_out_X", "self");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_triangular_solve_out_X", "A");
structured_triangular_solve_out_out op(X, M);
op.meta(self, A, upper, transpose, unitriangular);
op.impl(self, A, upper, transpose, unitriangular, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(X, M);
}
namespace {
at::Tensor wrapper_CUDA__linalg_solve_triangular(const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__linalg_solve_triangular", "self");
  c10::impl::check_and_update_common_device(common_device, B, "wrapper_CUDA__linalg_solve_triangular", "B");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::linalg_solve_triangular(self, B, upper, left, unitriangular);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_linalg_solve_triangular_out(const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_linalg_solve_triangular_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_linalg_solve_triangular_out", "self");
  c10::impl::check_and_update_common_device(common_device, B, "wrapper_CUDA_out_linalg_solve_triangular_out", "B");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::linalg_solve_triangular_out(self, B, upper, left, unitriangular, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__cholesky(const at::Tensor & self, bool upper) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__cholesky", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cholesky(self, upper);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_cholesky_out(const at::Tensor & self, bool upper, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_cholesky_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_cholesky_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cholesky_out(self, upper, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___cholesky_solve_helper(const at::Tensor & self, const at::Tensor & A, bool upper) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___cholesky_solve_helper", "self");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA___cholesky_solve_helper", "A");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_cholesky_solve_helper_cuda(self, A, upper);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__cholesky_inverse(const at::Tensor & self, bool upper) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__cholesky_inverse", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cholesky_inverse(self, upper);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_cholesky_inverse_out(const at::Tensor & self, bool upper, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_cholesky_inverse_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_cholesky_inverse_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cholesky_inverse_out(self, upper, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__geqrf(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__geqrf", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::geqrf(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_a_geqrf_out(const at::Tensor & self, at::Tensor & a, at::Tensor & tau) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, a, "wrapper_CUDA_a_geqrf_out", "a");
  c10::impl::check_and_update_common_device(common_device, tau, "wrapper_CUDA_a_geqrf_out", "tau");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_a_geqrf_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::geqrf_out(self, a, tau);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__ormqr(const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__ormqr", "self");
  c10::impl::check_and_update_common_device(common_device, input2, "wrapper_CUDA__ormqr", "input2");
  c10::impl::check_and_update_common_device(common_device, input3, "wrapper_CUDA__ormqr", "input3");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::ormqr(self, input2, input3, left, transpose);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_ormqr_out(const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_ormqr_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_ormqr_out", "self");
  c10::impl::check_and_update_common_device(common_device, input2, "wrapper_CUDA_out_ormqr_out", "input2");
  c10::impl::check_and_update_common_device(common_device, input3, "wrapper_CUDA_out_ormqr_out", "input3");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::ormqr_out(self, input2, input3, left, transpose, out);
}
} // anonymous namespace
struct structured_lu_unpack_out_functional final : public at::native::structured_lu_unpack_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA_lu_unpack(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, LU_data, "wrapper_CUDA_lu_unpack", "LU_data");
  c10::impl::check_and_update_common_device(common_device, LU_pivots, "wrapper_CUDA_lu_unpack", "LU_pivots");
structured_lu_unpack_out_functional op;
op.meta(LU_data, LU_pivots, unpack_data, unpack_pivots);
op.impl(LU_data, LU_pivots, unpack_data, unpack_pivots, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured_lu_unpack_out_out final : public at::native::structured_lu_unpack_out {
    structured_lu_unpack_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA_lu_unpack_out_out(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, P, "wrapper_CUDA_lu_unpack_out_out", "P");
  c10::impl::check_and_update_common_device(common_device, L, "wrapper_CUDA_lu_unpack_out_out", "L");
  c10::impl::check_and_update_common_device(common_device, U, "wrapper_CUDA_lu_unpack_out_out", "U");
  c10::impl::check_and_update_common_device(common_device, LU_data, "wrapper_CUDA_lu_unpack_out_out", "LU_data");
  c10::impl::check_and_update_common_device(common_device, LU_pivots, "wrapper_CUDA_lu_unpack_out_out", "LU_pivots");
structured_lu_unpack_out_out op(P, L, U);
op.meta(LU_data, LU_pivots, unpack_data, unpack_pivots);
op.impl(LU_data, LU_pivots, unpack_data, unpack_pivots, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(P, L, U);
}
namespace {
at::Tensor wrapper_CUDA__multinomial(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__multinomial", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multinomial(self, num_samples, replacement, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_multinomial_out(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_multinomial_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_multinomial_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multinomial_out(self, num_samples, replacement, generator, out);
}
} // anonymous namespace
struct structured_lgamma_out_functional final : public at::native::structured_lgamma_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_lgamma(const at::Tensor & self) {
  // No device check
structured_lgamma_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lgamma_out_out final : public at::native::structured_lgamma_out {
    structured_lgamma_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lgamma_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_lgamma_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lgamma_out_inplace final : public at::native::structured_lgamma_out {
    structured_lgamma_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_lgamma_(at::Tensor & self) {
  // No device check
structured_lgamma_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_polygamma_out_functional final : public at::native::structured_polygamma_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_polygamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_polygamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_polygamma(int64_t n, const at::Tensor & self) {
  // No device check
structured_polygamma_out_functional op;
op.meta(n, self);
op.impl(n, self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_polygamma_out_out final : public at::native::structured_polygamma_out {
    structured_polygamma_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_polygamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_polygamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_polygamma_out_out(int64_t n, const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_polygamma_out_out op(out);
op.meta(n, self);
op.impl(n, self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_erfinv_out_functional final : public at::native::structured_erfinv_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_erfinv(const at::Tensor & self) {
  // No device check
structured_erfinv_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_erfinv_out_out final : public at::native::structured_erfinv_out {
    structured_erfinv_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_erfinv_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_erfinv_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_erfinv_out_inplace final : public at::native::structured_erfinv_out {
    structured_erfinv_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_erfinv_(at::Tensor & self) {
  // No device check
structured_erfinv_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_i0_out_functional final : public at::native::structured_i0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_i0(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_i0", "self");
structured_i0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_i0_out_out final : public at::native::structured_i0_out {
    structured_i0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_i0_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_i0_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_i0_out_out", "self");
structured_i0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_i0_out_inplace final : public at::native::structured_i0_out {
    structured_i0_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_i0_(at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_i0_", "self");
structured_i0_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_sign_out_functional final : public at::native::structured_sign_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sign(const at::Tensor & self) {
  // No device check
structured_sign_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sign_out_out final : public at::native::structured_sign_out {
    structured_sign_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sign_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_sign_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sign_out_inplace final : public at::native::structured_sign_out {
    structured_sign_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sign_(at::Tensor & self) {
  // No device check
structured_sign_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_signbit_out_functional final : public at::native::structured_signbit_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_signbit_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_signbit_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_signbit(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_signbit", "self");
structured_signbit_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_signbit_out_out final : public at::native::structured_signbit_out {
    structured_signbit_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_signbit_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_signbit_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_signbit_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_signbit_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_signbit_out_out", "self");
structured_signbit_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_atan2_out_functional final : public at::native::structured_atan2_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_atan2(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_atan2_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_atan2_out_out final : public at::native::structured_atan2_out {
    structured_atan2_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_atan2_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_atan2_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_atan2_out_inplace final : public at::native::structured_atan2_out {
    structured_atan2_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_atan2_(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_atan2_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__histc(const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__histc", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_histc_cuda(self, bins, min, max);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_histc_out(const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_histc_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_histc_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_histc_out_cuda(self, bins, min, max, out);
}
} // anonymous namespace
struct structured_fmod_out_functional final : public at::native::structured_fmod_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_fmod_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_fmod_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_fmod_out_out final : public at::native::structured_fmod_out {
    structured_fmod_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_fmod_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_fmod_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_fmod_out_inplace final : public at::native::structured_fmod_out {
    structured_fmod_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_fmod__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_fmod_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_hypot_out_functional final : public at::native::structured_hypot_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_hypot(const at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_hypot", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_hypot", "other");
structured_hypot_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hypot_out_out final : public at::native::structured_hypot_out {
    structured_hypot_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_hypot_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_hypot_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_hypot_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_hypot_out_out", "other");
structured_hypot_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_hypot_out_inplace final : public at::native::structured_hypot_out {
    structured_hypot_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_hypot_(at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_hypot_", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_hypot_", "other");
structured_hypot_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_igamma_out_functional final : public at::native::structured_igamma_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_igamma(const at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_igamma", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_igamma", "other");
structured_igamma_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_igamma_out_out final : public at::native::structured_igamma_out {
    structured_igamma_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_igamma_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_igamma_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_igamma_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_igamma_out_out", "other");
structured_igamma_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_igamma_out_inplace final : public at::native::structured_igamma_out {
    structured_igamma_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_igamma_(at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_igamma_", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_igamma_", "other");
structured_igamma_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_igammac_out_functional final : public at::native::structured_igammac_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_igammac(const at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_igammac", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_igammac", "other");
structured_igammac_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_igammac_out_out final : public at::native::structured_igammac_out {
    structured_igammac_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_igammac_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_igammac_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_igammac_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_igammac_out_out", "other");
structured_igammac_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_igammac_out_inplace final : public at::native::structured_igammac_out {
    structured_igammac_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_igammac_(at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_igammac_", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_igammac_", "other");
structured_igammac_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_nextafter_out_functional final : public at::native::structured_nextafter_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_nextafter(const at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_nextafter", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_nextafter", "other");
structured_nextafter_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_nextafter_out_out final : public at::native::structured_nextafter_out {
    structured_nextafter_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_nextafter_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_nextafter_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_nextafter_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_nextafter_out_out", "other");
structured_nextafter_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_nextafter_out_inplace final : public at::native::structured_nextafter_out {
    structured_nextafter_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_nextafter_(at::Tensor & self, const at::Tensor & other) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_nextafter_", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_nextafter_", "other");
structured_nextafter_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_remainder_out_functional final : public at::native::structured_remainder_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_remainder_Tensor(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_remainder_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_remainder_out_out final : public at::native::structured_remainder_out {
    structured_remainder_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_remainder_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_remainder_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_remainder_out_inplace final : public at::native::structured_remainder_out {
    structured_remainder_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_remainder__Tensor(at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_remainder_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA_Scalar_Tensor_remainder(const at::Scalar & self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(other));
  return at::native::remainder(self, other);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__min(const at::Tensor & self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::min(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_unary_out_min_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::min_unary_out(self, out);
}
} // anonymous namespace
struct structured_fmin_out_functional final : public at::native::structured_fmin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_fmin(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_fmin_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_fmin_out_out final : public at::native::structured_fmin_out {
    structured_fmin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_fmin_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_fmin_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA__max(const at::Tensor & self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_unary_out_max_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max_unary_out(self, out);
}
} // anonymous namespace
struct structured_fmax_out_functional final : public at::native::structured_fmax_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmax_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmax_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_fmax(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_fmax_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_fmax_out_out final : public at::native::structured_fmax_out {
    structured_fmax_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmax_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmax_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_fmax_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_fmax_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_maximum_out_functional final : public at::native::structured_maximum_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_maximum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_maximum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_maximum(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_maximum_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_maximum_out_out final : public at::native::structured_maximum_out {
    structured_maximum_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_maximum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_maximum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_maximum_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_maximum_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_minimum_out_functional final : public at::native::structured_minimum_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_minimum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_minimum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_minimum(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_minimum_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_minimum_out_out final : public at::native::structured_minimum_out {
    structured_minimum_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_minimum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_minimum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_minimum_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_minimum_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sort_stable_out_functional final : public at::native::structured_sort_stable_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_sort_stable(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_sort_stable", "self");
structured_sort_stable_out_functional op;
op.meta(self, stable, dim, descending);
op.impl(self, stable, dim, descending, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_sort_stable_out_out final : public at::native::structured_sort_stable_out {
    structured_sort_stable_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_sort_out_values_stable(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending, at::Tensor & values, at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, values, "wrapper_CUDA_sort_out_values_stable", "values");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_sort_out_values_stable", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_sort_out_values_stable", "self");
structured_sort_stable_out_out op(values, indices);
op.meta(self, stable, dim, descending);
op.impl(self, stable, dim, descending, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(values, indices);
}
namespace {
at::Tensor wrapper_CUDA_stable_argsort(const at::Tensor & self, bool stable, int64_t dim, bool descending) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::argsort_stable(self, stable, dim, descending);
}
} // anonymous namespace
struct structured_topk_out_cuda_functional final : public at::native::structured_topk_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_topk(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_topk", "self");
structured_topk_out_cuda_functional op;
op.meta(self, k, dim, largest, sorted);
op.impl(self, k, dim, largest, sorted, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_topk_out_cuda_out final : public at::native::structured_topk_out_cuda {
    structured_topk_out_cuda_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_topk_out_values(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted, at::Tensor & values, at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, values, "wrapper_CUDA_topk_out_values", "values");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_topk_out_values", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_topk_out_values", "self");
structured_topk_out_cuda_out op(values, indices);
op.meta(self, k, dim, largest, sorted);
op.impl(self, k, dim, largest, sorted, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(values, indices);
}
struct structured_all_all_out_functional final : public at::native::structured_all_all_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_all(const at::Tensor & self) {
  // No device check
structured_all_all_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_all_all_out_out final : public at::native::structured_all_all_out {
    structured_all_all_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_all_out_all_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_all_all_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_any_all_out_functional final : public at::native::structured_any_all_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_any(const at::Tensor & self) {
  // No device check
structured_any_all_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_any_all_out_out final : public at::native::structured_any_all_out {
    structured_any_all_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_any_out_all_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_any_all_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_renorm_out_functional final : public at::native::structured_renorm_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_renorm(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
  // No device check
structured_renorm_out_functional op;
op.meta(self, p, dim, maxnorm);
op.impl(self, p, dim, maxnorm, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_renorm_out_out final : public at::native::structured_renorm_out {
    structured_renorm_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_renorm_out_out(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm, at::Tensor & out) {
  // No device check
structured_renorm_out_out op(out);
op.meta(self, p, dim, maxnorm);
op.impl(self, p, dim, maxnorm, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_renorm_out_inplace final : public at::native::structured_renorm_out {
    structured_renorm_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_renorm_(at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
  // No device check
structured_renorm_out_inplace op(self);
op.meta(self, p, dim, maxnorm);
op.impl(self, p, dim, maxnorm, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CUDA__unfold(const at::Tensor & self, int64_t dimension, int64_t size, int64_t step) {
    // No device check
  // DeviceGuard omitted
  return at::native::unfold(self, dimension, size, step);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__unfold_backward(const at::Tensor & grad_in, c10::SymIntArrayRef input_sizes, int64_t dim, int64_t size, int64_t step) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_in, "wrapper_CUDA__unfold_backward", "grad_in");
  const OptionalDeviceGuard device_guard(device_of(grad_in));
  return at::native::unfold_backward(grad_in, C10_AS_INTARRAYREF_SLOW(input_sizes), dim, size, step);
}
} // anonymous namespace
namespace {
bool wrapper_CUDA__equal(const at::Tensor & self, const at::Tensor & other) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__equal", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA__equal", "other");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::cuda_equal(self, other);
}
} // anonymous namespace
struct structured_pow_Tensor_Tensor_out_functional final : public at::native::structured_pow_Tensor_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_pow_Tensor_Tensor(const at::Tensor & self, const at::Tensor & exponent) {
  // No device check
structured_pow_Tensor_Tensor_out_functional op;
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_pow_Tensor_Tensor_out_out final : public at::native::structured_pow_Tensor_Tensor_out {
    structured_pow_Tensor_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_pow_out_Tensor_Tensor_out(const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
  // No device check
structured_pow_Tensor_Tensor_out_out op(out);
op.meta(self, exponent);
op.impl(self, exponent, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_pow_Tensor_Tensor_out_inplace final : public at::native::structured_pow_Tensor_Tensor_out {
    structured_pow_Tensor_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_pow__Tensor(at::Tensor & self, const at::Tensor & exponent) {
  // No device check
structured_pow_Tensor_Tensor_out_inplace op(self);
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_pow_Scalar_out_functional final : public at::native::structured_pow_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_pow_Scalar(const at::Scalar & self, const at::Tensor & exponent) {
  // No device check
structured_pow_Scalar_out_functional op;
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_pow_Scalar_out_out final : public at::native::structured_pow_Scalar_out {
    structured_pow_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_pow_out_Scalar_out(const at::Scalar & self, const at::Tensor & exponent, at::Tensor & out) {
  // No device check
structured_pow_Scalar_out_out op(out);
op.meta(self, exponent);
op.impl(self, exponent, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_pow_Tensor_Scalar_out_functional final : public at::native::structured_pow_Tensor_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_pow_Tensor_Scalar(const at::Tensor & self, const at::Scalar & exponent) {
  // No device check
structured_pow_Tensor_Scalar_out_functional op;
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_pow_Tensor_Scalar_out_out final : public at::native::structured_pow_Tensor_Scalar_out {
    structured_pow_Tensor_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_pow_out_Tensor_Scalar_out(const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
  // No device check
structured_pow_Tensor_Scalar_out_out op(out);
op.meta(self, exponent);
op.impl(self, exponent, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_pow_Tensor_Scalar_out_inplace final : public at::native::structured_pow_Tensor_Scalar_out {
    structured_pow_Tensor_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_pow__Scalar(at::Tensor & self, const at::Scalar & exponent) {
  // No device check
structured_pow_Tensor_Scalar_out_inplace op(self);
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CUDA__normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::normal_(self, mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_Tensor_float_normal(const at::Tensor & mean, double std, c10::optional<at::Generator> generator) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA_Tensor_float_normal", "mean");
  const OptionalDeviceGuard device_guard(device_of(mean));
  return at::native::normal(mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor_float_out_normal_out(const at::Tensor & mean, double std, c10::optional<at::Generator> generator, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_Tensor_float_out_normal_out", "out");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA_Tensor_float_out_normal_out", "mean");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::normal_out(mean, std, generator, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_float_Tensor_normal(double mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, std, "wrapper_CUDA_float_Tensor_normal", "std");
  const OptionalDeviceGuard device_guard(device_of(std));
  return at::native::normal(mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_float_Tensor_out_normal_out(double mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_float_Tensor_out_normal_out", "out");
  c10::impl::check_and_update_common_device(common_device, std, "wrapper_CUDA_float_Tensor_out_normal_out", "std");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::normal_out(mean, std, generator, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_Tensor_Tensor_normal(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA_Tensor_Tensor_normal", "mean");
  c10::impl::check_and_update_common_device(common_device, std, "wrapper_CUDA_Tensor_Tensor_normal", "std");
  const OptionalDeviceGuard device_guard(device_of(mean));
  return at::native::normal(mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor_Tensor_out_normal_out(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_Tensor_Tensor_out_normal_out", "out");
  c10::impl::check_and_update_common_device(common_device, mean, "wrapper_CUDA_Tensor_Tensor_out_normal_out", "mean");
  c10::impl::check_and_update_common_device(common_device, std, "wrapper_CUDA_Tensor_Tensor_out_normal_out", "std");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::normal_out(mean, std, generator, out);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___amp_foreach_non_finite_check_and_unscale_(at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___amp_foreach_non_finite_check_and_unscale_", "self");
  c10::impl::check_and_update_common_device(common_device, found_inf, "wrapper_CUDA___amp_foreach_non_finite_check_and_unscale_", "found_inf");
  c10::impl::check_and_update_common_device(common_device, inv_scale, "wrapper_CUDA___amp_foreach_non_finite_check_and_unscale_", "inv_scale");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_amp_foreach_non_finite_check_and_unscale_cuda_(self, found_inf, inv_scale);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA___amp_update_scale_(at::Tensor & self, at::Tensor & growth_tracker, const at::Tensor & found_inf, double scale_growth_factor, double scale_backoff_factor, int64_t growth_interval) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___amp_update_scale_", "self");
  c10::impl::check_and_update_common_device(common_device, growth_tracker, "wrapper_CUDA___amp_update_scale_", "growth_tracker");
  c10::impl::check_and_update_common_device(common_device, found_inf, "wrapper_CUDA___amp_update_scale_", "found_inf");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_amp_update_scale_cuda_(self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_add(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_add_scalar_kernel_cuda(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_add_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_add_scalar_kernel_cuda_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_add(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_add_list_kernel_cuda(self, other, alpha);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_add_(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_add_list_kernel_cuda_(self, other, alpha);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_add(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_add_scalarlist_kernel_cuda(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_add_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_add_scalarlist_kernel_cuda_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Tensor__foreach_add(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_add_tensor_kernel_cuda(self, other, alpha);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Tensor__foreach_add_(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_add_tensor_kernel_cuda_(self, other, alpha);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_sub(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sub_scalar_kernel_cuda(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_sub_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sub_scalar_kernel_cuda_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_sub(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sub_list_kernel_cuda(self, other, alpha);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_sub_(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sub_list_kernel_cuda_(self, other, alpha);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_sub(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sub_scalarlist_kernel_cuda(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_sub_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sub_scalarlist_kernel_cuda_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_mul(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_mul_scalar_kernel_cuda(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_mul_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_mul_scalar_kernel_cuda_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_mul(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_mul_list_kernel_cuda(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_mul_(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_mul_list_kernel_cuda_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_mul(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_mul_scalarlist_kernel_cuda(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_mul_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_mul_scalarlist_kernel_cuda_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Tensor__foreach_mul(at::TensorList self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_mul_tensor_kernel_cuda(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Tensor__foreach_mul_(at::TensorList self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_mul_tensor_kernel_cuda_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_div(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_div_scalar_kernel_cuda(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_div_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_div_scalar_kernel_cuda_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_div(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_div_list_kernel_cuda(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_div_(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_div_list_kernel_cuda_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_div(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_div_scalarlist_kernel_cuda(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_div_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_div_scalarlist_kernel_cuda_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Tensor__foreach_div(at::TensorList self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_div_tensor_kernel_cuda(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Tensor__foreach_div_(at::TensorList self, const at::Tensor & other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_div_tensor_kernel_cuda_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_clamp_max(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_scalar_kernel_cuda(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_clamp_max_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_scalar_kernel_cuda_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_clamp_max(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_list_kernel_cuda(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_clamp_max_(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_list_kernel_cuda_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_clamp_max(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_scalarlist_kernel_cuda(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_clamp_max_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_scalarlist_kernel_cuda_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_clamp_min(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_scalar_kernel_cuda(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_clamp_min_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_scalar_kernel_cuda_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_clamp_min(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_list_kernel_cuda(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_clamp_min_(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_list_kernel_cuda_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_clamp_min(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_scalarlist_kernel_cuda(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_clamp_min_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_scalarlist_kernel_cuda_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_maximum(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_scalar_kernel_cuda(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_maximum_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_scalar_kernel_cuda_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_maximum(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_list_kernel_cuda(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_maximum_(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_list_kernel_cuda_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_maximum(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_scalarlist_kernel_cuda(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_maximum_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_min_scalarlist_kernel_cuda_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_minimum(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_scalar_kernel_cuda(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_minimum_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_scalar_kernel_cuda_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_minimum(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_list_kernel_cuda(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_minimum_(at::TensorList self, at::TensorList other) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_list_kernel_cuda_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_minimum(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_scalarlist_kernel_cuda(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_minimum_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_clamp_max_scalarlist_kernel_cuda_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcdiv_scalar_cuda(self, tensor1, tensor2, value);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcdiv_scalar_cuda_(self, tensor1, tensor2, value);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcdiv_scalarlist_cuda(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcdiv_scalarlist_cuda_(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Tensor__foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcdiv_tensor_cuda(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Tensor__foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcdiv_tensor_cuda_(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcmul_scalar_cuda(self, tensor1, tensor2, value);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcmul_scalar_cuda_(self, tensor1, tensor2, value);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcmul_scalarlist_cuda(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcmul_scalarlist_cuda_(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Tensor__foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcmul_tensor_cuda(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Tensor__foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_addcmul_tensor_cuda_(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_abs(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_abs_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_abs_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_abs_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_acos(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_acos_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_acos_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_acos_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_asin(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_asin_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_asin_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_asin_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_atan(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_atan_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_atan_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_atan_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_ceil(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_ceil_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_ceil_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_ceil_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_cos(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_cos_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_cos_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_cos_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_cosh(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_cosh_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_cosh_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_cosh_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_erf(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_erf_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_erf_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_erf_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_erfc(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_erfc_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_erfc_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_erfc_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_exp(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_exp_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_exp_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_exp_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_expm1(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_expm1_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_expm1_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_expm1_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_floor(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_floor_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_floor_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_floor_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_frac(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_frac_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_frac_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_frac_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_lerp(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_lerp_ternary_cuda(self, tensors1, weights);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_lerp_(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_lerp_ternary_cuda_(self, tensors1, weights);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_lerp(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_lerp_list_cuda(self, tensors1, weight);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_lerp_(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_lerp_list_cuda_(self, tensors1, weight);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_lgamma(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_lgamma_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_lgamma_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_lgamma_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_log(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_log_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_log_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_log_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_log10(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_log10_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_log10_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_log10_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_log1p(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_log1p_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_log1p_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_log1p_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_log2(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_log2_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_log2_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_log2_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_neg(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_neg_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_neg_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_neg_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_norm(at::TensorList self, const at::Scalar & ord) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_norm_cuda(self, ord);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_List__foreach_pow(at::TensorList self, at::TensorList exponent) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_pow_list_kernel_cuda(self, exponent);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_List__foreach_pow_(at::TensorList self, at::TensorList exponent) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_pow_list_kernel_cuda_(self, exponent);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_Scalar__foreach_pow(at::TensorList self, const at::Scalar & exponent) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_pow_scalar_kernel_cuda(self, exponent);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_Scalar__foreach_pow_(at::TensorList self, const at::Scalar & exponent) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_pow_scalar_kernel_cuda_(self, exponent);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarList__foreach_pow(at::TensorList self, at::ArrayRef<at::Scalar> exponent) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_pow_scalarlist_kernel_cuda(self, exponent);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_ScalarList__foreach_pow_(at::TensorList self, at::ArrayRef<at::Scalar> exponent) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_pow_scalarlist_kernel_cuda_(self, exponent);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA_ScalarAndTensor__foreach_pow(const at::Scalar & self, at::TensorList exponent) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(exponent));
  return at::native::foreach_scalar_pow_list_kernel_cuda(self, exponent);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_reciprocal(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_reciprocal_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_reciprocal_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_reciprocal_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_round(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_round_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_round_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_round_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_sigmoid(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sigmoid_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_sigmoid_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sigmoid_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_sign(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sign_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_sign_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sign_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_sin(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sin_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_sin_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sin_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_sinh(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sinh_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_sinh_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sinh_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_sqrt(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sqrt_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_sqrt_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_sqrt_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_tan(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_tan_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_tan_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_tan_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_tanh(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_tanh_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_tanh_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_tanh_cuda_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CUDA___foreach_trunc(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_trunc_cuda(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_trunc_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_trunc_cuda_(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_zero_(at::TensorList self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_zero_cuda_(self);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___foreach_copy_(at::TensorList self, at::TensorList src, bool non_blocking) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::foreach_tensor_copy_list_kernel_cuda_(self, src, non_blocking);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_Tensor_bucketize(const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_Tensor_bucketize", "self");
  c10::impl::check_and_update_common_device(common_device, boundaries, "wrapper_CUDA_Tensor_bucketize", "boundaries");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::bucketize_cuda(self, boundaries, out_int32, right);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor_out_bucketize_out(const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_Tensor_out_bucketize_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_Tensor_out_bucketize_out", "self");
  c10::impl::check_and_update_common_device(common_device, boundaries, "wrapper_CUDA_Tensor_out_bucketize_out", "boundaries");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::bucketize_out_cuda(self, boundaries, out_int32, right, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_Scalar_bucketize(const at::Scalar & self, const at::Tensor & boundaries, bool out_int32, bool right) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, boundaries, "wrapper_CUDA_Scalar_bucketize", "boundaries");
  const OptionalDeviceGuard device_guard(device_of(boundaries));
  return at::native::bucketize_cuda(self, boundaries, out_int32, right);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_Tensor_searchsorted(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, sorted_sequence, "wrapper_CUDA_Tensor_searchsorted", "sorted_sequence");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_Tensor_searchsorted", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::searchsorted_cuda(sorted_sequence, self, out_int32, right, side, sorter);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Tensor_out_searchsorted_out(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_Tensor_out_searchsorted_out", "out");
  c10::impl::check_and_update_common_device(common_device, sorted_sequence, "wrapper_CUDA_Tensor_out_searchsorted_out", "sorted_sequence");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_Tensor_out_searchsorted_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::searchsorted_out_cuda(sorted_sequence, self, out_int32, right, side, sorter, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA_Scalar_searchsorted(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, sorted_sequence, "wrapper_CUDA_Scalar_searchsorted", "sorted_sequence");
  const OptionalDeviceGuard device_guard(device_of(sorted_sequence));
  return at::native::searchsorted_cuda(sorted_sequence, self, out_int32, right, side, sorter);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_Scalar_out_searchsorted_out(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_Scalar_out_searchsorted_out", "out");
  c10::impl::check_and_update_common_device(common_device, sorted_sequence, "wrapper_CUDA_Scalar_out_searchsorted_out", "sorted_sequence");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::searchsorted_out_cuda(sorted_sequence, self, out_int32, right, side, sorter, out);
}
} // anonymous namespace
struct structured__convert_indices_from_coo_to_csr_structured_cuda_functional final : public at::native::structured__convert_indices_from_coo_to_csr_structured_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__convert_indices_from_coo_to_csr(const at::Tensor & self, int64_t size, bool out_int32) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__convert_indices_from_coo_to_csr", "self");
structured__convert_indices_from_coo_to_csr_structured_cuda_functional op;
op.meta(self, size, out_int32);
op.impl(self, size, out_int32, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__convert_indices_from_coo_to_csr_structured_cuda_out final : public at::native::structured__convert_indices_from_coo_to_csr_structured_cuda {
    structured__convert_indices_from_coo_to_csr_structured_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__convert_indices_from_coo_to_csr_out_out(const at::Tensor & self, int64_t size, bool out_int32, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__convert_indices_from_coo_to_csr_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__convert_indices_from_coo_to_csr_out_out", "self");
structured__convert_indices_from_coo_to_csr_structured_cuda_out op(out);
op.meta(self, size, out_int32);
op.impl(self, size, out_int32, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__convert_indices_from_csr_to_coo_structured_cuda_functional final : public at::native::structured__convert_indices_from_csr_to_coo_structured_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__convert_indices_from_csr_to_coo(const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, crow_indices, "wrapper_CUDA__convert_indices_from_csr_to_coo", "crow_indices");
  c10::impl::check_and_update_common_device(common_device, col_indices, "wrapper_CUDA__convert_indices_from_csr_to_coo", "col_indices");
structured__convert_indices_from_csr_to_coo_structured_cuda_functional op;
op.meta(crow_indices, col_indices, out_int32, transpose);
op.impl(crow_indices, col_indices, out_int32, transpose, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__convert_indices_from_csr_to_coo_structured_cuda_out final : public at::native::structured__convert_indices_from_csr_to_coo_structured_cuda {
    structured__convert_indices_from_csr_to_coo_structured_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__convert_indices_from_csr_to_coo_out_out(const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__convert_indices_from_csr_to_coo_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, crow_indices, "wrapper_CUDA__convert_indices_from_csr_to_coo_out_out", "crow_indices");
  c10::impl::check_and_update_common_device(common_device, col_indices, "wrapper_CUDA__convert_indices_from_csr_to_coo_out_out", "col_indices");
structured__convert_indices_from_csr_to_coo_structured_cuda_out op(out);
op.meta(crow_indices, col_indices, out_int32, transpose);
op.impl(crow_indices, col_indices, out_int32, transpose, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_mse_loss_out_functional final : public at::native::structured_mse_loss_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mse_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mse_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_mse_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
  // No device check
structured_mse_loss_out_functional op;
op.meta(self, target, reduction);
op.impl(self, target, reduction, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mse_loss_out_out final : public at::native::structured_mse_loss_out {
    structured_mse_loss_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mse_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mse_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_mse_loss_out_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & out) {
  // No device check
structured_mse_loss_out_out op(out);
op.meta(self, target, reduction);
op.impl(self, target, reduction, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA__mse_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__mse_loss_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__mse_loss_backward", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA__mse_loss_backward", "target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::mse_loss_backward(grad_output, self, target, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_mse_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_mse_loss_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_mse_loss_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_mse_loss_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_grad_input_mse_loss_backward_out", "target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::mse_loss_backward_out(grad_output, self, target, reduction, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__multi_margin_loss(const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__multi_margin_loss", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA__multi_margin_loss", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__multi_margin_loss", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multi_margin_loss_cuda(self, target, p, margin, weight, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_multi_margin_loss_out(const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_multi_margin_loss_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_multi_margin_loss_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_out_multi_margin_loss_out", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_out_multi_margin_loss_out", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multi_margin_loss_cuda_out(self, target, p, margin, weight, reduction, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__multi_margin_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__multi_margin_loss_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__multi_margin_loss_backward", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA__multi_margin_loss_backward", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__multi_margin_loss_backward", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multi_margin_loss_cuda_backward(grad_output, self, target, p, margin, weight, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_multi_margin_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_multi_margin_loss_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_multi_margin_loss_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_multi_margin_loss_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_grad_input_multi_margin_loss_backward_out", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_grad_input_multi_margin_loss_backward_out", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multi_margin_loss_cuda_backward_out(grad_output, self, target, p, margin, weight, reduction, grad_input);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__multilabel_margin_loss_forward(const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__multilabel_margin_loss_forward", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA__multilabel_margin_loss_forward", "target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multilabel_margin_loss_forward_cuda(self, target, reduction);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_output_multilabel_margin_loss_forward_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & output, at::Tensor & is_target) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_output_multilabel_margin_loss_forward_out", "output");
  c10::impl::check_and_update_common_device(common_device, is_target, "wrapper_CUDA_output_multilabel_margin_loss_forward_out", "is_target");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_output_multilabel_margin_loss_forward_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_output_multilabel_margin_loss_forward_out", "target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multilabel_margin_loss_forward_out_cuda(self, target, reduction, output, is_target);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__multilabel_margin_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__multilabel_margin_loss_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__multilabel_margin_loss_backward", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA__multilabel_margin_loss_backward", "target");
  c10::impl::check_and_update_common_device(common_device, is_target, "wrapper_CUDA__multilabel_margin_loss_backward", "is_target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multilabel_margin_loss_backward_cuda(grad_output, self, target, reduction, is_target);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_multilabel_margin_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_multilabel_margin_loss_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_multilabel_margin_loss_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_multilabel_margin_loss_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_grad_input_multilabel_margin_loss_backward_out", "target");
  c10::impl::check_and_update_common_device(common_device, is_target, "wrapper_CUDA_grad_input_multilabel_margin_loss_backward_out", "is_target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::multilabel_margin_loss_backward_cuda_out(grad_output, self, target, reduction, is_target, grad_input);
}
} // anonymous namespace
struct structured_nll_loss_forward_out_cuda_functional final : public at::native::structured_nll_loss_forward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_nll_loss_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_nll_loss_forward", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_nll_loss_forward", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_nll_loss_forward", "weight");
structured_nll_loss_forward_out_cuda_functional op;
op.meta(self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index);
op.impl(self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_nll_loss_forward_out_cuda_out final : public at::native::structured_nll_loss_forward_out_cuda {
    structured_nll_loss_forward_out_cuda_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_nll_loss_forward_out_output(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, at::Tensor & output, at::Tensor & total_weight) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_nll_loss_forward_out_output", "output");
  c10::impl::check_and_update_common_device(common_device, total_weight, "wrapper_CUDA_nll_loss_forward_out_output", "total_weight");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_nll_loss_forward_out_output", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_nll_loss_forward_out_output", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_nll_loss_forward_out_output", "weight");
structured_nll_loss_forward_out_cuda_out op(output, total_weight);
op.meta(self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index);
op.impl(self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(output, total_weight);
}
struct structured_nll_loss_backward_out_cuda_functional final : public at::native::structured_nll_loss_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_nll_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_nll_loss_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_nll_loss_backward", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_nll_loss_backward", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_nll_loss_backward", "weight");
  c10::impl::check_and_update_common_device(common_device, total_weight, "wrapper_CUDA_nll_loss_backward", "total_weight");
structured_nll_loss_backward_out_cuda_functional op;
op.meta(grad_output, self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, total_weight);
op.impl(grad_output, self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, total_weight, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_nll_loss_backward_out_cuda_out final : public at::native::structured_nll_loss_backward_out_cuda {
    structured_nll_loss_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_nll_loss_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_nll_loss_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_nll_loss_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_nll_loss_backward_out_grad_input", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_nll_loss_backward_out_grad_input", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_nll_loss_backward_out_grad_input", "weight");
  c10::impl::check_and_update_common_device(common_device, total_weight, "wrapper_CUDA_nll_loss_backward_out_grad_input", "total_weight");
structured_nll_loss_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, total_weight);
op.impl(grad_output, self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, total_weight, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__nll_loss2d_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__nll_loss2d_forward", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA__nll_loss2d_forward", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__nll_loss2d_forward", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nll_loss2d_forward_cuda(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_output_nll_loss2d_forward_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, at::Tensor & output, at::Tensor & total_weight) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_output_nll_loss2d_forward_out", "output");
  c10::impl::check_and_update_common_device(common_device, total_weight, "wrapper_CUDA_output_nll_loss2d_forward_out", "total_weight");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_output_nll_loss2d_forward_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_output_nll_loss2d_forward_out", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_output_nll_loss2d_forward_out", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nll_loss2d_forward_out_cuda(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), output, total_weight);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__nll_loss2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__nll_loss2d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__nll_loss2d_backward", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA__nll_loss2d_backward", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__nll_loss2d_backward", "weight");
  c10::impl::check_and_update_common_device(common_device, total_weight, "wrapper_CUDA__nll_loss2d_backward", "total_weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nll_loss2d_backward_cuda(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_nll_loss2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_nll_loss2d_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_nll_loss2d_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_nll_loss2d_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_grad_input_nll_loss2d_backward_out", "target");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_grad_input_nll_loss2d_backward_out", "weight");
  c10::impl::check_and_update_common_device(common_device, total_weight, "wrapper_CUDA_grad_input_nll_loss2d_backward_out", "total_weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::nll_loss2d_backward_out_cuda(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight, grad_input);
}
} // anonymous namespace
struct structured_smooth_l1_loss_out_functional final : public at::native::structured_smooth_l1_loss_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_smooth_l1_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_smooth_l1_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_smooth_l1_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
  // No device check
structured_smooth_l1_loss_out_functional op;
op.meta(self, target, reduction, beta);
op.impl(self, target, reduction, beta, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_smooth_l1_loss_out_out final : public at::native::structured_smooth_l1_loss_out {
    structured_smooth_l1_loss_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_smooth_l1_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_smooth_l1_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_smooth_l1_loss_out_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & out) {
  // No device check
structured_smooth_l1_loss_out_out op(out);
op.meta(self, target, reduction, beta);
op.impl(self, target, reduction, beta, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor & wrapper_CUDA_grad_input_smooth_l1_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_smooth_l1_loss_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_smooth_l1_loss_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_smooth_l1_loss_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_grad_input_smooth_l1_loss_backward_out", "target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::smooth_l1_loss_backward_out(grad_output, self, target, reduction, beta, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__huber_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__huber_loss", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA__huber_loss", "target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::huber_loss(self, target, reduction, delta);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_huber_loss_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_huber_loss_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_huber_loss_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_out_huber_loss_out", "target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::huber_loss_out(self, target, reduction, delta, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_huber_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_out_huber_loss_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_out_huber_loss_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_huber_loss_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, target, "wrapper_CUDA_out_huber_loss_backward_out", "target");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::huber_loss_backward_out(grad_output, self, target, reduction, delta, grad_input);
}
} // anonymous namespace
struct structured_elu_out_functional final : public at::native::structured_elu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_elu(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
  // No device check
structured_elu_out_functional op;
op.meta(self, alpha, scale, input_scale);
op.impl(self, alpha, scale, input_scale, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_elu_out_out final : public at::native::structured_elu_out {
    structured_elu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_elu_out_out(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, at::Tensor & out) {
  // No device check
structured_elu_out_out op(out);
op.meta(self, alpha, scale, input_scale);
op.impl(self, alpha, scale, input_scale, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_elu_out_inplace final : public at::native::structured_elu_out {
    structured_elu_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_elu_(at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
  // No device check
structured_elu_out_inplace op(self);
op.meta(self, alpha, scale, input_scale);
op.impl(self, alpha, scale, input_scale, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_elu_backward_out_functional final : public at::native::structured_elu_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_elu_backward(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_elu_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self_or_result, "wrapper_CUDA_elu_backward", "self_or_result");
structured_elu_backward_out_functional op;
op.meta(grad_output, alpha, scale, input_scale, is_result, self_or_result);
op.impl(grad_output, alpha, scale, input_scale, is_result, self_or_result, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_elu_backward_out_out final : public at::native::structured_elu_backward_out {
    structured_elu_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_elu_backward_out_grad_input(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_elu_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_elu_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self_or_result, "wrapper_CUDA_elu_backward_out_grad_input", "self_or_result");
structured_elu_backward_out_out op(grad_input);
op.meta(grad_output, alpha, scale, input_scale, is_result, self_or_result);
op.impl(grad_output, alpha, scale, input_scale, is_result, self_or_result, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_glu_out_functional final : public at::native::structured_glu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_glu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_glu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_glu(const at::Tensor & self, int64_t dim) {
  // No device check
structured_glu_out_functional op;
op.meta(self, dim);
op.impl(self, dim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_glu_out_out final : public at::native::structured_glu_out {
    structured_glu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_glu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_glu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_glu_out_out(const at::Tensor & self, int64_t dim, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_glu_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_glu_out_out", "self");
structured_glu_out_out op(out);
op.meta(self, dim);
op.impl(self, dim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA__glu_backward(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__glu_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__glu_backward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::glu_backward_cuda(grad_output, self, dim);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_glu_backward_out(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_glu_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_glu_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_glu_backward_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::glu_backward_cuda_out(grad_output, self, dim, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__glu_jvp(const at::Tensor & glu, const at::Tensor & x, const at::Tensor & dx, int64_t dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, glu, "wrapper_CUDA__glu_jvp", "glu");
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA__glu_jvp", "x");
  c10::impl::check_and_update_common_device(common_device, dx, "wrapper_CUDA__glu_jvp", "dx");
  const OptionalDeviceGuard device_guard(device_of(glu));
  return at::native::glu_jvp(glu, x, dx, dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__glu_backward_jvp(const at::Tensor & grad_x, const at::Tensor & grad_glu, const at::Tensor & x, const at::Tensor & dgrad_glu, const at::Tensor & dx, int64_t dim) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_x, "wrapper_CUDA__glu_backward_jvp", "grad_x");
  c10::impl::check_and_update_common_device(common_device, grad_glu, "wrapper_CUDA__glu_backward_jvp", "grad_glu");
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA__glu_backward_jvp", "x");
  c10::impl::check_and_update_common_device(common_device, dgrad_glu, "wrapper_CUDA__glu_backward_jvp", "dgrad_glu");
  c10::impl::check_and_update_common_device(common_device, dx, "wrapper_CUDA__glu_backward_jvp", "dx");
  const OptionalDeviceGuard device_guard(device_of(grad_x));
  return at::native::glu_backward_jvp(grad_x, grad_glu, x, dgrad_glu, dx, dim);
}
} // anonymous namespace
struct structured_hardsigmoid_out_functional final : public at::native::structured_hardsigmoid_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_hardsigmoid(const at::Tensor & self) {
  // No device check
structured_hardsigmoid_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hardsigmoid_out_out final : public at::native::structured_hardsigmoid_out {
    structured_hardsigmoid_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_hardsigmoid_out_out(const at::Tensor & self, at::Tensor & out) {
  // No device check
structured_hardsigmoid_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_hardsigmoid_out_inplace final : public at::native::structured_hardsigmoid_out {
    structured_hardsigmoid_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_hardsigmoid_(at::Tensor & self) {
  // No device check
structured_hardsigmoid_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_hardsigmoid_backward_out_functional final : public at::native::structured_hardsigmoid_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_hardsigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_hardsigmoid_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_hardsigmoid_backward", "self");
structured_hardsigmoid_backward_out_functional op;
op.meta(grad_output, self);
op.impl(grad_output, self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hardsigmoid_backward_out_out final : public at::native::structured_hardsigmoid_backward_out {
    structured_hardsigmoid_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_hardsigmoid_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_hardsigmoid_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_hardsigmoid_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_hardsigmoid_backward_out_grad_input", "self");
structured_hardsigmoid_backward_out_out op(grad_input);
op.meta(grad_output, self);
op.impl(grad_output, self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor wrapper_CUDA__hardtanh(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::hardtanh(self, min_val, max_val);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_hardtanh_out(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::hardtanh_out(self, min_val, max_val, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__hardtanh_(at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::hardtanh_(self, min_val, max_val);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__hardtanh_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__hardtanh_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__hardtanh_backward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::hardtanh_backward(grad_output, self, min_val, max_val);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_hardtanh_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_hardtanh_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_hardtanh_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_hardtanh_backward_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::hardtanh_backward_out(grad_output, self, min_val, max_val, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__hardswish(const at::Tensor & self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::hardswish(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_hardswish_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::hardswish_out(self, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__hardswish_(at::Tensor & self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::hardswish_(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__hardswish_backward(const at::Tensor & grad_output, const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__hardswish_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__hardswish_backward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::hardswish_backward(grad_output, self);
}
} // anonymous namespace
struct structured_leaky_relu_out_functional final : public at::native::structured_leaky_relu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_leaky_relu(const at::Tensor & self, const at::Scalar & negative_slope) {
  // No device check
structured_leaky_relu_out_functional op;
op.meta(self, negative_slope);
op.impl(self, negative_slope, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_leaky_relu_out_out final : public at::native::structured_leaky_relu_out {
    structured_leaky_relu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_leaky_relu_out_out(const at::Tensor & self, const at::Scalar & negative_slope, at::Tensor & out) {
  // No device check
structured_leaky_relu_out_out op(out);
op.meta(self, negative_slope);
op.impl(self, negative_slope, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_leaky_relu_out_inplace final : public at::native::structured_leaky_relu_out {
    structured_leaky_relu_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_leaky_relu_(at::Tensor & self, const at::Scalar & negative_slope) {
  // No device check
structured_leaky_relu_out_inplace op(self);
op.meta(self, negative_slope);
op.impl(self, negative_slope, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_leaky_relu_backward_out_functional final : public at::native::structured_leaky_relu_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_leaky_relu_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_leaky_relu_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_leaky_relu_backward", "self");
structured_leaky_relu_backward_out_functional op;
op.meta(grad_output, self, negative_slope, self_is_result);
op.impl(grad_output, self, negative_slope, self_is_result, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_leaky_relu_backward_out_out final : public at::native::structured_leaky_relu_backward_out {
    structured_leaky_relu_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_leaky_relu_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_leaky_relu_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_leaky_relu_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_leaky_relu_backward_out_grad_input", "self");
structured_leaky_relu_backward_out_out op(grad_input);
op.meta(grad_output, self, negative_slope, self_is_result);
op.impl(grad_output, self, negative_slope, self_is_result, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__log_sigmoid_forward(const at::Tensor & self) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::log_sigmoid_forward_cuda(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_output_log_sigmoid_forward_out(const at::Tensor & self, at::Tensor & output, at::Tensor & buffer) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::log_sigmoid_forward_out_cuda(self, output, buffer);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__log_sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__log_sigmoid_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__log_sigmoid_backward", "self");
  c10::impl::check_and_update_common_device(common_device, buffer, "wrapper_CUDA__log_sigmoid_backward", "buffer");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::log_sigmoid_backward_cuda(grad_output, self, buffer);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_log_sigmoid_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_log_sigmoid_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_log_sigmoid_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_log_sigmoid_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, buffer, "wrapper_CUDA_grad_input_log_sigmoid_backward_out", "buffer");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::log_sigmoid_backward_cuda_out(grad_output, self, buffer, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__rrelu_with_noise(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__rrelu_with_noise", "self");
  c10::impl::check_and_update_common_device(common_device, noise, "wrapper_CUDA__rrelu_with_noise", "noise");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::rrelu_with_noise_cuda(self, noise, lower, upper, training, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_rrelu_with_noise_out(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_rrelu_with_noise_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_rrelu_with_noise_out", "self");
  c10::impl::check_and_update_common_device(common_device, noise, "wrapper_CUDA_out_rrelu_with_noise_out", "noise");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::rrelu_with_noise_out_cuda(self, noise, lower, upper, training, generator, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA__rrelu_with_noise_(at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__rrelu_with_noise_", "self");
  c10::impl::check_and_update_common_device(common_device, noise, "wrapper_CUDA__rrelu_with_noise_", "noise");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::rrelu_with_noise_cuda_(self, noise, lower, upper, training, generator);
}
} // anonymous namespace
struct structured_softplus_out_functional final : public at::native::structured_softplus_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_softplus(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
  // No device check
structured_softplus_out_functional op;
op.meta(self, beta, threshold);
op.impl(self, beta, threshold, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softplus_out_out final : public at::native::structured_softplus_out {
    structured_softplus_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_softplus_out_out(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & out) {
  // No device check
structured_softplus_out_out op(out);
op.meta(self, beta, threshold);
op.impl(self, beta, threshold, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_softplus_backward_out_functional final : public at::native::structured_softplus_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_softplus_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_softplus_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_softplus_backward", "self");
structured_softplus_backward_out_functional op;
op.meta(grad_output, self, beta, threshold);
op.impl(grad_output, self, beta, threshold, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softplus_backward_out_out final : public at::native::structured_softplus_backward_out {
    structured_softplus_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_softplus_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_softplus_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_softplus_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_softplus_backward_out_grad_input", "self");
structured_softplus_backward_out_out op(grad_input);
op.meta(grad_output, self, beta, threshold);
op.impl(grad_output, self, beta, threshold, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_softshrink_out_functional final : public at::native::structured_softshrink_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_softshrink(const at::Tensor & self, const at::Scalar & lambd) {
  // No device check
structured_softshrink_out_functional op;
op.meta(self, lambd);
op.impl(self, lambd, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softshrink_out_out final : public at::native::structured_softshrink_out {
    structured_softshrink_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_softshrink_out_out(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
  // No device check
structured_softshrink_out_out op(out);
op.meta(self, lambd);
op.impl(self, lambd, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_softshrink_backward_out_functional final : public at::native::structured_softshrink_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_softshrink_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_softshrink_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_softshrink_backward", "self");
structured_softshrink_backward_out_functional op;
op.meta(grad_output, self, lambd);
op.impl(grad_output, self, lambd, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softshrink_backward_out_out final : public at::native::structured_softshrink_backward_out {
    structured_softshrink_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_softshrink_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_softshrink_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_softshrink_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_softshrink_backward_out_grad_input", "self");
structured_softshrink_backward_out_out op(grad_input);
op.meta(grad_output, self, lambd);
op.impl(grad_output, self, lambd, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor & wrapper_CUDA_out_adaptive_avg_pool2d_out(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_adaptive_avg_pool2d_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_adaptive_avg_pool2d_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::adaptive_avg_pool2d_out_cuda(self, C10_AS_INTARRAYREF_SLOW(output_size), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___adaptive_avg_pool2d(const at::Tensor & self, c10::SymIntArrayRef output_size) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___adaptive_avg_pool2d", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::adaptive_avg_pool2d_cuda(self, C10_AS_INTARRAYREF_SLOW(output_size));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___adaptive_avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA___adaptive_avg_pool2d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___adaptive_avg_pool2d_backward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::adaptive_avg_pool2d_backward_cuda(grad_output, self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_adaptive_avg_pool3d_out(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_adaptive_avg_pool3d_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_adaptive_avg_pool3d_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::adaptive_avg_pool3d_out_cuda(self, C10_AS_INTARRAYREF_SLOW(output_size), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___adaptive_avg_pool3d(const at::Tensor & self, c10::SymIntArrayRef output_size) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___adaptive_avg_pool3d", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::adaptive_avg_pool3d_cuda(self, C10_AS_INTARRAYREF_SLOW(output_size));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_adaptive_avg_pool3d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_adaptive_avg_pool3d_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_adaptive_avg_pool3d_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_adaptive_avg_pool3d_backward_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::adaptive_avg_pool3d_backward_out_cuda(grad_output, self, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___adaptive_avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA___adaptive_avg_pool3d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___adaptive_avg_pool3d_backward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::adaptive_avg_pool3d_backward_cuda(grad_output, self);
}
} // anonymous namespace
struct structured_adaptive_max_pool2d_out_cuda_functional final : public at::native::structured_adaptive_max_pool2d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_adaptive_max_pool2d(const at::Tensor & self, at::IntArrayRef output_size) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_adaptive_max_pool2d", "self");
structured_adaptive_max_pool2d_out_cuda_functional op;
op.meta(self, output_size);
op.impl(self, output_size, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_adaptive_max_pool2d_out_cuda_out final : public at::native::structured_adaptive_max_pool2d_out_cuda {
    structured_adaptive_max_pool2d_out_cuda_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_adaptive_max_pool2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out, at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_adaptive_max_pool2d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_adaptive_max_pool2d_out_out", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_adaptive_max_pool2d_out_out", "self");
structured_adaptive_max_pool2d_out_cuda_out op(out, indices);
op.meta(self, output_size);
op.impl(self, output_size, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(out, indices);
}
struct structured_adaptive_max_pool2d_backward_out_cuda_functional final : public at::native::structured_adaptive_max_pool2d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_adaptive_max_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_adaptive_max_pool2d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_adaptive_max_pool2d_backward", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_adaptive_max_pool2d_backward", "indices");
structured_adaptive_max_pool2d_backward_out_cuda_functional op;
op.meta(grad_output, self, indices);
op.impl(grad_output, self, indices, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_adaptive_max_pool2d_backward_out_cuda_out final : public at::native::structured_adaptive_max_pool2d_backward_out_cuda {
    structured_adaptive_max_pool2d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_adaptive_max_pool2d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_adaptive_max_pool2d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_adaptive_max_pool2d_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_adaptive_max_pool2d_backward_out_grad_input", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_adaptive_max_pool2d_backward_out_grad_input", "indices");
structured_adaptive_max_pool2d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, indices);
op.impl(grad_output, self, indices, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_adaptive_max_pool3d_out_cuda_functional final : public at::native::structured_adaptive_max_pool3d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_adaptive_max_pool3d(const at::Tensor & self, at::IntArrayRef output_size) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_adaptive_max_pool3d", "self");
structured_adaptive_max_pool3d_out_cuda_functional op;
op.meta(self, output_size);
op.impl(self, output_size, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_adaptive_max_pool3d_out_cuda_out final : public at::native::structured_adaptive_max_pool3d_out_cuda {
    structured_adaptive_max_pool3d_out_cuda_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_adaptive_max_pool3d_out_out(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out, at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_adaptive_max_pool3d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_adaptive_max_pool3d_out_out", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_adaptive_max_pool3d_out_out", "self");
structured_adaptive_max_pool3d_out_cuda_out op(out, indices);
op.meta(self, output_size);
op.impl(self, output_size, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(out, indices);
}
struct structured_adaptive_max_pool3d_backward_out_cuda_functional final : public at::native::structured_adaptive_max_pool3d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_adaptive_max_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_adaptive_max_pool3d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_adaptive_max_pool3d_backward", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_adaptive_max_pool3d_backward", "indices");
structured_adaptive_max_pool3d_backward_out_cuda_functional op;
op.meta(grad_output, self, indices);
op.impl(grad_output, self, indices, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_adaptive_max_pool3d_backward_out_cuda_out final : public at::native::structured_adaptive_max_pool3d_backward_out_cuda {
    structured_adaptive_max_pool3d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_adaptive_max_pool3d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_adaptive_max_pool3d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_adaptive_max_pool3d_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_adaptive_max_pool3d_backward_out_grad_input", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_adaptive_max_pool3d_backward_out_grad_input", "indices");
structured_adaptive_max_pool3d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, indices);
op.impl(grad_output, self, indices, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_avg_pool2d_out_cuda_functional final : public at::native::structured_avg_pool2d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_avg_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_avg_pool2d", "self");
structured_avg_pool2d_out_cuda_functional op;
auto precompute = op.meta(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
(void)precompute;
op.impl(self, precompute.kH, precompute.kW, precompute.dH, precompute.dW, precompute.padH, precompute.padW, ceil_mode, count_include_pad, divisor_override, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_avg_pool2d_out_cuda_out final : public at::native::structured_avg_pool2d_out_cuda {
    structured_avg_pool2d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_avg_pool2d_out_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_avg_pool2d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_avg_pool2d_out_out", "self");
structured_avg_pool2d_out_cuda_out op(out);
auto precompute = op.meta(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
(void)precompute;
op.impl(self, precompute.kH, precompute.kW, precompute.dH, precompute.dW, precompute.padH, precompute.padW, ceil_mode, count_include_pad, divisor_override, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_avg_pool2d_backward_out_cuda_functional final : public at::native::structured_avg_pool2d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_avg_pool2d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_avg_pool2d_backward", "self");
structured_avg_pool2d_backward_out_cuda_functional op;
op.meta(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_avg_pool2d_backward_out_cuda_out final : public at::native::structured_avg_pool2d_backward_out_cuda {
    structured_avg_pool2d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_avg_pool2d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_avg_pool2d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_avg_pool2d_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_avg_pool2d_backward_out_grad_input", "self");
structured_avg_pool2d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_avg_pool3d_out_cuda_functional final : public at::native::structured_avg_pool3d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_avg_pool3d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_avg_pool3d", "self");
structured_avg_pool3d_out_cuda_functional op;
op.meta(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_avg_pool3d_out_cuda_out final : public at::native::structured_avg_pool3d_out_cuda {
    structured_avg_pool3d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_avg_pool3d_out_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_avg_pool3d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_avg_pool3d_out_out", "self");
structured_avg_pool3d_out_cuda_out op(out);
op.meta(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_avg_pool3d_backward_out_cuda_functional final : public at::native::structured_avg_pool3d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_avg_pool3d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_avg_pool3d_backward", "self");
structured_avg_pool3d_backward_out_cuda_functional op;
op.meta(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_avg_pool3d_backward_out_cuda_out final : public at::native::structured_avg_pool3d_backward_out_cuda {
    structured_avg_pool3d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_avg_pool3d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_avg_pool3d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_avg_pool3d_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_avg_pool3d_backward_out_grad_input", "self");
structured_avg_pool3d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_fractional_max_pool2d_out_cuda_functional final : public at::native::structured_fractional_max_pool2d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_fractional_max_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_fractional_max_pool2d", "self");
  c10::impl::check_and_update_common_device(common_device, random_samples, "wrapper_CUDA_fractional_max_pool2d", "random_samples");
structured_fractional_max_pool2d_out_cuda_functional op;
op.meta(self, kernel_size, output_size, random_samples);
op.impl(self, kernel_size, output_size, random_samples, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_fractional_max_pool2d_out_cuda_out final : public at::native::structured_fractional_max_pool2d_out_cuda {
    structured_fractional_max_pool2d_out_cuda_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_fractional_max_pool2d_out_output(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples, at::Tensor & output, at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_fractional_max_pool2d_out_output", "output");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_fractional_max_pool2d_out_output", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_fractional_max_pool2d_out_output", "self");
  c10::impl::check_and_update_common_device(common_device, random_samples, "wrapper_CUDA_fractional_max_pool2d_out_output", "random_samples");
structured_fractional_max_pool2d_out_cuda_out op(output, indices);
op.meta(self, kernel_size, output_size, random_samples);
op.impl(self, kernel_size, output_size, random_samples, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(output, indices);
}
struct structured_fractional_max_pool2d_backward_cuda_functional final : public at::native::structured_fractional_max_pool2d_backward_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_fractional_max_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_fractional_max_pool2d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_fractional_max_pool2d_backward", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_fractional_max_pool2d_backward", "indices");
structured_fractional_max_pool2d_backward_cuda_functional op;
op.meta(grad_output, self, kernel_size, output_size, indices);
op.impl(grad_output, self, kernel_size, output_size, indices, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_fractional_max_pool2d_backward_cuda_out final : public at::native::structured_fractional_max_pool2d_backward_cuda {
    structured_fractional_max_pool2d_backward_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_fractional_max_pool2d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_fractional_max_pool2d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_fractional_max_pool2d_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_fractional_max_pool2d_backward_out_grad_input", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_fractional_max_pool2d_backward_out_grad_input", "indices");
structured_fractional_max_pool2d_backward_cuda_out op(grad_input);
op.meta(grad_output, self, kernel_size, output_size, indices);
op.impl(grad_output, self, kernel_size, output_size, indices, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_fractional_max_pool3d_out_cuda_functional final : public at::native::structured_fractional_max_pool3d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_fractional_max_pool3d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_fractional_max_pool3d", "self");
  c10::impl::check_and_update_common_device(common_device, random_samples, "wrapper_CUDA_fractional_max_pool3d", "random_samples");
structured_fractional_max_pool3d_out_cuda_functional op;
auto precompute = op.meta(self, kernel_size, output_size, random_samples);
(void)precompute;
op.impl(self, precompute.poolSizeT, precompute.poolSizeH, precompute.poolSizeW, precompute.outputT, precompute.outputH, precompute.outputW, random_samples, precompute.numBatch, precompute.numPlanes, precompute.inputT, precompute.inputH, precompute.inputW, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_fractional_max_pool3d_out_cuda_out final : public at::native::structured_fractional_max_pool3d_out_cuda {
    structured_fractional_max_pool3d_out_cuda_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_fractional_max_pool3d_out_output(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples, at::Tensor & output, at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_fractional_max_pool3d_out_output", "output");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_fractional_max_pool3d_out_output", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_fractional_max_pool3d_out_output", "self");
  c10::impl::check_and_update_common_device(common_device, random_samples, "wrapper_CUDA_fractional_max_pool3d_out_output", "random_samples");
structured_fractional_max_pool3d_out_cuda_out op(output, indices);
auto precompute = op.meta(self, kernel_size, output_size, random_samples);
(void)precompute;
op.impl(self, precompute.poolSizeT, precompute.poolSizeH, precompute.poolSizeW, precompute.outputT, precompute.outputH, precompute.outputW, random_samples, precompute.numBatch, precompute.numPlanes, precompute.inputT, precompute.inputH, precompute.inputW, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(output, indices);
}
namespace {
at::Tensor wrapper_CUDA__fractional_max_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__fractional_max_pool3d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__fractional_max_pool3d_backward", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA__fractional_max_pool3d_backward", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::fractional_max_pool3d_backward_cuda(grad_output, self, kernel_size, output_size, indices);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_fractional_max_pool3d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_fractional_max_pool3d_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_fractional_max_pool3d_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_fractional_max_pool3d_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_grad_input_fractional_max_pool3d_backward_out", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::fractional_max_pool3d_backward_out_cuda(grad_output, self, kernel_size, output_size, indices, grad_input);
}
} // anonymous namespace
struct structured_max_pool2d_with_indices_out_cuda_functional final : public at::native::structured_max_pool2d_with_indices_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_max_pool2d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_max_pool2d_with_indices", "self");
structured_max_pool2d_with_indices_out_cuda_functional op;
op.meta(self, kernel_size, stride, padding, dilation, ceil_mode);
op.impl(self, kernel_size, stride, padding, dilation, ceil_mode, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_max_pool2d_with_indices_out_cuda_out final : public at::native::structured_max_pool2d_with_indices_out_cuda {
    structured_max_pool2d_with_indices_out_cuda_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_max_pool2d_with_indices_out_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_max_pool2d_with_indices_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_max_pool2d_with_indices_out_out", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_max_pool2d_with_indices_out_out", "self");
structured_max_pool2d_with_indices_out_cuda_out op(out, indices);
op.meta(self, kernel_size, stride, padding, dilation, ceil_mode);
op.impl(self, kernel_size, stride, padding, dilation, ceil_mode, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(out, indices);
}
struct structured_max_pool2d_with_indices_backward_out_cuda_functional final : public at::native::structured_max_pool2d_with_indices_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_max_pool2d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_max_pool2d_with_indices_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_max_pool2d_with_indices_backward", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_max_pool2d_with_indices_backward", "indices");
structured_max_pool2d_with_indices_backward_out_cuda_functional op;
op.meta(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
op.impl(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_max_pool2d_with_indices_backward_out_cuda_out final : public at::native::structured_max_pool2d_with_indices_backward_out_cuda {
    structured_max_pool2d_with_indices_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_max_pool2d_with_indices_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_max_pool2d_with_indices_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_max_pool2d_with_indices_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_max_pool2d_with_indices_backward_out_grad_input", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_max_pool2d_with_indices_backward_out_grad_input", "indices");
structured_max_pool2d_with_indices_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
op.impl(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__max_pool3d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__max_pool3d_with_indices", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max_pool3d_with_indices_cuda(self, kernel_size, stride, padding, dilation, ceil_mode);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_out_max_pool3d_with_indices_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_max_pool3d_with_indices_out", "out");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_out_max_pool3d_with_indices_out", "indices");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_max_pool3d_with_indices_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max_pool3d_with_indices_out_cuda(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__max_pool3d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__max_pool3d_with_indices_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__max_pool3d_with_indices_backward", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA__max_pool3d_with_indices_backward", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max_pool3d_with_indices_backward_cuda(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_max_pool3d_with_indices_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_max_pool3d_with_indices_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_max_pool3d_with_indices_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_max_pool3d_with_indices_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_grad_input_max_pool3d_with_indices_backward_out", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max_pool3d_with_indices_backward_out_cuda(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__max_unpool2d(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__max_unpool2d", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA__max_unpool2d", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max_unpooling2d_forward_cuda(self, indices, C10_AS_INTARRAYREF_SLOW(output_size));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_max_unpool2d_out(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_max_unpool2d_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_max_unpool2d_out", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_out_max_unpool2d_out", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max_unpooling2d_forward_out_cuda(self, indices, C10_AS_INTARRAYREF_SLOW(output_size), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__max_unpool3d(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__max_unpool3d", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA__max_unpool3d", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max_unpooling3d_forward_cuda(self, indices, C10_AS_INTARRAYREF_SLOW(output_size), stride, padding);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_max_unpool3d_out(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_max_unpool3d_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_max_unpool3d_out", "self");
  c10::impl::check_and_update_common_device(common_device, indices, "wrapper_CUDA_out_max_unpool3d_out", "indices");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::max_unpooling3d_forward_out_cuda(self, indices, C10_AS_INTARRAYREF_SLOW(output_size), stride, padding, out);
}
} // anonymous namespace
struct structured_reflection_pad1d_out_cuda_functional final : public at::native::structured_reflection_pad1d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_reflection_pad1d(const at::Tensor & self, at::IntArrayRef padding) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_reflection_pad1d", "self");
structured_reflection_pad1d_out_cuda_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reflection_pad1d_out_cuda_out final : public at::native::structured_reflection_pad1d_out_cuda {
    structured_reflection_pad1d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_reflection_pad1d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_reflection_pad1d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_reflection_pad1d_out_out", "self");
structured_reflection_pad1d_out_cuda_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_reflection_pad1d_backward_out_cuda_functional final : public at::native::structured_reflection_pad1d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_reflection_pad1d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_reflection_pad1d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_reflection_pad1d_backward", "self");
structured_reflection_pad1d_backward_out_cuda_functional op;
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reflection_pad1d_backward_out_cuda_out final : public at::native::structured_reflection_pad1d_backward_out_cuda {
    structured_reflection_pad1d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_reflection_pad1d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_reflection_pad1d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_reflection_pad1d_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_reflection_pad1d_backward_out_grad_input", "self");
structured_reflection_pad1d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor wrapper_CUDA__reflection_pad2d(const at::Tensor & self, c10::SymIntArrayRef padding) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__reflection_pad2d", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::reflection_pad2d_cuda(self, C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_reflection_pad2d_out(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_reflection_pad2d_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_reflection_pad2d_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::reflection_pad2d_out_cuda(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__reflection_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__reflection_pad2d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__reflection_pad2d_backward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::reflection_pad2d_backward_cuda(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_reflection_pad2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_reflection_pad2d_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_reflection_pad2d_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_reflection_pad2d_backward_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::reflection_pad2d_backward_out_cuda(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
} // anonymous namespace
struct structured_reflection_pad3d_out_cuda_functional final : public at::native::structured_reflection_pad3d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_reflection_pad3d(const at::Tensor & self, at::IntArrayRef padding) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_reflection_pad3d", "self");
structured_reflection_pad3d_out_cuda_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reflection_pad3d_out_cuda_out final : public at::native::structured_reflection_pad3d_out_cuda {
    structured_reflection_pad3d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_reflection_pad3d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_reflection_pad3d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_reflection_pad3d_out_out", "self");
structured_reflection_pad3d_out_cuda_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_reflection_pad3d_backward_out_cuda_functional final : public at::native::structured_reflection_pad3d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_reflection_pad3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_reflection_pad3d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_reflection_pad3d_backward", "self");
structured_reflection_pad3d_backward_out_cuda_functional op;
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reflection_pad3d_backward_out_cuda_out final : public at::native::structured_reflection_pad3d_backward_out_cuda {
    structured_reflection_pad3d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_reflection_pad3d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_reflection_pad3d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_reflection_pad3d_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_reflection_pad3d_backward_out_grad_input", "self");
structured_reflection_pad3d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_replication_pad1d_out_cuda_functional final : public at::native::structured_replication_pad1d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_replication_pad1d(const at::Tensor & self, at::IntArrayRef padding) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_replication_pad1d", "self");
structured_replication_pad1d_out_cuda_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_replication_pad1d_out_cuda_out final : public at::native::structured_replication_pad1d_out_cuda {
    structured_replication_pad1d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_replication_pad1d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_replication_pad1d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_replication_pad1d_out_out", "self");
structured_replication_pad1d_out_cuda_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_replication_pad1d_backward_out_cuda_functional final : public at::native::structured_replication_pad1d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_replication_pad1d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_replication_pad1d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_replication_pad1d_backward", "self");
structured_replication_pad1d_backward_out_cuda_functional op;
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_replication_pad1d_backward_out_cuda_out final : public at::native::structured_replication_pad1d_backward_out_cuda {
    structured_replication_pad1d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_replication_pad1d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_replication_pad1d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_replication_pad1d_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_replication_pad1d_backward_out_grad_input", "self");
structured_replication_pad1d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_replication_pad2d_out_cuda_functional final : public at::native::structured_replication_pad2d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_replication_pad2d(const at::Tensor & self, at::IntArrayRef padding) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_replication_pad2d", "self");
structured_replication_pad2d_out_cuda_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_replication_pad2d_out_cuda_out final : public at::native::structured_replication_pad2d_out_cuda {
    structured_replication_pad2d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_replication_pad2d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_replication_pad2d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_replication_pad2d_out_out", "self");
structured_replication_pad2d_out_cuda_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA__replication_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__replication_pad2d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__replication_pad2d_backward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::replication_pad2d_backward_cuda(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_replication_pad2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_replication_pad2d_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_replication_pad2d_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_replication_pad2d_backward_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::replication_pad2d_backward_out_cuda(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
} // anonymous namespace
struct structured_replication_pad3d_out_cuda_functional final : public at::native::structured_replication_pad3d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_replication_pad3d(const at::Tensor & self, at::IntArrayRef padding) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_replication_pad3d", "self");
structured_replication_pad3d_out_cuda_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_replication_pad3d_out_cuda_out final : public at::native::structured_replication_pad3d_out_cuda {
    structured_replication_pad3d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_replication_pad3d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_replication_pad3d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_replication_pad3d_out_out", "self");
structured_replication_pad3d_out_cuda_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA__replication_pad3d_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__replication_pad3d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__replication_pad3d_backward", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::replication_pad3d_backward_cuda(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_grad_input_replication_pad3d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input_replication_pad3d_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input_replication_pad3d_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input_replication_pad3d_backward_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::replication_pad3d_backward_out_cuda(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
} // anonymous namespace
struct structured_upsample_linear1d_out_cuda_functional final : public at::native::structured_upsample_linear1d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_linear1d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_linear1d", "self");
structured_upsample_linear1d_out_cuda_functional op;
op.meta(self, output_size, align_corners, scales);
op.impl(self, output_size, align_corners, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_linear1d_out_cuda_out final : public at::native::structured_upsample_linear1d_out_cuda {
    structured_upsample_linear1d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_linear1d_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_upsample_linear1d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_linear1d_out_out", "self");
structured_upsample_linear1d_out_cuda_out op(out);
op.meta(self, output_size, align_corners, scales);
op.impl(self, output_size, align_corners, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_linear1d_backward_out_cuda_functional final : public at::native::structured_upsample_linear1d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_linear1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_linear1d_backward", "grad_output");
structured_upsample_linear1d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales);
op.impl(grad_output, output_size, input_size, align_corners, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_linear1d_backward_out_cuda_out final : public at::native::structured_upsample_linear1d_backward_out_cuda {
    structured_upsample_linear1d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_linear1d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_upsample_linear1d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_linear1d_backward_out_grad_input", "grad_output");
structured_upsample_linear1d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales);
op.impl(grad_output, output_size, input_size, align_corners, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_bilinear2d_out_cuda_functional final : public at::native::structured_upsample_bilinear2d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_bilinear2d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_bilinear2d", "self");
structured_upsample_bilinear2d_out_cuda_functional op;
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_bilinear2d_out_cuda_out final : public at::native::structured_upsample_bilinear2d_out_cuda {
    structured_upsample_bilinear2d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_bilinear2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_upsample_bilinear2d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_bilinear2d_out_out", "self");
structured_upsample_bilinear2d_out_cuda_out op(out);
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_bilinear2d_backward_out_cuda_functional final : public at::native::structured_upsample_bilinear2d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_bilinear2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_bilinear2d_backward", "grad_output");
structured_upsample_bilinear2d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_bilinear2d_backward_out_cuda_out final : public at::native::structured_upsample_bilinear2d_backward_out_cuda {
    structured_upsample_bilinear2d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_bilinear2d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_upsample_bilinear2d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_bilinear2d_backward_out_grad_input", "grad_output");
structured_upsample_bilinear2d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_bilinear2d_aa_out_cuda_functional final : public at::native::structured__upsample_bilinear2d_aa_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_bilinear2d_aa(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_bilinear2d_aa", "self");
structured__upsample_bilinear2d_aa_out_cuda_functional op;
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_bilinear2d_aa_out_cuda_out final : public at::native::structured__upsample_bilinear2d_aa_out_cuda {
    structured__upsample_bilinear2d_aa_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_bilinear2d_aa_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__upsample_bilinear2d_aa_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_bilinear2d_aa_out_out", "self");
structured__upsample_bilinear2d_aa_out_cuda_out op(out);
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_bilinear2d_aa_backward_out_cuda_functional final : public at::native::structured__upsample_bilinear2d_aa_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_bilinear2d_aa_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_bilinear2d_aa_backward", "grad_output");
structured__upsample_bilinear2d_aa_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_bilinear2d_aa_backward_out_cuda_out final : public at::native::structured__upsample_bilinear2d_aa_backward_out_cuda {
    structured__upsample_bilinear2d_aa_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_bilinear2d_aa_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA__upsample_bilinear2d_aa_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_bilinear2d_aa_backward_out_grad_input", "grad_output");
structured__upsample_bilinear2d_aa_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_bicubic2d_out_cuda_functional final : public at::native::structured_upsample_bicubic2d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_bicubic2d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_bicubic2d", "self");
structured_upsample_bicubic2d_out_cuda_functional op;
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_bicubic2d_out_cuda_out final : public at::native::structured_upsample_bicubic2d_out_cuda {
    structured_upsample_bicubic2d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_bicubic2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_upsample_bicubic2d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_bicubic2d_out_out", "self");
structured_upsample_bicubic2d_out_cuda_out op(out);
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_bicubic2d_backward_out_cuda_functional final : public at::native::structured_upsample_bicubic2d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_bicubic2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_bicubic2d_backward", "grad_output");
structured_upsample_bicubic2d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_bicubic2d_backward_out_cuda_out final : public at::native::structured_upsample_bicubic2d_backward_out_cuda {
    structured_upsample_bicubic2d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_bicubic2d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_upsample_bicubic2d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_bicubic2d_backward_out_grad_input", "grad_output");
structured_upsample_bicubic2d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_bicubic2d_aa_out_cuda_functional final : public at::native::structured__upsample_bicubic2d_aa_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_bicubic2d_aa(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_bicubic2d_aa", "self");
structured__upsample_bicubic2d_aa_out_cuda_functional op;
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_bicubic2d_aa_out_cuda_out final : public at::native::structured__upsample_bicubic2d_aa_out_cuda {
    structured__upsample_bicubic2d_aa_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_bicubic2d_aa_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__upsample_bicubic2d_aa_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_bicubic2d_aa_out_out", "self");
structured__upsample_bicubic2d_aa_out_cuda_out op(out);
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_bicubic2d_aa_backward_out_cuda_functional final : public at::native::structured__upsample_bicubic2d_aa_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_bicubic2d_aa_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_bicubic2d_aa_backward", "grad_output");
structured__upsample_bicubic2d_aa_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_bicubic2d_aa_backward_out_cuda_out final : public at::native::structured__upsample_bicubic2d_aa_backward_out_cuda {
    structured__upsample_bicubic2d_aa_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_bicubic2d_aa_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA__upsample_bicubic2d_aa_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_bicubic2d_aa_backward_out_grad_input", "grad_output");
structured__upsample_bicubic2d_aa_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_trilinear3d_out_cuda_functional final : public at::native::structured_upsample_trilinear3d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_trilinear3d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_trilinear3d", "self");
structured_upsample_trilinear3d_out_cuda_functional op;
op.meta(self, output_size, align_corners, scales_d, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_trilinear3d_out_cuda_out final : public at::native::structured_upsample_trilinear3d_out_cuda {
    structured_upsample_trilinear3d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_trilinear3d_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_upsample_trilinear3d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_trilinear3d_out_out", "self");
structured_upsample_trilinear3d_out_cuda_out op(out);
op.meta(self, output_size, align_corners, scales_d, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_trilinear3d_backward_out_cuda_functional final : public at::native::structured_upsample_trilinear3d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_trilinear3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_trilinear3d_backward", "grad_output");
structured_upsample_trilinear3d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_trilinear3d_backward_out_cuda_out final : public at::native::structured_upsample_trilinear3d_backward_out_cuda {
    structured_upsample_trilinear3d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_trilinear3d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_upsample_trilinear3d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_trilinear3d_backward_out_grad_input", "grad_output");
structured_upsample_trilinear3d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_nearest1d_out_cuda_functional final : public at::native::structured_upsample_nearest1d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_nearest1d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_nearest1d", "self");
structured_upsample_nearest1d_out_cuda_functional op;
op.meta(self, output_size, scales);
op.impl(self, output_size, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest1d_out_cuda_out final : public at::native::structured_upsample_nearest1d_out_cuda {
    structured_upsample_nearest1d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_nearest1d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_upsample_nearest1d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_nearest1d_out_out", "self");
structured_upsample_nearest1d_out_cuda_out op(out);
op.meta(self, output_size, scales);
op.impl(self, output_size, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_nearest_exact1d_out_cuda_functional final : public at::native::structured__upsample_nearest_exact1d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_nearest_exact1d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_nearest_exact1d", "self");
structured__upsample_nearest_exact1d_out_cuda_functional op;
op.meta(self, output_size, scales);
op.impl(self, output_size, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact1d_out_cuda_out final : public at::native::structured__upsample_nearest_exact1d_out_cuda {
    structured__upsample_nearest_exact1d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_nearest_exact1d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__upsample_nearest_exact1d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_nearest_exact1d_out_out", "self");
structured__upsample_nearest_exact1d_out_cuda_out op(out);
op.meta(self, output_size, scales);
op.impl(self, output_size, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_nearest1d_backward_out_cuda_functional final : public at::native::structured_upsample_nearest1d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_nearest1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_nearest1d_backward", "grad_output");
structured_upsample_nearest1d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, scales);
op.impl(grad_output, output_size, input_size, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest1d_backward_out_cuda_out final : public at::native::structured_upsample_nearest1d_backward_out_cuda {
    structured_upsample_nearest1d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_nearest1d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_upsample_nearest1d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_nearest1d_backward_out_grad_input", "grad_output");
structured_upsample_nearest1d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales);
op.impl(grad_output, output_size, input_size, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_nearest_exact1d_backward_out_cuda_functional final : public at::native::structured__upsample_nearest_exact1d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_nearest_exact1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_nearest_exact1d_backward", "grad_output");
structured__upsample_nearest_exact1d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, scales);
op.impl(grad_output, output_size, input_size, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact1d_backward_out_cuda_out final : public at::native::structured__upsample_nearest_exact1d_backward_out_cuda {
    structured__upsample_nearest_exact1d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_nearest_exact1d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA__upsample_nearest_exact1d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_nearest_exact1d_backward_out_grad_input", "grad_output");
structured__upsample_nearest_exact1d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales);
op.impl(grad_output, output_size, input_size, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_nearest2d_out_cuda_functional final : public at::native::structured_upsample_nearest2d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_nearest2d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_nearest2d", "self");
structured_upsample_nearest2d_out_cuda_functional op;
op.meta(self, output_size, scales_h, scales_w);
op.impl(self, output_size, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest2d_out_cuda_out final : public at::native::structured_upsample_nearest2d_out_cuda {
    structured_upsample_nearest2d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_nearest2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_upsample_nearest2d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_nearest2d_out_out", "self");
structured_upsample_nearest2d_out_cuda_out op(out);
op.meta(self, output_size, scales_h, scales_w);
op.impl(self, output_size, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_nearest_exact2d_out_cuda_functional final : public at::native::structured__upsample_nearest_exact2d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_nearest_exact2d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_nearest_exact2d", "self");
structured__upsample_nearest_exact2d_out_cuda_functional op;
op.meta(self, output_size, scales_h, scales_w);
op.impl(self, output_size, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact2d_out_cuda_out final : public at::native::structured__upsample_nearest_exact2d_out_cuda {
    structured__upsample_nearest_exact2d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_nearest_exact2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__upsample_nearest_exact2d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_nearest_exact2d_out_out", "self");
structured__upsample_nearest_exact2d_out_cuda_out op(out);
op.meta(self, output_size, scales_h, scales_w);
op.impl(self, output_size, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_nearest2d_backward_out_cuda_functional final : public at::native::structured_upsample_nearest2d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_nearest2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_nearest2d_backward", "grad_output");
structured_upsample_nearest2d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest2d_backward_out_cuda_out final : public at::native::structured_upsample_nearest2d_backward_out_cuda {
    structured_upsample_nearest2d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_nearest2d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_upsample_nearest2d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_nearest2d_backward_out_grad_input", "grad_output");
structured_upsample_nearest2d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_nearest_exact2d_backward_out_cuda_functional final : public at::native::structured__upsample_nearest_exact2d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_nearest_exact2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_nearest_exact2d_backward", "grad_output");
structured__upsample_nearest_exact2d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact2d_backward_out_cuda_out final : public at::native::structured__upsample_nearest_exact2d_backward_out_cuda {
    structured__upsample_nearest_exact2d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_nearest_exact2d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA__upsample_nearest_exact2d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_nearest_exact2d_backward_out_grad_input", "grad_output");
structured__upsample_nearest_exact2d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_nearest3d_out_cuda_functional final : public at::native::structured_upsample_nearest3d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_nearest3d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_nearest3d", "self");
structured_upsample_nearest3d_out_cuda_functional op;
op.meta(self, output_size, scales_d, scales_h, scales_w);
op.impl(self, output_size, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest3d_out_cuda_out final : public at::native::structured_upsample_nearest3d_out_cuda {
    structured_upsample_nearest3d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_nearest3d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_upsample_nearest3d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_upsample_nearest3d_out_out", "self");
structured_upsample_nearest3d_out_cuda_out op(out);
op.meta(self, output_size, scales_d, scales_h, scales_w);
op.impl(self, output_size, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_nearest_exact3d_out_cuda_functional final : public at::native::structured__upsample_nearest_exact3d_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_nearest_exact3d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_nearest_exact3d", "self");
structured__upsample_nearest_exact3d_out_cuda_functional op;
op.meta(self, output_size, scales_d, scales_h, scales_w);
op.impl(self, output_size, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact3d_out_cuda_out final : public at::native::structured__upsample_nearest_exact3d_out_cuda {
    structured__upsample_nearest_exact3d_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_nearest_exact3d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA__upsample_nearest_exact3d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__upsample_nearest_exact3d_out_out", "self");
structured__upsample_nearest_exact3d_out_cuda_out op(out);
op.meta(self, output_size, scales_d, scales_h, scales_w);
op.impl(self, output_size, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_nearest3d_backward_out_cuda_functional final : public at::native::structured_upsample_nearest3d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_upsample_nearest3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_nearest3d_backward", "grad_output");
structured_upsample_nearest3d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest3d_backward_out_cuda_out final : public at::native::structured_upsample_nearest3d_backward_out_cuda {
    structured_upsample_nearest3d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_upsample_nearest3d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_upsample_nearest3d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_upsample_nearest3d_backward_out_grad_input", "grad_output");
structured_upsample_nearest3d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_nearest_exact3d_backward_out_cuda_functional final : public at::native::structured__upsample_nearest_exact3d_backward_out_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA__upsample_nearest_exact3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_nearest_exact3d_backward", "grad_output");
structured__upsample_nearest_exact3d_backward_out_cuda_functional op;
op.meta(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact3d_backward_out_cuda_out final : public at::native::structured__upsample_nearest_exact3d_backward_out_cuda {
    structured__upsample_nearest_exact3d_backward_out_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA__upsample_nearest_exact3d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA__upsample_nearest_exact3d_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA__upsample_nearest_exact3d_backward_out_grad_input", "grad_output");
structured__upsample_nearest_exact3d_backward_out_cuda_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_sigmoid_backward_out_functional final : public at::native::structured_sigmoid_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & output) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_sigmoid_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_sigmoid_backward", "output");
structured_sigmoid_backward_out_functional op;
op.meta(grad_output, output);
op.impl(grad_output, output, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sigmoid_backward_out_out final : public at::native::structured_sigmoid_backward_out {
    structured_sigmoid_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_sigmoid_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_sigmoid_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_sigmoid_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_sigmoid_backward_out_grad_input", "output");
structured_sigmoid_backward_out_out op(grad_input);
op.meta(grad_output, output);
op.impl(grad_output, output, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_logit_backward_out_functional final : public at::native::structured_logit_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logit_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logit_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_logit_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_logit_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_logit_backward", "self");
structured_logit_backward_out_functional op;
op.meta(grad_output, self, eps);
op.impl(grad_output, self, eps, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_logit_backward_out_out final : public at::native::structured_logit_backward_out {
    structured_logit_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logit_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logit_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_logit_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_logit_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_logit_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_logit_backward_out_grad_input", "self");
structured_logit_backward_out_out op(grad_input);
op.meta(grad_output, self, eps);
op.impl(grad_output, self, eps, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_tanh_backward_out_functional final : public at::native::structured_tanh_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_tanh_backward(const at::Tensor & grad_output, const at::Tensor & output) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_tanh_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_tanh_backward", "output");
structured_tanh_backward_out_functional op;
op.meta(grad_output, output);
op.impl(grad_output, output, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_tanh_backward_out_out final : public at::native::structured_tanh_backward_out {
    structured_tanh_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_tanh_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_tanh_backward_out_grad_input", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_tanh_backward_out_grad_input", "grad_output");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_tanh_backward_out_grad_input", "output");
structured_tanh_backward_out_out op(grad_input);
op.meta(grad_output, output);
op.impl(grad_output, output, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_slow_conv_transpose2d_structured_cuda_functional final : public at::native::structured_slow_conv_transpose2d_structured_cuda {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_slow_conv_transpose2d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_slow_conv_transpose2d", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_slow_conv_transpose2d", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_slow_conv_transpose2d", "bias");
structured_slow_conv_transpose2d_structured_cuda_functional op;
op.meta(self, weight, kernel_size, ((bias.has_value() && (*bias).defined()) ? at::OptionalTensorRef(*bias) : at::OptionalTensorRef()), stride, padding, output_padding, dilation);
op.impl(self, weight, kernel_size, ((bias.has_value() && (*bias).defined()) ? at::OptionalTensorRef(*bias) : at::OptionalTensorRef()), stride, padding, output_padding, dilation, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_slow_conv_transpose2d_structured_cuda_out final : public at::native::structured_slow_conv_transpose2d_structured_cuda {
    structured_slow_conv_transpose2d_structured_cuda_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_slow_conv_transpose2d_out_out(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_slow_conv_transpose2d_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_slow_conv_transpose2d_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_slow_conv_transpose2d_out_out", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_slow_conv_transpose2d_out_out", "bias");
structured_slow_conv_transpose2d_structured_cuda_out op(out);
op.meta(self, weight, kernel_size, ((bias.has_value() && (*bias).defined()) ? at::OptionalTensorRef(*bias) : at::OptionalTensorRef()), stride, padding, output_padding, dilation);
op.impl(self, weight, kernel_size, ((bias.has_value() && (*bias).defined()) ? at::OptionalTensorRef(*bias) : at::OptionalTensorRef()), stride, padding, output_padding, dilation, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CUDA__slow_conv_transpose3d(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__slow_conv_transpose3d", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__slow_conv_transpose3d", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__slow_conv_transpose3d", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::slow_conv_transpose3d_cuda(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_slow_conv_transpose3d_out(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_slow_conv_transpose3d_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_slow_conv_transpose3d_out", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_out_slow_conv_transpose3d_out", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_out_slow_conv_transpose3d_out", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::slow_conv_transpose3d_out_cuda(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___slow_conv2d_forward(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___slow_conv2d_forward", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___slow_conv2d_forward", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA___slow_conv2d_forward", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::slow_conv2d_forward_cuda(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_output__slow_conv2d_forward_out(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA_output__slow_conv2d_forward_out", "output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_output__slow_conv2d_forward_out", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_output__slow_conv2d_forward_out", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_output__slow_conv2d_forward_out", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::slow_conv2d_forward_out_cuda(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), output);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA_grad_input__slow_conv2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_input, "wrapper_CUDA_grad_input__slow_conv2d_backward_out", "grad_input");
  c10::impl::check_and_update_common_device(common_device, grad_weight, "wrapper_CUDA_grad_input__slow_conv2d_backward_out", "grad_weight");
  c10::impl::check_and_update_common_device(common_device, grad_bias, "wrapper_CUDA_grad_input__slow_conv2d_backward_out", "grad_bias");
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_grad_input__slow_conv2d_backward_out", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_grad_input__slow_conv2d_backward_out", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_grad_input__slow_conv2d_backward_out", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::slow_conv2d_backward_out_cuda(grad_output, self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), grad_input, grad_weight, grad_bias);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA_output_mask__slow_conv2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, ::std::array<bool,3> output_mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad_output, "wrapper_CUDA_output_mask__slow_conv2d_backward", "grad_output");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_output_mask__slow_conv2d_backward", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_output_mask__slow_conv2d_backward", "weight");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::slow_conv2d_backward_cuda(grad_output, self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), output_mask);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___conv_depthwise2d(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___conv_depthwise2d", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA___conv_depthwise2d", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA___conv_depthwise2d", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::conv_depthwise2d_cuda(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
} // anonymous namespace
namespace {
const at::Tensor & wrapper_CUDA_out__conv_depthwise2d_out(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, const at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out__conv_depthwise2d_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out__conv_depthwise2d_out", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA_out__conv_depthwise2d_out", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA_out__conv_depthwise2d_out", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::conv_depthwise2d_cuda_out(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__conv_depthwise3d(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__conv_depthwise3d", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__conv_depthwise3d", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__conv_depthwise3d", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::conv_depthwise3d_cuda(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__slow_conv_dilated2d(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__slow_conv_dilated2d", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__slow_conv_dilated2d", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__slow_conv_dilated2d", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::slow_conv_dilated2d_cuda(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__slow_conv_dilated3d(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__slow_conv_dilated3d", "self");
  c10::impl::check_and_update_common_device(common_device, weight, "wrapper_CUDA__slow_conv_dilated3d", "weight");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA__slow_conv_dilated3d", "bias");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::slow_conv_dilated3d_cuda(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__col2im(const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__col2im", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::col2im_cuda(self, C10_AS_INTARRAYREF_SLOW(output_size), kernel_size, dilation, padding, stride);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_col2im_out(const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_col2im_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_col2im_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::col2im_out_cuda(self, C10_AS_INTARRAYREF_SLOW(output_size), kernel_size, dilation, padding, stride, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__im2col(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__im2col", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::im2col_cuda(self, kernel_size, dilation, padding, stride);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_im2col_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_im2col_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_im2col_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::im2col_out_cuda(self, kernel_size, dilation, padding, stride, out);
}
} // anonymous namespace
namespace {
void wrapper_CUDA__record_stream(at::Tensor & self, at::Stream s) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__record_stream", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::record_stream_cuda(self, s);
}
} // anonymous namespace
struct structured_isposinf_out_functional final : public at::native::structured_isposinf_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isposinf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isposinf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_isposinf(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_isposinf", "self");
structured_isposinf_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isposinf_out_out final : public at::native::structured_isposinf_out {
    structured_isposinf_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isposinf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isposinf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_isposinf_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_isposinf_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_isposinf_out_out", "self");
structured_isposinf_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_isneginf_out_functional final : public at::native::structured_isneginf_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isneginf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isneginf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_isneginf(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_isneginf", "self");
structured_isneginf_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isneginf_out_out final : public at::native::structured_isneginf_out {
    structured_isneginf_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isneginf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isneginf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_isneginf_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_isneginf_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_isneginf_out_out", "self");
structured_isneginf_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_entr_out_functional final : public at::native::structured_special_entr_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_entr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_entr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_entr(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_entr", "self");
structured_special_entr_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_entr_out_out final : public at::native::structured_special_entr_out {
    structured_special_entr_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_entr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_entr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_entr_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_entr_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_entr_out_out", "self");
structured_special_entr_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_ndtri_out_functional final : public at::native::structured_special_ndtri_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_ndtri_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_ndtri_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_ndtri(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_ndtri", "self");
structured_special_ndtri_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_ndtri_out_out final : public at::native::structured_special_ndtri_out {
    structured_special_ndtri_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_ndtri_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_ndtri_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_ndtri_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_ndtri_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_ndtri_out_out", "self");
structured_special_ndtri_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_log_ndtr_out_functional final : public at::native::structured_special_log_ndtr_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_log_ndtr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_log_ndtr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_log_ndtr(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_log_ndtr", "self");
structured_special_log_ndtr_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_log_ndtr_out_out final : public at::native::structured_special_log_ndtr_out {
    structured_special_log_ndtr_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_log_ndtr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_log_ndtr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_log_ndtr_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_log_ndtr_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_log_ndtr_out_out", "self");
structured_special_log_ndtr_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_erfcx_out_functional final : public at::native::structured_special_erfcx_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_erfcx_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_erfcx_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_erfcx(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_erfcx", "self");
structured_special_erfcx_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_erfcx_out_out final : public at::native::structured_special_erfcx_out {
    structured_special_erfcx_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_erfcx_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_erfcx_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_erfcx_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_erfcx_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_erfcx_out_out", "self");
structured_special_erfcx_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_xlog1py_out_functional final : public at::native::structured_special_xlog1py_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_xlog1py_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_xlog1py_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_xlog1py(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_special_xlog1py_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_xlog1py_out_out final : public at::native::structured_special_xlog1py_out {
    structured_special_xlog1py_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_xlog1py_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_xlog1py_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_xlog1py_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_special_xlog1py_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_zeta_out_functional final : public at::native::structured_special_zeta_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_zeta_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_zeta_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_zeta(const at::Tensor & self, const at::Tensor & other) {
  // No device check
structured_special_zeta_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_zeta_out_out final : public at::native::structured_special_zeta_out {
    structured_special_zeta_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_zeta_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_zeta_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_zeta_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  // No device check
structured_special_zeta_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_i0e_out_functional final : public at::native::structured_special_i0e_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i0e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i0e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_i0e(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_i0e", "self");
structured_special_i0e_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_i0e_out_out final : public at::native::structured_special_i0e_out {
    structured_special_i0e_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i0e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i0e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_i0e_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_i0e_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_i0e_out_out", "self");
structured_special_i0e_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_i1_out_functional final : public at::native::structured_special_i1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_i1(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_i1", "self");
structured_special_i1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_i1_out_out final : public at::native::structured_special_i1_out {
    structured_special_i1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_i1_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_i1_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_i1_out_out", "self");
structured_special_i1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_i1e_out_functional final : public at::native::structured_special_i1e_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_i1e(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_i1e", "self");
structured_special_i1e_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_i1e_out_out final : public at::native::structured_special_i1e_out {
    structured_special_i1e_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_i1e_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_i1e_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_i1e_out_out", "self");
structured_special_i1e_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_linalg_cholesky_ex_out_functional final : public at::native::structured_linalg_cholesky_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_linalg_cholesky_ex(const at::Tensor & self, bool upper, bool check_errors) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_linalg_cholesky_ex", "self");
structured_linalg_cholesky_ex_out_functional op;
op.meta(self, upper, check_errors);
op.impl(self, upper, check_errors, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_linalg_cholesky_ex_out_out final : public at::native::structured_linalg_cholesky_ex_out {
    structured_linalg_cholesky_ex_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_linalg_cholesky_ex_out_L(const at::Tensor & self, bool upper, bool check_errors, at::Tensor & L, at::Tensor & info) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, L, "wrapper_CUDA_linalg_cholesky_ex_out_L", "L");
  c10::impl::check_and_update_common_device(common_device, info, "wrapper_CUDA_linalg_cholesky_ex_out_L", "info");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_linalg_cholesky_ex_out_L", "self");
structured_linalg_cholesky_ex_out_out op(L, info);
op.meta(self, upper, check_errors);
op.impl(self, upper, check_errors, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(L, info);
}
struct structured_linalg_cross_out_functional final : public at::native::structured_linalg_cross_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_linalg_cross(const at::Tensor & self, const at::Tensor & other, int64_t dim) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_linalg_cross", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_linalg_cross", "other");
structured_linalg_cross_out_functional op;
op.meta(self, other, dim);
op.impl(self, other, dim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_linalg_cross_out_out final : public at::native::structured_linalg_cross_out {
    structured_linalg_cross_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_linalg_cross_out_out(const at::Tensor & self, const at::Tensor & other, int64_t dim, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_linalg_cross_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_linalg_cross_out_out", "self");
  c10::impl::check_and_update_common_device(common_device, other, "wrapper_CUDA_linalg_cross_out_out", "other");
structured_linalg_cross_out_out op(out);
op.meta(self, other, dim);
op.impl(self, other, dim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_linalg_lu_factor_ex_out_functional final : public at::native::structured_linalg_lu_factor_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA_linalg_lu_factor_ex(const at::Tensor & A, bool pivot, bool check_errors) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_linalg_lu_factor_ex", "A");
structured_linalg_lu_factor_ex_out_functional op;
op.meta(A, pivot, check_errors);
op.impl(A, pivot, check_errors, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured_linalg_lu_factor_ex_out_out final : public at::native::structured_linalg_lu_factor_ex_out {
    structured_linalg_lu_factor_ex_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA_linalg_lu_factor_ex_out_out(const at::Tensor & A, bool pivot, bool check_errors, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, LU, "wrapper_CUDA_linalg_lu_factor_ex_out_out", "LU");
  c10::impl::check_and_update_common_device(common_device, pivots, "wrapper_CUDA_linalg_lu_factor_ex_out_out", "pivots");
  c10::impl::check_and_update_common_device(common_device, info, "wrapper_CUDA_linalg_lu_factor_ex_out_out", "info");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_linalg_lu_factor_ex_out_out", "A");
structured_linalg_lu_factor_ex_out_out op(LU, pivots, info);
op.meta(A, pivot, check_errors);
op.impl(A, pivot, check_errors, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(LU, pivots, info);
}
struct structured_linalg_lu_out_functional final : public at::native::structured_linalg_lu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA_linalg_lu(const at::Tensor & A, bool pivot) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_linalg_lu", "A");
structured_linalg_lu_out_functional op;
op.meta(A, pivot);
op.impl(A, pivot, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured_linalg_lu_out_out final : public at::native::structured_linalg_lu_out {
    structured_linalg_lu_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA_linalg_lu_out_out(const at::Tensor & A, bool pivot, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, P, "wrapper_CUDA_linalg_lu_out_out", "P");
  c10::impl::check_and_update_common_device(common_device, L, "wrapper_CUDA_linalg_lu_out_out", "L");
  c10::impl::check_and_update_common_device(common_device, U, "wrapper_CUDA_linalg_lu_out_out", "U");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_linalg_lu_out_out", "A");
structured_linalg_lu_out_out op(P, L, U);
op.meta(A, pivot);
op.impl(A, pivot, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(P, L, U);
}
struct structured_linalg_lu_solve_out_functional final : public at::native::structured_linalg_lu_solve_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_linalg_lu_solve(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, LU, "wrapper_CUDA_linalg_lu_solve", "LU");
  c10::impl::check_and_update_common_device(common_device, pivots, "wrapper_CUDA_linalg_lu_solve", "pivots");
  c10::impl::check_and_update_common_device(common_device, B, "wrapper_CUDA_linalg_lu_solve", "B");
structured_linalg_lu_solve_out_functional op;
op.meta(LU, pivots, B, left, adjoint);
op.impl(LU, pivots, B, left, adjoint, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_linalg_lu_solve_out_out final : public at::native::structured_linalg_lu_solve_out {
    structured_linalg_lu_solve_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_linalg_lu_solve_out_out(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_linalg_lu_solve_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, LU, "wrapper_CUDA_linalg_lu_solve_out_out", "LU");
  c10::impl::check_and_update_common_device(common_device, pivots, "wrapper_CUDA_linalg_lu_solve_out_out", "pivots");
  c10::impl::check_and_update_common_device(common_device, B, "wrapper_CUDA_linalg_lu_solve_out_out", "B");
structured_linalg_lu_solve_out_out op(out);
op.meta(LU, pivots, B, left, adjoint);
op.impl(LU, pivots, B, left, adjoint, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__linalg_det_out_functional final : public at::native::structured__linalg_det_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__linalg_det(const at::Tensor & A) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_det", "A");
structured__linalg_det_out_functional op;
op.meta(A);
op.impl(A, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured__linalg_det_out_out final : public at::native::structured__linalg_det_out {
    structured__linalg_det_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA__linalg_det_out_result(const at::Tensor & A, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, result, "wrapper_CUDA__linalg_det_out_result", "result");
  c10::impl::check_and_update_common_device(common_device, LU, "wrapper_CUDA__linalg_det_out_result", "LU");
  c10::impl::check_and_update_common_device(common_device, pivots, "wrapper_CUDA__linalg_det_out_result", "pivots");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_det_out_result", "A");
structured__linalg_det_out_out op(result, LU, pivots);
op.meta(A);
op.impl(A, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(result, LU, pivots);
}
struct structured_linalg_ldl_factor_ex_out_functional final : public at::native::structured_linalg_ldl_factor_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA_linalg_ldl_factor_ex(const at::Tensor & self, bool hermitian, bool check_errors) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_linalg_ldl_factor_ex", "self");
structured_linalg_ldl_factor_ex_out_functional op;
op.meta(self, hermitian, check_errors);
op.impl(self, hermitian, check_errors, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured_linalg_ldl_factor_ex_out_out final : public at::native::structured_linalg_ldl_factor_ex_out {
    structured_linalg_ldl_factor_ex_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA_linalg_ldl_factor_ex_out_out(const at::Tensor & self, bool hermitian, bool check_errors, at::Tensor & LD, at::Tensor & pivots, at::Tensor & info) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, LD, "wrapper_CUDA_linalg_ldl_factor_ex_out_out", "LD");
  c10::impl::check_and_update_common_device(common_device, pivots, "wrapper_CUDA_linalg_ldl_factor_ex_out_out", "pivots");
  c10::impl::check_and_update_common_device(common_device, info, "wrapper_CUDA_linalg_ldl_factor_ex_out_out", "info");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_linalg_ldl_factor_ex_out_out", "self");
structured_linalg_ldl_factor_ex_out_out op(LD, pivots, info);
op.meta(self, hermitian, check_errors);
op.impl(self, hermitian, check_errors, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(LD, pivots, info);
}
struct structured_linalg_ldl_solve_out_functional final : public at::native::structured_linalg_ldl_solve_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_linalg_ldl_solve(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, LD, "wrapper_CUDA_linalg_ldl_solve", "LD");
  c10::impl::check_and_update_common_device(common_device, pivots, "wrapper_CUDA_linalg_ldl_solve", "pivots");
  c10::impl::check_and_update_common_device(common_device, B, "wrapper_CUDA_linalg_ldl_solve", "B");
structured_linalg_ldl_solve_out_functional op;
op.meta(LD, pivots, B, hermitian);
op.impl(LD, pivots, B, hermitian, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_linalg_ldl_solve_out_out final : public at::native::structured_linalg_ldl_solve_out {
    structured_linalg_ldl_solve_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_linalg_ldl_solve_out_out(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_linalg_ldl_solve_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, LD, "wrapper_CUDA_linalg_ldl_solve_out_out", "LD");
  c10::impl::check_and_update_common_device(common_device, pivots, "wrapper_CUDA_linalg_ldl_solve_out_out", "pivots");
  c10::impl::check_and_update_common_device(common_device, B, "wrapper_CUDA_linalg_ldl_solve_out_out", "B");
structured_linalg_ldl_solve_out_out op(out);
op.meta(LD, pivots, B, hermitian);
op.impl(LD, pivots, B, hermitian, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA_out_linalg_lstsq_out(const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver, at::Tensor & solution, at::Tensor & residuals, at::Tensor & rank, at::Tensor & singular_values) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, solution, "wrapper_CUDA_out_linalg_lstsq_out", "solution");
  c10::impl::check_and_update_common_device(common_device, residuals, "wrapper_CUDA_out_linalg_lstsq_out", "residuals");
  c10::impl::check_and_update_common_device(common_device, rank, "wrapper_CUDA_out_linalg_lstsq_out", "rank");
  c10::impl::check_and_update_common_device(common_device, singular_values, "wrapper_CUDA_out_linalg_lstsq_out", "singular_values");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_linalg_lstsq_out", "self");
  c10::impl::check_and_update_common_device(common_device, b, "wrapper_CUDA_out_linalg_lstsq_out", "b");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::linalg_lstsq_out(self, b, rcond, driver, solution, residuals, rank, singular_values);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA__linalg_matrix_exp(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__linalg_matrix_exp", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::linalg_matrix_exp(self);
}
} // anonymous namespace
struct structured__linalg_slogdet_out_functional final : public at::native::structured__linalg_slogdet_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 4> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__linalg_slogdet(const at::Tensor & A) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_slogdet", "A");
structured__linalg_slogdet_out_functional op;
op.meta(A);
op.impl(A, op.outputs_[0], op.outputs_[1], op.outputs_[2], op.outputs_[3]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]), std::move(op.outputs_[3]));
}
struct structured__linalg_slogdet_out_out final : public at::native::structured__linalg_slogdet_out {
    structured__linalg_slogdet_out_out(Tensor& out0, Tensor& out1, Tensor& out2, Tensor& out3) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2), std::ref(out3) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 4> outputs_;
    std::array<c10::optional<Tensor>, 4> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA__linalg_slogdet_out_sign(const at::Tensor & A, at::Tensor & sign, at::Tensor & logabsdet, at::Tensor & LU, at::Tensor & pivots) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, sign, "wrapper_CUDA__linalg_slogdet_out_sign", "sign");
  c10::impl::check_and_update_common_device(common_device, logabsdet, "wrapper_CUDA__linalg_slogdet_out_sign", "logabsdet");
  c10::impl::check_and_update_common_device(common_device, LU, "wrapper_CUDA__linalg_slogdet_out_sign", "LU");
  c10::impl::check_and_update_common_device(common_device, pivots, "wrapper_CUDA__linalg_slogdet_out_sign", "pivots");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_slogdet_out_sign", "A");
structured__linalg_slogdet_out_out op(sign, logabsdet, LU, pivots);
op.meta(A);
op.impl(A, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2), op.maybe_get_output(3));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
if (op.proxy_outputs_[3].has_value()) op.outputs_[3].get().copy_(*op.proxy_outputs_[3]);
return std::forward_as_tuple(sign, logabsdet, LU, pivots);
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__linalg_eig(const at::Tensor & self) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA__linalg_eig", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::linalg_eig(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_out_linalg_eig_out(const at::Tensor & self, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, eigenvalues, "wrapper_CUDA_out_linalg_eig_out", "eigenvalues");
  c10::impl::check_and_update_common_device(common_device, eigenvectors, "wrapper_CUDA_out_linalg_eig_out", "eigenvectors");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_out_linalg_eig_out", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::linalg_eig_out(self, eigenvalues, eigenvectors);
}
} // anonymous namespace
struct structured__linalg_eigh_out_functional final : public at::native::structured__linalg_eigh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA__linalg_eigh(const at::Tensor & A, c10::string_view UPLO, bool compute_v) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_eigh", "A");
structured__linalg_eigh_out_functional op;
op.meta(A, UPLO, compute_v);
op.impl(A, UPLO, compute_v, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured__linalg_eigh_out_out final : public at::native::structured__linalg_eigh_out {
    structured__linalg_eigh_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA__linalg_eigh_out_eigenvalues(const at::Tensor & A, c10::string_view UPLO, bool compute_v, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, eigenvalues, "wrapper_CUDA__linalg_eigh_out_eigenvalues", "eigenvalues");
  c10::impl::check_and_update_common_device(common_device, eigenvectors, "wrapper_CUDA__linalg_eigh_out_eigenvalues", "eigenvectors");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_eigh_out_eigenvalues", "A");
structured__linalg_eigh_out_out op(eigenvalues, eigenvectors);
op.meta(A, UPLO, compute_v);
op.impl(A, UPLO, compute_v, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(eigenvalues, eigenvectors);
}
namespace {
at::Tensor wrapper_CUDA__linalg_householder_product(const at::Tensor & input, const at::Tensor & tau) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA__linalg_householder_product", "input");
  c10::impl::check_and_update_common_device(common_device, tau, "wrapper_CUDA__linalg_householder_product", "tau");
  const OptionalDeviceGuard device_guard(device_of(input));
  return at::native::linalg_householder_product(input, tau);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA_out_linalg_householder_product_out(const at::Tensor & input, const at::Tensor & tau, at::Tensor & out) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_out_linalg_householder_product_out", "out");
  c10::impl::check_and_update_common_device(common_device, input, "wrapper_CUDA_out_linalg_householder_product_out", "input");
  c10::impl::check_and_update_common_device(common_device, tau, "wrapper_CUDA_out_linalg_householder_product_out", "tau");
  const OptionalDeviceGuard device_guard(device_of(out));
  return at::native::linalg_householder_product_out(input, tau, out);
}
} // anonymous namespace
struct structured_linalg_inv_ex_out_functional final : public at::native::structured_linalg_inv_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_linalg_inv_ex(const at::Tensor & A, bool check_errors) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_linalg_inv_ex", "A");
structured_linalg_inv_ex_out_functional op;
op.meta(A, check_errors);
op.impl(A, check_errors, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_linalg_inv_ex_out_out final : public at::native::structured_linalg_inv_ex_out {
    structured_linalg_inv_ex_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_linalg_inv_ex_out_inverse(const at::Tensor & A, bool check_errors, at::Tensor & inverse, at::Tensor & info) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, inverse, "wrapper_CUDA_linalg_inv_ex_out_inverse", "inverse");
  c10::impl::check_and_update_common_device(common_device, info, "wrapper_CUDA_linalg_inv_ex_out_inverse", "info");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_linalg_inv_ex_out_inverse", "A");
structured_linalg_inv_ex_out_out op(inverse, info);
op.meta(A, check_errors);
op.impl(A, check_errors, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(inverse, info);
}
struct structured_linalg_vector_norm_out_functional final : public at::native::structured_linalg_vector_norm_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_linalg_vector_norm(const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_linalg_vector_norm", "self");
structured_linalg_vector_norm_out_functional op;
op.meta(self, ord, dim, keepdim, dtype);
op.impl(self, ord, dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_linalg_vector_norm_out_out final : public at::native::structured_linalg_vector_norm_out {
    structured_linalg_vector_norm_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_linalg_vector_norm_out_out(const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_linalg_vector_norm_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_linalg_vector_norm_out_out", "self");
structured_linalg_vector_norm_out_out op(out);
op.meta(self, ord, dim, keepdim, dtype);
op.impl(self, ord, dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__linalg_svd_out_functional final : public at::native::structured__linalg_svd_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__linalg_svd(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_svd", "A");
structured__linalg_svd_out_functional op;
op.meta(A, full_matrices, compute_uv, driver);
op.impl(A, full_matrices, compute_uv, driver, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured__linalg_svd_out_out final : public at::native::structured__linalg_svd_out {
    structured__linalg_svd_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA__linalg_svd_out_U(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver, at::Tensor & U, at::Tensor & S, at::Tensor & Vh) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, U, "wrapper_CUDA__linalg_svd_out_U", "U");
  c10::impl::check_and_update_common_device(common_device, S, "wrapper_CUDA__linalg_svd_out_U", "S");
  c10::impl::check_and_update_common_device(common_device, Vh, "wrapper_CUDA__linalg_svd_out_U", "Vh");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_svd_out_U", "A");
structured__linalg_svd_out_out op(U, S, Vh);
op.meta(A, full_matrices, compute_uv, driver);
op.impl(A, full_matrices, compute_uv, driver, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(U, S, Vh);
}
struct structured__linalg_solve_ex_out_functional final : public at::native::structured__linalg_solve_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 4> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA__linalg_solve_ex(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_solve_ex", "A");
  c10::impl::check_and_update_common_device(common_device, B, "wrapper_CUDA__linalg_solve_ex", "B");
structured__linalg_solve_ex_out_functional op;
op.meta(A, B, left, check_errors);
op.impl(A, B, left, check_errors, op.outputs_[0], op.outputs_[1], op.outputs_[2], op.outputs_[3]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]), std::move(op.outputs_[3]));
}
struct structured__linalg_solve_ex_out_out final : public at::native::structured__linalg_solve_ex_out {
    structured__linalg_solve_ex_out_out(Tensor& out0, Tensor& out1, Tensor& out2, Tensor& out3) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2), std::ref(out3) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 4> outputs_;
    std::array<c10::optional<Tensor>, 4> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CUDA__linalg_solve_ex_out_result(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, result, "wrapper_CUDA__linalg_solve_ex_out_result", "result");
  c10::impl::check_and_update_common_device(common_device, LU, "wrapper_CUDA__linalg_solve_ex_out_result", "LU");
  c10::impl::check_and_update_common_device(common_device, pivots, "wrapper_CUDA__linalg_solve_ex_out_result", "pivots");
  c10::impl::check_and_update_common_device(common_device, info, "wrapper_CUDA__linalg_solve_ex_out_result", "info");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA__linalg_solve_ex_out_result", "A");
  c10::impl::check_and_update_common_device(common_device, B, "wrapper_CUDA__linalg_solve_ex_out_result", "B");
structured__linalg_solve_ex_out_out op(result, LU, pivots, info);
op.meta(A, B, left, check_errors);
op.impl(A, B, left, check_errors, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2), op.maybe_get_output(3));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
if (op.proxy_outputs_[3].has_value()) op.outputs_[3].get().copy_(*op.proxy_outputs_[3]);
return std::forward_as_tuple(result, LU, pivots, info);
}
struct structured_linalg_qr_out_functional final : public at::native::structured_linalg_qr_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA_linalg_qr(const at::Tensor & A, c10::string_view mode) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_linalg_qr", "A");
structured_linalg_qr_out_functional op;
op.meta(A, mode);
op.impl(A, mode, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_linalg_qr_out_out final : public at::native::structured_linalg_qr_out {
    structured_linalg_qr_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CUDA_linalg_qr_out_out(const at::Tensor & A, c10::string_view mode, at::Tensor & Q, at::Tensor & R) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, Q, "wrapper_CUDA_linalg_qr_out_out", "Q");
  c10::impl::check_and_update_common_device(common_device, R, "wrapper_CUDA_linalg_qr_out_out", "R");
  c10::impl::check_and_update_common_device(common_device, A, "wrapper_CUDA_linalg_qr_out_out", "A");
structured_linalg_qr_out_out op(Q, R);
op.meta(A, mode);
op.impl(A, mode, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(Q, R);
}
namespace {
at::Tensor wrapper_CUDA__segment_reduce(const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & indices, const c10::optional<at::Tensor> & offsets, int64_t axis, bool unsafe, const c10::optional<at::Scalar> & initial) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, data, "wrapper_CUDA__segment_reduce", "data");
  const OptionalDeviceGuard device_guard(device_of(data));
  return at::native::segment_reduce_kernel(data, reduce, lengths, indices, offsets, axis, unsafe, initial);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___segment_reduce_backward(const at::Tensor & grad, const at::Tensor & output, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & offsets, int64_t axis, const c10::optional<at::Scalar> & initial) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, grad, "wrapper_CUDA___segment_reduce_backward", "grad");
  c10::impl::check_and_update_common_device(common_device, output, "wrapper_CUDA___segment_reduce_backward", "output");
  c10::impl::check_and_update_common_device(common_device, data, "wrapper_CUDA___segment_reduce_backward", "data");
  const OptionalDeviceGuard device_guard(device_of(grad));
  return at::native::_segment_reduce_backward_kernel(grad, output, data, reduce, lengths, offsets, axis, initial);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___transformer_encoder_layer_fwd(const at::Tensor & src, int64_t embed_dim, int64_t num_heads, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, bool use_gelu, bool norm_first, double eps, const at::Tensor & norm_weight_1, const at::Tensor & norm_bias_1, const at::Tensor & norm_weight_2, const at::Tensor & norm_bias_2, const at::Tensor & ffn_weight_1, const at::Tensor & ffn_bias_1, const at::Tensor & ffn_weight_2, const at::Tensor & ffn_bias_2, const c10::optional<at::Tensor> & mask, c10::optional<int64_t> mask_type) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, src, "wrapper_CUDA___transformer_encoder_layer_fwd", "src");
  c10::impl::check_and_update_common_device(common_device, qkv_weight, "wrapper_CUDA___transformer_encoder_layer_fwd", "qkv_weight");
  c10::impl::check_and_update_common_device(common_device, qkv_bias, "wrapper_CUDA___transformer_encoder_layer_fwd", "qkv_bias");
  c10::impl::check_and_update_common_device(common_device, proj_weight, "wrapper_CUDA___transformer_encoder_layer_fwd", "proj_weight");
  c10::impl::check_and_update_common_device(common_device, proj_bias, "wrapper_CUDA___transformer_encoder_layer_fwd", "proj_bias");
  c10::impl::check_and_update_common_device(common_device, norm_weight_1, "wrapper_CUDA___transformer_encoder_layer_fwd", "norm_weight_1");
  c10::impl::check_and_update_common_device(common_device, norm_bias_1, "wrapper_CUDA___transformer_encoder_layer_fwd", "norm_bias_1");
  c10::impl::check_and_update_common_device(common_device, norm_weight_2, "wrapper_CUDA___transformer_encoder_layer_fwd", "norm_weight_2");
  c10::impl::check_and_update_common_device(common_device, norm_bias_2, "wrapper_CUDA___transformer_encoder_layer_fwd", "norm_bias_2");
  c10::impl::check_and_update_common_device(common_device, ffn_weight_1, "wrapper_CUDA___transformer_encoder_layer_fwd", "ffn_weight_1");
  c10::impl::check_and_update_common_device(common_device, ffn_bias_1, "wrapper_CUDA___transformer_encoder_layer_fwd", "ffn_bias_1");
  c10::impl::check_and_update_common_device(common_device, ffn_weight_2, "wrapper_CUDA___transformer_encoder_layer_fwd", "ffn_weight_2");
  c10::impl::check_and_update_common_device(common_device, ffn_bias_2, "wrapper_CUDA___transformer_encoder_layer_fwd", "ffn_bias_2");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA___transformer_encoder_layer_fwd", "mask");
  const OptionalDeviceGuard device_guard(device_of(src));
  return at::native::transformer_encoder_layer_forward(src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, mask_type);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CUDA___native_multi_head_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, int64_t embed_dim, int64_t num_head, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, const c10::optional<at::Tensor> & mask, bool need_weights, bool average_attn_weights, c10::optional<int64_t> mask_type) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, query, "wrapper_CUDA___native_multi_head_attention", "query");
  c10::impl::check_and_update_common_device(common_device, key, "wrapper_CUDA___native_multi_head_attention", "key");
  c10::impl::check_and_update_common_device(common_device, value, "wrapper_CUDA___native_multi_head_attention", "value");
  c10::impl::check_and_update_common_device(common_device, qkv_weight, "wrapper_CUDA___native_multi_head_attention", "qkv_weight");
  c10::impl::check_and_update_common_device(common_device, qkv_bias, "wrapper_CUDA___native_multi_head_attention", "qkv_bias");
  c10::impl::check_and_update_common_device(common_device, proj_weight, "wrapper_CUDA___native_multi_head_attention", "proj_weight");
  c10::impl::check_and_update_common_device(common_device, proj_bias, "wrapper_CUDA___native_multi_head_attention", "proj_bias");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA___native_multi_head_attention", "mask");
  const OptionalDeviceGuard device_guard(device_of(query));
  return at::native::native_multi_head_attention_cuda(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, need_weights, average_attn_weights, mask_type);
}
} // anonymous namespace
namespace {
int64_t wrapper_CUDA___fused_sdp_choice(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & attn_mask, double dropout_p, bool is_causal, c10::optional<double> scale) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, query, "wrapper_CUDA___fused_sdp_choice", "query");
  c10::impl::check_and_update_common_device(common_device, key, "wrapper_CUDA___fused_sdp_choice", "key");
  c10::impl::check_and_update_common_device(common_device, value, "wrapper_CUDA___fused_sdp_choice", "value");
  c10::impl::check_and_update_common_device(common_device, attn_mask, "wrapper_CUDA___fused_sdp_choice", "attn_mask");
  const OptionalDeviceGuard device_guard(device_of(query));
  return at::native::_fused_sdp_choice_cuda(query, key, value, attn_mask, dropout_p, is_causal, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,c10::SymInt,c10::SymInt,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___scaled_dot_product_flash_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, double dropout_p, bool is_causal, bool return_debug_mask, c10::optional<double> scale) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, query, "wrapper_CUDA___scaled_dot_product_flash_attention", "query");
  c10::impl::check_and_update_common_device(common_device, key, "wrapper_CUDA___scaled_dot_product_flash_attention", "key");
  c10::impl::check_and_update_common_device(common_device, value, "wrapper_CUDA___scaled_dot_product_flash_attention", "value");
  const OptionalDeviceGuard device_guard(device_of(query));
  return at::native::_scaled_dot_product_flash_attention_cuda(query, key, value, dropout_p, is_causal, return_debug_mask, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___scaled_dot_product_flash_attention_backward(const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & cum_seq_q, const at::Tensor & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, const at::Tensor & philox_seed, const at::Tensor & philox_offset, c10::optional<double> scale) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(grad_out));
  return at::native::_scaled_dot_product_flash_attention_backward_cuda(grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q.guard_int(__FILE__, __LINE__), max_k.guard_int(__FILE__, __LINE__), dropout_p, is_causal, philox_seed, philox_offset, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___scaled_dot_product_efficient_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & attn_bias, bool compute_log_sumexp, double dropout_p, bool is_causal, c10::optional<double> scale) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, query, "wrapper_CUDA___scaled_dot_product_efficient_attention", "query");
  c10::impl::check_and_update_common_device(common_device, key, "wrapper_CUDA___scaled_dot_product_efficient_attention", "key");
  c10::impl::check_and_update_common_device(common_device, value, "wrapper_CUDA___scaled_dot_product_efficient_attention", "value");
  c10::impl::check_and_update_common_device(common_device, attn_bias, "wrapper_CUDA___scaled_dot_product_efficient_attention", "attn_bias");
  const OptionalDeviceGuard device_guard(device_of(query));
  return at::native::_scaled_dot_product_efficient_attention_cuda(query, key, value, attn_bias, compute_log_sumexp, dropout_p, is_causal, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___scaled_dot_product_efficient_attention_backward(const at::Tensor & grad_out_, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & attn_bias, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & philox_seed, const at::Tensor & philox_offset, double dropout_p, ::std::array<bool,4> grad_input_mask, bool is_causal, c10::optional<double> scale) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(grad_out_));
  return at::native::_scaled_dot_product_efficient_attention_backward_cuda(grad_out_, query, key, value, attn_bias, out, logsumexp, philox_seed, philox_offset, dropout_p, grad_input_mask, is_causal, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___flash_attention_forward(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & cum_seq_q, const c10::optional<at::Tensor> & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, bool return_debug_mask, c10::optional<double> scale) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, query, "wrapper_CUDA___flash_attention_forward", "query");
  c10::impl::check_and_update_common_device(common_device, key, "wrapper_CUDA___flash_attention_forward", "key");
  c10::impl::check_and_update_common_device(common_device, value, "wrapper_CUDA___flash_attention_forward", "value");
  c10::impl::check_and_update_common_device(common_device, cum_seq_q, "wrapper_CUDA___flash_attention_forward", "cum_seq_q");
  c10::impl::check_and_update_common_device(common_device, cum_seq_k, "wrapper_CUDA___flash_attention_forward", "cum_seq_k");
  const OptionalDeviceGuard device_guard(device_of(query));
  return at::native::_flash_attention_forward(query, key, value, cum_seq_q, cum_seq_k, max_q.guard_int(__FILE__, __LINE__), max_k.guard_int(__FILE__, __LINE__), dropout_p, is_causal, return_debug_mask, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___flash_attention_backward(const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & cum_seq_q, const at::Tensor & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, const at::Tensor & philox_seed, const at::Tensor & philox_offset, c10::optional<double> scale) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(grad_out));
  return at::native::_flash_attention_backward(grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q.guard_int(__FILE__, __LINE__), max_k.guard_int(__FILE__, __LINE__), dropout_p, is_causal, philox_seed, philox_offset, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,c10::SymInt,c10::SymInt> wrapper_CUDA___efficient_attention_forward(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & cu_seqlens_q, const c10::optional<at::Tensor> & cu_seqlens_k, c10::optional<int64_t> max_seqlen_q, c10::optional<int64_t> max_seqlen_k, double dropout_p, int64_t custom_mask_type, bool compute_log_sumexp, c10::optional<double> scale, const c10::optional<at::Tensor> & causal_diagonal, const c10::optional<at::Tensor> & seqlen_k) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, query, "wrapper_CUDA___efficient_attention_forward", "query");
  c10::impl::check_and_update_common_device(common_device, key, "wrapper_CUDA___efficient_attention_forward", "key");
  c10::impl::check_and_update_common_device(common_device, value, "wrapper_CUDA___efficient_attention_forward", "value");
  c10::impl::check_and_update_common_device(common_device, bias, "wrapper_CUDA___efficient_attention_forward", "bias");
  c10::impl::check_and_update_common_device(common_device, cu_seqlens_q, "wrapper_CUDA___efficient_attention_forward", "cu_seqlens_q");
  c10::impl::check_and_update_common_device(common_device, cu_seqlens_k, "wrapper_CUDA___efficient_attention_forward", "cu_seqlens_k");
  const OptionalDeviceGuard device_guard(device_of(query));
  return at::native::_efficient_attention_forward(query, key, value, bias, cu_seqlens_q, cu_seqlens_k, max_seqlen_q, max_seqlen_k, dropout_p, custom_mask_type, compute_log_sumexp, scale, causal_diagonal, seqlen_k);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CUDA___efficient_attention_backward(const at::Tensor & grad_out_, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & bias, const at::Tensor & out, const c10::optional<at::Tensor> & cu_seqlens_q, const c10::optional<at::Tensor> & cu_seqlens_k, c10::SymInt max_seqlen_q, c10::SymInt max_seqlen_k, const at::Tensor & logsumexp, double dropout_p, const at::Tensor & philox_seed, const at::Tensor & philox_offset, int64_t custom_mask_type, bool bias_requires_grad, c10::optional<double> scale, c10::optional<int64_t> num_splits_key) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(grad_out_));
  return at::native::_efficient_attention_backward(grad_out_, query, key, value, bias, out, cu_seqlens_q, cu_seqlens_k, max_seqlen_q.guard_int(__FILE__, __LINE__), max_seqlen_k.guard_int(__FILE__, __LINE__), logsumexp, dropout_p, philox_seed, philox_offset, custom_mask_type, bias_requires_grad, scale, num_splits_key);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___triton_scaled_dot_attention(const at::Tensor & q, const at::Tensor & k, const at::Tensor & v, double dropout_p) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, q, "wrapper_CUDA___triton_scaled_dot_attention", "q");
  c10::impl::check_and_update_common_device(common_device, k, "wrapper_CUDA___triton_scaled_dot_attention", "k");
  c10::impl::check_and_update_common_device(common_device, v, "wrapper_CUDA___triton_scaled_dot_attention", "v");
  const OptionalDeviceGuard device_guard(device_of(q));
  return at::native::triton_scaled_dot_attention(q, k, v, dropout_p);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CUDA___fill_mem_eff_dropout_mask_(at::Tensor & self, double dropout_p, int64_t seed, int64_t offset) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fill_mem_eff_dropout_mask_", "self");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fill_mem_eff_dropout_mask_(self, dropout_p, seed, offset);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CUDA___triton_multi_head_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, int64_t embed_dim, int64_t num_head, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, const c10::optional<at::Tensor> & mask) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, query, "wrapper_CUDA___triton_multi_head_attention", "query");
  c10::impl::check_and_update_common_device(common_device, key, "wrapper_CUDA___triton_multi_head_attention", "key");
  c10::impl::check_and_update_common_device(common_device, value, "wrapper_CUDA___triton_multi_head_attention", "value");
  c10::impl::check_and_update_common_device(common_device, qkv_weight, "wrapper_CUDA___triton_multi_head_attention", "qkv_weight");
  c10::impl::check_and_update_common_device(common_device, qkv_bias, "wrapper_CUDA___triton_multi_head_attention", "qkv_bias");
  c10::impl::check_and_update_common_device(common_device, proj_weight, "wrapper_CUDA___triton_multi_head_attention", "proj_weight");
  c10::impl::check_and_update_common_device(common_device, proj_bias, "wrapper_CUDA___triton_multi_head_attention", "proj_bias");
  c10::impl::check_and_update_common_device(common_device, mask, "wrapper_CUDA___triton_multi_head_attention", "mask");
  const OptionalDeviceGuard device_guard(device_of(query));
  return at::native::triton_multi_head_attention(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask);
}
} // anonymous namespace
struct structured_special_airy_ai_out_functional final : public at::native::structured_special_airy_ai_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_airy_ai_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_airy_ai_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_airy_ai(const at::Tensor & x) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA_special_airy_ai", "x");
structured_special_airy_ai_out_functional op;
op.meta(x);
op.impl(x, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_airy_ai_out_out final : public at::native::structured_special_airy_ai_out {
    structured_special_airy_ai_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_airy_ai_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_airy_ai_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_airy_ai_out_out(const at::Tensor & x, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_airy_ai_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA_special_airy_ai_out_out", "x");
structured_special_airy_ai_out_out op(out);
op.meta(x);
op.impl(x, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_bessel_j0_out_functional final : public at::native::structured_special_bessel_j0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_bessel_j0(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_bessel_j0", "self");
structured_special_bessel_j0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_bessel_j0_out_out final : public at::native::structured_special_bessel_j0_out {
    structured_special_bessel_j0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_bessel_j0_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_bessel_j0_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_bessel_j0_out_out", "self");
structured_special_bessel_j0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_bessel_j1_out_functional final : public at::native::structured_special_bessel_j1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_bessel_j1(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_bessel_j1", "self");
structured_special_bessel_j1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_bessel_j1_out_out final : public at::native::structured_special_bessel_j1_out {
    structured_special_bessel_j1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_bessel_j1_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_bessel_j1_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_bessel_j1_out_out", "self");
structured_special_bessel_j1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_bessel_y0_out_functional final : public at::native::structured_special_bessel_y0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_bessel_y0(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_bessel_y0", "self");
structured_special_bessel_y0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_bessel_y0_out_out final : public at::native::structured_special_bessel_y0_out {
    structured_special_bessel_y0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_bessel_y0_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_bessel_y0_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_bessel_y0_out_out", "self");
structured_special_bessel_y0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_bessel_y1_out_functional final : public at::native::structured_special_bessel_y1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_bessel_y1(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_bessel_y1", "self");
structured_special_bessel_y1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_bessel_y1_out_out final : public at::native::structured_special_bessel_y1_out {
    structured_special_bessel_y1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_bessel_y1_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_bessel_y1_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_bessel_y1_out_out", "self");
structured_special_bessel_y1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_chebyshev_polynomial_t_out_functional final : public at::native::structured_special_chebyshev_polynomial_t_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_chebyshev_polynomial_t(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_chebyshev_polynomial_t_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_chebyshev_polynomial_t_out_out final : public at::native::structured_special_chebyshev_polynomial_t_out {
    structured_special_chebyshev_polynomial_t_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_chebyshev_polynomial_t_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_chebyshev_polynomial_t_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_chebyshev_polynomial_u_out_functional final : public at::native::structured_special_chebyshev_polynomial_u_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_chebyshev_polynomial_u(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_chebyshev_polynomial_u_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_chebyshev_polynomial_u_out_out final : public at::native::structured_special_chebyshev_polynomial_u_out {
    structured_special_chebyshev_polynomial_u_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_chebyshev_polynomial_u_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_chebyshev_polynomial_u_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_chebyshev_polynomial_v_out_functional final : public at::native::structured_special_chebyshev_polynomial_v_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_chebyshev_polynomial_v(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_chebyshev_polynomial_v_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_chebyshev_polynomial_v_out_out final : public at::native::structured_special_chebyshev_polynomial_v_out {
    structured_special_chebyshev_polynomial_v_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_chebyshev_polynomial_v_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_chebyshev_polynomial_v_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_chebyshev_polynomial_w_out_functional final : public at::native::structured_special_chebyshev_polynomial_w_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_chebyshev_polynomial_w(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_chebyshev_polynomial_w_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_chebyshev_polynomial_w_out_out final : public at::native::structured_special_chebyshev_polynomial_w_out {
    structured_special_chebyshev_polynomial_w_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_chebyshev_polynomial_w_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_chebyshev_polynomial_w_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_hermite_polynomial_h_out_functional final : public at::native::structured_special_hermite_polynomial_h_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_h_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_h_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_hermite_polynomial_h(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_hermite_polynomial_h_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_hermite_polynomial_h_out_out final : public at::native::structured_special_hermite_polynomial_h_out {
    structured_special_hermite_polynomial_h_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_h_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_h_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_hermite_polynomial_h_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_hermite_polynomial_h_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_hermite_polynomial_he_out_functional final : public at::native::structured_special_hermite_polynomial_he_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_he_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_he_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_hermite_polynomial_he(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_hermite_polynomial_he_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_hermite_polynomial_he_out_out final : public at::native::structured_special_hermite_polynomial_he_out {
    structured_special_hermite_polynomial_he_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_he_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_he_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_hermite_polynomial_he_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_hermite_polynomial_he_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_laguerre_polynomial_l_out_functional final : public at::native::structured_special_laguerre_polynomial_l_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_laguerre_polynomial_l_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_laguerre_polynomial_l_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_laguerre_polynomial_l(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_laguerre_polynomial_l_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_laguerre_polynomial_l_out_out final : public at::native::structured_special_laguerre_polynomial_l_out {
    structured_special_laguerre_polynomial_l_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_laguerre_polynomial_l_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_laguerre_polynomial_l_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_laguerre_polynomial_l_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_laguerre_polynomial_l_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_legendre_polynomial_p_out_functional final : public at::native::structured_special_legendre_polynomial_p_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_legendre_polynomial_p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_legendre_polynomial_p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_legendre_polynomial_p(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_legendre_polynomial_p_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_legendre_polynomial_p_out_out final : public at::native::structured_special_legendre_polynomial_p_out {
    structured_special_legendre_polynomial_p_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_legendre_polynomial_p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_legendre_polynomial_p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_legendre_polynomial_p_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_legendre_polynomial_p_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_modified_bessel_i0_out_functional final : public at::native::structured_special_modified_bessel_i0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_modified_bessel_i0(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_modified_bessel_i0", "self");
structured_special_modified_bessel_i0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_modified_bessel_i0_out_out final : public at::native::structured_special_modified_bessel_i0_out {
    structured_special_modified_bessel_i0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_modified_bessel_i0_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_modified_bessel_i0_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_modified_bessel_i0_out_out", "self");
structured_special_modified_bessel_i0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_modified_bessel_i1_out_functional final : public at::native::structured_special_modified_bessel_i1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_modified_bessel_i1(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_modified_bessel_i1", "self");
structured_special_modified_bessel_i1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_modified_bessel_i1_out_out final : public at::native::structured_special_modified_bessel_i1_out {
    structured_special_modified_bessel_i1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_modified_bessel_i1_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_modified_bessel_i1_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_modified_bessel_i1_out_out", "self");
structured_special_modified_bessel_i1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_modified_bessel_k0_out_functional final : public at::native::structured_special_modified_bessel_k0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_modified_bessel_k0(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_modified_bessel_k0", "self");
structured_special_modified_bessel_k0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_modified_bessel_k0_out_out final : public at::native::structured_special_modified_bessel_k0_out {
    structured_special_modified_bessel_k0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_modified_bessel_k0_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_modified_bessel_k0_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_modified_bessel_k0_out_out", "self");
structured_special_modified_bessel_k0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_modified_bessel_k1_out_functional final : public at::native::structured_special_modified_bessel_k1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_modified_bessel_k1(const at::Tensor & self) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_modified_bessel_k1", "self");
structured_special_modified_bessel_k1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_modified_bessel_k1_out_out final : public at::native::structured_special_modified_bessel_k1_out {
    structured_special_modified_bessel_k1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_modified_bessel_k1_out_out(const at::Tensor & self, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_modified_bessel_k1_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA_special_modified_bessel_k1_out_out", "self");
structured_special_modified_bessel_k1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_scaled_modified_bessel_k0_out_functional final : public at::native::structured_special_scaled_modified_bessel_k0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_scaled_modified_bessel_k0(const at::Tensor & x) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA_special_scaled_modified_bessel_k0", "x");
structured_special_scaled_modified_bessel_k0_out_functional op;
op.meta(x);
op.impl(x, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_scaled_modified_bessel_k0_out_out final : public at::native::structured_special_scaled_modified_bessel_k0_out {
    structured_special_scaled_modified_bessel_k0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_scaled_modified_bessel_k0_out_out(const at::Tensor & x, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_scaled_modified_bessel_k0_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA_special_scaled_modified_bessel_k0_out_out", "x");
structured_special_scaled_modified_bessel_k0_out_out op(out);
op.meta(x);
op.impl(x, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_scaled_modified_bessel_k1_out_functional final : public at::native::structured_special_scaled_modified_bessel_k1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_scaled_modified_bessel_k1(const at::Tensor & x) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA_special_scaled_modified_bessel_k1", "x");
structured_special_scaled_modified_bessel_k1_out_functional op;
op.meta(x);
op.impl(x, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_scaled_modified_bessel_k1_out_out final : public at::native::structured_special_scaled_modified_bessel_k1_out {
    structured_special_scaled_modified_bessel_k1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_scaled_modified_bessel_k1_out_out(const at::Tensor & x, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_scaled_modified_bessel_k1_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA_special_scaled_modified_bessel_k1_out_out", "x");
structured_special_scaled_modified_bessel_k1_out_out op(out);
op.meta(x);
op.impl(x, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_shifted_chebyshev_polynomial_t_out_functional final : public at::native::structured_special_shifted_chebyshev_polynomial_t_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_shifted_chebyshev_polynomial_t(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_shifted_chebyshev_polynomial_t_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_shifted_chebyshev_polynomial_t_out_out final : public at::native::structured_special_shifted_chebyshev_polynomial_t_out {
    structured_special_shifted_chebyshev_polynomial_t_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_shifted_chebyshev_polynomial_t_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_shifted_chebyshev_polynomial_t_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_shifted_chebyshev_polynomial_u_out_functional final : public at::native::structured_special_shifted_chebyshev_polynomial_u_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_shifted_chebyshev_polynomial_u(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_shifted_chebyshev_polynomial_u_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_shifted_chebyshev_polynomial_u_out_out final : public at::native::structured_special_shifted_chebyshev_polynomial_u_out {
    structured_special_shifted_chebyshev_polynomial_u_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_shifted_chebyshev_polynomial_u_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_shifted_chebyshev_polynomial_u_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_shifted_chebyshev_polynomial_v_out_functional final : public at::native::structured_special_shifted_chebyshev_polynomial_v_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_shifted_chebyshev_polynomial_v(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_shifted_chebyshev_polynomial_v_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_shifted_chebyshev_polynomial_v_out_out final : public at::native::structured_special_shifted_chebyshev_polynomial_v_out {
    structured_special_shifted_chebyshev_polynomial_v_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_shifted_chebyshev_polynomial_v_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_shifted_chebyshev_polynomial_v_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_shifted_chebyshev_polynomial_w_out_functional final : public at::native::structured_special_shifted_chebyshev_polynomial_w_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_shifted_chebyshev_polynomial_w(const at::Tensor & x, const at::Tensor & n) {
  // No device check
structured_special_shifted_chebyshev_polynomial_w_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_shifted_chebyshev_polynomial_w_out_out final : public at::native::structured_special_shifted_chebyshev_polynomial_w_out {
    structured_special_shifted_chebyshev_polynomial_w_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_shifted_chebyshev_polynomial_w_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
  // No device check
structured_special_shifted_chebyshev_polynomial_w_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_spherical_bessel_j0_out_functional final : public at::native::structured_special_spherical_bessel_j0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_spherical_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_spherical_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor wrapper_CUDA_special_spherical_bessel_j0(const at::Tensor & x) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA_special_spherical_bessel_j0", "x");
structured_special_spherical_bessel_j0_out_functional op;
op.meta(x);
op.impl(x, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_spherical_bessel_j0_out_out final : public at::native::structured_special_spherical_bessel_j0_out {
    structured_special_spherical_bessel_j0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_spherical_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        auto current_device = guard_.current_device();
        if (C10_UNLIKELY(current_device.has_value())) {
          TORCH_INTERNAL_ASSERT(*current_device == options.device(),
            "structured kernels don't support multi-device outputs");
        } else {
          guard_.reset_device(options.device());
        }
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_spherical_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
    c10::cuda::OptionalCUDAGuard guard_;
};
at::Tensor & wrapper_CUDA_special_spherical_bessel_j0_out_out(const at::Tensor & x, at::Tensor & out) {
c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, out, "wrapper_CUDA_special_spherical_bessel_j0_out_out", "out");
  c10::impl::check_and_update_common_device(common_device, x, "wrapper_CUDA_special_spherical_bessel_j0_out_out", "x");
structured_special_spherical_bessel_j0_out_out op(out);
op.meta(x);
op.impl(x, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
void wrapper_CUDA___fused_adam_(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, double lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fused_adam_", "self");
  c10::impl::check_and_update_common_device(common_device, grads, "wrapper_CUDA___fused_adam_", "grads");
  c10::impl::check_and_update_common_device(common_device, exp_avgs, "wrapper_CUDA___fused_adam_", "exp_avgs");
  c10::impl::check_and_update_common_device(common_device, exp_avg_sqs, "wrapper_CUDA___fused_adam_", "exp_avg_sqs");
  c10::impl::check_and_update_common_device(common_device, max_exp_avg_sqs, "wrapper_CUDA___fused_adam_", "max_exp_avg_sqs");
  c10::impl::check_and_update_common_device(common_device, state_steps, "wrapper_CUDA___fused_adam_", "state_steps");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fused_adam_kernel_cuda_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_tensor_lr__fused_adam_(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, const at::Tensor & lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fused_adam_kernel_cuda_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___fused_adamw_(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, double lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fused_adamw_", "self");
  c10::impl::check_and_update_common_device(common_device, grads, "wrapper_CUDA___fused_adamw_", "grads");
  c10::impl::check_and_update_common_device(common_device, exp_avgs, "wrapper_CUDA___fused_adamw_", "exp_avgs");
  c10::impl::check_and_update_common_device(common_device, exp_avg_sqs, "wrapper_CUDA___fused_adamw_", "exp_avg_sqs");
  c10::impl::check_and_update_common_device(common_device, max_exp_avg_sqs, "wrapper_CUDA___fused_adamw_", "max_exp_avg_sqs");
  c10::impl::check_and_update_common_device(common_device, state_steps, "wrapper_CUDA___fused_adamw_", "state_steps");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fused_adamw_kernel_cuda_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_tensor_lr__fused_adamw_(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, const at::Tensor & lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fused_adamw_kernel_cuda_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
}
} // anonymous namespace
namespace {
void wrapper_CUDA___fused_sgd_(at::TensorList self, at::TensorList grads, at::TensorList momentum_buffer_list, double weight_decay, double momentum, double lr, double dampening, bool nesterov, bool maximize, bool is_first_step, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
  c10::optional<Device> common_device = nullopt;
(void)common_device; // Suppress unused variable warning
  c10::impl::check_and_update_common_device(common_device, self, "wrapper_CUDA___fused_sgd_", "self");
  c10::impl::check_and_update_common_device(common_device, grads, "wrapper_CUDA___fused_sgd_", "grads");
  c10::impl::check_and_update_common_device(common_device, momentum_buffer_list, "wrapper_CUDA___fused_sgd_", "momentum_buffer_list");
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fused_sgd_kernel_cuda_(self, grads, momentum_buffer_list, weight_decay, momentum, lr, dampening, nesterov, maximize, is_first_step, grad_scale, found_inf);
}
} // anonymous namespace
namespace {
void wrapper_CUDA_tensor_lr__fused_sgd_(at::TensorList self, at::TensorList grads, at::TensorList momentum_buffer_list, double weight_decay, double momentum, const at::Tensor & lr, double dampening, bool nesterov, bool maximize, bool is_first_step, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
    // No device check
  const OptionalDeviceGuard device_guard(device_of(self));
  return at::native::_fused_sgd_kernel_cuda_(self, grads, momentum_buffer_list, weight_decay, momentum, lr, dampening, nesterov, maximize, is_first_step, grad_scale, found_inf);
}
} // anonymous namespace
TORCH_LIBRARY_IMPL(aten, CUDA, m) {
    m.impl("_assert_async",
TORCH_FN(wrapper_CUDA___assert_async));
m.impl("_assert_async.msg",
TORCH_FN(wrapper_CUDA_msg__assert_async));
m.impl("_use_cudnn_ctc_loss",
TORCH_FN(wrapper_CUDA___use_cudnn_ctc_loss));
m.impl("_use_cudnn_ctc_loss.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__use_cudnn_ctc_loss));
m.impl("_cudnn_ctc_loss",
TORCH_FN(wrapper_CUDA___cudnn_ctc_loss));
m.impl("_cudnn_ctc_loss.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__cudnn_ctc_loss));
m.impl("_cudnn_rnn_flatten_weight",
TORCH_FN(wrapper_CUDA___cudnn_rnn_flatten_weight));
m.impl("_cudnn_rnn",
TORCH_FN(wrapper_CUDA___cudnn_rnn));
m.impl("_cudnn_rnn_backward",
TORCH_FN(wrapper_CUDA___cudnn_rnn_backward));
m.impl("_cudnn_init_dropout_state",
TORCH_FN(wrapper_CUDA___cudnn_init_dropout_state));
m.impl("_fused_dropout",
TORCH_FN(wrapper_CUDA___fused_dropout));
m.impl("_masked_scale",
TORCH_FN(wrapper_CUDA___masked_scale));
m.impl("native_dropout",
TORCH_FN(wrapper_CUDA__native_dropout));
m.impl("native_dropout_backward",
TORCH_FN(wrapper_CUDA__native_dropout_backward));
m.impl("abs.out",
TORCH_FN(wrapper_CUDA_out_abs_out));
m.impl("angle",
TORCH_FN(wrapper_CUDA__angle));
m.impl("angle.out",
TORCH_FN(wrapper_CUDA_out_angle_out));
m.impl("view_as_real",
TORCH_FN(wrapper_CUDA__view_as_real));
m.impl("view_as_complex",
TORCH_FN(wrapper_CUDA__view_as_complex));
m.impl("sgn", TORCH_FN(wrapper_CUDA_sgn));
m.impl("sgn.out", TORCH_FN(wrapper_CUDA_sgn_out_out));
m.impl("sgn_", TORCH_FN(wrapper_CUDA_sgn_));
m.impl("conj_physical.out",
TORCH_FN(wrapper_CUDA_out_conj_physical_out));
m.impl("acos", TORCH_FN(wrapper_CUDA_acos));
m.impl("acos.out", TORCH_FN(wrapper_CUDA_acos_out_out));
m.impl("acos_", TORCH_FN(wrapper_CUDA_acos_));
m.impl("add.Tensor", TORCH_FN(wrapper_CUDA_add_Tensor));
m.impl("add.out", TORCH_FN(wrapper_CUDA_add_out_out));
m.impl("add_.Tensor", TORCH_FN(wrapper_CUDA_add__Tensor));
m.impl("addmv", TORCH_FN(wrapper_CUDA_addmv));
m.impl("addmv.out", TORCH_FN(wrapper_CUDA_addmv_out_out));
m.impl("addmv_", TORCH_FN(wrapper_CUDA_addmv_));
m.impl("addr",
TORCH_FN(wrapper_CUDA__addr));
m.impl("addr.out",
TORCH_FN(wrapper_CUDA_out_addr_out));
m.impl("all.dim", TORCH_FN(wrapper_CUDA_all_dim));
m.impl("all.out", TORCH_FN(wrapper_CUDA_all_out_out));
m.impl("all.dims", TORCH_FN(wrapper_CUDA_all_dims));
m.impl("all.dims_out", TORCH_FN(wrapper_CUDA_all_out_dims_out));
m.impl("any.dim", TORCH_FN(wrapper_CUDA_any_dim));
m.impl("any.out", TORCH_FN(wrapper_CUDA_any_out_out));
m.impl("any.dims", TORCH_FN(wrapper_CUDA_any_dims));
m.impl("any.dims_out", TORCH_FN(wrapper_CUDA_any_out_dims_out));
m.impl("arange.start_out",
TORCH_FN(wrapper_CUDA_start_out_arange_out));
m.impl("argmax", TORCH_FN(wrapper_CUDA_argmax));
m.impl("argmax.out", TORCH_FN(wrapper_CUDA_argmax_out_out));
m.impl("argmin", TORCH_FN(wrapper_CUDA_argmin));
m.impl("argmin.out", TORCH_FN(wrapper_CUDA_argmin_out_out));
m.impl("acosh", TORCH_FN(wrapper_CUDA_acosh));
m.impl("acosh.out", TORCH_FN(wrapper_CUDA_acosh_out_out));
m.impl("acosh_", TORCH_FN(wrapper_CUDA_acosh_));
m.impl("asinh", TORCH_FN(wrapper_CUDA_asinh));
m.impl("asinh.out", TORCH_FN(wrapper_CUDA_asinh_out_out));
m.impl("asinh_", TORCH_FN(wrapper_CUDA_asinh_));
m.impl("atanh", TORCH_FN(wrapper_CUDA_atanh));
m.impl("atanh.out", TORCH_FN(wrapper_CUDA_atanh_out_out));
m.impl("atanh_", TORCH_FN(wrapper_CUDA_atanh_));
m.impl("as_strided",
TORCH_FN(wrapper_CUDA__as_strided));
m.impl("asin", TORCH_FN(wrapper_CUDA_asin));
m.impl("asin.out", TORCH_FN(wrapper_CUDA_asin_out_out));
m.impl("asin_", TORCH_FN(wrapper_CUDA_asin_));
m.impl("atan", TORCH_FN(wrapper_CUDA_atan));
m.impl("atan.out", TORCH_FN(wrapper_CUDA_atan_out_out));
m.impl("atan_", TORCH_FN(wrapper_CUDA_atan_));
m.impl("baddbmm", TORCH_FN(wrapper_CUDA_baddbmm));
m.impl("baddbmm.out", TORCH_FN(wrapper_CUDA_baddbmm_out_out));
m.impl("baddbmm_", TORCH_FN(wrapper_CUDA_baddbmm_));
m.impl("bernoulli.out",
TORCH_FN(wrapper_CUDA_out_bernoulli_out));
m.impl("bernoulli_.Tensor",
TORCH_FN(wrapper_CUDA_Tensor_bernoulli_));
m.impl("bernoulli_.float",
TORCH_FN(wrapper_CUDA_float_bernoulli_));
m.impl("binary_cross_entropy",
TORCH_FN(wrapper_CUDA__binary_cross_entropy));
m.impl("binary_cross_entropy.out",
TORCH_FN(wrapper_CUDA_out_binary_cross_entropy_out));
m.impl("binary_cross_entropy_backward",
TORCH_FN(wrapper_CUDA__binary_cross_entropy_backward));
m.impl("binary_cross_entropy_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_binary_cross_entropy_backward_out));
m.impl("bincount",
TORCH_FN(wrapper_CUDA__bincount));
m.impl("bitwise_not", TORCH_FN(wrapper_CUDA_bitwise_not));
m.impl("bitwise_not.out", TORCH_FN(wrapper_CUDA_bitwise_not_out_out));
m.impl("bitwise_not_", TORCH_FN(wrapper_CUDA_bitwise_not_));
m.impl("copysign.Tensor", TORCH_FN(wrapper_CUDA_copysign_Tensor));
m.impl("copysign.out", TORCH_FN(wrapper_CUDA_copysign_out_out));
m.impl("copysign_.Tensor", TORCH_FN(wrapper_CUDA_copysign__Tensor));
m.impl("logical_not.out",
TORCH_FN(wrapper_CUDA_out_logical_not_out));
m.impl("logical_xor.out",
TORCH_FN(wrapper_CUDA_out_logical_xor_out));
m.impl("logical_and.out",
TORCH_FN(wrapper_CUDA_out_logical_and_out));
m.impl("logical_or.out",
TORCH_FN(wrapper_CUDA_out_logical_or_out));
m.impl("bmm", TORCH_FN(wrapper_CUDA_bmm));
m.impl("bmm.out", TORCH_FN(wrapper_CUDA_bmm_out_out));
m.impl("cat", TORCH_FN(wrapper_CUDA_cat));
m.impl("cat.out", TORCH_FN(wrapper_CUDA_cat_out_out));
m.impl("ceil", TORCH_FN(wrapper_CUDA_ceil));
m.impl("ceil.out", TORCH_FN(wrapper_CUDA_ceil_out_out));
m.impl("ceil_", TORCH_FN(wrapper_CUDA_ceil_));
m.impl("clamp", TORCH_FN(wrapper_CUDA_clamp));
m.impl("clamp.out", TORCH_FN(wrapper_CUDA_clamp_out_out));
m.impl("clamp_", TORCH_FN(wrapper_CUDA_clamp_));
m.impl("clamp.Tensor", TORCH_FN(wrapper_CUDA_clamp_Tensor));
m.impl("clamp.Tensor_out", TORCH_FN(wrapper_CUDA_clamp_out_Tensor_out));
m.impl("clamp_.Tensor", TORCH_FN(wrapper_CUDA_clamp__Tensor));
m.impl("clamp_max", TORCH_FN(wrapper_CUDA_clamp_max));
m.impl("clamp_max.out", TORCH_FN(wrapper_CUDA_clamp_max_out_out));
m.impl("clamp_max_", TORCH_FN(wrapper_CUDA_clamp_max_));
m.impl("clamp_max.Tensor", TORCH_FN(wrapper_CUDA_clamp_max_Tensor));
m.impl("clamp_max.Tensor_out", TORCH_FN(wrapper_CUDA_clamp_max_out_Tensor_out));
m.impl("clamp_max_.Tensor", TORCH_FN(wrapper_CUDA_clamp_max__Tensor));
m.impl("clamp_min", TORCH_FN(wrapper_CUDA_clamp_min));
m.impl("clamp_min.out", TORCH_FN(wrapper_CUDA_clamp_min_out_out));
m.impl("clamp_min_", TORCH_FN(wrapper_CUDA_clamp_min_));
m.impl("clamp_min.Tensor", TORCH_FN(wrapper_CUDA_clamp_min_Tensor));
m.impl("clamp_min.Tensor_out", TORCH_FN(wrapper_CUDA_clamp_min_out_Tensor_out));
m.impl("clamp_min_.Tensor", TORCH_FN(wrapper_CUDA_clamp_min__Tensor));
m.impl("complex.out",
TORCH_FN(wrapper_CUDA_out_complex_out));
m.impl("polar.out",
TORCH_FN(wrapper_CUDA_out_polar_out));
m.impl("convolution_backward",
TORCH_FN(wrapper_CUDA__convolution_backward));
m.impl("cos", TORCH_FN(wrapper_CUDA_cos));
m.impl("cos.out", TORCH_FN(wrapper_CUDA_cos_out_out));
m.impl("cos_", TORCH_FN(wrapper_CUDA_cos_));
m.impl("cosh", TORCH_FN(wrapper_CUDA_cosh));
m.impl("cosh.out", TORCH_FN(wrapper_CUDA_cosh_out_out));
m.impl("cosh_", TORCH_FN(wrapper_CUDA_cosh_));
m.impl("count_nonzero.dim_IntList",
TORCH_FN(wrapper_CUDA_dim_IntList_count_nonzero));
m.impl("cudnn_affine_grid_generator",
TORCH_FN(wrapper_CUDA__cudnn_affine_grid_generator));
m.impl("cudnn_affine_grid_generator_backward",
TORCH_FN(wrapper_CUDA__cudnn_affine_grid_generator_backward));
m.impl("cudnn_batch_norm",
TORCH_FN(wrapper_CUDA__cudnn_batch_norm));
m.impl("cudnn_batch_norm_backward",
TORCH_FN(wrapper_CUDA__cudnn_batch_norm_backward));
m.impl("cudnn_convolution",
TORCH_FN(wrapper_CUDA__cudnn_convolution));
m.impl("cudnn_convolution.out",
TORCH_FN(wrapper_CUDA_out_cudnn_convolution_out));
m.impl("cudnn_convolution_transpose",
TORCH_FN(wrapper_CUDA__cudnn_convolution_transpose));
m.impl("cudnn_convolution_relu",
TORCH_FN(wrapper_CUDA__cudnn_convolution_relu));
m.impl("cudnn_convolution_add_relu",
TORCH_FN(wrapper_CUDA__cudnn_convolution_add_relu));
m.impl("cudnn_grid_sampler",
TORCH_FN(wrapper_CUDA__cudnn_grid_sampler));
m.impl("cudnn_grid_sampler_backward",
TORCH_FN(wrapper_CUDA__cudnn_grid_sampler_backward));
m.impl("_cummax_helper",
TORCH_FN(wrapper_CUDA___cummax_helper));
m.impl("_cummin_helper",
TORCH_FN(wrapper_CUDA___cummin_helper));
m.impl("cumprod", TORCH_FN(wrapper_CUDA_cumprod));
m.impl("cumprod.out", TORCH_FN(wrapper_CUDA_cumprod_out_out));
m.impl("cumprod_", TORCH_FN(wrapper_CUDA_cumprod_));
m.impl("cumsum", TORCH_FN(wrapper_CUDA_cumsum));
m.impl("cumsum.out", TORCH_FN(wrapper_CUDA_cumsum_out_out));
m.impl("cumsum_", TORCH_FN(wrapper_CUDA_cumsum_));
m.impl("_ctc_loss",
TORCH_FN(wrapper_CUDA___ctc_loss));
m.impl("_ctc_loss.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__ctc_loss));
m.impl("_ctc_loss_backward",
TORCH_FN(wrapper_CUDA___ctc_loss_backward));
m.impl("_ctc_loss_backward.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__ctc_loss_backward));
m.impl("div.Tensor", TORCH_FN(wrapper_CUDA_div_Tensor));
m.impl("div.out", TORCH_FN(wrapper_CUDA_div_out_out));
m.impl("div_.Tensor", TORCH_FN(wrapper_CUDA_div__Tensor));
m.impl("div.Tensor_mode", TORCH_FN(wrapper_CUDA_div_Tensor_mode));
m.impl("div.out_mode", TORCH_FN(wrapper_CUDA_div_out_out_mode));
m.impl("div_.Tensor_mode", TORCH_FN(wrapper_CUDA_div__Tensor_mode));
m.impl("dot",
TORCH_FN(wrapper_CUDA__dot));
m.impl("vdot",
TORCH_FN(wrapper_CUDA__vdot));
m.impl("embedding_dense_backward",
TORCH_FN(wrapper_CUDA__embedding_dense_backward));
m.impl("embedding_renorm_",
TORCH_FN(wrapper_CUDA__embedding_renorm_));
m.impl("_embedding_bag_forward_only",
TORCH_FN(wrapper_CUDA___embedding_bag_forward_only));
m.impl("_embedding_bag",
TORCH_FN(wrapper_CUDA___embedding_bag));
m.impl("_embedding_bag_dense_backward",
TORCH_FN(wrapper_CUDA___embedding_bag_dense_backward));
m.impl("_embedding_bag_per_sample_weights_backward",
TORCH_FN(wrapper_CUDA___embedding_bag_per_sample_weights_backward));
m.impl("empty.memory_format",
TORCH_FN(wrapper_CUDA_memory_format_empty));
m.impl("resize_",
TORCH_FN(wrapper_CUDA__resize_));
m.impl("empty_strided",
TORCH_FN(wrapper_CUDA__empty_strided));
m.impl("erf", TORCH_FN(wrapper_CUDA_erf));
m.impl("erf.out", TORCH_FN(wrapper_CUDA_erf_out_out));
m.impl("erf_", TORCH_FN(wrapper_CUDA_erf_));
m.impl("erfc", TORCH_FN(wrapper_CUDA_erfc));
m.impl("erfc.out", TORCH_FN(wrapper_CUDA_erfc_out_out));
m.impl("erfc_", TORCH_FN(wrapper_CUDA_erfc_));
m.impl("exp", TORCH_FN(wrapper_CUDA_exp));
m.impl("exp.out", TORCH_FN(wrapper_CUDA_exp_out_out));
m.impl("exp_", TORCH_FN(wrapper_CUDA_exp_));
m.impl("exp2", TORCH_FN(wrapper_CUDA_exp2));
m.impl("exp2.out", TORCH_FN(wrapper_CUDA_exp2_out_out));
m.impl("exp2_", TORCH_FN(wrapper_CUDA_exp2_));
m.impl("expm1", TORCH_FN(wrapper_CUDA_expm1));
m.impl("expm1.out", TORCH_FN(wrapper_CUDA_expm1_out_out));
m.impl("expm1_", TORCH_FN(wrapper_CUDA_expm1_));
m.impl("eye.out",
TORCH_FN(wrapper_CUDA_out_eye_out));
m.impl("eye.m_out",
TORCH_FN(wrapper_CUDA_m_out_eye_out));
m.impl("fill_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar_fill_));
m.impl("fill_.Tensor",
TORCH_FN(wrapper_CUDA_Tensor_fill_));
m.impl("floor", TORCH_FN(wrapper_CUDA_floor));
m.impl("floor.out", TORCH_FN(wrapper_CUDA_floor_out_out));
m.impl("floor_", TORCH_FN(wrapper_CUDA_floor_));
m.impl("floor_divide",
TORCH_FN(wrapper_CUDA__floor_divide));
m.impl("floor_divide.out",
TORCH_FN(wrapper_CUDA_out_floor_divide_out));
m.impl("floor_divide_.Tensor",
TORCH_FN(wrapper_CUDA_Tensor_floor_divide_));
m.impl("frac", TORCH_FN(wrapper_CUDA_frac));
m.impl("frac.out", TORCH_FN(wrapper_CUDA_frac_out_out));
m.impl("frac_", TORCH_FN(wrapper_CUDA_frac_));
m.impl("gcd", TORCH_FN(wrapper_CUDA_gcd));
m.impl("gcd.out", TORCH_FN(wrapper_CUDA_gcd_out_out));
m.impl("gcd_", TORCH_FN(wrapper_CUDA_gcd_));
m.impl("lcm", TORCH_FN(wrapper_CUDA_lcm));
m.impl("lcm.out", TORCH_FN(wrapper_CUDA_lcm_out_out));
m.impl("lcm_", TORCH_FN(wrapper_CUDA_lcm_));
m.impl("grid_sampler_2d",
TORCH_FN(wrapper_CUDA__grid_sampler_2d));
m.impl("grid_sampler_2d_backward",
TORCH_FN(wrapper_CUDA__grid_sampler_2d_backward));
m.impl("grid_sampler_3d",
TORCH_FN(wrapper_CUDA__grid_sampler_3d));
m.impl("grid_sampler_3d_backward",
TORCH_FN(wrapper_CUDA__grid_sampler_3d_backward));
m.impl("native_group_norm",
TORCH_FN(wrapper_CUDA__native_group_norm));
m.impl("native_group_norm_backward",
TORCH_FN(wrapper_CUDA__native_group_norm_backward));
m.impl("_fft_r2c",
TORCH_FN(wrapper_CUDA___fft_r2c));
m.impl("_fft_r2c.out",
TORCH_FN(wrapper_CUDA_out__fft_r2c_out));
m.impl("_fft_c2r",
TORCH_FN(wrapper_CUDA___fft_c2r));
m.impl("_fft_c2r.out",
TORCH_FN(wrapper_CUDA_out__fft_c2r_out));
m.impl("_fft_c2c",
TORCH_FN(wrapper_CUDA___fft_c2c));
m.impl("_fft_c2c.out",
TORCH_FN(wrapper_CUDA_out__fft_c2c_out));
m.impl("_validate_compressed_sparse_indices",
TORCH_FN(wrapper_CUDA___validate_compressed_sparse_indices));
m.impl("index.Tensor", TORCH_FN(wrapper_CUDA_index_Tensor));
m.impl("index.Tensor_out", TORCH_FN(wrapper_CUDA_index_out_Tensor_out));
m.impl("index_copy", TORCH_FN(wrapper_CUDA_index_copy));
m.impl("index_copy.out", TORCH_FN(wrapper_CUDA_index_copy_out_out));
m.impl("index_copy_", TORCH_FN(wrapper_CUDA_index_copy_));
m.impl("_index_put_impl_",
TORCH_FN(wrapper_CUDA___index_put_impl_));
m.impl("isin.Tensor_Tensor", TORCH_FN(wrapper_CUDA_isin_Tensor_Tensor));
m.impl("isin.Tensor_Tensor_out", TORCH_FN(wrapper_CUDA_isin_out_Tensor_Tensor_out));
m.impl("isin.Tensor_Scalar", TORCH_FN(wrapper_CUDA_isin_Tensor_Scalar));
m.impl("isin.Tensor_Scalar_out", TORCH_FN(wrapper_CUDA_isin_out_Tensor_Scalar_out));
m.impl("isin.Scalar_Tensor", TORCH_FN(wrapper_CUDA_isin_Scalar_Tensor));
m.impl("isin.Scalar_Tensor_out", TORCH_FN(wrapper_CUDA_isin_out_Scalar_Tensor_out));
m.impl("isnan",
TORCH_FN(wrapper_CUDA__isnan));
m.impl("kthvalue.values",
TORCH_FN(wrapper_CUDA_values_kthvalue_out));
m.impl("native_layer_norm",
TORCH_FN(wrapper_CUDA__native_layer_norm));
m.impl("native_layer_norm_backward",
TORCH_FN(wrapper_CUDA__native_layer_norm_backward));
m.impl("nan_to_num.out",
TORCH_FN(wrapper_CUDA_out_nan_to_num_out));
m.impl("_cslt_compress",
TORCH_FN(wrapper_CUDA___cslt_compress));
m.impl("_cslt_sparse_mm",
TORCH_FN(wrapper_CUDA___cslt_sparse_mm));
m.impl("_cslt_sparse_mm_search",
TORCH_FN(wrapper_CUDA___cslt_sparse_mm_search));
m.impl("_sparse_semi_structured_linear",
TORCH_FN(wrapper_CUDA___sparse_semi_structured_linear));
m.impl("_mixed_dtypes_linear",
TORCH_FN(wrapper_CUDA___mixed_dtypes_linear));
m.impl("linspace.out",
TORCH_FN(wrapper_CUDA_out_linspace_out));
m.impl("log", TORCH_FN(wrapper_CUDA_log));
m.impl("log.out", TORCH_FN(wrapper_CUDA_log_out_out));
m.impl("log_", TORCH_FN(wrapper_CUDA_log_));
m.impl("log10", TORCH_FN(wrapper_CUDA_log10));
m.impl("log10.out", TORCH_FN(wrapper_CUDA_log10_out_out));
m.impl("log10_", TORCH_FN(wrapper_CUDA_log10_));
m.impl("log1p", TORCH_FN(wrapper_CUDA_log1p));
m.impl("log1p.out", TORCH_FN(wrapper_CUDA_log1p_out_out));
m.impl("log1p_", TORCH_FN(wrapper_CUDA_log1p_));
m.impl("log2", TORCH_FN(wrapper_CUDA_log2));
m.impl("log2.out", TORCH_FN(wrapper_CUDA_log2_out_out));
m.impl("log2_", TORCH_FN(wrapper_CUDA_log2_));
m.impl("logaddexp", TORCH_FN(wrapper_CUDA_logaddexp));
m.impl("logaddexp.out", TORCH_FN(wrapper_CUDA_logaddexp_out_out));
m.impl("logaddexp2", TORCH_FN(wrapper_CUDA_logaddexp2));
m.impl("logaddexp2.out", TORCH_FN(wrapper_CUDA_logaddexp2_out_out));
m.impl("xlogy.Tensor", TORCH_FN(wrapper_CUDA_xlogy_Tensor));
m.impl("xlogy.OutTensor", TORCH_FN(wrapper_CUDA_xlogy_out_OutTensor));
m.impl("xlogy_.Tensor", TORCH_FN(wrapper_CUDA_xlogy__Tensor));
m.impl("logspace.out",
TORCH_FN(wrapper_CUDA_out_logspace_out));
m.impl("_log_softmax", TORCH_FN(wrapper_CUDA__log_softmax));
m.impl("_log_softmax.out", TORCH_FN(wrapper_CUDA__log_softmax_out_out));
m.impl("_log_softmax_backward_data", TORCH_FN(wrapper_CUDA__log_softmax_backward_data));
m.impl("_log_softmax_backward_data.out", TORCH_FN(wrapper_CUDA__log_softmax_backward_data_out_out));
m.impl("_logcumsumexp",
TORCH_FN(wrapper_CUDA___logcumsumexp));
m.impl("_logcumsumexp.out",
TORCH_FN(wrapper_CUDA_out__logcumsumexp_out));
m.impl("_aminmax",
TORCH_FN(wrapper_CUDA___aminmax));
m.impl("_aminmax.dim",
TORCH_FN(wrapper_CUDA_dim__aminmax));
m.impl("aminmax", TORCH_FN(wrapper_CUDA_aminmax));
m.impl("aminmax.out", TORCH_FN(wrapper_CUDA_aminmax_out_out));
m.impl("_compute_linear_combination",
TORCH_FN(wrapper_CUDA___compute_linear_combination));
m.impl("_compute_linear_combination.out",
TORCH_FN(wrapper_CUDA_out__compute_linear_combination_out));
m.impl("max.dim", TORCH_FN(wrapper_CUDA_max_dim));
m.impl("max.dim_max", TORCH_FN(wrapper_CUDA_max_out_dim_max));
m.impl("amax", TORCH_FN(wrapper_CUDA_amax));
m.impl("amax.out", TORCH_FN(wrapper_CUDA_amax_out_out));
m.impl("mean.dim", TORCH_FN(wrapper_CUDA_mean_dim));
m.impl("mean.out", TORCH_FN(wrapper_CUDA_mean_out_out));
m.impl("median",
TORCH_FN(wrapper_CUDA__median));
m.impl("median.dim_values",
TORCH_FN(wrapper_CUDA_dim_values_median_out));
m.impl("nanmedian",
TORCH_FN(wrapper_CUDA__nanmedian));
m.impl("nanmedian.dim_values",
TORCH_FN(wrapper_CUDA_dim_values_nanmedian_out));
m.impl("min.dim", TORCH_FN(wrapper_CUDA_min_dim));
m.impl("min.dim_min", TORCH_FN(wrapper_CUDA_min_out_dim_min));
m.impl("amin", TORCH_FN(wrapper_CUDA_amin));
m.impl("amin.out", TORCH_FN(wrapper_CUDA_amin_out_out));
m.impl("miopen_batch_norm",
TORCH_FN(wrapper_CUDA__miopen_batch_norm));
m.impl("miopen_batch_norm_backward",
TORCH_FN(wrapper_CUDA__miopen_batch_norm_backward));
m.impl("miopen_convolution",
TORCH_FN(wrapper_CUDA__miopen_convolution));
m.impl("miopen_convolution_transpose",
TORCH_FN(wrapper_CUDA__miopen_convolution_transpose));
m.impl("miopen_depthwise_convolution",
TORCH_FN(wrapper_CUDA__miopen_depthwise_convolution));
m.impl("miopen_convolution_relu",
TORCH_FN(wrapper_CUDA__miopen_convolution_relu));
m.impl("miopen_convolution_add_relu",
TORCH_FN(wrapper_CUDA__miopen_convolution_add_relu));
m.impl("miopen_rnn",
TORCH_FN(wrapper_CUDA__miopen_rnn));
m.impl("miopen_rnn_backward",
TORCH_FN(wrapper_CUDA__miopen_rnn_backward));
m.impl("mm", TORCH_FN(wrapper_CUDA_mm));
m.impl("mm.out", TORCH_FN(wrapper_CUDA_mm_out_out));
m.impl("_int_mm",
TORCH_FN(wrapper_CUDA___int_mm));
m.impl("_int_mm.out",
TORCH_FN(wrapper_CUDA_out__int_mm_out));
m.impl("_convert_weight_to_int4pack",
TORCH_FN(wrapper_CUDA___convert_weight_to_int4pack));
m.impl("_weight_int4pack_mm",
TORCH_FN(wrapper_CUDA___weight_int4pack_mm));
m.impl("mode",
TORCH_FN(wrapper_CUDA__mode));
m.impl("mul.Tensor", TORCH_FN(wrapper_CUDA_mul_Tensor));
m.impl("mul.out", TORCH_FN(wrapper_CUDA_mul_out_out));
m.impl("mul_.Tensor", TORCH_FN(wrapper_CUDA_mul__Tensor));
m.impl("mvlgamma.out",
TORCH_FN(wrapper_CUDA_out_mvlgamma_out));
m.impl("native_batch_norm",
TORCH_FN(wrapper_CUDA__native_batch_norm));
m.impl("native_batch_norm.out",
TORCH_FN(wrapper_CUDA_out_native_batch_norm_out));
m.impl("_native_batch_norm_legit.out",
TORCH_FN(wrapper_CUDA_out__native_batch_norm_legit_out));
m.impl("_native_batch_norm_legit",
TORCH_FN(wrapper_CUDA___native_batch_norm_legit));
m.impl("_native_batch_norm_legit.no_stats",
TORCH_FN(wrapper_CUDA_no_stats__native_batch_norm_legit));
m.impl("_native_batch_norm_legit.no_stats_out",
TORCH_FN(wrapper_CUDA_no_stats_out__native_batch_norm_legit_out));
m.impl("batch_norm_stats",
TORCH_FN(wrapper_CUDA__batch_norm_stats));
m.impl("batch_norm_elemt",
TORCH_FN(wrapper_CUDA__batch_norm_elemt));
m.impl("batch_norm_elemt.out",
TORCH_FN(wrapper_CUDA_out_batch_norm_elemt_out));
m.impl("batch_norm_gather_stats",
TORCH_FN(wrapper_CUDA__batch_norm_gather_stats));
m.impl("batch_norm_gather_stats_with_counts",
TORCH_FN(wrapper_CUDA__batch_norm_gather_stats_with_counts));
m.impl("native_batch_norm_backward",
TORCH_FN(wrapper_CUDA__native_batch_norm_backward));
m.impl("batch_norm_backward_reduce",
TORCH_FN(wrapper_CUDA__batch_norm_backward_reduce));
m.impl("batch_norm_backward_elemt",
TORCH_FN(wrapper_CUDA__batch_norm_backward_elemt));
m.impl("batch_norm_update_stats",
TORCH_FN(wrapper_CUDA__batch_norm_update_stats));
m.impl("_cdist_forward",
TORCH_FN(wrapper_CUDA___cdist_forward));
m.impl("_cdist_backward",
TORCH_FN(wrapper_CUDA___cdist_backward));
m.impl("_pdist_forward",
TORCH_FN(wrapper_CUDA___pdist_forward));
m.impl("_pdist_backward",
TORCH_FN(wrapper_CUDA___pdist_backward));
m.impl("channel_shuffle",
TORCH_FN(wrapper_CUDA__channel_shuffle));
m.impl("is_pinned",
TORCH_FN(wrapper_CUDA__is_pinned));
m.impl("_pin_memory",
TORCH_FN(wrapper_CUDA___pin_memory));
m.impl("randperm.generator_out",
TORCH_FN(wrapper_CUDA_generator_out_randperm_out));
m.impl("range.out",
TORCH_FN(wrapper_CUDA_out_range_out));
m.impl("reciprocal", TORCH_FN(wrapper_CUDA_reciprocal));
m.impl("reciprocal.out", TORCH_FN(wrapper_CUDA_reciprocal_out_out));
m.impl("reciprocal_", TORCH_FN(wrapper_CUDA_reciprocal_));
m.impl("neg", TORCH_FN(wrapper_CUDA_neg));
m.impl("neg.out", TORCH_FN(wrapper_CUDA_neg_out_out));
m.impl("neg_", TORCH_FN(wrapper_CUDA_neg_));
m.impl("repeat_interleave.Tensor",
TORCH_FN(wrapper_CUDA_Tensor_repeat_interleave));
m.impl("_reshape_alias",
TORCH_FN(wrapper_CUDA___reshape_alias));
m.impl("round", TORCH_FN(wrapper_CUDA_round));
m.impl("round.out", TORCH_FN(wrapper_CUDA_round_out_out));
m.impl("round_", TORCH_FN(wrapper_CUDA_round_));
m.impl("round.decimals", TORCH_FN(wrapper_CUDA_round_decimals));
m.impl("round.decimals_out", TORCH_FN(wrapper_CUDA_round_out_decimals_out));
m.impl("round_.decimals", TORCH_FN(wrapper_CUDA_round__decimals));
m.impl("relu",
TORCH_FN(wrapper_CUDA__relu));
m.impl("relu_",
TORCH_FN(wrapper_CUDA__relu_));
m.impl("_prelu_kernel",
TORCH_FN(wrapper_CUDA___prelu_kernel));
m.impl("_prelu_kernel_backward",
TORCH_FN(wrapper_CUDA___prelu_kernel_backward));
m.impl("gelu", TORCH_FN(wrapper_CUDA_gelu));
m.impl("gelu.out", TORCH_FN(wrapper_CUDA_gelu_out_out));
m.impl("gelu_", TORCH_FN(wrapper_CUDA_gelu_));
m.impl("gelu_backward", TORCH_FN(wrapper_CUDA_gelu_backward));
m.impl("gelu_backward.grad_input", TORCH_FN(wrapper_CUDA_gelu_backward_out_grad_input));
m.impl("hardshrink", TORCH_FN(wrapper_CUDA_hardshrink));
m.impl("hardshrink.out", TORCH_FN(wrapper_CUDA_hardshrink_out_out));
m.impl("hardshrink_backward", TORCH_FN(wrapper_CUDA_hardshrink_backward));
m.impl("hardshrink_backward.grad_input", TORCH_FN(wrapper_CUDA_hardshrink_backward_out_grad_input));
m.impl("rsqrt", TORCH_FN(wrapper_CUDA_rsqrt));
m.impl("rsqrt.out", TORCH_FN(wrapper_CUDA_rsqrt_out_out));
m.impl("rsqrt_", TORCH_FN(wrapper_CUDA_rsqrt_));
m.impl("silu", TORCH_FN(wrapper_CUDA_silu));
m.impl("silu.out", TORCH_FN(wrapper_CUDA_silu_out_out));
m.impl("silu_", TORCH_FN(wrapper_CUDA_silu_));
m.impl("silu_backward", TORCH_FN(wrapper_CUDA_silu_backward));
m.impl("silu_backward.grad_input", TORCH_FN(wrapper_CUDA_silu_backward_out_grad_input));
m.impl("mish", TORCH_FN(wrapper_CUDA_mish));
m.impl("mish.out", TORCH_FN(wrapper_CUDA_mish_out_out));
m.impl("mish_", TORCH_FN(wrapper_CUDA_mish_));
m.impl("mish_backward",
TORCH_FN(wrapper_CUDA__mish_backward));
m.impl("sigmoid", TORCH_FN(wrapper_CUDA_sigmoid));
m.impl("sigmoid.out", TORCH_FN(wrapper_CUDA_sigmoid_out_out));
m.impl("sigmoid_", TORCH_FN(wrapper_CUDA_sigmoid_));
m.impl("logit",
TORCH_FN(wrapper_CUDA__logit));
m.impl("logit.out",
TORCH_FN(wrapper_CUDA_out_logit_out));
m.impl("logit_",
TORCH_FN(wrapper_CUDA__logit_));
m.impl("sin", TORCH_FN(wrapper_CUDA_sin));
m.impl("sin.out", TORCH_FN(wrapper_CUDA_sin_out_out));
m.impl("sin_", TORCH_FN(wrapper_CUDA_sin_));
m.impl("sinc", TORCH_FN(wrapper_CUDA_sinc));
m.impl("sinc.out", TORCH_FN(wrapper_CUDA_sinc_out_out));
m.impl("sinc_", TORCH_FN(wrapper_CUDA_sinc_));
m.impl("sinh", TORCH_FN(wrapper_CUDA_sinh));
m.impl("sinh.out", TORCH_FN(wrapper_CUDA_sinh_out_out));
m.impl("sinh_", TORCH_FN(wrapper_CUDA_sinh_));
m.impl("_softmax", TORCH_FN(wrapper_CUDA__softmax));
m.impl("_softmax.out", TORCH_FN(wrapper_CUDA__softmax_out_out));
m.impl("_softmax_backward_data", TORCH_FN(wrapper_CUDA__softmax_backward_data));
m.impl("_softmax_backward_data.out", TORCH_FN(wrapper_CUDA__softmax_backward_data_out_out));
m.impl("sspaddmm.out",
TORCH_FN(wrapper_CUDA_out_sspaddmm_out));
m.impl("sum.dim_IntList", TORCH_FN(wrapper_CUDA_sum_dim_IntList));
m.impl("sum.IntList_out", TORCH_FN(wrapper_CUDA_sum_out_IntList_out));
m.impl("nansum",
TORCH_FN(wrapper_CUDA__nansum));
m.impl("nansum.out",
TORCH_FN(wrapper_CUDA_out_nansum_out));
m.impl("sqrt", TORCH_FN(wrapper_CUDA_sqrt));
m.impl("sqrt.out", TORCH_FN(wrapper_CUDA_sqrt_out_out));
m.impl("sqrt_", TORCH_FN(wrapper_CUDA_sqrt_));
m.impl("std.correction",
TORCH_FN(wrapper_CUDA_correction_std));
m.impl("std.correction_out",
TORCH_FN(wrapper_CUDA_correction_out_std_out));
m.impl("std_mean.correction",
TORCH_FN(wrapper_CUDA_correction_std_mean));
m.impl("prod",
TORCH_FN(wrapper_CUDA__prod));
m.impl("prod.dim_int", TORCH_FN(wrapper_CUDA_prod_dim_int));
m.impl("prod.int_out", TORCH_FN(wrapper_CUDA_prod_out_int_out));
m.impl("tan", TORCH_FN(wrapper_CUDA_tan));
m.impl("tan.out", TORCH_FN(wrapper_CUDA_tan_out_out));
m.impl("tan_", TORCH_FN(wrapper_CUDA_tan_));
m.impl("tanh", TORCH_FN(wrapper_CUDA_tanh));
m.impl("tanh.out", TORCH_FN(wrapper_CUDA_tanh_out_out));
m.impl("tanh_", TORCH_FN(wrapper_CUDA_tanh_));
m.impl("threshold", TORCH_FN(wrapper_CUDA_threshold));
m.impl("threshold.out", TORCH_FN(wrapper_CUDA_threshold_out_out));
m.impl("threshold_", TORCH_FN(wrapper_CUDA_threshold_));
m.impl("threshold_backward", TORCH_FN(wrapper_CUDA_threshold_backward));
m.impl("threshold_backward.grad_input", TORCH_FN(wrapper_CUDA_threshold_backward_out_grad_input));
m.impl("flip",
TORCH_FN(wrapper_CUDA__flip));
m.impl("roll",
TORCH_FN(wrapper_CUDA__roll));
m.impl("_transform_bias_rescale_qkv",
TORCH_FN(wrapper_CUDA___transform_bias_rescale_qkv));
m.impl("_nested_tensor_from_mask",
TORCH_FN(wrapper_CUDA___nested_tensor_from_mask));
m.impl("_nested_tensor_from_mask_left_aligned",
TORCH_FN(wrapper_CUDA___nested_tensor_from_mask_left_aligned));
m.impl("_nested_from_padded",
TORCH_FN(wrapper_CUDA___nested_from_padded));
m.impl("_nested_view_from_buffer",
TORCH_FN(wrapper_CUDA___nested_view_from_buffer));
m.impl("trunc", TORCH_FN(wrapper_CUDA_trunc));
m.impl("trunc.out", TORCH_FN(wrapper_CUDA_trunc_out_out));
m.impl("trunc_", TORCH_FN(wrapper_CUDA_trunc_));
m.impl("_unique",
TORCH_FN(wrapper_CUDA___unique));
m.impl("unique_dim",
TORCH_FN(wrapper_CUDA__unique_dim));
m.impl("unique_consecutive",
TORCH_FN(wrapper_CUDA__unique_consecutive));
m.impl("unique_dim_consecutive",
TORCH_FN(wrapper_CUDA__unique_dim_consecutive));
m.impl("_unique2",
TORCH_FN(wrapper_CUDA___unique2));
m.impl("var.correction",
TORCH_FN(wrapper_CUDA_correction_var));
m.impl("var.correction_out",
TORCH_FN(wrapper_CUDA_correction_out_var_out));
m.impl("var_mean.correction",
TORCH_FN(wrapper_CUDA_correction_var_mean));
m.impl("where.self",
TORCH_FN(wrapper_CUDA_self_where));
m.impl("where.self_out",
TORCH_FN(wrapper_CUDA_self_out_where_out));
m.impl("_weight_norm_interface",
TORCH_FN(wrapper_CUDA___weight_norm_interface));
m.impl("_weight_norm_interface_backward",
TORCH_FN(wrapper_CUDA___weight_norm_interface_backward));
m.impl("_efficientzerotensor",
TORCH_FN(wrapper_CUDA___efficientzerotensor));
m.impl("_standard_gamma_grad",
TORCH_FN(wrapper_CUDA___standard_gamma_grad));
m.impl("_standard_gamma",
TORCH_FN(wrapper_CUDA___standard_gamma));
m.impl("_dirichlet_grad",
TORCH_FN(wrapper_CUDA___dirichlet_grad));
m.impl("_sample_dirichlet",
TORCH_FN(wrapper_CUDA___sample_dirichlet));
m.impl("poisson",
TORCH_FN(wrapper_CUDA__poisson));
m.impl("binomial",
TORCH_FN(wrapper_CUDA__binomial));
m.impl("norm.ScalarOpt_dim_dtype", TORCH_FN(wrapper_CUDA_norm_ScalarOpt_dim_dtype));
m.impl("norm.dtype_out", TORCH_FN(wrapper_CUDA_norm_out_dtype_out));
m.impl("norm.ScalarOpt_dim", TORCH_FN(wrapper_CUDA_norm_ScalarOpt_dim));
m.impl("norm.out", TORCH_FN(wrapper_CUDA_norm_out_out));
m.impl("frexp.Tensor_out",
TORCH_FN(wrapper_CUDA_Tensor_out_frexp_out));
m.impl("zero_",
TORCH_FN(wrapper_CUDA__zero_));
m.impl("sub.Tensor", TORCH_FN(wrapper_CUDA_sub_Tensor));
m.impl("sub.out", TORCH_FN(wrapper_CUDA_sub_out_out));
m.impl("sub_.Tensor", TORCH_FN(wrapper_CUDA_sub__Tensor));
m.impl("rsub.Tensor",
TORCH_FN(wrapper_CUDA_Tensor_rsub));
m.impl("heaviside", TORCH_FN(wrapper_CUDA_heaviside));
m.impl("heaviside.out", TORCH_FN(wrapper_CUDA_heaviside_out_out));
m.impl("heaviside_", TORCH_FN(wrapper_CUDA_heaviside_));
m.impl("addmm", TORCH_FN(wrapper_CUDA_addmm));
m.impl("addmm.out", TORCH_FN(wrapper_CUDA_addmm_out_out));
m.impl("addmm_", TORCH_FN(wrapper_CUDA_addmm_));
m.impl("_addmm_activation", TORCH_FN(wrapper_CUDA__addmm_activation));
m.impl("_addmm_activation.out", TORCH_FN(wrapper_CUDA__addmm_activation_out_out));
m.impl("_scaled_mm",
TORCH_FN(wrapper_CUDA___scaled_mm));
m.impl("_scaled_mm.out",
TORCH_FN(wrapper_CUDA_out__scaled_mm_out));
m.impl("sparse_dim",
TORCH_FN(wrapper_CUDA__sparse_dim));
m.impl("dense_dim",
TORCH_FN(wrapper_CUDA__dense_dim));
m.impl("_to_sparse.sparse_dim",
TORCH_FN(wrapper_CUDA_sparse_dim__to_sparse));
m.impl("_to_sparse",
TORCH_FN(wrapper_CUDA___to_sparse));
m.impl("_to_sparse_csr",
TORCH_FN(wrapper_CUDA___to_sparse_csr));
m.impl("_to_sparse_csc",
TORCH_FN(wrapper_CUDA___to_sparse_csc));
m.impl("_to_sparse_bsr",
TORCH_FN(wrapper_CUDA___to_sparse_bsr));
m.impl("_to_sparse_bsc",
TORCH_FN(wrapper_CUDA___to_sparse_bsc));
m.impl("_to_sparse_semi_structured",
TORCH_FN(wrapper_CUDA___to_sparse_semi_structured));
m.impl("quantize_per_tensor_dynamic",
TORCH_FN(wrapper_CUDA__quantize_per_tensor_dynamic));
m.impl("quantize_per_tensor",
TORCH_FN(wrapper_CUDA__quantize_per_tensor));
m.impl("quantize_per_tensor.tensor_qparams",
TORCH_FN(wrapper_CUDA_tensor_qparams_quantize_per_tensor));
m.impl("quantize_per_channel",
TORCH_FN(wrapper_CUDA__quantize_per_channel));
m.impl("dequantize.self",
TORCH_FN(wrapper_CUDA_self_dequantize));
m.impl("_make_per_tensor_quantized_tensor",
TORCH_FN(wrapper_CUDA___make_per_tensor_quantized_tensor));
m.impl("_make_per_channel_quantized_tensor",
TORCH_FN(wrapper_CUDA___make_per_channel_quantized_tensor));
m.impl("fake_quantize_per_tensor_affine_cachemask",
TORCH_FN(wrapper_CUDA__fake_quantize_per_tensor_affine_cachemask));
m.impl("_fake_quantize_per_tensor_affine_cachemask_tensor_qparams",
TORCH_FN(wrapper_CUDA___fake_quantize_per_tensor_affine_cachemask_tensor_qparams));
m.impl("_fake_quantize_learnable_per_tensor_affine",
TORCH_FN(wrapper_CUDA___fake_quantize_learnable_per_tensor_affine));
m.impl("_fake_quantize_learnable_per_tensor_affine_backward",
TORCH_FN(wrapper_CUDA___fake_quantize_learnable_per_tensor_affine_backward));
m.impl("fake_quantize_per_channel_affine_cachemask",
TORCH_FN(wrapper_CUDA__fake_quantize_per_channel_affine_cachemask));
m.impl("_fake_quantize_learnable_per_channel_affine",
TORCH_FN(wrapper_CUDA___fake_quantize_learnable_per_channel_affine));
m.impl("_fake_quantize_learnable_per_channel_affine_backward",
TORCH_FN(wrapper_CUDA___fake_quantize_learnable_per_channel_affine_backward));
m.impl("_fused_moving_avg_obs_fq_helper",
TORCH_FN(wrapper_CUDA___fused_moving_avg_obs_fq_helper));
m.impl("_local_scalar_dense",
TORCH_FN(wrapper_CUDA___local_scalar_dense));
m.impl("_thnn_fused_lstm_cell",
TORCH_FN(wrapper_CUDA___thnn_fused_lstm_cell));
m.impl("_thnn_fused_lstm_cell_backward_impl",
TORCH_FN(wrapper_CUDA___thnn_fused_lstm_cell_backward_impl));
m.impl("_thnn_fused_gru_cell",
TORCH_FN(wrapper_CUDA___thnn_fused_gru_cell));
m.impl("_thnn_fused_gru_cell_backward",
TORCH_FN(wrapper_CUDA___thnn_fused_gru_cell_backward));
m.impl("set_.source_Storage",
TORCH_FN(wrapper_CUDA_source_Storage_set_));
m.impl("set_.source_Storage_storage_offset",
TORCH_FN(wrapper_CUDA_source_Storage_storage_offset_set_));
m.impl("set_.source_Tensor",
TORCH_FN(wrapper_CUDA_source_Tensor_set_));
m.impl("set_",
TORCH_FN(wrapper_CUDA__set_));
m.impl("is_set_to",
TORCH_FN(wrapper_CUDA__is_set_to));
m.impl("masked_fill_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar_masked_fill_));
m.impl("masked_fill_.Tensor",
TORCH_FN(wrapper_CUDA_Tensor_masked_fill_));
m.impl("masked_scatter_",
TORCH_FN(wrapper_CUDA__masked_scatter_));
m.impl("_masked_softmax",
TORCH_FN(wrapper_CUDA___masked_softmax));
m.impl("_masked_softmax_backward",
TORCH_FN(wrapper_CUDA___masked_softmax_backward));
m.impl("view",
TORCH_FN(wrapper_CUDA__view));
m.impl("put_",
TORCH_FN(wrapper_CUDA__put_));
m.impl("index_add", TORCH_FN(wrapper_CUDA_index_add));
m.impl("index_add.out", TORCH_FN(wrapper_CUDA_index_add_out_out));
m.impl("index_add_", TORCH_FN(wrapper_CUDA_index_add_));
m.impl("index_reduce", TORCH_FN(wrapper_CUDA_index_reduce));
m.impl("index_reduce.out", TORCH_FN(wrapper_CUDA_index_reduce_out_out));
m.impl("index_reduce_", TORCH_FN(wrapper_CUDA_index_reduce_));
m.impl("index_fill_.int_Scalar",
TORCH_FN(wrapper_CUDA_int_Scalar_index_fill_));
m.impl("index_fill_.int_Tensor",
TORCH_FN(wrapper_CUDA_int_Tensor_index_fill_));
m.impl("scatter.src", TORCH_FN(wrapper_CUDA_scatter_src));
m.impl("scatter.src_out", TORCH_FN(wrapper_CUDA_scatter_out_src_out));
m.impl("scatter_.src", TORCH_FN(wrapper_CUDA_scatter__src));
m.impl("scatter.value", TORCH_FN(wrapper_CUDA_scatter_value));
m.impl("scatter.value_out", TORCH_FN(wrapper_CUDA_scatter_out_value_out));
m.impl("scatter_.value", TORCH_FN(wrapper_CUDA_scatter__value));
m.impl("scatter.reduce", TORCH_FN(wrapper_CUDA_scatter_reduce));
m.impl("scatter.reduce_out", TORCH_FN(wrapper_CUDA_scatter_out_reduce_out));
m.impl("scatter_.reduce", TORCH_FN(wrapper_CUDA_scatter__reduce));
m.impl("scatter.value_reduce", TORCH_FN(wrapper_CUDA_scatter_value_reduce));
m.impl("scatter.value_reduce_out", TORCH_FN(wrapper_CUDA_scatter_out_value_reduce_out));
m.impl("scatter_.value_reduce", TORCH_FN(wrapper_CUDA_scatter__value_reduce));
m.impl("scatter_add", TORCH_FN(wrapper_CUDA_scatter_add));
m.impl("scatter_add.out", TORCH_FN(wrapper_CUDA_scatter_add_out_out));
m.impl("scatter_add_", TORCH_FN(wrapper_CUDA_scatter_add_));
m.impl("scatter_reduce.two", TORCH_FN(wrapper_CUDA_scatter_reduce_two));
m.impl("scatter_reduce.two_out", TORCH_FN(wrapper_CUDA_scatter_reduce_out_two_out));
m.impl("scatter_reduce_.two", TORCH_FN(wrapper_CUDA_scatter_reduce__two));
m.impl("eq.Scalar", TORCH_FN(wrapper_CUDA_eq_Scalar));
m.impl("eq.Scalar_out", TORCH_FN(wrapper_CUDA_eq_out_Scalar_out));
m.impl("eq_.Scalar", TORCH_FN(wrapper_CUDA_eq__Scalar));
m.impl("eq.Tensor", TORCH_FN(wrapper_CUDA_eq_Tensor));
m.impl("eq.Tensor_out", TORCH_FN(wrapper_CUDA_eq_out_Tensor_out));
m.impl("eq_.Tensor", TORCH_FN(wrapper_CUDA_eq__Tensor));
m.impl("bitwise_and.Tensor", TORCH_FN(wrapper_CUDA_bitwise_and_Tensor));
m.impl("bitwise_and.Tensor_out", TORCH_FN(wrapper_CUDA_bitwise_and_out_Tensor_out));
m.impl("bitwise_and_.Tensor", TORCH_FN(wrapper_CUDA_bitwise_and__Tensor));
m.impl("bitwise_or.Tensor", TORCH_FN(wrapper_CUDA_bitwise_or_Tensor));
m.impl("bitwise_or.Tensor_out", TORCH_FN(wrapper_CUDA_bitwise_or_out_Tensor_out));
m.impl("bitwise_or_.Tensor", TORCH_FN(wrapper_CUDA_bitwise_or__Tensor));
m.impl("bitwise_xor.Tensor", TORCH_FN(wrapper_CUDA_bitwise_xor_Tensor));
m.impl("bitwise_xor.Tensor_out", TORCH_FN(wrapper_CUDA_bitwise_xor_out_Tensor_out));
m.impl("bitwise_xor_.Tensor", TORCH_FN(wrapper_CUDA_bitwise_xor__Tensor));
m.impl("__lshift__.Scalar",
TORCH_FN(wrapper_CUDA_Scalar___lshift__));
m.impl("__ilshift__.Scalar",
TORCH_FN(wrapper_CUDA_Scalar___ilshift__));
m.impl("__lshift__.Tensor",
TORCH_FN(wrapper_CUDA_Tensor___lshift__));
m.impl("__ilshift__.Tensor",
TORCH_FN(wrapper_CUDA_Tensor___ilshift__));
m.impl("bitwise_left_shift.Tensor", TORCH_FN(wrapper_CUDA_bitwise_left_shift_Tensor));
m.impl("bitwise_left_shift.Tensor_out", TORCH_FN(wrapper_CUDA_bitwise_left_shift_out_Tensor_out));
m.impl("bitwise_left_shift_.Tensor", TORCH_FN(wrapper_CUDA_bitwise_left_shift__Tensor));
m.impl("__rshift__.Scalar",
TORCH_FN(wrapper_CUDA_Scalar___rshift__));
m.impl("__irshift__.Scalar",
TORCH_FN(wrapper_CUDA_Scalar___irshift__));
m.impl("__rshift__.Tensor",
TORCH_FN(wrapper_CUDA_Tensor___rshift__));
m.impl("__irshift__.Tensor",
TORCH_FN(wrapper_CUDA_Tensor___irshift__));
m.impl("bitwise_right_shift.Tensor", TORCH_FN(wrapper_CUDA_bitwise_right_shift_Tensor));
m.impl("bitwise_right_shift.Tensor_out", TORCH_FN(wrapper_CUDA_bitwise_right_shift_out_Tensor_out));
m.impl("bitwise_right_shift_.Tensor", TORCH_FN(wrapper_CUDA_bitwise_right_shift__Tensor));
m.impl("tril", TORCH_FN(wrapper_CUDA_tril));
m.impl("tril.out", TORCH_FN(wrapper_CUDA_tril_out_out));
m.impl("tril_", TORCH_FN(wrapper_CUDA_tril_));
m.impl("triu", TORCH_FN(wrapper_CUDA_triu));
m.impl("triu.out", TORCH_FN(wrapper_CUDA_triu_out_out));
m.impl("triu_", TORCH_FN(wrapper_CUDA_triu_));
m.impl("digamma", TORCH_FN(wrapper_CUDA_digamma));
m.impl("digamma.out", TORCH_FN(wrapper_CUDA_digamma_out_out));
m.impl("digamma_", TORCH_FN(wrapper_CUDA_digamma_));
m.impl("lerp.Scalar", TORCH_FN(wrapper_CUDA_lerp_Scalar));
m.impl("lerp.Scalar_out", TORCH_FN(wrapper_CUDA_lerp_out_Scalar_out));
m.impl("lerp_.Scalar", TORCH_FN(wrapper_CUDA_lerp__Scalar));
m.impl("lerp.Tensor", TORCH_FN(wrapper_CUDA_lerp_Tensor));
m.impl("lerp.Tensor_out", TORCH_FN(wrapper_CUDA_lerp_out_Tensor_out));
m.impl("lerp_.Tensor", TORCH_FN(wrapper_CUDA_lerp__Tensor));
m.impl("addbmm",
TORCH_FN(wrapper_CUDA__addbmm));
m.impl("addbmm.out",
TORCH_FN(wrapper_CUDA_out_addbmm_out));
m.impl("addbmm_",
TORCH_FN(wrapper_CUDA__addbmm_));
m.impl("random_.from",
TORCH_FN(wrapper_CUDA_from_random_));
m.impl("random_.to",
TORCH_FN(wrapper_CUDA_to_random_));
m.impl("random_",
TORCH_FN(wrapper_CUDA__random_));
m.impl("uniform_",
TORCH_FN(wrapper_CUDA__uniform_));
m.impl("cauchy_",
TORCH_FN(wrapper_CUDA__cauchy_));
m.impl("log_normal_",
TORCH_FN(wrapper_CUDA__log_normal_));
m.impl("exponential_",
TORCH_FN(wrapper_CUDA__exponential_));
m.impl("geometric_",
TORCH_FN(wrapper_CUDA__geometric_));
m.impl("tril_indices",
TORCH_FN(wrapper_CUDA__tril_indices));
m.impl("triu_indices",
TORCH_FN(wrapper_CUDA__triu_indices));
m.impl("trace",
TORCH_FN(wrapper_CUDA__trace));
m.impl("ne.Scalar", TORCH_FN(wrapper_CUDA_ne_Scalar));
m.impl("ne.Scalar_out", TORCH_FN(wrapper_CUDA_ne_out_Scalar_out));
m.impl("ne_.Scalar", TORCH_FN(wrapper_CUDA_ne__Scalar));
m.impl("ne.Tensor", TORCH_FN(wrapper_CUDA_ne_Tensor));
m.impl("ne.Tensor_out", TORCH_FN(wrapper_CUDA_ne_out_Tensor_out));
m.impl("ne_.Tensor", TORCH_FN(wrapper_CUDA_ne__Tensor));
m.impl("ge.Scalar", TORCH_FN(wrapper_CUDA_ge_Scalar));
m.impl("ge.Scalar_out", TORCH_FN(wrapper_CUDA_ge_out_Scalar_out));
m.impl("ge_.Scalar", TORCH_FN(wrapper_CUDA_ge__Scalar));
m.impl("ge.Tensor", TORCH_FN(wrapper_CUDA_ge_Tensor));
m.impl("ge.Tensor_out", TORCH_FN(wrapper_CUDA_ge_out_Tensor_out));
m.impl("ge_.Tensor", TORCH_FN(wrapper_CUDA_ge__Tensor));
m.impl("le.Scalar", TORCH_FN(wrapper_CUDA_le_Scalar));
m.impl("le.Scalar_out", TORCH_FN(wrapper_CUDA_le_out_Scalar_out));
m.impl("le_.Scalar", TORCH_FN(wrapper_CUDA_le__Scalar));
m.impl("le.Tensor", TORCH_FN(wrapper_CUDA_le_Tensor));
m.impl("le.Tensor_out", TORCH_FN(wrapper_CUDA_le_out_Tensor_out));
m.impl("le_.Tensor", TORCH_FN(wrapper_CUDA_le__Tensor));
m.impl("gt.Scalar", TORCH_FN(wrapper_CUDA_gt_Scalar));
m.impl("gt.Scalar_out", TORCH_FN(wrapper_CUDA_gt_out_Scalar_out));
m.impl("gt_.Scalar", TORCH_FN(wrapper_CUDA_gt__Scalar));
m.impl("gt.Tensor", TORCH_FN(wrapper_CUDA_gt_Tensor));
m.impl("gt.Tensor_out", TORCH_FN(wrapper_CUDA_gt_out_Tensor_out));
m.impl("gt_.Tensor", TORCH_FN(wrapper_CUDA_gt__Tensor));
m.impl("lt.Scalar", TORCH_FN(wrapper_CUDA_lt_Scalar));
m.impl("lt.Scalar_out", TORCH_FN(wrapper_CUDA_lt_out_Scalar_out));
m.impl("lt_.Scalar", TORCH_FN(wrapper_CUDA_lt__Scalar));
m.impl("lt.Tensor", TORCH_FN(wrapper_CUDA_lt_Tensor));
m.impl("lt.Tensor_out", TORCH_FN(wrapper_CUDA_lt_out_Tensor_out));
m.impl("lt_.Tensor", TORCH_FN(wrapper_CUDA_lt__Tensor));
m.impl("take",
TORCH_FN(wrapper_CUDA__take));
m.impl("take.out",
TORCH_FN(wrapper_CUDA_out_take_out));
m.impl("index_select",
TORCH_FN(wrapper_CUDA__index_select));
m.impl("index_select.out",
TORCH_FN(wrapper_CUDA_out_index_select_out));
m.impl("masked_select",
TORCH_FN(wrapper_CUDA__masked_select));
m.impl("masked_select.out",
TORCH_FN(wrapper_CUDA_out_masked_select_out));
m.impl("nonzero",
TORCH_FN(wrapper_CUDA__nonzero));
m.impl("nonzero.out",
TORCH_FN(wrapper_CUDA_out_nonzero_out));
m.impl("gather", TORCH_FN(wrapper_CUDA_gather));
m.impl("gather.out", TORCH_FN(wrapper_CUDA_gather_out_out));
m.impl("addcmul", TORCH_FN(wrapper_CUDA_addcmul));
m.impl("addcmul.out", TORCH_FN(wrapper_CUDA_addcmul_out_out));
m.impl("addcmul_", TORCH_FN(wrapper_CUDA_addcmul_));
m.impl("addcdiv", TORCH_FN(wrapper_CUDA_addcdiv));
m.impl("addcdiv.out", TORCH_FN(wrapper_CUDA_addcdiv_out_out));
m.impl("addcdiv_", TORCH_FN(wrapper_CUDA_addcdiv_));
m.impl("triangular_solve", TORCH_FN(wrapper_CUDA_triangular_solve));
m.impl("triangular_solve.X", TORCH_FN(wrapper_CUDA_triangular_solve_out_X));
m.impl("linalg_solve_triangular",
TORCH_FN(wrapper_CUDA__linalg_solve_triangular));
m.impl("linalg_solve_triangular.out",
TORCH_FN(wrapper_CUDA_out_linalg_solve_triangular_out));
m.impl("cholesky",
TORCH_FN(wrapper_CUDA__cholesky));
m.impl("cholesky.out",
TORCH_FN(wrapper_CUDA_out_cholesky_out));
m.impl("_cholesky_solve_helper",
TORCH_FN(wrapper_CUDA___cholesky_solve_helper));
m.impl("cholesky_inverse",
TORCH_FN(wrapper_CUDA__cholesky_inverse));
m.impl("cholesky_inverse.out",
TORCH_FN(wrapper_CUDA_out_cholesky_inverse_out));
m.impl("geqrf",
TORCH_FN(wrapper_CUDA__geqrf));
m.impl("geqrf.a",
TORCH_FN(wrapper_CUDA_a_geqrf_out));
m.impl("ormqr",
TORCH_FN(wrapper_CUDA__ormqr));
m.impl("ormqr.out",
TORCH_FN(wrapper_CUDA_out_ormqr_out));
m.impl("lu_unpack", TORCH_FN(wrapper_CUDA_lu_unpack));
m.impl("lu_unpack.out", TORCH_FN(wrapper_CUDA_lu_unpack_out_out));
m.impl("multinomial",
TORCH_FN(wrapper_CUDA__multinomial));
m.impl("multinomial.out",
TORCH_FN(wrapper_CUDA_out_multinomial_out));
m.impl("lgamma", TORCH_FN(wrapper_CUDA_lgamma));
m.impl("lgamma.out", TORCH_FN(wrapper_CUDA_lgamma_out_out));
m.impl("lgamma_", TORCH_FN(wrapper_CUDA_lgamma_));
m.impl("polygamma", TORCH_FN(wrapper_CUDA_polygamma));
m.impl("polygamma.out", TORCH_FN(wrapper_CUDA_polygamma_out_out));
m.impl("erfinv", TORCH_FN(wrapper_CUDA_erfinv));
m.impl("erfinv.out", TORCH_FN(wrapper_CUDA_erfinv_out_out));
m.impl("erfinv_", TORCH_FN(wrapper_CUDA_erfinv_));
m.impl("i0", TORCH_FN(wrapper_CUDA_i0));
m.impl("i0.out", TORCH_FN(wrapper_CUDA_i0_out_out));
m.impl("i0_", TORCH_FN(wrapper_CUDA_i0_));
m.impl("sign", TORCH_FN(wrapper_CUDA_sign));
m.impl("sign.out", TORCH_FN(wrapper_CUDA_sign_out_out));
m.impl("sign_", TORCH_FN(wrapper_CUDA_sign_));
m.impl("signbit", TORCH_FN(wrapper_CUDA_signbit));
m.impl("signbit.out", TORCH_FN(wrapper_CUDA_signbit_out_out));
m.impl("atan2", TORCH_FN(wrapper_CUDA_atan2));
m.impl("atan2.out", TORCH_FN(wrapper_CUDA_atan2_out_out));
m.impl("atan2_", TORCH_FN(wrapper_CUDA_atan2_));
m.impl("histc",
TORCH_FN(wrapper_CUDA__histc));
m.impl("histc.out",
TORCH_FN(wrapper_CUDA_out_histc_out));
m.impl("fmod.Tensor", TORCH_FN(wrapper_CUDA_fmod_Tensor));
m.impl("fmod.Tensor_out", TORCH_FN(wrapper_CUDA_fmod_out_Tensor_out));
m.impl("fmod_.Tensor", TORCH_FN(wrapper_CUDA_fmod__Tensor));
m.impl("hypot", TORCH_FN(wrapper_CUDA_hypot));
m.impl("hypot.out", TORCH_FN(wrapper_CUDA_hypot_out_out));
m.impl("hypot_", TORCH_FN(wrapper_CUDA_hypot_));
m.impl("igamma", TORCH_FN(wrapper_CUDA_igamma));
m.impl("igamma.out", TORCH_FN(wrapper_CUDA_igamma_out_out));
m.impl("igamma_", TORCH_FN(wrapper_CUDA_igamma_));
m.impl("igammac", TORCH_FN(wrapper_CUDA_igammac));
m.impl("igammac.out", TORCH_FN(wrapper_CUDA_igammac_out_out));
m.impl("igammac_", TORCH_FN(wrapper_CUDA_igammac_));
m.impl("nextafter", TORCH_FN(wrapper_CUDA_nextafter));
m.impl("nextafter.out", TORCH_FN(wrapper_CUDA_nextafter_out_out));
m.impl("nextafter_", TORCH_FN(wrapper_CUDA_nextafter_));
m.impl("remainder.Tensor", TORCH_FN(wrapper_CUDA_remainder_Tensor));
m.impl("remainder.Tensor_out", TORCH_FN(wrapper_CUDA_remainder_out_Tensor_out));
m.impl("remainder_.Tensor", TORCH_FN(wrapper_CUDA_remainder__Tensor));
m.impl("remainder.Scalar_Tensor",
TORCH_FN(wrapper_CUDA_Scalar_Tensor_remainder));
m.impl("min",
TORCH_FN(wrapper_CUDA__min));
m.impl("min.unary_out",
TORCH_FN(wrapper_CUDA_unary_out_min_out));
m.impl("fmin", TORCH_FN(wrapper_CUDA_fmin));
m.impl("fmin.out", TORCH_FN(wrapper_CUDA_fmin_out_out));
m.impl("max",
TORCH_FN(wrapper_CUDA__max));
m.impl("max.unary_out",
TORCH_FN(wrapper_CUDA_unary_out_max_out));
m.impl("fmax", TORCH_FN(wrapper_CUDA_fmax));
m.impl("fmax.out", TORCH_FN(wrapper_CUDA_fmax_out_out));
m.impl("maximum", TORCH_FN(wrapper_CUDA_maximum));
m.impl("maximum.out", TORCH_FN(wrapper_CUDA_maximum_out_out));
m.impl("minimum", TORCH_FN(wrapper_CUDA_minimum));
m.impl("minimum.out", TORCH_FN(wrapper_CUDA_minimum_out_out));
m.impl("sort.stable", TORCH_FN(wrapper_CUDA_sort_stable));
m.impl("sort.values_stable", TORCH_FN(wrapper_CUDA_sort_out_values_stable));
m.impl("argsort.stable",
TORCH_FN(wrapper_CUDA_stable_argsort));
m.impl("topk", TORCH_FN(wrapper_CUDA_topk));
m.impl("topk.values", TORCH_FN(wrapper_CUDA_topk_out_values));
m.impl("all", TORCH_FN(wrapper_CUDA_all));
m.impl("all.all_out", TORCH_FN(wrapper_CUDA_all_out_all_out));
m.impl("any", TORCH_FN(wrapper_CUDA_any));
m.impl("any.all_out", TORCH_FN(wrapper_CUDA_any_out_all_out));
m.impl("renorm", TORCH_FN(wrapper_CUDA_renorm));
m.impl("renorm.out", TORCH_FN(wrapper_CUDA_renorm_out_out));
m.impl("renorm_", TORCH_FN(wrapper_CUDA_renorm_));
m.impl("unfold",
TORCH_FN(wrapper_CUDA__unfold));
m.impl("unfold_backward",
TORCH_FN(wrapper_CUDA__unfold_backward));
m.impl("equal",
TORCH_FN(wrapper_CUDA__equal));
m.impl("pow.Tensor_Tensor", TORCH_FN(wrapper_CUDA_pow_Tensor_Tensor));
m.impl("pow.Tensor_Tensor_out", TORCH_FN(wrapper_CUDA_pow_out_Tensor_Tensor_out));
m.impl("pow_.Tensor", TORCH_FN(wrapper_CUDA_pow__Tensor));
m.impl("pow.Scalar", TORCH_FN(wrapper_CUDA_pow_Scalar));
m.impl("pow.Scalar_out", TORCH_FN(wrapper_CUDA_pow_out_Scalar_out));
m.impl("pow.Tensor_Scalar", TORCH_FN(wrapper_CUDA_pow_Tensor_Scalar));
m.impl("pow.Tensor_Scalar_out", TORCH_FN(wrapper_CUDA_pow_out_Tensor_Scalar_out));
m.impl("pow_.Scalar", TORCH_FN(wrapper_CUDA_pow__Scalar));
m.impl("normal_",
TORCH_FN(wrapper_CUDA__normal_));
m.impl("normal.Tensor_float",
TORCH_FN(wrapper_CUDA_Tensor_float_normal));
m.impl("normal.Tensor_float_out",
TORCH_FN(wrapper_CUDA_Tensor_float_out_normal_out));
m.impl("normal.float_Tensor",
TORCH_FN(wrapper_CUDA_float_Tensor_normal));
m.impl("normal.float_Tensor_out",
TORCH_FN(wrapper_CUDA_float_Tensor_out_normal_out));
m.impl("normal.Tensor_Tensor",
TORCH_FN(wrapper_CUDA_Tensor_Tensor_normal));
m.impl("normal.Tensor_Tensor_out",
TORCH_FN(wrapper_CUDA_Tensor_Tensor_out_normal_out));
m.impl("_amp_foreach_non_finite_check_and_unscale_",
TORCH_FN(wrapper_CUDA___amp_foreach_non_finite_check_and_unscale_));
m.impl("_amp_update_scale_",
TORCH_FN(wrapper_CUDA___amp_update_scale_));
m.impl("_foreach_add.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_add));
m.impl("_foreach_add_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_add_));
m.impl("_foreach_add.List",
TORCH_FN(wrapper_CUDA_List__foreach_add));
m.impl("_foreach_add_.List",
TORCH_FN(wrapper_CUDA_List__foreach_add_));
m.impl("_foreach_add.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_add));
m.impl("_foreach_add_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_add_));
m.impl("_foreach_add.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_add));
m.impl("_foreach_add_.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_add_));
m.impl("_foreach_sub.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_sub));
m.impl("_foreach_sub_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_sub_));
m.impl("_foreach_sub.List",
TORCH_FN(wrapper_CUDA_List__foreach_sub));
m.impl("_foreach_sub_.List",
TORCH_FN(wrapper_CUDA_List__foreach_sub_));
m.impl("_foreach_sub.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_sub));
m.impl("_foreach_sub_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_sub_));
m.impl("_foreach_mul.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_mul));
m.impl("_foreach_mul_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_mul_));
m.impl("_foreach_mul.List",
TORCH_FN(wrapper_CUDA_List__foreach_mul));
m.impl("_foreach_mul_.List",
TORCH_FN(wrapper_CUDA_List__foreach_mul_));
m.impl("_foreach_mul.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_mul));
m.impl("_foreach_mul_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_mul_));
m.impl("_foreach_mul.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_mul));
m.impl("_foreach_mul_.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_mul_));
m.impl("_foreach_div.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_div));
m.impl("_foreach_div_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_div_));
m.impl("_foreach_div.List",
TORCH_FN(wrapper_CUDA_List__foreach_div));
m.impl("_foreach_div_.List",
TORCH_FN(wrapper_CUDA_List__foreach_div_));
m.impl("_foreach_div.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_div));
m.impl("_foreach_div_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_div_));
m.impl("_foreach_div.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_div));
m.impl("_foreach_div_.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_div_));
m.impl("_foreach_clamp_max.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_clamp_max));
m.impl("_foreach_clamp_max_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_clamp_max_));
m.impl("_foreach_clamp_max.List",
TORCH_FN(wrapper_CUDA_List__foreach_clamp_max));
m.impl("_foreach_clamp_max_.List",
TORCH_FN(wrapper_CUDA_List__foreach_clamp_max_));
m.impl("_foreach_clamp_max.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_clamp_max));
m.impl("_foreach_clamp_max_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_clamp_max_));
m.impl("_foreach_clamp_min.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_clamp_min));
m.impl("_foreach_clamp_min_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_clamp_min_));
m.impl("_foreach_clamp_min.List",
TORCH_FN(wrapper_CUDA_List__foreach_clamp_min));
m.impl("_foreach_clamp_min_.List",
TORCH_FN(wrapper_CUDA_List__foreach_clamp_min_));
m.impl("_foreach_clamp_min.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_clamp_min));
m.impl("_foreach_clamp_min_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_clamp_min_));
m.impl("_foreach_maximum.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_maximum));
m.impl("_foreach_maximum_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_maximum_));
m.impl("_foreach_maximum.List",
TORCH_FN(wrapper_CUDA_List__foreach_maximum));
m.impl("_foreach_maximum_.List",
TORCH_FN(wrapper_CUDA_List__foreach_maximum_));
m.impl("_foreach_maximum.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_maximum));
m.impl("_foreach_maximum_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_maximum_));
m.impl("_foreach_minimum.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_minimum));
m.impl("_foreach_minimum_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_minimum_));
m.impl("_foreach_minimum.List",
TORCH_FN(wrapper_CUDA_List__foreach_minimum));
m.impl("_foreach_minimum_.List",
TORCH_FN(wrapper_CUDA_List__foreach_minimum_));
m.impl("_foreach_minimum.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_minimum));
m.impl("_foreach_minimum_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_minimum_));
m.impl("_foreach_addcdiv.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_addcdiv));
m.impl("_foreach_addcdiv_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_addcdiv_));
m.impl("_foreach_addcdiv.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_addcdiv));
m.impl("_foreach_addcdiv_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_addcdiv_));
m.impl("_foreach_addcdiv.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_addcdiv));
m.impl("_foreach_addcdiv_.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_addcdiv_));
m.impl("_foreach_addcmul.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_addcmul));
m.impl("_foreach_addcmul_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_addcmul_));
m.impl("_foreach_addcmul.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_addcmul));
m.impl("_foreach_addcmul_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_addcmul_));
m.impl("_foreach_addcmul.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_addcmul));
m.impl("_foreach_addcmul_.Tensor",
TORCH_FN(wrapper_CUDA_Tensor__foreach_addcmul_));
m.impl("_foreach_abs",
TORCH_FN(wrapper_CUDA___foreach_abs));
m.impl("_foreach_abs_",
TORCH_FN(wrapper_CUDA___foreach_abs_));
m.impl("_foreach_acos",
TORCH_FN(wrapper_CUDA___foreach_acos));
m.impl("_foreach_acos_",
TORCH_FN(wrapper_CUDA___foreach_acos_));
m.impl("_foreach_asin",
TORCH_FN(wrapper_CUDA___foreach_asin));
m.impl("_foreach_asin_",
TORCH_FN(wrapper_CUDA___foreach_asin_));
m.impl("_foreach_atan",
TORCH_FN(wrapper_CUDA___foreach_atan));
m.impl("_foreach_atan_",
TORCH_FN(wrapper_CUDA___foreach_atan_));
m.impl("_foreach_ceil",
TORCH_FN(wrapper_CUDA___foreach_ceil));
m.impl("_foreach_ceil_",
TORCH_FN(wrapper_CUDA___foreach_ceil_));
m.impl("_foreach_cos",
TORCH_FN(wrapper_CUDA___foreach_cos));
m.impl("_foreach_cos_",
TORCH_FN(wrapper_CUDA___foreach_cos_));
m.impl("_foreach_cosh",
TORCH_FN(wrapper_CUDA___foreach_cosh));
m.impl("_foreach_cosh_",
TORCH_FN(wrapper_CUDA___foreach_cosh_));
m.impl("_foreach_erf",
TORCH_FN(wrapper_CUDA___foreach_erf));
m.impl("_foreach_erf_",
TORCH_FN(wrapper_CUDA___foreach_erf_));
m.impl("_foreach_erfc",
TORCH_FN(wrapper_CUDA___foreach_erfc));
m.impl("_foreach_erfc_",
TORCH_FN(wrapper_CUDA___foreach_erfc_));
m.impl("_foreach_exp",
TORCH_FN(wrapper_CUDA___foreach_exp));
m.impl("_foreach_exp_",
TORCH_FN(wrapper_CUDA___foreach_exp_));
m.impl("_foreach_expm1",
TORCH_FN(wrapper_CUDA___foreach_expm1));
m.impl("_foreach_expm1_",
TORCH_FN(wrapper_CUDA___foreach_expm1_));
m.impl("_foreach_floor",
TORCH_FN(wrapper_CUDA___foreach_floor));
m.impl("_foreach_floor_",
TORCH_FN(wrapper_CUDA___foreach_floor_));
m.impl("_foreach_frac",
TORCH_FN(wrapper_CUDA___foreach_frac));
m.impl("_foreach_frac_",
TORCH_FN(wrapper_CUDA___foreach_frac_));
m.impl("_foreach_lerp.List",
TORCH_FN(wrapper_CUDA_List__foreach_lerp));
m.impl("_foreach_lerp_.List",
TORCH_FN(wrapper_CUDA_List__foreach_lerp_));
m.impl("_foreach_lerp.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_lerp));
m.impl("_foreach_lerp_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_lerp_));
m.impl("_foreach_lgamma",
TORCH_FN(wrapper_CUDA___foreach_lgamma));
m.impl("_foreach_lgamma_",
TORCH_FN(wrapper_CUDA___foreach_lgamma_));
m.impl("_foreach_log",
TORCH_FN(wrapper_CUDA___foreach_log));
m.impl("_foreach_log_",
TORCH_FN(wrapper_CUDA___foreach_log_));
m.impl("_foreach_log10",
TORCH_FN(wrapper_CUDA___foreach_log10));
m.impl("_foreach_log10_",
TORCH_FN(wrapper_CUDA___foreach_log10_));
m.impl("_foreach_log1p",
TORCH_FN(wrapper_CUDA___foreach_log1p));
m.impl("_foreach_log1p_",
TORCH_FN(wrapper_CUDA___foreach_log1p_));
m.impl("_foreach_log2",
TORCH_FN(wrapper_CUDA___foreach_log2));
m.impl("_foreach_log2_",
TORCH_FN(wrapper_CUDA___foreach_log2_));
m.impl("_foreach_neg",
TORCH_FN(wrapper_CUDA___foreach_neg));
m.impl("_foreach_neg_",
TORCH_FN(wrapper_CUDA___foreach_neg_));
m.impl("_foreach_norm.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_norm));
m.impl("_foreach_pow.List",
TORCH_FN(wrapper_CUDA_List__foreach_pow));
m.impl("_foreach_pow_.List",
TORCH_FN(wrapper_CUDA_List__foreach_pow_));
m.impl("_foreach_pow.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_pow));
m.impl("_foreach_pow_.Scalar",
TORCH_FN(wrapper_CUDA_Scalar__foreach_pow_));
m.impl("_foreach_pow.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_pow));
m.impl("_foreach_pow_.ScalarList",
TORCH_FN(wrapper_CUDA_ScalarList__foreach_pow_));
m.impl("_foreach_pow.ScalarAndTensor",
TORCH_FN(wrapper_CUDA_ScalarAndTensor__foreach_pow));
m.impl("_foreach_reciprocal",
TORCH_FN(wrapper_CUDA___foreach_reciprocal));
m.impl("_foreach_reciprocal_",
TORCH_FN(wrapper_CUDA___foreach_reciprocal_));
m.impl("_foreach_round",
TORCH_FN(wrapper_CUDA___foreach_round));
m.impl("_foreach_round_",
TORCH_FN(wrapper_CUDA___foreach_round_));
m.impl("_foreach_sigmoid",
TORCH_FN(wrapper_CUDA___foreach_sigmoid));
m.impl("_foreach_sigmoid_",
TORCH_FN(wrapper_CUDA___foreach_sigmoid_));
m.impl("_foreach_sign",
TORCH_FN(wrapper_CUDA___foreach_sign));
m.impl("_foreach_sign_",
TORCH_FN(wrapper_CUDA___foreach_sign_));
m.impl("_foreach_sin",
TORCH_FN(wrapper_CUDA___foreach_sin));
m.impl("_foreach_sin_",
TORCH_FN(wrapper_CUDA___foreach_sin_));
m.impl("_foreach_sinh",
TORCH_FN(wrapper_CUDA___foreach_sinh));
m.impl("_foreach_sinh_",
TORCH_FN(wrapper_CUDA___foreach_sinh_));
m.impl("_foreach_sqrt",
TORCH_FN(wrapper_CUDA___foreach_sqrt));
m.impl("_foreach_sqrt_",
TORCH_FN(wrapper_CUDA___foreach_sqrt_));
m.impl("_foreach_tan",
TORCH_FN(wrapper_CUDA___foreach_tan));
m.impl("_foreach_tan_",
TORCH_FN(wrapper_CUDA___foreach_tan_));
m.impl("_foreach_tanh",
TORCH_FN(wrapper_CUDA___foreach_tanh));
m.impl("_foreach_tanh_",
TORCH_FN(wrapper_CUDA___foreach_tanh_));
m.impl("_foreach_trunc",
TORCH_FN(wrapper_CUDA___foreach_trunc));
m.impl("_foreach_trunc_",
TORCH_FN(wrapper_CUDA___foreach_trunc_));
m.impl("_foreach_zero_",
TORCH_FN(wrapper_CUDA___foreach_zero_));
m.impl("_foreach_copy_",
TORCH_FN(wrapper_CUDA___foreach_copy_));
m.impl("bucketize.Tensor",
TORCH_FN(wrapper_CUDA_Tensor_bucketize));
m.impl("bucketize.Tensor_out",
TORCH_FN(wrapper_CUDA_Tensor_out_bucketize_out));
m.impl("bucketize.Scalar",
TORCH_FN(wrapper_CUDA_Scalar_bucketize));
m.impl("searchsorted.Tensor",
TORCH_FN(wrapper_CUDA_Tensor_searchsorted));
m.impl("searchsorted.Tensor_out",
TORCH_FN(wrapper_CUDA_Tensor_out_searchsorted_out));
m.impl("searchsorted.Scalar",
TORCH_FN(wrapper_CUDA_Scalar_searchsorted));
m.impl("searchsorted.Scalar_out",
TORCH_FN(wrapper_CUDA_Scalar_out_searchsorted_out));
m.impl("_convert_indices_from_coo_to_csr", TORCH_FN(wrapper_CUDA__convert_indices_from_coo_to_csr));
m.impl("_convert_indices_from_coo_to_csr.out", TORCH_FN(wrapper_CUDA__convert_indices_from_coo_to_csr_out_out));
m.impl("_convert_indices_from_csr_to_coo", TORCH_FN(wrapper_CUDA__convert_indices_from_csr_to_coo));
m.impl("_convert_indices_from_csr_to_coo.out", TORCH_FN(wrapper_CUDA__convert_indices_from_csr_to_coo_out_out));
m.impl("mse_loss", TORCH_FN(wrapper_CUDA_mse_loss));
m.impl("mse_loss.out", TORCH_FN(wrapper_CUDA_mse_loss_out_out));
m.impl("mse_loss_backward",
TORCH_FN(wrapper_CUDA__mse_loss_backward));
m.impl("mse_loss_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_mse_loss_backward_out));
m.impl("multi_margin_loss",
TORCH_FN(wrapper_CUDA__multi_margin_loss));
m.impl("multi_margin_loss.out",
TORCH_FN(wrapper_CUDA_out_multi_margin_loss_out));
m.impl("multi_margin_loss_backward",
TORCH_FN(wrapper_CUDA__multi_margin_loss_backward));
m.impl("multi_margin_loss_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_multi_margin_loss_backward_out));
m.impl("multilabel_margin_loss_forward",
TORCH_FN(wrapper_CUDA__multilabel_margin_loss_forward));
m.impl("multilabel_margin_loss_forward.output",
TORCH_FN(wrapper_CUDA_output_multilabel_margin_loss_forward_out));
m.impl("multilabel_margin_loss_backward",
TORCH_FN(wrapper_CUDA__multilabel_margin_loss_backward));
m.impl("multilabel_margin_loss_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_multilabel_margin_loss_backward_out));
m.impl("nll_loss_forward", TORCH_FN(wrapper_CUDA_nll_loss_forward));
m.impl("nll_loss_forward.output", TORCH_FN(wrapper_CUDA_nll_loss_forward_out_output));
m.impl("nll_loss_backward", TORCH_FN(wrapper_CUDA_nll_loss_backward));
m.impl("nll_loss_backward.grad_input", TORCH_FN(wrapper_CUDA_nll_loss_backward_out_grad_input));
m.impl("nll_loss2d_forward",
TORCH_FN(wrapper_CUDA__nll_loss2d_forward));
m.impl("nll_loss2d_forward.output",
TORCH_FN(wrapper_CUDA_output_nll_loss2d_forward_out));
m.impl("nll_loss2d_backward",
TORCH_FN(wrapper_CUDA__nll_loss2d_backward));
m.impl("nll_loss2d_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_nll_loss2d_backward_out));
m.impl("smooth_l1_loss", TORCH_FN(wrapper_CUDA_smooth_l1_loss));
m.impl("smooth_l1_loss.out", TORCH_FN(wrapper_CUDA_smooth_l1_loss_out_out));
m.impl("smooth_l1_loss_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_smooth_l1_loss_backward_out));
m.impl("huber_loss",
TORCH_FN(wrapper_CUDA__huber_loss));
m.impl("huber_loss.out",
TORCH_FN(wrapper_CUDA_out_huber_loss_out));
m.impl("huber_loss_backward.out",
TORCH_FN(wrapper_CUDA_out_huber_loss_backward_out));
m.impl("elu", TORCH_FN(wrapper_CUDA_elu));
m.impl("elu.out", TORCH_FN(wrapper_CUDA_elu_out_out));
m.impl("elu_", TORCH_FN(wrapper_CUDA_elu_));
m.impl("elu_backward", TORCH_FN(wrapper_CUDA_elu_backward));
m.impl("elu_backward.grad_input", TORCH_FN(wrapper_CUDA_elu_backward_out_grad_input));
m.impl("glu", TORCH_FN(wrapper_CUDA_glu));
m.impl("glu.out", TORCH_FN(wrapper_CUDA_glu_out_out));
m.impl("glu_backward",
TORCH_FN(wrapper_CUDA__glu_backward));
m.impl("glu_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_glu_backward_out));
m.impl("glu_jvp",
TORCH_FN(wrapper_CUDA__glu_jvp));
m.impl("glu_backward_jvp",
TORCH_FN(wrapper_CUDA__glu_backward_jvp));
m.impl("hardsigmoid", TORCH_FN(wrapper_CUDA_hardsigmoid));
m.impl("hardsigmoid.out", TORCH_FN(wrapper_CUDA_hardsigmoid_out_out));
m.impl("hardsigmoid_", TORCH_FN(wrapper_CUDA_hardsigmoid_));
m.impl("hardsigmoid_backward", TORCH_FN(wrapper_CUDA_hardsigmoid_backward));
m.impl("hardsigmoid_backward.grad_input", TORCH_FN(wrapper_CUDA_hardsigmoid_backward_out_grad_input));
m.impl("hardtanh",
TORCH_FN(wrapper_CUDA__hardtanh));
m.impl("hardtanh.out",
TORCH_FN(wrapper_CUDA_out_hardtanh_out));
m.impl("hardtanh_",
TORCH_FN(wrapper_CUDA__hardtanh_));
m.impl("hardtanh_backward",
TORCH_FN(wrapper_CUDA__hardtanh_backward));
m.impl("hardtanh_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_hardtanh_backward_out));
m.impl("hardswish",
TORCH_FN(wrapper_CUDA__hardswish));
m.impl("hardswish.out",
TORCH_FN(wrapper_CUDA_out_hardswish_out));
m.impl("hardswish_",
TORCH_FN(wrapper_CUDA__hardswish_));
m.impl("hardswish_backward",
TORCH_FN(wrapper_CUDA__hardswish_backward));
m.impl("leaky_relu", TORCH_FN(wrapper_CUDA_leaky_relu));
m.impl("leaky_relu.out", TORCH_FN(wrapper_CUDA_leaky_relu_out_out));
m.impl("leaky_relu_", TORCH_FN(wrapper_CUDA_leaky_relu_));
m.impl("leaky_relu_backward", TORCH_FN(wrapper_CUDA_leaky_relu_backward));
m.impl("leaky_relu_backward.grad_input", TORCH_FN(wrapper_CUDA_leaky_relu_backward_out_grad_input));
m.impl("log_sigmoid_forward",
TORCH_FN(wrapper_CUDA__log_sigmoid_forward));
m.impl("log_sigmoid_forward.output",
TORCH_FN(wrapper_CUDA_output_log_sigmoid_forward_out));
m.impl("log_sigmoid_backward",
TORCH_FN(wrapper_CUDA__log_sigmoid_backward));
m.impl("log_sigmoid_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_log_sigmoid_backward_out));
m.impl("rrelu_with_noise",
TORCH_FN(wrapper_CUDA__rrelu_with_noise));
m.impl("rrelu_with_noise.out",
TORCH_FN(wrapper_CUDA_out_rrelu_with_noise_out));
m.impl("rrelu_with_noise_",
TORCH_FN(wrapper_CUDA__rrelu_with_noise_));
m.impl("softplus", TORCH_FN(wrapper_CUDA_softplus));
m.impl("softplus.out", TORCH_FN(wrapper_CUDA_softplus_out_out));
m.impl("softplus_backward", TORCH_FN(wrapper_CUDA_softplus_backward));
m.impl("softplus_backward.grad_input", TORCH_FN(wrapper_CUDA_softplus_backward_out_grad_input));
m.impl("softshrink", TORCH_FN(wrapper_CUDA_softshrink));
m.impl("softshrink.out", TORCH_FN(wrapper_CUDA_softshrink_out_out));
m.impl("softshrink_backward", TORCH_FN(wrapper_CUDA_softshrink_backward));
m.impl("softshrink_backward.grad_input", TORCH_FN(wrapper_CUDA_softshrink_backward_out_grad_input));
m.impl("adaptive_avg_pool2d.out",
TORCH_FN(wrapper_CUDA_out_adaptive_avg_pool2d_out));
m.impl("_adaptive_avg_pool2d",
TORCH_FN(wrapper_CUDA___adaptive_avg_pool2d));
m.impl("_adaptive_avg_pool2d_backward",
TORCH_FN(wrapper_CUDA___adaptive_avg_pool2d_backward));
m.impl("adaptive_avg_pool3d.out",
TORCH_FN(wrapper_CUDA_out_adaptive_avg_pool3d_out));
m.impl("_adaptive_avg_pool3d",
TORCH_FN(wrapper_CUDA___adaptive_avg_pool3d));
m.impl("adaptive_avg_pool3d_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_adaptive_avg_pool3d_backward_out));
m.impl("_adaptive_avg_pool3d_backward",
TORCH_FN(wrapper_CUDA___adaptive_avg_pool3d_backward));
m.impl("adaptive_max_pool2d", TORCH_FN(wrapper_CUDA_adaptive_max_pool2d));
m.impl("adaptive_max_pool2d.out", TORCH_FN(wrapper_CUDA_adaptive_max_pool2d_out_out));
m.impl("adaptive_max_pool2d_backward", TORCH_FN(wrapper_CUDA_adaptive_max_pool2d_backward));
m.impl("adaptive_max_pool2d_backward.grad_input", TORCH_FN(wrapper_CUDA_adaptive_max_pool2d_backward_out_grad_input));
m.impl("adaptive_max_pool3d", TORCH_FN(wrapper_CUDA_adaptive_max_pool3d));
m.impl("adaptive_max_pool3d.out", TORCH_FN(wrapper_CUDA_adaptive_max_pool3d_out_out));
m.impl("adaptive_max_pool3d_backward", TORCH_FN(wrapper_CUDA_adaptive_max_pool3d_backward));
m.impl("adaptive_max_pool3d_backward.grad_input", TORCH_FN(wrapper_CUDA_adaptive_max_pool3d_backward_out_grad_input));
m.impl("avg_pool2d", TORCH_FN(wrapper_CUDA_avg_pool2d));
m.impl("avg_pool2d.out", TORCH_FN(wrapper_CUDA_avg_pool2d_out_out));
m.impl("avg_pool2d_backward", TORCH_FN(wrapper_CUDA_avg_pool2d_backward));
m.impl("avg_pool2d_backward.grad_input", TORCH_FN(wrapper_CUDA_avg_pool2d_backward_out_grad_input));
m.impl("avg_pool3d", TORCH_FN(wrapper_CUDA_avg_pool3d));
m.impl("avg_pool3d.out", TORCH_FN(wrapper_CUDA_avg_pool3d_out_out));
m.impl("avg_pool3d_backward", TORCH_FN(wrapper_CUDA_avg_pool3d_backward));
m.impl("avg_pool3d_backward.grad_input", TORCH_FN(wrapper_CUDA_avg_pool3d_backward_out_grad_input));
m.impl("fractional_max_pool2d", TORCH_FN(wrapper_CUDA_fractional_max_pool2d));
m.impl("fractional_max_pool2d.output", TORCH_FN(wrapper_CUDA_fractional_max_pool2d_out_output));
m.impl("fractional_max_pool2d_backward", TORCH_FN(wrapper_CUDA_fractional_max_pool2d_backward));
m.impl("fractional_max_pool2d_backward.grad_input", TORCH_FN(wrapper_CUDA_fractional_max_pool2d_backward_out_grad_input));
m.impl("fractional_max_pool3d", TORCH_FN(wrapper_CUDA_fractional_max_pool3d));
m.impl("fractional_max_pool3d.output", TORCH_FN(wrapper_CUDA_fractional_max_pool3d_out_output));
m.impl("fractional_max_pool3d_backward",
TORCH_FN(wrapper_CUDA__fractional_max_pool3d_backward));
m.impl("fractional_max_pool3d_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_fractional_max_pool3d_backward_out));
m.impl("max_pool2d_with_indices", TORCH_FN(wrapper_CUDA_max_pool2d_with_indices));
m.impl("max_pool2d_with_indices.out", TORCH_FN(wrapper_CUDA_max_pool2d_with_indices_out_out));
m.impl("max_pool2d_with_indices_backward", TORCH_FN(wrapper_CUDA_max_pool2d_with_indices_backward));
m.impl("max_pool2d_with_indices_backward.grad_input", TORCH_FN(wrapper_CUDA_max_pool2d_with_indices_backward_out_grad_input));
m.impl("max_pool3d_with_indices",
TORCH_FN(wrapper_CUDA__max_pool3d_with_indices));
m.impl("max_pool3d_with_indices.out",
TORCH_FN(wrapper_CUDA_out_max_pool3d_with_indices_out));
m.impl("max_pool3d_with_indices_backward",
TORCH_FN(wrapper_CUDA__max_pool3d_with_indices_backward));
m.impl("max_pool3d_with_indices_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_max_pool3d_with_indices_backward_out));
m.impl("max_unpool2d",
TORCH_FN(wrapper_CUDA__max_unpool2d));
m.impl("max_unpool2d.out",
TORCH_FN(wrapper_CUDA_out_max_unpool2d_out));
m.impl("max_unpool3d",
TORCH_FN(wrapper_CUDA__max_unpool3d));
m.impl("max_unpool3d.out",
TORCH_FN(wrapper_CUDA_out_max_unpool3d_out));
m.impl("reflection_pad1d", TORCH_FN(wrapper_CUDA_reflection_pad1d));
m.impl("reflection_pad1d.out", TORCH_FN(wrapper_CUDA_reflection_pad1d_out_out));
m.impl("reflection_pad1d_backward", TORCH_FN(wrapper_CUDA_reflection_pad1d_backward));
m.impl("reflection_pad1d_backward.grad_input", TORCH_FN(wrapper_CUDA_reflection_pad1d_backward_out_grad_input));
m.impl("reflection_pad2d",
TORCH_FN(wrapper_CUDA__reflection_pad2d));
m.impl("reflection_pad2d.out",
TORCH_FN(wrapper_CUDA_out_reflection_pad2d_out));
m.impl("reflection_pad2d_backward",
TORCH_FN(wrapper_CUDA__reflection_pad2d_backward));
m.impl("reflection_pad2d_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_reflection_pad2d_backward_out));
m.impl("reflection_pad3d", TORCH_FN(wrapper_CUDA_reflection_pad3d));
m.impl("reflection_pad3d.out", TORCH_FN(wrapper_CUDA_reflection_pad3d_out_out));
m.impl("reflection_pad3d_backward", TORCH_FN(wrapper_CUDA_reflection_pad3d_backward));
m.impl("reflection_pad3d_backward.grad_input", TORCH_FN(wrapper_CUDA_reflection_pad3d_backward_out_grad_input));
m.impl("replication_pad1d", TORCH_FN(wrapper_CUDA_replication_pad1d));
m.impl("replication_pad1d.out", TORCH_FN(wrapper_CUDA_replication_pad1d_out_out));
m.impl("replication_pad1d_backward", TORCH_FN(wrapper_CUDA_replication_pad1d_backward));
m.impl("replication_pad1d_backward.grad_input", TORCH_FN(wrapper_CUDA_replication_pad1d_backward_out_grad_input));
m.impl("replication_pad2d", TORCH_FN(wrapper_CUDA_replication_pad2d));
m.impl("replication_pad2d.out", TORCH_FN(wrapper_CUDA_replication_pad2d_out_out));
m.impl("replication_pad2d_backward",
TORCH_FN(wrapper_CUDA__replication_pad2d_backward));
m.impl("replication_pad2d_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_replication_pad2d_backward_out));
m.impl("replication_pad3d", TORCH_FN(wrapper_CUDA_replication_pad3d));
m.impl("replication_pad3d.out", TORCH_FN(wrapper_CUDA_replication_pad3d_out_out));
m.impl("replication_pad3d_backward",
TORCH_FN(wrapper_CUDA__replication_pad3d_backward));
m.impl("replication_pad3d_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input_replication_pad3d_backward_out));
m.impl("upsample_linear1d", TORCH_FN(wrapper_CUDA_upsample_linear1d));
m.impl("upsample_linear1d.out", TORCH_FN(wrapper_CUDA_upsample_linear1d_out_out));
m.impl("upsample_linear1d_backward", TORCH_FN(wrapper_CUDA_upsample_linear1d_backward));
m.impl("upsample_linear1d_backward.grad_input", TORCH_FN(wrapper_CUDA_upsample_linear1d_backward_out_grad_input));
m.impl("upsample_bilinear2d", TORCH_FN(wrapper_CUDA_upsample_bilinear2d));
m.impl("upsample_bilinear2d.out", TORCH_FN(wrapper_CUDA_upsample_bilinear2d_out_out));
m.impl("upsample_bilinear2d_backward", TORCH_FN(wrapper_CUDA_upsample_bilinear2d_backward));
m.impl("upsample_bilinear2d_backward.grad_input", TORCH_FN(wrapper_CUDA_upsample_bilinear2d_backward_out_grad_input));
m.impl("_upsample_bilinear2d_aa", TORCH_FN(wrapper_CUDA__upsample_bilinear2d_aa));
m.impl("_upsample_bilinear2d_aa.out", TORCH_FN(wrapper_CUDA__upsample_bilinear2d_aa_out_out));
m.impl("_upsample_bilinear2d_aa_backward", TORCH_FN(wrapper_CUDA__upsample_bilinear2d_aa_backward));
m.impl("_upsample_bilinear2d_aa_backward.grad_input", TORCH_FN(wrapper_CUDA__upsample_bilinear2d_aa_backward_out_grad_input));
m.impl("upsample_bicubic2d", TORCH_FN(wrapper_CUDA_upsample_bicubic2d));
m.impl("upsample_bicubic2d.out", TORCH_FN(wrapper_CUDA_upsample_bicubic2d_out_out));
m.impl("upsample_bicubic2d_backward", TORCH_FN(wrapper_CUDA_upsample_bicubic2d_backward));
m.impl("upsample_bicubic2d_backward.grad_input", TORCH_FN(wrapper_CUDA_upsample_bicubic2d_backward_out_grad_input));
m.impl("_upsample_bicubic2d_aa", TORCH_FN(wrapper_CUDA__upsample_bicubic2d_aa));
m.impl("_upsample_bicubic2d_aa.out", TORCH_FN(wrapper_CUDA__upsample_bicubic2d_aa_out_out));
m.impl("_upsample_bicubic2d_aa_backward", TORCH_FN(wrapper_CUDA__upsample_bicubic2d_aa_backward));
m.impl("_upsample_bicubic2d_aa_backward.grad_input", TORCH_FN(wrapper_CUDA__upsample_bicubic2d_aa_backward_out_grad_input));
m.impl("upsample_trilinear3d", TORCH_FN(wrapper_CUDA_upsample_trilinear3d));
m.impl("upsample_trilinear3d.out", TORCH_FN(wrapper_CUDA_upsample_trilinear3d_out_out));
m.impl("upsample_trilinear3d_backward", TORCH_FN(wrapper_CUDA_upsample_trilinear3d_backward));
m.impl("upsample_trilinear3d_backward.grad_input", TORCH_FN(wrapper_CUDA_upsample_trilinear3d_backward_out_grad_input));
m.impl("upsample_nearest1d", TORCH_FN(wrapper_CUDA_upsample_nearest1d));
m.impl("upsample_nearest1d.out", TORCH_FN(wrapper_CUDA_upsample_nearest1d_out_out));
m.impl("_upsample_nearest_exact1d", TORCH_FN(wrapper_CUDA__upsample_nearest_exact1d));
m.impl("_upsample_nearest_exact1d.out", TORCH_FN(wrapper_CUDA__upsample_nearest_exact1d_out_out));
m.impl("upsample_nearest1d_backward", TORCH_FN(wrapper_CUDA_upsample_nearest1d_backward));
m.impl("upsample_nearest1d_backward.grad_input", TORCH_FN(wrapper_CUDA_upsample_nearest1d_backward_out_grad_input));
m.impl("_upsample_nearest_exact1d_backward", TORCH_FN(wrapper_CUDA__upsample_nearest_exact1d_backward));
m.impl("_upsample_nearest_exact1d_backward.grad_input", TORCH_FN(wrapper_CUDA__upsample_nearest_exact1d_backward_out_grad_input));
m.impl("upsample_nearest2d", TORCH_FN(wrapper_CUDA_upsample_nearest2d));
m.impl("upsample_nearest2d.out", TORCH_FN(wrapper_CUDA_upsample_nearest2d_out_out));
m.impl("_upsample_nearest_exact2d", TORCH_FN(wrapper_CUDA__upsample_nearest_exact2d));
m.impl("_upsample_nearest_exact2d.out", TORCH_FN(wrapper_CUDA__upsample_nearest_exact2d_out_out));
m.impl("upsample_nearest2d_backward", TORCH_FN(wrapper_CUDA_upsample_nearest2d_backward));
m.impl("upsample_nearest2d_backward.grad_input", TORCH_FN(wrapper_CUDA_upsample_nearest2d_backward_out_grad_input));
m.impl("_upsample_nearest_exact2d_backward", TORCH_FN(wrapper_CUDA__upsample_nearest_exact2d_backward));
m.impl("_upsample_nearest_exact2d_backward.grad_input", TORCH_FN(wrapper_CUDA__upsample_nearest_exact2d_backward_out_grad_input));
m.impl("upsample_nearest3d", TORCH_FN(wrapper_CUDA_upsample_nearest3d));
m.impl("upsample_nearest3d.out", TORCH_FN(wrapper_CUDA_upsample_nearest3d_out_out));
m.impl("_upsample_nearest_exact3d", TORCH_FN(wrapper_CUDA__upsample_nearest_exact3d));
m.impl("_upsample_nearest_exact3d.out", TORCH_FN(wrapper_CUDA__upsample_nearest_exact3d_out_out));
m.impl("upsample_nearest3d_backward", TORCH_FN(wrapper_CUDA_upsample_nearest3d_backward));
m.impl("upsample_nearest3d_backward.grad_input", TORCH_FN(wrapper_CUDA_upsample_nearest3d_backward_out_grad_input));
m.impl("_upsample_nearest_exact3d_backward", TORCH_FN(wrapper_CUDA__upsample_nearest_exact3d_backward));
m.impl("_upsample_nearest_exact3d_backward.grad_input", TORCH_FN(wrapper_CUDA__upsample_nearest_exact3d_backward_out_grad_input));
m.impl("sigmoid_backward", TORCH_FN(wrapper_CUDA_sigmoid_backward));
m.impl("sigmoid_backward.grad_input", TORCH_FN(wrapper_CUDA_sigmoid_backward_out_grad_input));
m.impl("logit_backward", TORCH_FN(wrapper_CUDA_logit_backward));
m.impl("logit_backward.grad_input", TORCH_FN(wrapper_CUDA_logit_backward_out_grad_input));
m.impl("tanh_backward", TORCH_FN(wrapper_CUDA_tanh_backward));
m.impl("tanh_backward.grad_input", TORCH_FN(wrapper_CUDA_tanh_backward_out_grad_input));
m.impl("slow_conv_transpose2d", TORCH_FN(wrapper_CUDA_slow_conv_transpose2d));
m.impl("slow_conv_transpose2d.out", TORCH_FN(wrapper_CUDA_slow_conv_transpose2d_out_out));
m.impl("slow_conv_transpose3d",
TORCH_FN(wrapper_CUDA__slow_conv_transpose3d));
m.impl("slow_conv_transpose3d.out",
TORCH_FN(wrapper_CUDA_out_slow_conv_transpose3d_out));
m.impl("_slow_conv2d_forward",
TORCH_FN(wrapper_CUDA___slow_conv2d_forward));
m.impl("_slow_conv2d_forward.output",
TORCH_FN(wrapper_CUDA_output__slow_conv2d_forward_out));
m.impl("_slow_conv2d_backward.grad_input",
TORCH_FN(wrapper_CUDA_grad_input__slow_conv2d_backward_out));
m.impl("_slow_conv2d_backward.output_mask",
TORCH_FN(wrapper_CUDA_output_mask__slow_conv2d_backward));
m.impl("_conv_depthwise2d",
TORCH_FN(wrapper_CUDA___conv_depthwise2d));
m.impl("_conv_depthwise2d.out",
TORCH_FN(wrapper_CUDA_out__conv_depthwise2d_out));
m.impl("conv_depthwise3d",
TORCH_FN(wrapper_CUDA__conv_depthwise3d));
m.impl("slow_conv_dilated2d",
TORCH_FN(wrapper_CUDA__slow_conv_dilated2d));
m.impl("slow_conv_dilated3d",
TORCH_FN(wrapper_CUDA__slow_conv_dilated3d));
m.impl("col2im",
TORCH_FN(wrapper_CUDA__col2im));
m.impl("col2im.out",
TORCH_FN(wrapper_CUDA_out_col2im_out));
m.impl("im2col",
TORCH_FN(wrapper_CUDA__im2col));
m.impl("im2col.out",
TORCH_FN(wrapper_CUDA_out_im2col_out));
m.impl("record_stream",
TORCH_FN(wrapper_CUDA__record_stream));
m.impl("isposinf", TORCH_FN(wrapper_CUDA_isposinf));
m.impl("isposinf.out", TORCH_FN(wrapper_CUDA_isposinf_out_out));
m.impl("isneginf", TORCH_FN(wrapper_CUDA_isneginf));
m.impl("isneginf.out", TORCH_FN(wrapper_CUDA_isneginf_out_out));
m.impl("special_entr", TORCH_FN(wrapper_CUDA_special_entr));
m.impl("special_entr.out", TORCH_FN(wrapper_CUDA_special_entr_out_out));
m.impl("special_ndtri", TORCH_FN(wrapper_CUDA_special_ndtri));
m.impl("special_ndtri.out", TORCH_FN(wrapper_CUDA_special_ndtri_out_out));
m.impl("special_log_ndtr", TORCH_FN(wrapper_CUDA_special_log_ndtr));
m.impl("special_log_ndtr.out", TORCH_FN(wrapper_CUDA_special_log_ndtr_out_out));
m.impl("special_erfcx", TORCH_FN(wrapper_CUDA_special_erfcx));
m.impl("special_erfcx.out", TORCH_FN(wrapper_CUDA_special_erfcx_out_out));
m.impl("special_xlog1py", TORCH_FN(wrapper_CUDA_special_xlog1py));
m.impl("special_xlog1py.out", TORCH_FN(wrapper_CUDA_special_xlog1py_out_out));
m.impl("special_zeta", TORCH_FN(wrapper_CUDA_special_zeta));
m.impl("special_zeta.out", TORCH_FN(wrapper_CUDA_special_zeta_out_out));
m.impl("special_i0e", TORCH_FN(wrapper_CUDA_special_i0e));
m.impl("special_i0e.out", TORCH_FN(wrapper_CUDA_special_i0e_out_out));
m.impl("special_i1", TORCH_FN(wrapper_CUDA_special_i1));
m.impl("special_i1.out", TORCH_FN(wrapper_CUDA_special_i1_out_out));
m.impl("special_i1e", TORCH_FN(wrapper_CUDA_special_i1e));
m.impl("special_i1e.out", TORCH_FN(wrapper_CUDA_special_i1e_out_out));
m.impl("linalg_cholesky_ex", TORCH_FN(wrapper_CUDA_linalg_cholesky_ex));
m.impl("linalg_cholesky_ex.L", TORCH_FN(wrapper_CUDA_linalg_cholesky_ex_out_L));
m.impl("linalg_cross", TORCH_FN(wrapper_CUDA_linalg_cross));
m.impl("linalg_cross.out", TORCH_FN(wrapper_CUDA_linalg_cross_out_out));
m.impl("linalg_lu_factor_ex", TORCH_FN(wrapper_CUDA_linalg_lu_factor_ex));
m.impl("linalg_lu_factor_ex.out", TORCH_FN(wrapper_CUDA_linalg_lu_factor_ex_out_out));
m.impl("linalg_lu", TORCH_FN(wrapper_CUDA_linalg_lu));
m.impl("linalg_lu.out", TORCH_FN(wrapper_CUDA_linalg_lu_out_out));
m.impl("linalg_lu_solve", TORCH_FN(wrapper_CUDA_linalg_lu_solve));
m.impl("linalg_lu_solve.out", TORCH_FN(wrapper_CUDA_linalg_lu_solve_out_out));
m.impl("_linalg_det", TORCH_FN(wrapper_CUDA__linalg_det));
m.impl("_linalg_det.result", TORCH_FN(wrapper_CUDA__linalg_det_out_result));
m.impl("linalg_ldl_factor_ex", TORCH_FN(wrapper_CUDA_linalg_ldl_factor_ex));
m.impl("linalg_ldl_factor_ex.out", TORCH_FN(wrapper_CUDA_linalg_ldl_factor_ex_out_out));
m.impl("linalg_ldl_solve", TORCH_FN(wrapper_CUDA_linalg_ldl_solve));
m.impl("linalg_ldl_solve.out", TORCH_FN(wrapper_CUDA_linalg_ldl_solve_out_out));
m.impl("linalg_lstsq.out",
TORCH_FN(wrapper_CUDA_out_linalg_lstsq_out));
m.impl("linalg_matrix_exp",
TORCH_FN(wrapper_CUDA__linalg_matrix_exp));
m.impl("_linalg_slogdet", TORCH_FN(wrapper_CUDA__linalg_slogdet));
m.impl("_linalg_slogdet.sign", TORCH_FN(wrapper_CUDA__linalg_slogdet_out_sign));
m.impl("linalg_eig",
TORCH_FN(wrapper_CUDA__linalg_eig));
m.impl("linalg_eig.out",
TORCH_FN(wrapper_CUDA_out_linalg_eig_out));
m.impl("_linalg_eigh", TORCH_FN(wrapper_CUDA__linalg_eigh));
m.impl("_linalg_eigh.eigenvalues", TORCH_FN(wrapper_CUDA__linalg_eigh_out_eigenvalues));
m.impl("linalg_householder_product",
TORCH_FN(wrapper_CUDA__linalg_householder_product));
m.impl("linalg_householder_product.out",
TORCH_FN(wrapper_CUDA_out_linalg_householder_product_out));
m.impl("linalg_inv_ex", TORCH_FN(wrapper_CUDA_linalg_inv_ex));
m.impl("linalg_inv_ex.inverse", TORCH_FN(wrapper_CUDA_linalg_inv_ex_out_inverse));
m.impl("linalg_vector_norm", TORCH_FN(wrapper_CUDA_linalg_vector_norm));
m.impl("linalg_vector_norm.out", TORCH_FN(wrapper_CUDA_linalg_vector_norm_out_out));
m.impl("_linalg_svd", TORCH_FN(wrapper_CUDA__linalg_svd));
m.impl("_linalg_svd.U", TORCH_FN(wrapper_CUDA__linalg_svd_out_U));
m.impl("_linalg_solve_ex", TORCH_FN(wrapper_CUDA__linalg_solve_ex));
m.impl("_linalg_solve_ex.result", TORCH_FN(wrapper_CUDA__linalg_solve_ex_out_result));
m.impl("linalg_qr", TORCH_FN(wrapper_CUDA_linalg_qr));
m.impl("linalg_qr.out", TORCH_FN(wrapper_CUDA_linalg_qr_out_out));
m.impl("segment_reduce",
TORCH_FN(wrapper_CUDA__segment_reduce));
m.impl("_segment_reduce_backward",
TORCH_FN(wrapper_CUDA___segment_reduce_backward));
m.impl("_transformer_encoder_layer_fwd",
TORCH_FN(wrapper_CUDA___transformer_encoder_layer_fwd));
m.impl("_native_multi_head_attention",
TORCH_FN(wrapper_CUDA___native_multi_head_attention));
m.impl("_fused_sdp_choice",
TORCH_FN(wrapper_CUDA___fused_sdp_choice));
m.impl("_scaled_dot_product_flash_attention",
TORCH_FN(wrapper_CUDA___scaled_dot_product_flash_attention));
m.impl("_scaled_dot_product_flash_attention_backward",
TORCH_FN(wrapper_CUDA___scaled_dot_product_flash_attention_backward));
m.impl("_scaled_dot_product_efficient_attention",
TORCH_FN(wrapper_CUDA___scaled_dot_product_efficient_attention));
m.impl("_scaled_dot_product_efficient_attention_backward",
TORCH_FN(wrapper_CUDA___scaled_dot_product_efficient_attention_backward));
m.impl("_flash_attention_forward",
TORCH_FN(wrapper_CUDA___flash_attention_forward));
m.impl("_flash_attention_backward",
TORCH_FN(wrapper_CUDA___flash_attention_backward));
m.impl("_efficient_attention_forward",
TORCH_FN(wrapper_CUDA___efficient_attention_forward));
m.impl("_efficient_attention_backward",
TORCH_FN(wrapper_CUDA___efficient_attention_backward));
m.impl("_triton_scaled_dot_attention",
TORCH_FN(wrapper_CUDA___triton_scaled_dot_attention));
m.impl("_fill_mem_eff_dropout_mask_",
TORCH_FN(wrapper_CUDA___fill_mem_eff_dropout_mask_));
m.impl("_triton_multi_head_attention",
TORCH_FN(wrapper_CUDA___triton_multi_head_attention));
m.impl("special_airy_ai", TORCH_FN(wrapper_CUDA_special_airy_ai));
m.impl("special_airy_ai.out", TORCH_FN(wrapper_CUDA_special_airy_ai_out_out));
m.impl("special_bessel_j0", TORCH_FN(wrapper_CUDA_special_bessel_j0));
m.impl("special_bessel_j0.out", TORCH_FN(wrapper_CUDA_special_bessel_j0_out_out));
m.impl("special_bessel_j1", TORCH_FN(wrapper_CUDA_special_bessel_j1));
m.impl("special_bessel_j1.out", TORCH_FN(wrapper_CUDA_special_bessel_j1_out_out));
m.impl("special_bessel_y0", TORCH_FN(wrapper_CUDA_special_bessel_y0));
m.impl("special_bessel_y0.out", TORCH_FN(wrapper_CUDA_special_bessel_y0_out_out));
m.impl("special_bessel_y1", TORCH_FN(wrapper_CUDA_special_bessel_y1));
m.impl("special_bessel_y1.out", TORCH_FN(wrapper_CUDA_special_bessel_y1_out_out));
m.impl("special_chebyshev_polynomial_t", TORCH_FN(wrapper_CUDA_special_chebyshev_polynomial_t));
m.impl("special_chebyshev_polynomial_t.out", TORCH_FN(wrapper_CUDA_special_chebyshev_polynomial_t_out_out));
m.impl("special_chebyshev_polynomial_u", TORCH_FN(wrapper_CUDA_special_chebyshev_polynomial_u));
m.impl("special_chebyshev_polynomial_u.out", TORCH_FN(wrapper_CUDA_special_chebyshev_polynomial_u_out_out));
m.impl("special_chebyshev_polynomial_v", TORCH_FN(wrapper_CUDA_special_chebyshev_polynomial_v));
m.impl("special_chebyshev_polynomial_v.out", TORCH_FN(wrapper_CUDA_special_chebyshev_polynomial_v_out_out));
m.impl("special_chebyshev_polynomial_w", TORCH_FN(wrapper_CUDA_special_chebyshev_polynomial_w));
m.impl("special_chebyshev_polynomial_w.out", TORCH_FN(wrapper_CUDA_special_chebyshev_polynomial_w_out_out));
m.impl("special_hermite_polynomial_h", TORCH_FN(wrapper_CUDA_special_hermite_polynomial_h));
m.impl("special_hermite_polynomial_h.out", TORCH_FN(wrapper_CUDA_special_hermite_polynomial_h_out_out));
m.impl("special_hermite_polynomial_he", TORCH_FN(wrapper_CUDA_special_hermite_polynomial_he));
m.impl("special_hermite_polynomial_he.out", TORCH_FN(wrapper_CUDA_special_hermite_polynomial_he_out_out));
m.impl("special_laguerre_polynomial_l", TORCH_FN(wrapper_CUDA_special_laguerre_polynomial_l));
m.impl("special_laguerre_polynomial_l.out", TORCH_FN(wrapper_CUDA_special_laguerre_polynomial_l_out_out));
m.impl("special_legendre_polynomial_p", TORCH_FN(wrapper_CUDA_special_legendre_polynomial_p));
m.impl("special_legendre_polynomial_p.out", TORCH_FN(wrapper_CUDA_special_legendre_polynomial_p_out_out));
m.impl("special_modified_bessel_i0", TORCH_FN(wrapper_CUDA_special_modified_bessel_i0));
m.impl("special_modified_bessel_i0.out", TORCH_FN(wrapper_CUDA_special_modified_bessel_i0_out_out));
m.impl("special_modified_bessel_i1", TORCH_FN(wrapper_CUDA_special_modified_bessel_i1));
m.impl("special_modified_bessel_i1.out", TORCH_FN(wrapper_CUDA_special_modified_bessel_i1_out_out));
m.impl("special_modified_bessel_k0", TORCH_FN(wrapper_CUDA_special_modified_bessel_k0));
m.impl("special_modified_bessel_k0.out", TORCH_FN(wrapper_CUDA_special_modified_bessel_k0_out_out));
m.impl("special_modified_bessel_k1", TORCH_FN(wrapper_CUDA_special_modified_bessel_k1));
m.impl("special_modified_bessel_k1.out", TORCH_FN(wrapper_CUDA_special_modified_bessel_k1_out_out));
m.impl("special_scaled_modified_bessel_k0", TORCH_FN(wrapper_CUDA_special_scaled_modified_bessel_k0));
m.impl("special_scaled_modified_bessel_k0.out", TORCH_FN(wrapper_CUDA_special_scaled_modified_bessel_k0_out_out));
m.impl("special_scaled_modified_bessel_k1", TORCH_FN(wrapper_CUDA_special_scaled_modified_bessel_k1));
m.impl("special_scaled_modified_bessel_k1.out", TORCH_FN(wrapper_CUDA_special_scaled_modified_bessel_k1_out_out));
m.impl("special_shifted_chebyshev_polynomial_t", TORCH_FN(wrapper_CUDA_special_shifted_chebyshev_polynomial_t));
m.impl("special_shifted_chebyshev_polynomial_t.out", TORCH_FN(wrapper_CUDA_special_shifted_chebyshev_polynomial_t_out_out));
m.impl("special_shifted_chebyshev_polynomial_u", TORCH_FN(wrapper_CUDA_special_shifted_chebyshev_polynomial_u));
m.impl("special_shifted_chebyshev_polynomial_u.out", TORCH_FN(wrapper_CUDA_special_shifted_chebyshev_polynomial_u_out_out));
m.impl("special_shifted_chebyshev_polynomial_v", TORCH_FN(wrapper_CUDA_special_shifted_chebyshev_polynomial_v));
m.impl("special_shifted_chebyshev_polynomial_v.out", TORCH_FN(wrapper_CUDA_special_shifted_chebyshev_polynomial_v_out_out));
m.impl("special_shifted_chebyshev_polynomial_w", TORCH_FN(wrapper_CUDA_special_shifted_chebyshev_polynomial_w));
m.impl("special_shifted_chebyshev_polynomial_w.out", TORCH_FN(wrapper_CUDA_special_shifted_chebyshev_polynomial_w_out_out));
m.impl("special_spherical_bessel_j0", TORCH_FN(wrapper_CUDA_special_spherical_bessel_j0));
m.impl("special_spherical_bessel_j0.out", TORCH_FN(wrapper_CUDA_special_spherical_bessel_j0_out_out));
m.impl("_fused_adam_",
TORCH_FN(wrapper_CUDA___fused_adam_));
m.impl("_fused_adam_.tensor_lr",
TORCH_FN(wrapper_CUDA_tensor_lr__fused_adam_));
m.impl("_fused_adamw_",
TORCH_FN(wrapper_CUDA___fused_adamw_));
m.impl("_fused_adamw_.tensor_lr",
TORCH_FN(wrapper_CUDA_tensor_lr__fused_adamw_));
m.impl("_fused_sgd_",
TORCH_FN(wrapper_CUDA___fused_sgd_));
m.impl("_fused_sgd_.tensor_lr",
TORCH_FN(wrapper_CUDA_tensor_lr__fused_sgd_));
};
} // anonymous namespace
namespace cuda {
void _assert_async(const at::Tensor & self) {
return wrapper_CUDA___assert_async(self);
}
void _assert_async(const at::Tensor & self, c10::string_view assert_msg) {
return wrapper_CUDA_msg__assert_async(self, assert_msg);
}
bool _use_cudnn_ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank) {
return wrapper_CUDA___use_cudnn_ctc_loss(log_probs, targets, input_lengths, target_lengths, blank);
}
bool _use_cudnn_ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank) {
return wrapper_CUDA_Tensor__use_cudnn_ctc_loss(log_probs, targets, input_lengths, target_lengths, blank);
}
::std::tuple<at::Tensor,at::Tensor> _cudnn_ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool deterministic, bool zero_infinity) {
return wrapper_CUDA___cudnn_ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity);
}
::std::tuple<at::Tensor,at::Tensor> _cudnn_ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool deterministic, bool zero_infinity) {
return wrapper_CUDA_Tensor__cudnn_ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity);
}
at::Tensor _cudnn_rnn_flatten_weight(at::TensorList weight_arr, int64_t weight_stride0, int64_t input_size, int64_t mode, int64_t hidden_size, int64_t proj_size, int64_t num_layers, bool batch_first, bool bidirectional) {
return wrapper_CUDA___cudnn_rnn_flatten_weight(weight_arr, weight_stride0, input_size, mode, hidden_size, proj_size, num_layers, batch_first, bidirectional);
}
at::Tensor _cudnn_rnn_flatten_weight_symint(at::TensorList weight_arr, int64_t weight_stride0, c10::SymInt input_size, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, bool bidirectional) {
return wrapper_CUDA___cudnn_rnn_flatten_weight(weight_arr, weight_stride0, input_size, mode, hidden_size, proj_size, num_layers, batch_first, bidirectional);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _cudnn_rnn(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const c10::optional<at::Tensor> & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, int64_t hidden_size, int64_t proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state) {
return wrapper_CUDA___cudnn_rnn(input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, c10::fromIntArrayRefSlow(batch_sizes), dropout_state);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _cudnn_rnn_symint(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const c10::optional<at::Tensor> & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state) {
return wrapper_CUDA___cudnn_rnn(input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,::std::vector<at::Tensor>> _cudnn_rnn_backward(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, int64_t hidden_size, int64_t proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask) {
return wrapper_CUDA___cudnn_rnn_backward(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, c10::fromIntArrayRefSlow(batch_sizes), dropout_state, reserve, output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,::std::vector<at::Tensor>> _cudnn_rnn_backward_symint(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, c10::SymInt hidden_size, c10::SymInt proj_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, c10::SymIntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask) {
return wrapper_CUDA___cudnn_rnn_backward(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask);
}
at::Tensor _cudnn_init_dropout_state(double dropout, bool train, int64_t dropout_seed, at::TensorOptions options) {
return wrapper_CUDA___cudnn_init_dropout_state(dropout, train, dropout_seed, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor _cudnn_init_dropout_state(double dropout, bool train, int64_t dropout_seed, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CUDA___cudnn_init_dropout_state(dropout, train, dropout_seed, dtype, layout, device, pin_memory);
}
::std::tuple<at::Tensor,at::Tensor> _fused_dropout(const at::Tensor & self, double p, c10::optional<at::Generator> generator) {
return wrapper_CUDA___fused_dropout(self, p, generator);
}
at::Tensor _masked_scale(const at::Tensor & self, const at::Tensor & mask, double scale) {
return wrapper_CUDA___masked_scale(self, mask, scale);
}
::std::tuple<at::Tensor,at::Tensor> native_dropout(const at::Tensor & input, double p, c10::optional<bool> train) {
return wrapper_CUDA__native_dropout(input, p, train);
}
at::Tensor native_dropout_backward(const at::Tensor & grad_output, const at::Tensor & mask, double scale) {
return wrapper_CUDA__native_dropout_backward(grad_output, mask, scale);
}
at::Tensor & abs_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_out_abs_out(self, out);
}
at::Tensor & abs_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_out_abs_out(self, out);
}
at::Tensor angle(const at::Tensor & self) {
return wrapper_CUDA__angle(self);
}
at::Tensor & angle_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_out_angle_out(self, out);
}
at::Tensor & angle_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_out_angle_out(self, out);
}
at::Tensor view_as_real(const at::Tensor & self) {
return wrapper_CUDA__view_as_real(self);
}
at::Tensor view_as_complex(const at::Tensor & self) {
return wrapper_CUDA__view_as_complex(self);
}
at::Tensor sgn(const at::Tensor & self) {
return wrapper_CUDA_sgn(self);
}
at::Tensor & sgn_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_sgn_out_out(self, out);
}
at::Tensor & sgn_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_sgn_out_out(self, out);
}
at::Tensor & sgn_(at::Tensor & self) {
return wrapper_CUDA_sgn_(self);
}
at::Tensor & conj_physical_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_out_conj_physical_out(self, out);
}
at::Tensor & conj_physical_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_out_conj_physical_out(self, out);
}
at::Tensor acos(const at::Tensor & self) {
return wrapper_CUDA_acos(self);
}
at::Tensor & acos_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_acos_out_out(self, out);
}
at::Tensor & acos_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_acos_out_out(self, out);
}
at::Tensor & acos_(at::Tensor & self) {
return wrapper_CUDA_acos_(self);
}
at::Tensor add(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CUDA_add_Tensor(self, other, alpha);
}
at::Tensor & add_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CUDA_add_out_out(self, other, alpha, out);
}
at::Tensor & add_outf(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CUDA_add_out_out(self, other, alpha, out);
}
at::Tensor & add_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CUDA_add__Tensor(self, other, alpha);
}
at::Tensor addmv(const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_addmv(self, mat, vec, beta, alpha);
}
at::Tensor & addmv_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_addmv_out_out(self, mat, vec, beta, alpha, out);
}
at::Tensor & addmv_outf(const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CUDA_addmv_out_out(self, mat, vec, beta, alpha, out);
}
at::Tensor & addmv_(at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_addmv_(self, mat, vec, beta, alpha);
}
at::Tensor addr(const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA__addr(self, vec1, vec2, beta, alpha);
}
at::Tensor & addr_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_out_addr_out(self, vec1, vec2, beta, alpha, out);
}
at::Tensor & addr_outf(const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CUDA_out_addr_out(self, vec1, vec2, beta, alpha, out);
}
at::Tensor all(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_all_dim(self, dim, keepdim);
}
at::Tensor & all_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_all_out_out(self, dim, keepdim, out);
}
at::Tensor & all_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_all_out_out(self, dim, keepdim, out);
}
at::Tensor all(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
return wrapper_CUDA_all_dims(self, dim, keepdim);
}
at::Tensor & all_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
return wrapper_CUDA_all_out_dims_out(self, dim, keepdim, out);
}
at::Tensor & all_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_all_out_dims_out(self, dim, keepdim, out);
}
at::Tensor any(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_any_dim(self, dim, keepdim);
}
at::Tensor & any_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_any_out_out(self, dim, keepdim, out);
}
at::Tensor & any_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_any_out_out(self, dim, keepdim, out);
}
at::Tensor any(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
return wrapper_CUDA_any_dims(self, dim, keepdim);
}
at::Tensor & any_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
return wrapper_CUDA_any_out_dims_out(self, dim, keepdim, out);
}
at::Tensor & any_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_any_out_dims_out(self, dim, keepdim, out);
}
at::Tensor & arange_out(at::Tensor & out, const at::Scalar & start, const at::Scalar & end, const at::Scalar & step) {
return wrapper_CUDA_start_out_arange_out(start, end, step, out);
}
at::Tensor & arange_outf(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
return wrapper_CUDA_start_out_arange_out(start, end, step, out);
}
at::Tensor argmax(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CUDA_argmax(self, dim, keepdim);
}
at::Tensor & argmax_out(at::Tensor & out, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CUDA_argmax_out_out(self, dim, keepdim, out);
}
at::Tensor & argmax_outf(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_argmax_out_out(self, dim, keepdim, out);
}
at::Tensor argmin(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CUDA_argmin(self, dim, keepdim);
}
at::Tensor & argmin_out(at::Tensor & out, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CUDA_argmin_out_out(self, dim, keepdim, out);
}
at::Tensor & argmin_outf(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_argmin_out_out(self, dim, keepdim, out);
}
at::Tensor acosh(const at::Tensor & self) {
return wrapper_CUDA_acosh(self);
}
at::Tensor & acosh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_acosh_out_out(self, out);
}
at::Tensor & acosh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_acosh_out_out(self, out);
}
at::Tensor & acosh_(at::Tensor & self) {
return wrapper_CUDA_acosh_(self);
}
at::Tensor asinh(const at::Tensor & self) {
return wrapper_CUDA_asinh(self);
}
at::Tensor & asinh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_asinh_out_out(self, out);
}
at::Tensor & asinh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_asinh_out_out(self, out);
}
at::Tensor & asinh_(at::Tensor & self) {
return wrapper_CUDA_asinh_(self);
}
at::Tensor atanh(const at::Tensor & self) {
return wrapper_CUDA_atanh(self);
}
at::Tensor & atanh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_atanh_out_out(self, out);
}
at::Tensor & atanh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_atanh_out_out(self, out);
}
at::Tensor & atanh_(at::Tensor & self) {
return wrapper_CUDA_atanh_(self);
}
at::Tensor as_strided(const at::Tensor & self, at::IntArrayRef size, at::IntArrayRef stride, c10::optional<int64_t> storage_offset) {
return wrapper_CUDA__as_strided(self, c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride), storage_offset.has_value() ? c10::make_optional(c10::SymInt(*storage_offset)) : c10::nullopt);
}
at::Tensor as_strided_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
return wrapper_CUDA__as_strided(self, size, stride, storage_offset);
}
at::Tensor asin(const at::Tensor & self) {
return wrapper_CUDA_asin(self);
}
at::Tensor & asin_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_asin_out_out(self, out);
}
at::Tensor & asin_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_asin_out_out(self, out);
}
at::Tensor & asin_(at::Tensor & self) {
return wrapper_CUDA_asin_(self);
}
at::Tensor atan(const at::Tensor & self) {
return wrapper_CUDA_atan(self);
}
at::Tensor & atan_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_atan_out_out(self, out);
}
at::Tensor & atan_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_atan_out_out(self, out);
}
at::Tensor & atan_(at::Tensor & self) {
return wrapper_CUDA_atan_(self);
}
at::Tensor baddbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_baddbmm(self, batch1, batch2, beta, alpha);
}
at::Tensor & baddbmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_baddbmm_out_out(self, batch1, batch2, beta, alpha, out);
}
at::Tensor & baddbmm_outf(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CUDA_baddbmm_out_out(self, batch1, batch2, beta, alpha, out);
}
at::Tensor & baddbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_baddbmm_(self, batch1, batch2, beta, alpha);
}
at::Tensor & bernoulli_out(at::Tensor & out, const at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CUDA_out_bernoulli_out(self, generator, out);
}
at::Tensor & bernoulli_outf(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CUDA_out_bernoulli_out(self, generator, out);
}
at::Tensor & bernoulli_(at::Tensor & self, const at::Tensor & p, c10::optional<at::Generator> generator) {
return wrapper_CUDA_Tensor_bernoulli_(self, p, generator);
}
at::Tensor & bernoulli_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
return wrapper_CUDA_float_bernoulli_(self, p, generator);
}
at::Tensor binary_cross_entropy(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CUDA__binary_cross_entropy(self, target, weight, reduction);
}
at::Tensor & binary_cross_entropy_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CUDA_out_binary_cross_entropy_out(self, target, weight, reduction, out);
}
at::Tensor & binary_cross_entropy_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
return wrapper_CUDA_out_binary_cross_entropy_out(self, target, weight, reduction, out);
}
at::Tensor binary_cross_entropy_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CUDA__binary_cross_entropy_backward(grad_output, self, target, weight, reduction);
}
at::Tensor & binary_cross_entropy_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CUDA_grad_input_binary_cross_entropy_backward_out(grad_output, self, target, weight, reduction, grad_input);
}
at::Tensor & binary_cross_entropy_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_binary_cross_entropy_backward_out(grad_output, self, target, weight, reduction, grad_input);
}
at::Tensor bincount(const at::Tensor & self, const c10::optional<at::Tensor> & weights, int64_t minlength) {
return wrapper_CUDA__bincount(self, weights, minlength);
}
at::Tensor bitwise_not(const at::Tensor & self) {
return wrapper_CUDA_bitwise_not(self);
}
at::Tensor & bitwise_not_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_bitwise_not_out_out(self, out);
}
at::Tensor & bitwise_not_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_bitwise_not_out_out(self, out);
}
at::Tensor & bitwise_not_(at::Tensor & self) {
return wrapper_CUDA_bitwise_not_(self);
}
at::Tensor copysign(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_copysign_Tensor(self, other);
}
at::Tensor & copysign_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_copysign_out_out(self, other, out);
}
at::Tensor & copysign_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_copysign_out_out(self, other, out);
}
at::Tensor & copysign_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_copysign__Tensor(self, other);
}
at::Tensor & logical_not_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_out_logical_not_out(self, out);
}
at::Tensor & logical_not_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_out_logical_not_out(self, out);
}
at::Tensor & logical_xor_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_out_logical_xor_out(self, other, out);
}
at::Tensor & logical_xor_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_out_logical_xor_out(self, other, out);
}
at::Tensor & logical_and_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_out_logical_and_out(self, other, out);
}
at::Tensor & logical_and_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_out_logical_and_out(self, other, out);
}
at::Tensor & logical_or_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_out_logical_or_out(self, other, out);
}
at::Tensor & logical_or_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_out_logical_or_out(self, other, out);
}
at::Tensor bmm(const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CUDA_bmm(self, mat2);
}
at::Tensor & bmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CUDA_bmm_out_out(self, mat2, out);
}
at::Tensor & bmm_outf(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
return wrapper_CUDA_bmm_out_out(self, mat2, out);
}
at::Tensor cat(const at::ITensorListRef & tensors, int64_t dim) {
return wrapper_CUDA_cat(tensors, dim);
}
at::Tensor & cat_out(at::Tensor & out, const at::ITensorListRef & tensors, int64_t dim) {
return wrapper_CUDA_cat_out_out(tensors, dim, out);
}
at::Tensor & cat_outf(const at::ITensorListRef & tensors, int64_t dim, at::Tensor & out) {
return wrapper_CUDA_cat_out_out(tensors, dim, out);
}
at::Tensor ceil(const at::Tensor & self) {
return wrapper_CUDA_ceil(self);
}
at::Tensor & ceil_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_ceil_out_out(self, out);
}
at::Tensor & ceil_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_ceil_out_out(self, out);
}
at::Tensor & ceil_(at::Tensor & self) {
return wrapper_CUDA_ceil_(self);
}
at::Tensor clamp(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
return wrapper_CUDA_clamp(self, min, max);
}
at::Tensor & clamp_out(at::Tensor & out, const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
return wrapper_CUDA_clamp_out_out(self, min, max, out);
}
at::Tensor & clamp_outf(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max, at::Tensor & out) {
return wrapper_CUDA_clamp_out_out(self, min, max, out);
}
at::Tensor & clamp_(at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
return wrapper_CUDA_clamp_(self, min, max);
}
at::Tensor clamp(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
return wrapper_CUDA_clamp_Tensor(self, min, max);
}
at::Tensor & clamp_out(at::Tensor & out, const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
return wrapper_CUDA_clamp_out_Tensor_out(self, min, max, out);
}
at::Tensor & clamp_outf(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max, at::Tensor & out) {
return wrapper_CUDA_clamp_out_Tensor_out(self, min, max, out);
}
at::Tensor & clamp_(at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
return wrapper_CUDA_clamp__Tensor(self, min, max);
}
at::Tensor clamp_max(const at::Tensor & self, const at::Scalar & max) {
return wrapper_CUDA_clamp_max(self, max);
}
at::Tensor & clamp_max_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & max) {
return wrapper_CUDA_clamp_max_out_out(self, max, out);
}
at::Tensor & clamp_max_outf(const at::Tensor & self, const at::Scalar & max, at::Tensor & out) {
return wrapper_CUDA_clamp_max_out_out(self, max, out);
}
at::Tensor & clamp_max_(at::Tensor & self, const at::Scalar & max) {
return wrapper_CUDA_clamp_max_(self, max);
}
at::Tensor clamp_max(const at::Tensor & self, const at::Tensor & max) {
return wrapper_CUDA_clamp_max_Tensor(self, max);
}
at::Tensor & clamp_max_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & max) {
return wrapper_CUDA_clamp_max_out_Tensor_out(self, max, out);
}
at::Tensor & clamp_max_outf(const at::Tensor & self, const at::Tensor & max, at::Tensor & out) {
return wrapper_CUDA_clamp_max_out_Tensor_out(self, max, out);
}
at::Tensor & clamp_max_(at::Tensor & self, const at::Tensor & max) {
return wrapper_CUDA_clamp_max__Tensor(self, max);
}
at::Tensor clamp_min(const at::Tensor & self, const at::Scalar & min) {
return wrapper_CUDA_clamp_min(self, min);
}
at::Tensor & clamp_min_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & min) {
return wrapper_CUDA_clamp_min_out_out(self, min, out);
}
at::Tensor & clamp_min_outf(const at::Tensor & self, const at::Scalar & min, at::Tensor & out) {
return wrapper_CUDA_clamp_min_out_out(self, min, out);
}
at::Tensor & clamp_min_(at::Tensor & self, const at::Scalar & min) {
return wrapper_CUDA_clamp_min_(self, min);
}
at::Tensor clamp_min(const at::Tensor & self, const at::Tensor & min) {
return wrapper_CUDA_clamp_min_Tensor(self, min);
}
at::Tensor & clamp_min_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & min) {
return wrapper_CUDA_clamp_min_out_Tensor_out(self, min, out);
}
at::Tensor & clamp_min_outf(const at::Tensor & self, const at::Tensor & min, at::Tensor & out) {
return wrapper_CUDA_clamp_min_out_Tensor_out(self, min, out);
}
at::Tensor & clamp_min_(at::Tensor & self, const at::Tensor & min) {
return wrapper_CUDA_clamp_min__Tensor(self, min);
}
at::Tensor & complex_out(at::Tensor & out, const at::Tensor & real, const at::Tensor & imag) {
return wrapper_CUDA_out_complex_out(real, imag, out);
}
at::Tensor & complex_outf(const at::Tensor & real, const at::Tensor & imag, at::Tensor & out) {
return wrapper_CUDA_out_complex_out(real, imag, out);
}
at::Tensor & polar_out(at::Tensor & out, const at::Tensor & abs, const at::Tensor & angle) {
return wrapper_CUDA_out_polar_out(abs, angle, out);
}
at::Tensor & polar_outf(const at::Tensor & abs, const at::Tensor & angle, at::Tensor & out) {
return wrapper_CUDA_out_polar_out(abs, angle, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> convolution_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalIntArrayRef bias_sizes, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool transposed, at::IntArrayRef output_padding, int64_t groups, ::std::array<bool,3> output_mask) {
return wrapper_CUDA__convolution_backward(grad_output, input, weight, bias_sizes.has_value() ? c10::make_optional(c10::fromIntArrayRefSlow(*bias_sizes)) : c10::nullopt, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation), transposed, c10::fromIntArrayRefSlow(output_padding), groups, output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> convolution_backward_symint(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::OptionalSymIntArrayRef bias_sizes, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, bool transposed, c10::SymIntArrayRef output_padding, c10::SymInt groups, ::std::array<bool,3> output_mask) {
return wrapper_CUDA__convolution_backward(grad_output, input, weight, bias_sizes, stride, padding, dilation, transposed, output_padding, groups, output_mask);
}
at::Tensor cos(const at::Tensor & self) {
return wrapper_CUDA_cos(self);
}
at::Tensor & cos_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_cos_out_out(self, out);
}
at::Tensor & cos_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_cos_out_out(self, out);
}
at::Tensor & cos_(at::Tensor & self) {
return wrapper_CUDA_cos_(self);
}
at::Tensor cosh(const at::Tensor & self) {
return wrapper_CUDA_cosh(self);
}
at::Tensor & cosh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_cosh_out_out(self, out);
}
at::Tensor & cosh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_cosh_out_out(self, out);
}
at::Tensor & cosh_(at::Tensor & self) {
return wrapper_CUDA_cosh_(self);
}
at::Tensor count_nonzero(const at::Tensor & self, at::IntArrayRef dim) {
return wrapper_CUDA_dim_IntList_count_nonzero(self, dim);
}
at::Tensor cudnn_affine_grid_generator(const at::Tensor & theta, int64_t N, int64_t C, int64_t H, int64_t W) {
return wrapper_CUDA__cudnn_affine_grid_generator(theta, N, C, H, W);
}
at::Tensor cudnn_affine_grid_generator_backward(const at::Tensor & grad, int64_t N, int64_t C, int64_t H, int64_t W) {
return wrapper_CUDA__cudnn_affine_grid_generator_backward(grad, N, C, H, W);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> cudnn_batch_norm(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon) {
return wrapper_CUDA__cudnn_batch_norm(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> cudnn_batch_norm_backward(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon, const at::Tensor & reserveSpace) {
return wrapper_CUDA__cudnn_batch_norm_backward(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace);
}
at::Tensor cudnn_convolution(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef padding, at::IntArrayRef stride, at::IntArrayRef dilation, int64_t groups, bool benchmark, bool deterministic, bool allow_tf32) {
return wrapper_CUDA__cudnn_convolution(self, weight, c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(dilation), groups, benchmark, deterministic, allow_tf32);
}
at::Tensor cudnn_convolution_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) {
return wrapper_CUDA__cudnn_convolution(self, weight, padding, stride, dilation, groups, benchmark, deterministic, allow_tf32);
}
at::Tensor & cudnn_convolution_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef padding, at::IntArrayRef stride, at::IntArrayRef dilation, int64_t groups, bool benchmark, bool deterministic, bool allow_tf32) {
return wrapper_CUDA_out_cudnn_convolution_out(self, weight, c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(dilation), groups, benchmark, deterministic, allow_tf32, out);
}
at::Tensor & cudnn_convolution_outf(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef padding, at::IntArrayRef stride, at::IntArrayRef dilation, int64_t groups, bool benchmark, bool deterministic, bool allow_tf32, at::Tensor & out) {
return wrapper_CUDA_out_cudnn_convolution_out(self, weight, c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(dilation), groups, benchmark, deterministic, allow_tf32, out);
}
at::Tensor & cudnn_convolution_symint_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) {
return wrapper_CUDA_out_cudnn_convolution_out(self, weight, padding, stride, dilation, groups, benchmark, deterministic, allow_tf32, out);
}
at::Tensor & cudnn_convolution_symint_outf(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32, at::Tensor & out) {
return wrapper_CUDA_out_cudnn_convolution_out(self, weight, padding, stride, dilation, groups, benchmark, deterministic, allow_tf32, out);
}
at::Tensor cudnn_convolution_transpose(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef stride, at::IntArrayRef dilation, int64_t groups, bool benchmark, bool deterministic, bool allow_tf32) {
return wrapper_CUDA__cudnn_convolution_transpose(self, weight, c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(output_padding), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(dilation), groups, benchmark, deterministic, allow_tf32);
}
at::Tensor cudnn_convolution_transpose_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic, bool allow_tf32) {
return wrapper_CUDA__cudnn_convolution_transpose(self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32);
}
at::Tensor cudnn_convolution_relu(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, int64_t groups) {
return wrapper_CUDA__cudnn_convolution_relu(self, weight, bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation), groups);
}
at::Tensor cudnn_convolution_relu_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
return wrapper_CUDA__cudnn_convolution_relu(self, weight, bias, stride, padding, dilation, groups);
}
at::Tensor cudnn_convolution_add_relu(const at::Tensor & self, const at::Tensor & weight, const at::Tensor & z, const c10::optional<at::Scalar> & alpha, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, int64_t groups) {
return wrapper_CUDA__cudnn_convolution_add_relu(self, weight, z, alpha, bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation), groups);
}
at::Tensor cudnn_convolution_add_relu_symint(const at::Tensor & self, const at::Tensor & weight, const at::Tensor & z, const c10::optional<at::Scalar> & alpha, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
return wrapper_CUDA__cudnn_convolution_add_relu(self, weight, z, alpha, bias, stride, padding, dilation, groups);
}
at::Tensor cudnn_grid_sampler(const at::Tensor & self, const at::Tensor & grid) {
return wrapper_CUDA__cudnn_grid_sampler(self, grid);
}
::std::tuple<at::Tensor,at::Tensor> cudnn_grid_sampler_backward(const at::Tensor & self, const at::Tensor & grid, const at::Tensor & grad_output) {
return wrapper_CUDA__cudnn_grid_sampler_backward(self, grid, grad_output);
}
void _cummax_helper(const at::Tensor & self, at::Tensor & values, at::Tensor & indices, int64_t dim) {
return wrapper_CUDA___cummax_helper(self, values, indices, dim);
}
void _cummin_helper(const at::Tensor & self, at::Tensor & values, at::Tensor & indices, int64_t dim) {
return wrapper_CUDA___cummin_helper(self, values, indices, dim);
}
at::Tensor cumprod(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_cumprod(self, dim, dtype);
}
at::Tensor & cumprod_out(at::Tensor & out, const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_cumprod_out_out(self, dim, dtype, out);
}
at::Tensor & cumprod_outf(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CUDA_cumprod_out_out(self, dim, dtype, out);
}
at::Tensor & cumprod_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_cumprod_(self, dim, dtype);
}
at::Tensor cumsum(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_cumsum(self, dim, dtype);
}
at::Tensor & cumsum_out(at::Tensor & out, const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_cumsum_out_out(self, dim, dtype, out);
}
at::Tensor & cumsum_outf(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CUDA_cumsum_out_out(self, dim, dtype, out);
}
at::Tensor & cumsum_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_cumsum_(self, dim, dtype);
}
::std::tuple<at::Tensor,at::Tensor> _ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool zero_infinity) {
return wrapper_CUDA___ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}
::std::tuple<at::Tensor,at::Tensor> _ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool zero_infinity) {
return wrapper_CUDA_Tensor__ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}
at::Tensor _ctc_loss_backward(const at::Tensor & grad, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, const at::Tensor & neg_log_likelihood, const at::Tensor & log_alpha, int64_t blank, bool zero_infinity) {
return wrapper_CUDA___ctc_loss_backward(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity);
}
at::Tensor _ctc_loss_backward(const at::Tensor & grad, const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, const at::Tensor & neg_log_likelihood, const at::Tensor & log_alpha, int64_t blank, bool zero_infinity) {
return wrapper_CUDA_Tensor__ctc_loss_backward(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity);
}
at::Tensor div(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_div_Tensor(self, other);
}
at::Tensor & div_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_div_out_out(self, other, out);
}
at::Tensor & div_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_div_out_out(self, other, out);
}
at::Tensor & div_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_div__Tensor(self, other);
}
at::Tensor div(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
return wrapper_CUDA_div_Tensor_mode(self, other, rounding_mode);
}
at::Tensor & div_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
return wrapper_CUDA_div_out_out_mode(self, other, rounding_mode, out);
}
at::Tensor & div_outf(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode, at::Tensor & out) {
return wrapper_CUDA_div_out_out_mode(self, other, rounding_mode, out);
}
at::Tensor & div_(at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
return wrapper_CUDA_div__Tensor_mode(self, other, rounding_mode);
}
at::Tensor dot(const at::Tensor & self, const at::Tensor & tensor) {
return wrapper_CUDA__dot(self, tensor);
}
at::Tensor vdot(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA__vdot(self, other);
}
at::Tensor embedding_dense_backward(const at::Tensor & grad_output, const at::Tensor & indices, int64_t num_weights, int64_t padding_idx, bool scale_grad_by_freq) {
return wrapper_CUDA__embedding_dense_backward(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq);
}
at::Tensor embedding_dense_backward_symint(const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq) {
return wrapper_CUDA__embedding_dense_backward(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq);
}
at::Tensor & embedding_renorm_(at::Tensor & self, const at::Tensor & indices, double max_norm, double norm_type) {
return wrapper_CUDA__embedding_renorm_(self, indices, max_norm, norm_type);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _embedding_bag_forward_only(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
return wrapper_CUDA___embedding_bag_forward_only(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _embedding_bag(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
return wrapper_CUDA___embedding_bag(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}
at::Tensor _embedding_bag_dense_backward(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, int64_t num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
return wrapper_CUDA___embedding_bag_dense_backward(grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}
at::Tensor _embedding_bag_dense_backward_symint(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
return wrapper_CUDA___embedding_bag_dense_backward(grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}
at::Tensor _embedding_bag_per_sample_weights_backward(const at::Tensor & grad, const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, const at::Tensor & offset2bag, int64_t mode, int64_t padding_idx) {
return wrapper_CUDA___embedding_bag_per_sample_weights_backward(grad, weight, indices, offsets, offset2bag, mode, padding_idx);
}
at::Tensor empty(at::IntArrayRef size, at::TensorOptions options, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CUDA_memory_format_empty(c10::fromIntArrayRefSlow(size), c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt(), c10::impl::check_tensor_options_and_extract_memory_format(options, memory_format));
}
at::Tensor empty(at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CUDA_memory_format_empty(c10::fromIntArrayRefSlow(size), dtype, layout, device, pin_memory, memory_format);
}
at::Tensor empty_symint(c10::SymIntArrayRef size, at::TensorOptions options, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CUDA_memory_format_empty(size, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt(), c10::impl::check_tensor_options_and_extract_memory_format(options, memory_format));
}
at::Tensor empty_symint(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CUDA_memory_format_empty(size, dtype, layout, device, pin_memory, memory_format);
}
const at::Tensor & resize_(const at::Tensor & self, at::IntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CUDA__resize_(self, c10::fromIntArrayRefSlow(size), memory_format);
}
const at::Tensor & resize__symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CUDA__resize_(self, size, memory_format);
}
at::Tensor empty_strided(at::IntArrayRef size, at::IntArrayRef stride, at::TensorOptions options) {
return wrapper_CUDA__empty_strided(c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride), c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor empty_strided(at::IntArrayRef size, at::IntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CUDA__empty_strided(c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride), dtype, layout, device, pin_memory);
}
at::Tensor empty_strided_symint(c10::SymIntArrayRef size, c10::SymIntArrayRef stride, at::TensorOptions options) {
return wrapper_CUDA__empty_strided(size, stride, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor empty_strided_symint(c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CUDA__empty_strided(size, stride, dtype, layout, device, pin_memory);
}
at::Tensor erf(const at::Tensor & self) {
return wrapper_CUDA_erf(self);
}
at::Tensor & erf_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_erf_out_out(self, out);
}
at::Tensor & erf_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_erf_out_out(self, out);
}
at::Tensor & erf_(at::Tensor & self) {
return wrapper_CUDA_erf_(self);
}
at::Tensor erfc(const at::Tensor & self) {
return wrapper_CUDA_erfc(self);
}
at::Tensor & erfc_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_erfc_out_out(self, out);
}
at::Tensor & erfc_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_erfc_out_out(self, out);
}
at::Tensor & erfc_(at::Tensor & self) {
return wrapper_CUDA_erfc_(self);
}
at::Tensor exp(const at::Tensor & self) {
return wrapper_CUDA_exp(self);
}
at::Tensor & exp_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_exp_out_out(self, out);
}
at::Tensor & exp_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_exp_out_out(self, out);
}
at::Tensor & exp_(at::Tensor & self) {
return wrapper_CUDA_exp_(self);
}
at::Tensor exp2(const at::Tensor & self) {
return wrapper_CUDA_exp2(self);
}
at::Tensor & exp2_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_exp2_out_out(self, out);
}
at::Tensor & exp2_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_exp2_out_out(self, out);
}
at::Tensor & exp2_(at::Tensor & self) {
return wrapper_CUDA_exp2_(self);
}
at::Tensor expm1(const at::Tensor & self) {
return wrapper_CUDA_expm1(self);
}
at::Tensor & expm1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_expm1_out_out(self, out);
}
at::Tensor & expm1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_expm1_out_out(self, out);
}
at::Tensor & expm1_(at::Tensor & self) {
return wrapper_CUDA_expm1_(self);
}
at::Tensor & eye_out(at::Tensor & out, int64_t n) {
return wrapper_CUDA_out_eye_out(n, out);
}
at::Tensor & eye_outf(int64_t n, at::Tensor & out) {
return wrapper_CUDA_out_eye_out(n, out);
}
at::Tensor & eye_symint_out(at::Tensor & out, c10::SymInt n) {
return wrapper_CUDA_out_eye_out(n, out);
}
at::Tensor & eye_symint_outf(c10::SymInt n, at::Tensor & out) {
return wrapper_CUDA_out_eye_out(n, out);
}
at::Tensor & eye_out(at::Tensor & out, int64_t n, int64_t m) {
return wrapper_CUDA_m_out_eye_out(n, m, out);
}
at::Tensor & eye_outf(int64_t n, int64_t m, at::Tensor & out) {
return wrapper_CUDA_m_out_eye_out(n, m, out);
}
at::Tensor & eye_symint_out(at::Tensor & out, c10::SymInt n, c10::SymInt m) {
return wrapper_CUDA_m_out_eye_out(n, m, out);
}
at::Tensor & eye_symint_outf(c10::SymInt n, c10::SymInt m, at::Tensor & out) {
return wrapper_CUDA_m_out_eye_out(n, m, out);
}
at::Tensor & fill_(at::Tensor & self, const at::Scalar & value) {
return wrapper_CUDA_Scalar_fill_(self, value);
}
at::Tensor & fill_(at::Tensor & self, const at::Tensor & value) {
return wrapper_CUDA_Tensor_fill_(self, value);
}
at::Tensor floor(const at::Tensor & self) {
return wrapper_CUDA_floor(self);
}
at::Tensor & floor_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_floor_out_out(self, out);
}
at::Tensor & floor_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_floor_out_out(self, out);
}
at::Tensor & floor_(at::Tensor & self) {
return wrapper_CUDA_floor_(self);
}
at::Tensor floor_divide(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA__floor_divide(self, other);
}
at::Tensor & floor_divide_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_out_floor_divide_out(self, other, out);
}
at::Tensor & floor_divide_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_out_floor_divide_out(self, other, out);
}
at::Tensor & floor_divide_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_Tensor_floor_divide_(self, other);
}
at::Tensor frac(const at::Tensor & self) {
return wrapper_CUDA_frac(self);
}
at::Tensor & frac_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_frac_out_out(self, out);
}
at::Tensor & frac_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_frac_out_out(self, out);
}
at::Tensor & frac_(at::Tensor & self) {
return wrapper_CUDA_frac_(self);
}
at::Tensor gcd(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_gcd(self, other);
}
at::Tensor & gcd_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_gcd_out_out(self, other, out);
}
at::Tensor & gcd_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_gcd_out_out(self, other, out);
}
at::Tensor & gcd_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_gcd_(self, other);
}
at::Tensor lcm(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_lcm(self, other);
}
at::Tensor & lcm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_lcm_out_out(self, other, out);
}
at::Tensor & lcm_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_lcm_out_out(self, other, out);
}
at::Tensor & lcm_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_lcm_(self, other);
}
at::Tensor grid_sampler_2d(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
return wrapper_CUDA__grid_sampler_2d(input, grid, interpolation_mode, padding_mode, align_corners);
}
::std::tuple<at::Tensor,at::Tensor> grid_sampler_2d_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
return wrapper_CUDA__grid_sampler_2d_backward(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}
at::Tensor grid_sampler_3d(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
return wrapper_CUDA__grid_sampler_3d(input, grid, interpolation_mode, padding_mode, align_corners);
}
::std::tuple<at::Tensor,at::Tensor> grid_sampler_3d_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
return wrapper_CUDA__grid_sampler_3d_backward(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_group_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, int64_t N, int64_t C, int64_t HxW, int64_t group, double eps) {
return wrapper_CUDA__native_group_norm(input, weight, bias, N, C, HxW, group, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_group_norm_symint(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, double eps) {
return wrapper_CUDA__native_group_norm(input, weight, bias, N, C, HxW, group, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_group_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, int64_t N, int64_t C, int64_t HxW, int64_t group, ::std::array<bool,3> output_mask) {
return wrapper_CUDA__native_group_norm_backward(grad_out, input, mean, rstd, weight, N, C, HxW, group, output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_group_norm_backward_symint(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, ::std::array<bool,3> output_mask) {
return wrapper_CUDA__native_group_norm_backward(grad_out, input, mean, rstd, weight, N, C, HxW, group, output_mask);
}
at::Tensor _fft_r2c(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided) {
return wrapper_CUDA___fft_r2c(self, dim, normalization, onesided);
}
at::Tensor & _fft_r2c_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided) {
return wrapper_CUDA_out__fft_r2c_out(self, dim, normalization, onesided, out);
}
at::Tensor & _fft_r2c_outf(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided, at::Tensor & out) {
return wrapper_CUDA_out__fft_r2c_out(self, dim, normalization, onesided, out);
}
at::Tensor _fft_c2r(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, int64_t last_dim_size) {
return wrapper_CUDA___fft_c2r(self, dim, normalization, last_dim_size);
}
at::Tensor _fft_c2r_symint(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size) {
return wrapper_CUDA___fft_c2r(self, dim, normalization, last_dim_size);
}
at::Tensor & _fft_c2r_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, int64_t last_dim_size) {
return wrapper_CUDA_out__fft_c2r_out(self, dim, normalization, last_dim_size, out);
}
at::Tensor & _fft_c2r_outf(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, int64_t last_dim_size, at::Tensor & out) {
return wrapper_CUDA_out__fft_c2r_out(self, dim, normalization, last_dim_size, out);
}
at::Tensor & _fft_c2r_symint_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size) {
return wrapper_CUDA_out__fft_c2r_out(self, dim, normalization, last_dim_size, out);
}
at::Tensor & _fft_c2r_symint_outf(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size, at::Tensor & out) {
return wrapper_CUDA_out__fft_c2r_out(self, dim, normalization, last_dim_size, out);
}
at::Tensor _fft_c2c(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool forward) {
return wrapper_CUDA___fft_c2c(self, c10::fromIntArrayRefSlow(dim), normalization, forward);
}
at::Tensor _fft_c2c_symint(const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward) {
return wrapper_CUDA___fft_c2c(self, dim, normalization, forward);
}
at::Tensor & _fft_c2c_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool forward) {
return wrapper_CUDA_out__fft_c2c_out(self, c10::fromIntArrayRefSlow(dim), normalization, forward, out);
}
at::Tensor & _fft_c2c_outf(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool forward, at::Tensor & out) {
return wrapper_CUDA_out__fft_c2c_out(self, c10::fromIntArrayRefSlow(dim), normalization, forward, out);
}
at::Tensor & _fft_c2c_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward) {
return wrapper_CUDA_out__fft_c2c_out(self, dim, normalization, forward, out);
}
at::Tensor & _fft_c2c_symint_outf(const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward, at::Tensor & out) {
return wrapper_CUDA_out__fft_c2c_out(self, dim, normalization, forward, out);
}
void _validate_compressed_sparse_indices(bool is_crow, const at::Tensor & compressed_idx, const at::Tensor & plain_idx, int64_t cdim, int64_t dim, int64_t nnz) {
return wrapper_CUDA___validate_compressed_sparse_indices(is_crow, compressed_idx, plain_idx, cdim, dim, nnz);
}
at::Tensor index(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices) {
return wrapper_CUDA_index_Tensor(self, indices);
}
at::Tensor & index_out(at::Tensor & out, const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices) {
return wrapper_CUDA_index_out_Tensor_out(self, indices, out);
}
at::Tensor & index_outf(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, at::Tensor & out) {
return wrapper_CUDA_index_out_Tensor_out(self, indices, out);
}
at::Tensor index_copy(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
return wrapper_CUDA_index_copy(self, dim, index, source);
}
at::Tensor & index_copy_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
return wrapper_CUDA_index_copy_out_out(self, dim, index, source, out);
}
at::Tensor & index_copy_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, at::Tensor & out) {
return wrapper_CUDA_index_copy_out_out(self, dim, index, source, out);
}
at::Tensor & index_copy_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
return wrapper_CUDA_index_copy_(self, dim, index, source);
}
at::Tensor & _index_put_impl_(at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
return wrapper_CUDA___index_put_impl_(self, indices, values, accumulate, unsafe);
}
at::Tensor isin(const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert) {
return wrapper_CUDA_isin_Tensor_Tensor(elements, test_elements, assume_unique, invert);
}
at::Tensor & isin_out(at::Tensor & out, const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert) {
return wrapper_CUDA_isin_out_Tensor_Tensor_out(elements, test_elements, assume_unique, invert, out);
}
at::Tensor & isin_outf(const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert, at::Tensor & out) {
return wrapper_CUDA_isin_out_Tensor_Tensor_out(elements, test_elements, assume_unique, invert, out);
}
at::Tensor isin(const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert) {
return wrapper_CUDA_isin_Tensor_Scalar(elements, test_element, assume_unique, invert);
}
at::Tensor & isin_out(at::Tensor & out, const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert) {
return wrapper_CUDA_isin_out_Tensor_Scalar_out(elements, test_element, assume_unique, invert, out);
}
at::Tensor & isin_outf(const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert, at::Tensor & out) {
return wrapper_CUDA_isin_out_Tensor_Scalar_out(elements, test_element, assume_unique, invert, out);
}
at::Tensor isin(const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert) {
return wrapper_CUDA_isin_Scalar_Tensor(element, test_elements, assume_unique, invert);
}
at::Tensor & isin_out(at::Tensor & out, const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert) {
return wrapper_CUDA_isin_out_Scalar_Tensor_out(element, test_elements, assume_unique, invert, out);
}
at::Tensor & isin_outf(const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert, at::Tensor & out) {
return wrapper_CUDA_isin_out_Scalar_Tensor_out(element, test_elements, assume_unique, invert, out);
}
at::Tensor isnan(const at::Tensor & self) {
return wrapper_CUDA__isnan(self);
}
::std::tuple<at::Tensor &,at::Tensor &> kthvalue_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, int64_t k, int64_t dim, bool keepdim) {
return wrapper_CUDA_values_kthvalue_out(self, k, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> kthvalue_outf(const at::Tensor & self, int64_t k, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
return wrapper_CUDA_values_kthvalue_out(self, k, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_layer_norm(const at::Tensor & input, at::IntArrayRef normalized_shape, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps) {
return wrapper_CUDA__native_layer_norm(input, c10::fromIntArrayRefSlow(normalized_shape), weight, bias, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_layer_norm_symint(const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps) {
return wrapper_CUDA__native_layer_norm(input, normalized_shape, weight, bias, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_layer_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, at::IntArrayRef normalized_shape, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, ::std::array<bool,3> output_mask) {
return wrapper_CUDA__native_layer_norm_backward(grad_out, input, c10::fromIntArrayRefSlow(normalized_shape), mean, rstd, weight, bias, output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_layer_norm_backward_symint(const at::Tensor & grad_out, const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, ::std::array<bool,3> output_mask) {
return wrapper_CUDA__native_layer_norm_backward(grad_out, input, normalized_shape, mean, rstd, weight, bias, output_mask);
}
at::Tensor & nan_to_num_out(at::Tensor & out, const at::Tensor & self, c10::optional<double> nan, c10::optional<double> posinf, c10::optional<double> neginf) {
return wrapper_CUDA_out_nan_to_num_out(self, nan, posinf, neginf, out);
}
at::Tensor & nan_to_num_outf(const at::Tensor & self, c10::optional<double> nan, c10::optional<double> posinf, c10::optional<double> neginf, at::Tensor & out) {
return wrapper_CUDA_out_nan_to_num_out(self, nan, posinf, neginf, out);
}
at::Tensor _cslt_compress(const at::Tensor & input) {
return wrapper_CUDA___cslt_compress(input);
}
at::Tensor _cslt_sparse_mm(const at::Tensor & compressed_A, const at::Tensor & dense_B, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & alpha, c10::optional<at::ScalarType> out_dtype, bool transpose_result, int64_t alg_id) {
return wrapper_CUDA___cslt_sparse_mm(compressed_A, dense_B, bias, alpha, out_dtype, transpose_result, alg_id);
}
int64_t _cslt_sparse_mm_search(const at::Tensor & compressed_A, const at::Tensor & dense_B, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & alpha, c10::optional<at::ScalarType> out_dtype, bool transpose_result) {
return wrapper_CUDA___cslt_sparse_mm_search(compressed_A, dense_B, bias, alpha, out_dtype, transpose_result);
}
at::Tensor _sparse_semi_structured_linear(const at::Tensor & input, const at::Tensor & weight, const at::Tensor & meta, const c10::optional<at::Tensor> & bias, c10::optional<c10::string_view> activation, c10::optional<at::ScalarType> out_dtype) {
return wrapper_CUDA___sparse_semi_structured_linear(input, weight, meta, bias, activation, out_dtype);
}
at::Tensor _mixed_dtypes_linear(const at::Tensor & input, const at::Tensor & weight, const at::Tensor & scale, const c10::optional<at::Tensor> & bias, c10::optional<c10::string_view> activation) {
return wrapper_CUDA___mixed_dtypes_linear(input, weight, scale, bias, activation);
}
at::Tensor & linspace_out(at::Tensor & out, const at::Scalar & start, const at::Scalar & end, int64_t steps) {
return wrapper_CUDA_out_linspace_out(start, end, steps, out);
}
at::Tensor & linspace_outf(const at::Scalar & start, const at::Scalar & end, int64_t steps, at::Tensor & out) {
return wrapper_CUDA_out_linspace_out(start, end, steps, out);
}
at::Tensor log(const at::Tensor & self) {
return wrapper_CUDA_log(self);
}
at::Tensor & log_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_log_out_out(self, out);
}
at::Tensor & log_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_log_out_out(self, out);
}
at::Tensor & log_(at::Tensor & self) {
return wrapper_CUDA_log_(self);
}
at::Tensor log10(const at::Tensor & self) {
return wrapper_CUDA_log10(self);
}
at::Tensor & log10_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_log10_out_out(self, out);
}
at::Tensor & log10_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_log10_out_out(self, out);
}
at::Tensor & log10_(at::Tensor & self) {
return wrapper_CUDA_log10_(self);
}
at::Tensor log1p(const at::Tensor & self) {
return wrapper_CUDA_log1p(self);
}
at::Tensor & log1p_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_log1p_out_out(self, out);
}
at::Tensor & log1p_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_log1p_out_out(self, out);
}
at::Tensor & log1p_(at::Tensor & self) {
return wrapper_CUDA_log1p_(self);
}
at::Tensor log2(const at::Tensor & self) {
return wrapper_CUDA_log2(self);
}
at::Tensor & log2_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_log2_out_out(self, out);
}
at::Tensor & log2_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_log2_out_out(self, out);
}
at::Tensor & log2_(at::Tensor & self) {
return wrapper_CUDA_log2_(self);
}
at::Tensor logaddexp(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_logaddexp(self, other);
}
at::Tensor & logaddexp_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_logaddexp_out_out(self, other, out);
}
at::Tensor & logaddexp_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_logaddexp_out_out(self, other, out);
}
at::Tensor logaddexp2(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_logaddexp2(self, other);
}
at::Tensor & logaddexp2_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_logaddexp2_out_out(self, other, out);
}
at::Tensor & logaddexp2_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_logaddexp2_out_out(self, other, out);
}
at::Tensor xlogy(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_xlogy_Tensor(self, other);
}
at::Tensor & xlogy_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_xlogy_out_OutTensor(self, other, out);
}
at::Tensor & xlogy_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_xlogy_out_OutTensor(self, other, out);
}
at::Tensor & xlogy_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_xlogy__Tensor(self, other);
}
at::Tensor & logspace_out(at::Tensor & out, const at::Scalar & start, const at::Scalar & end, int64_t steps, double base) {
return wrapper_CUDA_out_logspace_out(start, end, steps, base, out);
}
at::Tensor & logspace_outf(const at::Scalar & start, const at::Scalar & end, int64_t steps, double base, at::Tensor & out) {
return wrapper_CUDA_out_logspace_out(start, end, steps, base, out);
}
at::Tensor _log_softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
return wrapper_CUDA__log_softmax(self, dim, half_to_float);
}
at::Tensor & _log_softmax_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool half_to_float) {
return wrapper_CUDA__log_softmax_out_out(self, dim, half_to_float, out);
}
at::Tensor & _log_softmax_outf(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
return wrapper_CUDA__log_softmax_out_out(self, dim, half_to_float, out);
}
at::Tensor _log_softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
return wrapper_CUDA__log_softmax_backward_data(grad_output, output, dim, input_dtype);
}
at::Tensor & _log_softmax_backward_data_out(at::Tensor & out, const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
return wrapper_CUDA__log_softmax_backward_data_out_out(grad_output, output, dim, input_dtype, out);
}
at::Tensor & _log_softmax_backward_data_outf(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & out) {
return wrapper_CUDA__log_softmax_backward_data_out_out(grad_output, output, dim, input_dtype, out);
}
at::Tensor _logcumsumexp(const at::Tensor & self, int64_t dim) {
return wrapper_CUDA___logcumsumexp(self, dim);
}
at::Tensor & _logcumsumexp_out(at::Tensor & out, const at::Tensor & self, int64_t dim) {
return wrapper_CUDA_out__logcumsumexp_out(self, dim, out);
}
at::Tensor & _logcumsumexp_outf(const at::Tensor & self, int64_t dim, at::Tensor & out) {
return wrapper_CUDA_out__logcumsumexp_out(self, dim, out);
}
::std::tuple<at::Tensor,at::Tensor> _aminmax(const at::Tensor & self) {
return wrapper_CUDA___aminmax(self);
}
::std::tuple<at::Tensor,at::Tensor> _aminmax(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_dim__aminmax(self, dim, keepdim);
}
::std::tuple<at::Tensor,at::Tensor> aminmax(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CUDA_aminmax(self, dim, keepdim);
}
::std::tuple<at::Tensor &,at::Tensor &> aminmax_out(at::Tensor & min, at::Tensor & max, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CUDA_aminmax_out_out(self, dim, keepdim, min, max);
}
::std::tuple<at::Tensor &,at::Tensor &> aminmax_outf(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & min, at::Tensor & max) {
return wrapper_CUDA_aminmax_out_out(self, dim, keepdim, min, max);
}
at::Tensor _compute_linear_combination(const at::Tensor & input, const at::Tensor & coefficients) {
return wrapper_CUDA___compute_linear_combination(input, coefficients);
}
at::Tensor & _compute_linear_combination_out(at::Tensor & out, const at::Tensor & input, const at::Tensor & coefficients) {
return wrapper_CUDA_out__compute_linear_combination_out(input, coefficients, out);
}
at::Tensor & _compute_linear_combination_outf(const at::Tensor & input, const at::Tensor & coefficients, at::Tensor & out) {
return wrapper_CUDA_out__compute_linear_combination_out(input, coefficients, out);
}
::std::tuple<at::Tensor,at::Tensor> max(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_max_dim(self, dim, keepdim);
}
::std::tuple<at::Tensor &,at::Tensor &> max_out(at::Tensor & max, at::Tensor & max_values, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_max_out_dim_max(self, dim, keepdim, max, max_values);
}
::std::tuple<at::Tensor &,at::Tensor &> max_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
return wrapper_CUDA_max_out_dim_max(self, dim, keepdim, max, max_values);
}
at::Tensor amax(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
return wrapper_CUDA_amax(self, dim, keepdim);
}
at::Tensor & amax_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
return wrapper_CUDA_amax_out_out(self, dim, keepdim, out);
}
at::Tensor & amax_outf(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_amax_out_out(self, dim, keepdim, out);
}
at::Tensor mean(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_mean_dim(self, dim, keepdim, dtype);
}
at::Tensor & mean_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_mean_out_out(self, dim, keepdim, dtype, out);
}
at::Tensor & mean_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CUDA_mean_out_out(self, dim, keepdim, dtype, out);
}
at::Tensor median(const at::Tensor & self) {
return wrapper_CUDA__median(self);
}
::std::tuple<at::Tensor &,at::Tensor &> median_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_dim_values_median_out(self, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> median_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
return wrapper_CUDA_dim_values_median_out(self, dim, keepdim, values, indices);
}
at::Tensor nanmedian(const at::Tensor & self) {
return wrapper_CUDA__nanmedian(self);
}
::std::tuple<at::Tensor &,at::Tensor &> nanmedian_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_dim_values_nanmedian_out(self, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> nanmedian_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
return wrapper_CUDA_dim_values_nanmedian_out(self, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor,at::Tensor> min(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_min_dim(self, dim, keepdim);
}
::std::tuple<at::Tensor &,at::Tensor &> min_out(at::Tensor & min, at::Tensor & min_indices, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA_min_out_dim_min(self, dim, keepdim, min, min_indices);
}
::std::tuple<at::Tensor &,at::Tensor &> min_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & min, at::Tensor & min_indices) {
return wrapper_CUDA_min_out_dim_min(self, dim, keepdim, min, min_indices);
}
at::Tensor amin(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
return wrapper_CUDA_amin(self, dim, keepdim);
}
at::Tensor & amin_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
return wrapper_CUDA_amin_out_out(self, dim, keepdim, out);
}
at::Tensor & amin_outf(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_amin_out_out(self, dim, keepdim, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> miopen_batch_norm(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double exponential_average_factor, double epsilon) {
return wrapper_CUDA__miopen_batch_norm(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> miopen_batch_norm_backward(const at::Tensor & input, const at::Tensor & grad_output, const at::Tensor & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_var, double epsilon) {
return wrapper_CUDA__miopen_batch_norm_backward(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon);
}
at::Tensor miopen_convolution(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::IntArrayRef padding, at::IntArrayRef stride, at::IntArrayRef dilation, int64_t groups, bool benchmark, bool deterministic) {
return wrapper_CUDA__miopen_convolution(self, weight, bias, c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(dilation), groups, benchmark, deterministic);
}
at::Tensor miopen_convolution_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic) {
return wrapper_CUDA__miopen_convolution(self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic);
}
at::Tensor miopen_convolution_transpose(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef stride, at::IntArrayRef dilation, int64_t groups, bool benchmark, bool deterministic) {
return wrapper_CUDA__miopen_convolution_transpose(self, weight, bias, c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(output_padding), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(dilation), groups, benchmark, deterministic);
}
at::Tensor miopen_convolution_transpose_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic) {
return wrapper_CUDA__miopen_convolution_transpose(self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic);
}
at::Tensor miopen_depthwise_convolution(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::IntArrayRef padding, at::IntArrayRef stride, at::IntArrayRef dilation, int64_t groups, bool benchmark, bool deterministic) {
return wrapper_CUDA__miopen_depthwise_convolution(self, weight, bias, c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(dilation), groups, benchmark, deterministic);
}
at::Tensor miopen_depthwise_convolution_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef padding, c10::SymIntArrayRef stride, c10::SymIntArrayRef dilation, c10::SymInt groups, bool benchmark, bool deterministic) {
return wrapper_CUDA__miopen_depthwise_convolution(self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic);
}
at::Tensor miopen_convolution_relu(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, int64_t groups) {
return wrapper_CUDA__miopen_convolution_relu(self, weight, bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation), groups);
}
at::Tensor miopen_convolution_relu_symint(const at::Tensor & self, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
return wrapper_CUDA__miopen_convolution_relu(self, weight, bias, stride, padding, dilation, groups);
}
at::Tensor miopen_convolution_add_relu(const at::Tensor & self, const at::Tensor & weight, const at::Tensor & z, const c10::optional<at::Scalar> & alpha, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, int64_t groups) {
return wrapper_CUDA__miopen_convolution_add_relu(self, weight, z, alpha, bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation), groups);
}
at::Tensor miopen_convolution_add_relu_symint(const at::Tensor & self, const at::Tensor & weight, const at::Tensor & z, const c10::optional<at::Scalar> & alpha, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, c10::SymInt groups) {
return wrapper_CUDA__miopen_convolution_add_relu(self, weight, z, alpha, bias, stride, padding, dilation, groups);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> miopen_rnn(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state) {
return wrapper_CUDA__miopen_rnn(input, weight, weight_stride0, hx, cx, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,::std::vector<at::Tensor>> miopen_rnn_backward(const at::Tensor & input, at::TensorList weight, int64_t weight_stride0, const at::Tensor & weight_buf, const at::Tensor & hx, const c10::optional<at::Tensor> & cx, const at::Tensor & output, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, int64_t mode, int64_t hidden_size, int64_t num_layers, bool batch_first, double dropout, bool train, bool bidirectional, at::IntArrayRef batch_sizes, const c10::optional<at::Tensor> & dropout_state, const at::Tensor & reserve, ::std::array<bool,4> output_mask) {
return wrapper_CUDA__miopen_rnn_backward(input, weight, weight_stride0, weight_buf, hx, cx, output, grad_output, grad_hy, grad_cy, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state, reserve, output_mask);
}
at::Tensor mm(const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CUDA_mm(self, mat2);
}
at::Tensor & mm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CUDA_mm_out_out(self, mat2, out);
}
at::Tensor & mm_outf(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
return wrapper_CUDA_mm_out_out(self, mat2, out);
}
at::Tensor _int_mm(const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CUDA___int_mm(self, mat2);
}
at::Tensor & _int_mm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CUDA_out__int_mm_out(self, mat2, out);
}
at::Tensor & _int_mm_outf(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
return wrapper_CUDA_out__int_mm_out(self, mat2, out);
}
at::Tensor _convert_weight_to_int4pack(const at::Tensor & self, int64_t innerKTiles) {
return wrapper_CUDA___convert_weight_to_int4pack(self, innerKTiles);
}
at::Tensor _weight_int4pack_mm(const at::Tensor & self, const at::Tensor & mat2, int64_t qGroupSize, const at::Tensor & qScaleAndZeros) {
return wrapper_CUDA___weight_int4pack_mm(self, mat2, qGroupSize, qScaleAndZeros);
}
::std::tuple<at::Tensor,at::Tensor> mode(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CUDA__mode(self, dim, keepdim);
}
at::Tensor mul(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_mul_Tensor(self, other);
}
at::Tensor & mul_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_mul_out_out(self, other, out);
}
at::Tensor & mul_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_mul_out_out(self, other, out);
}
at::Tensor & mul_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_mul__Tensor(self, other);
}
at::Tensor & mvlgamma_out(at::Tensor & out, const at::Tensor & self, int64_t p) {
return wrapper_CUDA_out_mvlgamma_out(self, p, out);
}
at::Tensor & mvlgamma_outf(const at::Tensor & self, int64_t p, at::Tensor & out) {
return wrapper_CUDA_out_mvlgamma_out(self, p, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_batch_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps) {
return wrapper_CUDA__native_batch_norm(input, weight, bias, running_mean, running_var, training, momentum, eps);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> native_batch_norm_out(at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps) {
return wrapper_CUDA_out_native_batch_norm_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> native_batch_norm_outf(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
return wrapper_CUDA_out_native_batch_norm_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _native_batch_norm_legit_out(at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps) {
return wrapper_CUDA_out__native_batch_norm_legit_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _native_batch_norm_legit_outf(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
return wrapper_CUDA_out__native_batch_norm_legit_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _native_batch_norm_legit(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps) {
return wrapper_CUDA___native_batch_norm_legit(input, weight, bias, running_mean, running_var, training, momentum, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _native_batch_norm_legit(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps) {
return wrapper_CUDA_no_stats__native_batch_norm_legit(input, weight, bias, training, momentum, eps);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _native_batch_norm_legit_out(at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps) {
return wrapper_CUDA_no_stats_out__native_batch_norm_legit_out(input, weight, bias, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _native_batch_norm_legit_outf(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
return wrapper_CUDA_no_stats_out__native_batch_norm_legit_out(input, weight, bias, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor,at::Tensor> batch_norm_stats(const at::Tensor & input, double eps) {
return wrapper_CUDA__batch_norm_stats(input, eps);
}
at::Tensor batch_norm_elemt(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & invstd, double eps) {
return wrapper_CUDA__batch_norm_elemt(input, weight, bias, mean, invstd, eps);
}
at::Tensor & batch_norm_elemt_out(at::Tensor & out, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & invstd, double eps) {
return wrapper_CUDA_out_batch_norm_elemt_out(input, weight, bias, mean, invstd, eps, out);
}
at::Tensor & batch_norm_elemt_outf(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const at::Tensor & mean, const at::Tensor & invstd, double eps, at::Tensor & out) {
return wrapper_CUDA_out_batch_norm_elemt_out(input, weight, bias, mean, invstd, eps, out);
}
::std::tuple<at::Tensor,at::Tensor> batch_norm_gather_stats(const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum, double eps, int64_t count) {
return wrapper_CUDA__batch_norm_gather_stats(input, mean, invstd, running_mean, running_var, momentum, eps, count);
}
::std::tuple<at::Tensor,at::Tensor> batch_norm_gather_stats_with_counts(const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum, double eps, const at::Tensor & counts) {
return wrapper_CUDA__batch_norm_gather_stats_with_counts(input, mean, invstd, running_mean, running_var, momentum, eps, counts);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_batch_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_invstd, bool train, double eps, ::std::array<bool,3> output_mask) {
return wrapper_CUDA__native_batch_norm_backward(grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> batch_norm_backward_reduce(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, bool input_g, bool weight_g, bool bias_g) {
return wrapper_CUDA__batch_norm_backward_reduce(grad_out, input, mean, invstd, weight, input_g, weight_g, bias_g);
}
at::Tensor batch_norm_backward_elemt(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & invstd, const c10::optional<at::Tensor> & weight, const at::Tensor & sum_dy, const at::Tensor & sum_dy_xmu, const at::Tensor & count) {
return wrapper_CUDA__batch_norm_backward_elemt(grad_out, input, mean, invstd, weight, sum_dy, sum_dy_xmu, count);
}
::std::tuple<at::Tensor,at::Tensor> batch_norm_update_stats(const at::Tensor & input, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum) {
return wrapper_CUDA__batch_norm_update_stats(input, running_mean, running_var, momentum);
}
at::Tensor _cdist_forward(const at::Tensor & x1, const at::Tensor & x2, double p, c10::optional<int64_t> compute_mode) {
return wrapper_CUDA___cdist_forward(x1, x2, p, compute_mode);
}
at::Tensor _cdist_backward(const at::Tensor & grad, const at::Tensor & x1, const at::Tensor & x2, double p, const at::Tensor & cdist) {
return wrapper_CUDA___cdist_backward(grad, x1, x2, p, cdist);
}
at::Tensor _pdist_forward(const at::Tensor & self, double p) {
return wrapper_CUDA___pdist_forward(self, p);
}
at::Tensor _pdist_backward(const at::Tensor & grad, const at::Tensor & self, double p, const at::Tensor & pdist) {
return wrapper_CUDA___pdist_backward(grad, self, p, pdist);
}
at::Tensor channel_shuffle(const at::Tensor & self, int64_t groups) {
return wrapper_CUDA__channel_shuffle(self, groups);
}
at::Tensor channel_shuffle_symint(const at::Tensor & self, c10::SymInt groups) {
return wrapper_CUDA__channel_shuffle(self, groups);
}
bool is_pinned(const at::Tensor & self, c10::optional<at::Device> device) {
return wrapper_CUDA__is_pinned(self, device);
}
at::Tensor _pin_memory(const at::Tensor & self, c10::optional<at::Device> device) {
return wrapper_CUDA___pin_memory(self, device);
}
at::Tensor & randperm_out(at::Tensor & out, int64_t n, c10::optional<at::Generator> generator) {
return wrapper_CUDA_generator_out_randperm_out(n, generator, out);
}
at::Tensor & randperm_outf(int64_t n, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CUDA_generator_out_randperm_out(n, generator, out);
}
at::Tensor & randperm_symint_out(at::Tensor & out, c10::SymInt n, c10::optional<at::Generator> generator) {
return wrapper_CUDA_generator_out_randperm_out(n, generator, out);
}
at::Tensor & randperm_symint_outf(c10::SymInt n, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CUDA_generator_out_randperm_out(n, generator, out);
}
at::Tensor & range_out(at::Tensor & out, const at::Scalar & start, const at::Scalar & end, const at::Scalar & step) {
return wrapper_CUDA_out_range_out(start, end, step, out);
}
at::Tensor & range_outf(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
return wrapper_CUDA_out_range_out(start, end, step, out);
}
at::Tensor reciprocal(const at::Tensor & self) {
return wrapper_CUDA_reciprocal(self);
}
at::Tensor & reciprocal_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_reciprocal_out_out(self, out);
}
at::Tensor & reciprocal_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_reciprocal_out_out(self, out);
}
at::Tensor & reciprocal_(at::Tensor & self) {
return wrapper_CUDA_reciprocal_(self);
}
at::Tensor neg(const at::Tensor & self) {
return wrapper_CUDA_neg(self);
}
at::Tensor & neg_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_neg_out_out(self, out);
}
at::Tensor & neg_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_neg_out_out(self, out);
}
at::Tensor & neg_(at::Tensor & self) {
return wrapper_CUDA_neg_(self);
}
at::Tensor repeat_interleave(const at::Tensor & repeats, c10::optional<int64_t> output_size) {
return wrapper_CUDA_Tensor_repeat_interleave(repeats, output_size.has_value() ? c10::make_optional(c10::SymInt(*output_size)) : c10::nullopt);
}
at::Tensor repeat_interleave_symint(const at::Tensor & repeats, c10::optional<c10::SymInt> output_size) {
return wrapper_CUDA_Tensor_repeat_interleave(repeats, output_size);
}
at::Tensor _reshape_alias(const at::Tensor & self, at::IntArrayRef size, at::IntArrayRef stride) {
return wrapper_CUDA___reshape_alias(self, c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride));
}
at::Tensor _reshape_alias_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
return wrapper_CUDA___reshape_alias(self, size, stride);
}
at::Tensor round(const at::Tensor & self) {
return wrapper_CUDA_round(self);
}
at::Tensor & round_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_round_out_out(self, out);
}
at::Tensor & round_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_round_out_out(self, out);
}
at::Tensor & round_(at::Tensor & self) {
return wrapper_CUDA_round_(self);
}
at::Tensor round(const at::Tensor & self, int64_t decimals) {
return wrapper_CUDA_round_decimals(self, decimals);
}
at::Tensor & round_out(at::Tensor & out, const at::Tensor & self, int64_t decimals) {
return wrapper_CUDA_round_out_decimals_out(self, decimals, out);
}
at::Tensor & round_outf(const at::Tensor & self, int64_t decimals, at::Tensor & out) {
return wrapper_CUDA_round_out_decimals_out(self, decimals, out);
}
at::Tensor & round_(at::Tensor & self, int64_t decimals) {
return wrapper_CUDA_round__decimals(self, decimals);
}
at::Tensor relu(const at::Tensor & self) {
return wrapper_CUDA__relu(self);
}
at::Tensor & relu_(at::Tensor & self) {
return wrapper_CUDA__relu_(self);
}
at::Tensor _prelu_kernel(const at::Tensor & self, const at::Tensor & weight) {
return wrapper_CUDA___prelu_kernel(self, weight);
}
::std::tuple<at::Tensor,at::Tensor> _prelu_kernel_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight) {
return wrapper_CUDA___prelu_kernel_backward(grad_output, self, weight);
}
at::Tensor gelu(const at::Tensor & self, c10::string_view approximate) {
return wrapper_CUDA_gelu(self, approximate);
}
at::Tensor & gelu_out(at::Tensor & out, const at::Tensor & self, c10::string_view approximate) {
return wrapper_CUDA_gelu_out_out(self, approximate, out);
}
at::Tensor & gelu_outf(const at::Tensor & self, c10::string_view approximate, at::Tensor & out) {
return wrapper_CUDA_gelu_out_out(self, approximate, out);
}
at::Tensor & gelu_(at::Tensor & self, c10::string_view approximate) {
return wrapper_CUDA_gelu_(self, approximate);
}
at::Tensor gelu_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
return wrapper_CUDA_gelu_backward(grad_output, self, approximate);
}
at::Tensor & gelu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
return wrapper_CUDA_gelu_backward_out_grad_input(grad_output, self, approximate, grad_input);
}
at::Tensor & gelu_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate, at::Tensor & grad_input) {
return wrapper_CUDA_gelu_backward_out_grad_input(grad_output, self, approximate, grad_input);
}
at::Tensor hardshrink(const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CUDA_hardshrink(self, lambd);
}
at::Tensor & hardshrink_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CUDA_hardshrink_out_out(self, lambd, out);
}
at::Tensor & hardshrink_outf(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
return wrapper_CUDA_hardshrink_out_out(self, lambd, out);
}
at::Tensor hardshrink_backward(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CUDA_hardshrink_backward(grad_out, self, lambd);
}
at::Tensor & hardshrink_backward_out(at::Tensor & grad_input, const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CUDA_hardshrink_backward_out_grad_input(grad_out, self, lambd, grad_input);
}
at::Tensor & hardshrink_backward_outf(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
return wrapper_CUDA_hardshrink_backward_out_grad_input(grad_out, self, lambd, grad_input);
}
at::Tensor rsqrt(const at::Tensor & self) {
return wrapper_CUDA_rsqrt(self);
}
at::Tensor & rsqrt_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_rsqrt_out_out(self, out);
}
at::Tensor & rsqrt_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_rsqrt_out_out(self, out);
}
at::Tensor & rsqrt_(at::Tensor & self) {
return wrapper_CUDA_rsqrt_(self);
}
at::Tensor silu(const at::Tensor & self) {
return wrapper_CUDA_silu(self);
}
at::Tensor & silu_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_silu_out_out(self, out);
}
at::Tensor & silu_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_silu_out_out(self, out);
}
at::Tensor & silu_(at::Tensor & self) {
return wrapper_CUDA_silu_(self);
}
at::Tensor silu_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CUDA_silu_backward(grad_output, self);
}
at::Tensor & silu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CUDA_silu_backward_out_grad_input(grad_output, self, grad_input);
}
at::Tensor & silu_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
return wrapper_CUDA_silu_backward_out_grad_input(grad_output, self, grad_input);
}
at::Tensor mish(const at::Tensor & self) {
return wrapper_CUDA_mish(self);
}
at::Tensor & mish_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_mish_out_out(self, out);
}
at::Tensor & mish_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_mish_out_out(self, out);
}
at::Tensor & mish_(at::Tensor & self) {
return wrapper_CUDA_mish_(self);
}
at::Tensor mish_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CUDA__mish_backward(grad_output, self);
}
at::Tensor sigmoid(const at::Tensor & self) {
return wrapper_CUDA_sigmoid(self);
}
at::Tensor & sigmoid_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_sigmoid_out_out(self, out);
}
at::Tensor & sigmoid_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_sigmoid_out_out(self, out);
}
at::Tensor & sigmoid_(at::Tensor & self) {
return wrapper_CUDA_sigmoid_(self);
}
at::Tensor logit(const at::Tensor & self, c10::optional<double> eps) {
return wrapper_CUDA__logit(self, eps);
}
at::Tensor & logit_out(at::Tensor & out, const at::Tensor & self, c10::optional<double> eps) {
return wrapper_CUDA_out_logit_out(self, eps, out);
}
at::Tensor & logit_outf(const at::Tensor & self, c10::optional<double> eps, at::Tensor & out) {
return wrapper_CUDA_out_logit_out(self, eps, out);
}
at::Tensor & logit_(at::Tensor & self, c10::optional<double> eps) {
return wrapper_CUDA__logit_(self, eps);
}
at::Tensor sin(const at::Tensor & self) {
return wrapper_CUDA_sin(self);
}
at::Tensor & sin_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_sin_out_out(self, out);
}
at::Tensor & sin_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_sin_out_out(self, out);
}
at::Tensor & sin_(at::Tensor & self) {
return wrapper_CUDA_sin_(self);
}
at::Tensor sinc(const at::Tensor & self) {
return wrapper_CUDA_sinc(self);
}
at::Tensor & sinc_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_sinc_out_out(self, out);
}
at::Tensor & sinc_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_sinc_out_out(self, out);
}
at::Tensor & sinc_(at::Tensor & self) {
return wrapper_CUDA_sinc_(self);
}
at::Tensor sinh(const at::Tensor & self) {
return wrapper_CUDA_sinh(self);
}
at::Tensor & sinh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_sinh_out_out(self, out);
}
at::Tensor & sinh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_sinh_out_out(self, out);
}
at::Tensor & sinh_(at::Tensor & self) {
return wrapper_CUDA_sinh_(self);
}
at::Tensor _softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
return wrapper_CUDA__softmax(self, dim, half_to_float);
}
at::Tensor & _softmax_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool half_to_float) {
return wrapper_CUDA__softmax_out_out(self, dim, half_to_float, out);
}
at::Tensor & _softmax_outf(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
return wrapper_CUDA__softmax_out_out(self, dim, half_to_float, out);
}
at::Tensor _softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
return wrapper_CUDA__softmax_backward_data(grad_output, output, dim, input_dtype);
}
at::Tensor & _softmax_backward_data_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
return wrapper_CUDA__softmax_backward_data_out_out(grad_output, output, dim, input_dtype, grad_input);
}
at::Tensor & _softmax_backward_data_outf(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & grad_input) {
return wrapper_CUDA__softmax_backward_data_out_out(grad_output, output, dim, input_dtype, grad_input);
}
at::Tensor & sspaddmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_out_sspaddmm_out(self, mat1, mat2, beta, alpha, out);
}
at::Tensor & sspaddmm_outf(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CUDA_out_sspaddmm_out(self, mat1, mat2, beta, alpha, out);
}
at::Tensor sum(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_sum_dim_IntList(self, dim, keepdim, dtype);
}
at::Tensor & sum_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_sum_out_IntList_out(self, dim, keepdim, dtype, out);
}
at::Tensor & sum_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CUDA_sum_out_IntList_out(self, dim, keepdim, dtype, out);
}
at::Tensor nansum(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA__nansum(self, dim, keepdim, dtype);
}
at::Tensor & nansum_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_out_nansum_out(self, dim, keepdim, dtype, out);
}
at::Tensor & nansum_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CUDA_out_nansum_out(self, dim, keepdim, dtype, out);
}
at::Tensor sqrt(const at::Tensor & self) {
return wrapper_CUDA_sqrt(self);
}
at::Tensor & sqrt_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_sqrt_out_out(self, out);
}
at::Tensor & sqrt_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_sqrt_out_out(self, out);
}
at::Tensor & sqrt_(at::Tensor & self) {
return wrapper_CUDA_sqrt_(self);
}
at::Tensor std(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CUDA_correction_std(self, dim, correction, keepdim);
}
at::Tensor & std_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CUDA_correction_out_std_out(self, dim, correction, keepdim, out);
}
at::Tensor & std_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_correction_out_std_out(self, dim, correction, keepdim, out);
}
::std::tuple<at::Tensor,at::Tensor> std_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CUDA_correction_std_mean(self, dim, correction, keepdim);
}
at::Tensor prod(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA__prod(self, dtype);
}
at::Tensor prod(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_prod_dim_int(self, dim, keepdim, dtype);
}
at::Tensor & prod_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_prod_out_int_out(self, dim, keepdim, dtype, out);
}
at::Tensor & prod_outf(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CUDA_prod_out_int_out(self, dim, keepdim, dtype, out);
}
at::Tensor tan(const at::Tensor & self) {
return wrapper_CUDA_tan(self);
}
at::Tensor & tan_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_tan_out_out(self, out);
}
at::Tensor & tan_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_tan_out_out(self, out);
}
at::Tensor & tan_(at::Tensor & self) {
return wrapper_CUDA_tan_(self);
}
at::Tensor tanh(const at::Tensor & self) {
return wrapper_CUDA_tanh(self);
}
at::Tensor & tanh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_tanh_out_out(self, out);
}
at::Tensor & tanh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_tanh_out_out(self, out);
}
at::Tensor & tanh_(at::Tensor & self) {
return wrapper_CUDA_tanh_(self);
}
at::Tensor threshold(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
return wrapper_CUDA_threshold(self, threshold, value);
}
at::Tensor & threshold_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
return wrapper_CUDA_threshold_out_out(self, threshold, value, out);
}
at::Tensor & threshold_outf(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value, at::Tensor & out) {
return wrapper_CUDA_threshold_out_out(self, threshold, value, out);
}
at::Tensor & threshold_(at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
return wrapper_CUDA_threshold_(self, threshold, value);
}
at::Tensor threshold_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
return wrapper_CUDA_threshold_backward(grad_output, self, threshold);
}
at::Tensor & threshold_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
return wrapper_CUDA_threshold_backward_out_grad_input(grad_output, self, threshold, grad_input);
}
at::Tensor & threshold_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold, at::Tensor & grad_input) {
return wrapper_CUDA_threshold_backward_out_grad_input(grad_output, self, threshold, grad_input);
}
at::Tensor flip(const at::Tensor & self, at::IntArrayRef dims) {
return wrapper_CUDA__flip(self, dims);
}
at::Tensor roll(const at::Tensor & self, at::IntArrayRef shifts, at::IntArrayRef dims) {
return wrapper_CUDA__roll(self, c10::fromIntArrayRefSlow(shifts), dims);
}
at::Tensor roll_symint(const at::Tensor & self, c10::SymIntArrayRef shifts, at::IntArrayRef dims) {
return wrapper_CUDA__roll(self, shifts, dims);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _transform_bias_rescale_qkv(const at::Tensor & qkv, const at::Tensor & qkv_bias, int64_t num_heads) {
return wrapper_CUDA___transform_bias_rescale_qkv(qkv, qkv_bias, num_heads);
}
at::Tensor _nested_tensor_from_mask(const at::Tensor & t, const at::Tensor & mask, bool mask_check) {
return wrapper_CUDA___nested_tensor_from_mask(t, mask, mask_check);
}
bool _nested_tensor_from_mask_left_aligned(const at::Tensor & t, const at::Tensor & mask) {
return wrapper_CUDA___nested_tensor_from_mask_left_aligned(t, mask);
}
at::Tensor _nested_from_padded(const at::Tensor & padded, const at::Tensor & cpu_nested_shape_example, bool fuse_transform_0213) {
return wrapper_CUDA___nested_from_padded(padded, cpu_nested_shape_example, fuse_transform_0213);
}
at::Tensor _nested_view_from_buffer(const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets) {
return wrapper_CUDA___nested_view_from_buffer(self, nested_size, nested_strides, offsets);
}
at::Tensor trunc(const at::Tensor & self) {
return wrapper_CUDA_trunc(self);
}
at::Tensor & trunc_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_trunc_out_out(self, out);
}
at::Tensor & trunc_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_trunc_out_out(self, out);
}
at::Tensor & trunc_(at::Tensor & self) {
return wrapper_CUDA_trunc_(self);
}
::std::tuple<at::Tensor,at::Tensor> _unique(const at::Tensor & self, bool sorted, bool return_inverse) {
return wrapper_CUDA___unique(self, sorted, return_inverse);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> unique_dim(const at::Tensor & self, int64_t dim, bool sorted, bool return_inverse, bool return_counts) {
return wrapper_CUDA__unique_dim(self, dim, sorted, return_inverse, return_counts);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> unique_consecutive(const at::Tensor & self, bool return_inverse, bool return_counts, c10::optional<int64_t> dim) {
return wrapper_CUDA__unique_consecutive(self, return_inverse, return_counts, dim);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> unique_dim_consecutive(const at::Tensor & self, int64_t dim, bool return_inverse, bool return_counts) {
return wrapper_CUDA__unique_dim_consecutive(self, dim, return_inverse, return_counts);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _unique2(const at::Tensor & self, bool sorted, bool return_inverse, bool return_counts) {
return wrapper_CUDA___unique2(self, sorted, return_inverse, return_counts);
}
at::Tensor var(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CUDA_correction_var(self, dim, correction, keepdim);
}
at::Tensor & var_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CUDA_correction_out_var_out(self, dim, correction, keepdim, out);
}
at::Tensor & var_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_correction_out_var_out(self, dim, correction, keepdim, out);
}
::std::tuple<at::Tensor,at::Tensor> var_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CUDA_correction_var_mean(self, dim, correction, keepdim);
}
at::Tensor where(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_self_where(condition, self, other);
}
at::Tensor & where_out(at::Tensor & out, const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_self_out_where_out(condition, self, other, out);
}
at::Tensor & where_outf(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_self_out_where_out(condition, self, other, out);
}
::std::tuple<at::Tensor,at::Tensor> _weight_norm_interface(const at::Tensor & v, const at::Tensor & g, int64_t dim) {
return wrapper_CUDA___weight_norm_interface(v, g, dim);
}
::std::tuple<at::Tensor,at::Tensor> _weight_norm_interface_backward(const at::Tensor & grad_w, const at::Tensor & saved_v, const at::Tensor & saved_g, const at::Tensor & saved_norms, int64_t dim) {
return wrapper_CUDA___weight_norm_interface_backward(grad_w, saved_v, saved_g, saved_norms, dim);
}
at::Tensor _efficientzerotensor(at::IntArrayRef size, at::TensorOptions options) {
return wrapper_CUDA___efficientzerotensor(c10::fromIntArrayRefSlow(size), c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor _efficientzerotensor(at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CUDA___efficientzerotensor(c10::fromIntArrayRefSlow(size), dtype, layout, device, pin_memory);
}
at::Tensor _efficientzerotensor_symint(c10::SymIntArrayRef size, at::TensorOptions options) {
return wrapper_CUDA___efficientzerotensor(size, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor _efficientzerotensor_symint(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CUDA___efficientzerotensor(size, dtype, layout, device, pin_memory);
}
at::Tensor _standard_gamma_grad(const at::Tensor & self, const at::Tensor & output) {
return wrapper_CUDA___standard_gamma_grad(self, output);
}
at::Tensor _standard_gamma(const at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CUDA___standard_gamma(self, generator);
}
at::Tensor _dirichlet_grad(const at::Tensor & x, const at::Tensor & alpha, const at::Tensor & total) {
return wrapper_CUDA___dirichlet_grad(x, alpha, total);
}
at::Tensor _sample_dirichlet(const at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CUDA___sample_dirichlet(self, generator);
}
at::Tensor poisson(const at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CUDA__poisson(self, generator);
}
at::Tensor binomial(const at::Tensor & count, const at::Tensor & prob, c10::optional<at::Generator> generator) {
return wrapper_CUDA__binomial(count, prob, generator);
}
at::Tensor norm(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype) {
return wrapper_CUDA_norm_ScalarOpt_dim_dtype(self, p, dim, keepdim, dtype);
}
at::Tensor & norm_out(at::Tensor & out, const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype) {
return wrapper_CUDA_norm_out_dtype_out(self, p, dim, keepdim, dtype, out);
}
at::Tensor & norm_outf(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype, at::Tensor & out) {
return wrapper_CUDA_norm_out_dtype_out(self, p, dim, keepdim, dtype, out);
}
at::Tensor norm(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim) {
return wrapper_CUDA_norm_ScalarOpt_dim(self, p, dim, keepdim);
}
at::Tensor & norm_out(at::Tensor & out, const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim) {
return wrapper_CUDA_norm_out_out(self, p, dim, keepdim, out);
}
at::Tensor & norm_outf(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CUDA_norm_out_out(self, p, dim, keepdim, out);
}
::std::tuple<at::Tensor &,at::Tensor &> frexp_out(at::Tensor & mantissa, at::Tensor & exponent, const at::Tensor & self) {
return wrapper_CUDA_Tensor_out_frexp_out(self, mantissa, exponent);
}
::std::tuple<at::Tensor &,at::Tensor &> frexp_outf(const at::Tensor & self, at::Tensor & mantissa, at::Tensor & exponent) {
return wrapper_CUDA_Tensor_out_frexp_out(self, mantissa, exponent);
}
at::Tensor & zero_(at::Tensor & self) {
return wrapper_CUDA__zero_(self);
}
at::Tensor sub(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CUDA_sub_Tensor(self, other, alpha);
}
at::Tensor & sub_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CUDA_sub_out_out(self, other, alpha, out);
}
at::Tensor & sub_outf(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CUDA_sub_out_out(self, other, alpha, out);
}
at::Tensor & sub_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CUDA_sub__Tensor(self, other, alpha);
}
at::Tensor rsub(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CUDA_Tensor_rsub(self, other, alpha);
}
at::Tensor heaviside(const at::Tensor & self, const at::Tensor & values) {
return wrapper_CUDA_heaviside(self, values);
}
at::Tensor & heaviside_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & values) {
return wrapper_CUDA_heaviside_out_out(self, values, out);
}
at::Tensor & heaviside_outf(const at::Tensor & self, const at::Tensor & values, at::Tensor & out) {
return wrapper_CUDA_heaviside_out_out(self, values, out);
}
at::Tensor & heaviside_(at::Tensor & self, const at::Tensor & values) {
return wrapper_CUDA_heaviside_(self, values);
}
at::Tensor addmm(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_addmm(self, mat1, mat2, beta, alpha);
}
at::Tensor & addmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_addmm_out_out(self, mat1, mat2, beta, alpha, out);
}
at::Tensor & addmm_outf(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CUDA_addmm_out_out(self, mat1, mat2, beta, alpha, out);
}
at::Tensor & addmm_(at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_addmm_(self, mat1, mat2, beta, alpha);
}
at::Tensor _addmm_activation(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu) {
return wrapper_CUDA__addmm_activation(self, mat1, mat2, beta, alpha, use_gelu);
}
at::Tensor & _addmm_activation_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu) {
return wrapper_CUDA__addmm_activation_out_out(self, mat1, mat2, beta, alpha, use_gelu, out);
}
at::Tensor & _addmm_activation_outf(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu, at::Tensor & out) {
return wrapper_CUDA__addmm_activation_out_out(self, mat1, mat2, beta, alpha, use_gelu, out);
}
::std::tuple<at::Tensor,at::Tensor> _scaled_mm(const at::Tensor & self, const at::Tensor & mat2, const c10::optional<at::Tensor> & bias, c10::optional<at::ScalarType> out_dtype, const c10::optional<at::Tensor> & scale_a, const c10::optional<at::Tensor> & scale_b, const c10::optional<at::Tensor> & scale_result, bool use_fast_accum) {
return wrapper_CUDA___scaled_mm(self, mat2, bias, out_dtype, scale_a, scale_b, scale_result, use_fast_accum);
}
::std::tuple<at::Tensor &,at::Tensor &> _scaled_mm_out(at::Tensor & out, at::Tensor & out_amax, const at::Tensor & self, const at::Tensor & mat2, const c10::optional<at::Tensor> & bias, c10::optional<at::ScalarType> out_dtype, const c10::optional<at::Tensor> & scale_a, const c10::optional<at::Tensor> & scale_b, const c10::optional<at::Tensor> & scale_result, bool use_fast_accum) {
return wrapper_CUDA_out__scaled_mm_out(self, mat2, bias, out_dtype, scale_a, scale_b, scale_result, use_fast_accum, out, out_amax);
}
::std::tuple<at::Tensor &,at::Tensor &> _scaled_mm_outf(const at::Tensor & self, const at::Tensor & mat2, const c10::optional<at::Tensor> & bias, c10::optional<at::ScalarType> out_dtype, const c10::optional<at::Tensor> & scale_a, const c10::optional<at::Tensor> & scale_b, const c10::optional<at::Tensor> & scale_result, bool use_fast_accum, at::Tensor & out, at::Tensor & out_amax) {
return wrapper_CUDA_out__scaled_mm_out(self, mat2, bias, out_dtype, scale_a, scale_b, scale_result, use_fast_accum, out, out_amax);
}
int64_t sparse_dim(const at::Tensor & self) {
return wrapper_CUDA__sparse_dim(self);
}
int64_t dense_dim(const at::Tensor & self) {
return wrapper_CUDA__dense_dim(self);
}
at::Tensor _to_sparse(const at::Tensor & self, int64_t sparse_dim) {
return wrapper_CUDA_sparse_dim__to_sparse(self, sparse_dim);
}
at::Tensor _to_sparse(const at::Tensor & self, c10::optional<at::Layout> layout, at::OptionalIntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
return wrapper_CUDA___to_sparse(self, layout, blocksize, dense_dim);
}
at::Tensor _to_sparse_csr(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
return wrapper_CUDA___to_sparse_csr(self, dense_dim);
}
at::Tensor _to_sparse_csc(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
return wrapper_CUDA___to_sparse_csc(self, dense_dim);
}
at::Tensor _to_sparse_bsr(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
return wrapper_CUDA___to_sparse_bsr(self, blocksize, dense_dim);
}
at::Tensor _to_sparse_bsc(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
return wrapper_CUDA___to_sparse_bsc(self, blocksize, dense_dim);
}
::std::tuple<at::Tensor,at::Tensor> _to_sparse_semi_structured(const at::Tensor & dense) {
return wrapper_CUDA___to_sparse_semi_structured(dense);
}
at::Tensor quantize_per_tensor_dynamic(const at::Tensor & self, at::ScalarType dtype, bool reduce_range) {
return wrapper_CUDA__quantize_per_tensor_dynamic(self, dtype, reduce_range);
}
at::Tensor quantize_per_tensor(const at::Tensor & self, double scale, int64_t zero_point, at::ScalarType dtype) {
return wrapper_CUDA__quantize_per_tensor(self, scale, zero_point, dtype);
}
at::Tensor quantize_per_tensor(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, at::ScalarType dtype) {
return wrapper_CUDA_tensor_qparams_quantize_per_tensor(self, scale, zero_point, dtype);
}
at::Tensor quantize_per_channel(const at::Tensor & self, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, at::ScalarType dtype) {
return wrapper_CUDA__quantize_per_channel(self, scales, zero_points, axis, dtype);
}
at::Tensor dequantize(const at::Tensor & self) {
return wrapper_CUDA_self_dequantize(self);
}
at::Tensor _make_per_tensor_quantized_tensor(const at::Tensor & self, double scale, int64_t zero_point) {
return wrapper_CUDA___make_per_tensor_quantized_tensor(self, scale, zero_point);
}
at::Tensor _make_per_channel_quantized_tensor(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis) {
return wrapper_CUDA___make_per_channel_quantized_tensor(self, scale, zero_point, axis);
}
::std::tuple<at::Tensor,at::Tensor> fake_quantize_per_tensor_affine_cachemask(const at::Tensor & self, double scale, int64_t zero_point, int64_t quant_min, int64_t quant_max) {
return wrapper_CUDA__fake_quantize_per_tensor_affine_cachemask(self, scale, zero_point, quant_min, quant_max);
}
::std::tuple<at::Tensor,at::Tensor> _fake_quantize_per_tensor_affine_cachemask_tensor_qparams(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, const at::Tensor & fake_quant_enabled, int64_t quant_min, int64_t quant_max) {
return wrapper_CUDA___fake_quantize_per_tensor_affine_cachemask_tensor_qparams(self, scale, zero_point, fake_quant_enabled, quant_min, quant_max);
}
at::Tensor _fake_quantize_learnable_per_tensor_affine(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t quant_min, int64_t quant_max, double grad_factor) {
return wrapper_CUDA___fake_quantize_learnable_per_tensor_affine(self, scale, zero_point, quant_min, quant_max, grad_factor);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _fake_quantize_learnable_per_tensor_affine_backward(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t quant_min, int64_t quant_max, double grad_factor) {
return wrapper_CUDA___fake_quantize_learnable_per_tensor_affine_backward(grad, self, scale, zero_point, quant_min, quant_max, grad_factor);
}
::std::tuple<at::Tensor,at::Tensor> fake_quantize_per_channel_affine_cachemask(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
return wrapper_CUDA__fake_quantize_per_channel_affine_cachemask(self, scale, zero_point, axis, quant_min, quant_max);
}
at::Tensor _fake_quantize_learnable_per_channel_affine(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, double grad_factor) {
return wrapper_CUDA___fake_quantize_learnable_per_channel_affine(self, scale, zero_point, axis, quant_min, quant_max, grad_factor);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _fake_quantize_learnable_per_channel_affine_backward(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, double grad_factor) {
return wrapper_CUDA___fake_quantize_learnable_per_channel_affine_backward(grad, self, scale, zero_point, axis, quant_min, quant_max, grad_factor);
}
::std::tuple<at::Tensor,at::Tensor> _fused_moving_avg_obs_fq_helper(const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, at::Tensor & running_min, at::Tensor & running_max, at::Tensor & scale, at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant) {
return wrapper_CUDA___fused_moving_avg_obs_fq_helper(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
}
at::Scalar _local_scalar_dense(const at::Tensor & self) {
return wrapper_CUDA___local_scalar_dense(self);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _thnn_fused_lstm_cell(const at::Tensor & input_gates, const at::Tensor & hidden_gates, const at::Tensor & cx, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias) {
return wrapper_CUDA___thnn_fused_lstm_cell(input_gates, hidden_gates, cx, input_bias, hidden_bias);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _thnn_fused_lstm_cell_backward_impl(const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, const at::Tensor & cx, const at::Tensor & cy, const at::Tensor & workspace, bool has_bias) {
return wrapper_CUDA___thnn_fused_lstm_cell_backward_impl(grad_hy, grad_cy, cx, cy, workspace, has_bias);
}
::std::tuple<at::Tensor,at::Tensor> _thnn_fused_gru_cell(const at::Tensor & input_gates, const at::Tensor & hidden_gates, const at::Tensor & hx, const c10::optional<at::Tensor> & input_bias, const c10::optional<at::Tensor> & hidden_bias) {
return wrapper_CUDA___thnn_fused_gru_cell(input_gates, hidden_gates, hx, input_bias, hidden_bias);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _thnn_fused_gru_cell_backward(const at::Tensor & grad_hy, const at::Tensor & workspace, bool has_bias) {
return wrapper_CUDA___thnn_fused_gru_cell_backward(grad_hy, workspace, has_bias);
}
at::Tensor & set_(at::Tensor & self, at::Storage source) {
return wrapper_CUDA_source_Storage_set_(self, source);
}
at::Tensor & set_(at::Tensor & self, at::Storage source, int64_t storage_offset, at::IntArrayRef size, at::IntArrayRef stride) {
return wrapper_CUDA_source_Storage_storage_offset_set_(self, source, storage_offset, c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride));
}
at::Tensor & set__symint(at::Tensor & self, at::Storage source, c10::SymInt storage_offset, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
return wrapper_CUDA_source_Storage_storage_offset_set_(self, source, storage_offset, size, stride);
}
at::Tensor & set_(at::Tensor & self, const at::Tensor & source) {
return wrapper_CUDA_source_Tensor_set_(self, source);
}
at::Tensor & set_(at::Tensor & self) {
return wrapper_CUDA__set_(self);
}
bool is_set_to(const at::Tensor & self, const at::Tensor & tensor) {
return wrapper_CUDA__is_set_to(self, tensor);
}
at::Tensor & masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
return wrapper_CUDA_Scalar_masked_fill_(self, mask, value);
}
at::Tensor & masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
return wrapper_CUDA_Tensor_masked_fill_(self, mask, value);
}
at::Tensor & masked_scatter_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & source) {
return wrapper_CUDA__masked_scatter_(self, mask, source);
}
at::Tensor _masked_softmax(const at::Tensor & self, const at::Tensor & mask, c10::optional<int64_t> dim, c10::optional<int64_t> mask_type) {
return wrapper_CUDA___masked_softmax(self, mask, dim, mask_type);
}
at::Tensor _masked_softmax_backward(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & mask, c10::optional<int64_t> dim) {
return wrapper_CUDA___masked_softmax_backward(grad_output, output, mask, dim);
}
at::Tensor view(const at::Tensor & self, at::IntArrayRef size) {
return wrapper_CUDA__view(self, c10::fromIntArrayRefSlow(size));
}
at::Tensor view_symint(const at::Tensor & self, c10::SymIntArrayRef size) {
return wrapper_CUDA__view(self, size);
}
at::Tensor & put_(at::Tensor & self, const at::Tensor & index, const at::Tensor & source, bool accumulate) {
return wrapper_CUDA__put_(self, index, source, accumulate);
}
at::Tensor index_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
return wrapper_CUDA_index_add(self, dim, index, source, alpha);
}
at::Tensor & index_add_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
return wrapper_CUDA_index_add_out_out(self, dim, index, source, alpha, out);
}
at::Tensor & index_add_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CUDA_index_add_out_out(self, dim, index, source, alpha, out);
}
at::Tensor & index_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
return wrapper_CUDA_index_add_(self, dim, index, source, alpha);
}
at::Tensor index_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
return wrapper_CUDA_index_reduce(self, dim, index, source, reduce, include_self);
}
at::Tensor & index_reduce_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
return wrapper_CUDA_index_reduce_out_out(self, dim, index, source, reduce, include_self, out);
}
at::Tensor & index_reduce_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self, at::Tensor & out) {
return wrapper_CUDA_index_reduce_out_out(self, dim, index, source, reduce, include_self, out);
}
at::Tensor & index_reduce_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
return wrapper_CUDA_index_reduce_(self, dim, index, source, reduce, include_self);
}
at::Tensor & index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
return wrapper_CUDA_int_Scalar_index_fill_(self, dim, index, value);
}
at::Tensor & index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & value) {
return wrapper_CUDA_int_Tensor_index_fill_(self, dim, index, value);
}
at::Tensor scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CUDA_scatter_src(self, dim, index, src);
}
at::Tensor & scatter_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CUDA_scatter_out_src_out(self, dim, index, src, out);
}
at::Tensor & scatter_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
return wrapper_CUDA_scatter_out_src_out(self, dim, index, src, out);
}
at::Tensor & scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CUDA_scatter__src(self, dim, index, src);
}
at::Tensor scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
return wrapper_CUDA_scatter_value(self, dim, index, value);
}
at::Tensor & scatter_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
return wrapper_CUDA_scatter_out_value_out(self, dim, index, value, out);
}
at::Tensor & scatter_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, at::Tensor & out) {
return wrapper_CUDA_scatter_out_value_out(self, dim, index, value, out);
}
at::Tensor & scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
return wrapper_CUDA_scatter__value(self, dim, index, value);
}
at::Tensor scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
return wrapper_CUDA_scatter_reduce(self, dim, index, src, reduce);
}
at::Tensor & scatter_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
return wrapper_CUDA_scatter_out_reduce_out(self, dim, index, src, reduce, out);
}
at::Tensor & scatter_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, at::Tensor & out) {
return wrapper_CUDA_scatter_out_reduce_out(self, dim, index, src, reduce, out);
}
at::Tensor & scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
return wrapper_CUDA_scatter__reduce(self, dim, index, src, reduce);
}
at::Tensor scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
return wrapper_CUDA_scatter_value_reduce(self, dim, index, value, reduce);
}
at::Tensor & scatter_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
return wrapper_CUDA_scatter_out_value_reduce_out(self, dim, index, value, reduce, out);
}
at::Tensor & scatter_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce, at::Tensor & out) {
return wrapper_CUDA_scatter_out_value_reduce_out(self, dim, index, value, reduce, out);
}
at::Tensor & scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
return wrapper_CUDA_scatter__value_reduce(self, dim, index, value, reduce);
}
at::Tensor scatter_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CUDA_scatter_add(self, dim, index, src);
}
at::Tensor & scatter_add_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CUDA_scatter_add_out_out(self, dim, index, src, out);
}
at::Tensor & scatter_add_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
return wrapper_CUDA_scatter_add_out_out(self, dim, index, src, out);
}
at::Tensor & scatter_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CUDA_scatter_add_(self, dim, index, src);
}
at::Tensor scatter_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
return wrapper_CUDA_scatter_reduce_two(self, dim, index, src, reduce, include_self);
}
at::Tensor & scatter_reduce_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
return wrapper_CUDA_scatter_reduce_out_two_out(self, dim, index, src, reduce, include_self, out);
}
at::Tensor & scatter_reduce_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self, at::Tensor & out) {
return wrapper_CUDA_scatter_reduce_out_two_out(self, dim, index, src, reduce, include_self, out);
}
at::Tensor & scatter_reduce_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
return wrapper_CUDA_scatter_reduce__two(self, dim, index, src, reduce, include_self);
}
at::Tensor eq(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_eq_Scalar(self, other);
}
at::Tensor & eq_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_eq_out_Scalar_out(self, other, out);
}
at::Tensor & eq_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CUDA_eq_out_Scalar_out(self, other, out);
}
at::Tensor & eq_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_eq__Scalar(self, other);
}
at::Tensor eq(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_eq_Tensor(self, other);
}
at::Tensor & eq_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_eq_out_Tensor_out(self, other, out);
}
at::Tensor & eq_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_eq_out_Tensor_out(self, other, out);
}
at::Tensor & eq_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_eq__Tensor(self, other);
}
at::Tensor bitwise_and(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_and_Tensor(self, other);
}
at::Tensor & bitwise_and_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_and_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_and_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_bitwise_and_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_and_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_and__Tensor(self, other);
}
at::Tensor bitwise_or(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_or_Tensor(self, other);
}
at::Tensor & bitwise_or_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_or_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_or_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_bitwise_or_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_or_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_or__Tensor(self, other);
}
at::Tensor bitwise_xor(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_xor_Tensor(self, other);
}
at::Tensor & bitwise_xor_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_xor_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_xor_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_bitwise_xor_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_xor_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_xor__Tensor(self, other);
}
at::Tensor __lshift__(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_Scalar___lshift__(self, other);
}
at::Tensor & __ilshift__(at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_Scalar___ilshift__(self, other);
}
at::Tensor __lshift__(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_Tensor___lshift__(self, other);
}
at::Tensor & __ilshift__(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_Tensor___ilshift__(self, other);
}
at::Tensor bitwise_left_shift(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_left_shift_Tensor(self, other);
}
at::Tensor & bitwise_left_shift_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_left_shift_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_left_shift_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_bitwise_left_shift_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_left_shift_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_left_shift__Tensor(self, other);
}
at::Tensor __rshift__(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_Scalar___rshift__(self, other);
}
at::Tensor & __irshift__(at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_Scalar___irshift__(self, other);
}
at::Tensor __rshift__(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_Tensor___rshift__(self, other);
}
at::Tensor & __irshift__(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_Tensor___irshift__(self, other);
}
at::Tensor bitwise_right_shift(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_right_shift_Tensor(self, other);
}
at::Tensor & bitwise_right_shift_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_right_shift_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_right_shift_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_bitwise_right_shift_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_right_shift_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_bitwise_right_shift__Tensor(self, other);
}
at::Tensor tril(const at::Tensor & self, int64_t diagonal) {
return wrapper_CUDA_tril(self, diagonal);
}
at::Tensor & tril_out(at::Tensor & out, const at::Tensor & self, int64_t diagonal) {
return wrapper_CUDA_tril_out_out(self, diagonal, out);
}
at::Tensor & tril_outf(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
return wrapper_CUDA_tril_out_out(self, diagonal, out);
}
at::Tensor & tril_(at::Tensor & self, int64_t diagonal) {
return wrapper_CUDA_tril_(self, diagonal);
}
at::Tensor triu(const at::Tensor & self, int64_t diagonal) {
return wrapper_CUDA_triu(self, diagonal);
}
at::Tensor & triu_out(at::Tensor & out, const at::Tensor & self, int64_t diagonal) {
return wrapper_CUDA_triu_out_out(self, diagonal, out);
}
at::Tensor & triu_outf(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
return wrapper_CUDA_triu_out_out(self, diagonal, out);
}
at::Tensor & triu_(at::Tensor & self, int64_t diagonal) {
return wrapper_CUDA_triu_(self, diagonal);
}
at::Tensor digamma(const at::Tensor & self) {
return wrapper_CUDA_digamma(self);
}
at::Tensor & digamma_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_digamma_out_out(self, out);
}
at::Tensor & digamma_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_digamma_out_out(self, out);
}
at::Tensor & digamma_(at::Tensor & self) {
return wrapper_CUDA_digamma_(self);
}
at::Tensor lerp(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
return wrapper_CUDA_lerp_Scalar(self, end, weight);
}
at::Tensor & lerp_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
return wrapper_CUDA_lerp_out_Scalar_out(self, end, weight, out);
}
at::Tensor & lerp_outf(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight, at::Tensor & out) {
return wrapper_CUDA_lerp_out_Scalar_out(self, end, weight, out);
}
at::Tensor & lerp_(at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
return wrapper_CUDA_lerp__Scalar(self, end, weight);
}
at::Tensor lerp(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
return wrapper_CUDA_lerp_Tensor(self, end, weight);
}
at::Tensor & lerp_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
return wrapper_CUDA_lerp_out_Tensor_out(self, end, weight, out);
}
at::Tensor & lerp_outf(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight, at::Tensor & out) {
return wrapper_CUDA_lerp_out_Tensor_out(self, end, weight, out);
}
at::Tensor & lerp_(at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
return wrapper_CUDA_lerp__Tensor(self, end, weight);
}
at::Tensor addbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA__addbmm(self, batch1, batch2, beta, alpha);
}
at::Tensor & addbmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA_out_addbmm_out(self, batch1, batch2, beta, alpha, out);
}
at::Tensor & addbmm_outf(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CUDA_out_addbmm_out(self, batch1, batch2, beta, alpha, out);
}
at::Tensor & addbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CUDA__addbmm_(self, batch1, batch2, beta, alpha);
}
at::Tensor & random_(at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator) {
return wrapper_CUDA_from_random_(self, from, to, generator);
}
at::Tensor & random_(at::Tensor & self, int64_t to, c10::optional<at::Generator> generator) {
return wrapper_CUDA_to_random_(self, to, generator);
}
at::Tensor & random_(at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CUDA__random_(self, generator);
}
at::Tensor & uniform_(at::Tensor & self, double from, double to, c10::optional<at::Generator> generator) {
return wrapper_CUDA__uniform_(self, from, to, generator);
}
at::Tensor & cauchy_(at::Tensor & self, double median, double sigma, c10::optional<at::Generator> generator) {
return wrapper_CUDA__cauchy_(self, median, sigma, generator);
}
at::Tensor & log_normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
return wrapper_CUDA__log_normal_(self, mean, std, generator);
}
at::Tensor & exponential_(at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
return wrapper_CUDA__exponential_(self, lambd, generator);
}
at::Tensor & geometric_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
return wrapper_CUDA__geometric_(self, p, generator);
}
at::Tensor tril_indices(int64_t row, int64_t col, int64_t offset, at::TensorOptions options) {
return wrapper_CUDA__tril_indices(row, col, offset, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor tril_indices(int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CUDA__tril_indices(row, col, offset, dtype, layout, device, pin_memory);
}
at::Tensor triu_indices(int64_t row, int64_t col, int64_t offset, at::TensorOptions options) {
return wrapper_CUDA__triu_indices(row, col, offset, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor triu_indices(int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CUDA__triu_indices(row, col, offset, dtype, layout, device, pin_memory);
}
at::Tensor trace(const at::Tensor & self) {
return wrapper_CUDA__trace(self);
}
at::Tensor ne(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_ne_Scalar(self, other);
}
at::Tensor & ne_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_ne_out_Scalar_out(self, other, out);
}
at::Tensor & ne_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CUDA_ne_out_Scalar_out(self, other, out);
}
at::Tensor & ne_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_ne__Scalar(self, other);
}
at::Tensor ne(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_ne_Tensor(self, other);
}
at::Tensor & ne_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_ne_out_Tensor_out(self, other, out);
}
at::Tensor & ne_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_ne_out_Tensor_out(self, other, out);
}
at::Tensor & ne_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_ne__Tensor(self, other);
}
at::Tensor ge(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_ge_Scalar(self, other);
}
at::Tensor & ge_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_ge_out_Scalar_out(self, other, out);
}
at::Tensor & ge_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CUDA_ge_out_Scalar_out(self, other, out);
}
at::Tensor & ge_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_ge__Scalar(self, other);
}
at::Tensor ge(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_ge_Tensor(self, other);
}
at::Tensor & ge_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_ge_out_Tensor_out(self, other, out);
}
at::Tensor & ge_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_ge_out_Tensor_out(self, other, out);
}
at::Tensor & ge_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_ge__Tensor(self, other);
}
at::Tensor le(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_le_Scalar(self, other);
}
at::Tensor & le_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_le_out_Scalar_out(self, other, out);
}
at::Tensor & le_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CUDA_le_out_Scalar_out(self, other, out);
}
at::Tensor & le_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_le__Scalar(self, other);
}
at::Tensor le(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_le_Tensor(self, other);
}
at::Tensor & le_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_le_out_Tensor_out(self, other, out);
}
at::Tensor & le_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_le_out_Tensor_out(self, other, out);
}
at::Tensor & le_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_le__Tensor(self, other);
}
at::Tensor gt(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_gt_Scalar(self, other);
}
at::Tensor & gt_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_gt_out_Scalar_out(self, other, out);
}
at::Tensor & gt_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CUDA_gt_out_Scalar_out(self, other, out);
}
at::Tensor & gt_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_gt__Scalar(self, other);
}
at::Tensor gt(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_gt_Tensor(self, other);
}
at::Tensor & gt_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_gt_out_Tensor_out(self, other, out);
}
at::Tensor & gt_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_gt_out_Tensor_out(self, other, out);
}
at::Tensor & gt_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_gt__Tensor(self, other);
}
at::Tensor lt(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_lt_Scalar(self, other);
}
at::Tensor & lt_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_lt_out_Scalar_out(self, other, out);
}
at::Tensor & lt_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CUDA_lt_out_Scalar_out(self, other, out);
}
at::Tensor & lt_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CUDA_lt__Scalar(self, other);
}
at::Tensor lt(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_lt_Tensor(self, other);
}
at::Tensor & lt_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_lt_out_Tensor_out(self, other, out);
}
at::Tensor & lt_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_lt_out_Tensor_out(self, other, out);
}
at::Tensor & lt_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_lt__Tensor(self, other);
}
at::Tensor take(const at::Tensor & self, const at::Tensor & index) {
return wrapper_CUDA__take(self, index);
}
at::Tensor & take_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & index) {
return wrapper_CUDA_out_take_out(self, index, out);
}
at::Tensor & take_outf(const at::Tensor & self, const at::Tensor & index, at::Tensor & out) {
return wrapper_CUDA_out_take_out(self, index, out);
}
at::Tensor index_select(const at::Tensor & self, int64_t dim, const at::Tensor & index) {
return wrapper_CUDA__index_select(self, dim, index);
}
at::Tensor & index_select_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index) {
return wrapper_CUDA_out_index_select_out(self, dim, index, out);
}
at::Tensor & index_select_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, at::Tensor & out) {
return wrapper_CUDA_out_index_select_out(self, dim, index, out);
}
at::Tensor masked_select(const at::Tensor & self, const at::Tensor & mask) {
return wrapper_CUDA__masked_select(self, mask);
}
at::Tensor & masked_select_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mask) {
return wrapper_CUDA_out_masked_select_out(self, mask, out);
}
at::Tensor & masked_select_outf(const at::Tensor & self, const at::Tensor & mask, at::Tensor & out) {
return wrapper_CUDA_out_masked_select_out(self, mask, out);
}
at::Tensor nonzero(const at::Tensor & self) {
return wrapper_CUDA__nonzero(self);
}
at::Tensor & nonzero_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_out_nonzero_out(self, out);
}
at::Tensor & nonzero_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_out_nonzero_out(self, out);
}
at::Tensor gather(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad) {
return wrapper_CUDA_gather(self, dim, index, sparse_grad);
}
at::Tensor & gather_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad) {
return wrapper_CUDA_gather_out_out(self, dim, index, sparse_grad, out);
}
at::Tensor & gather_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad, at::Tensor & out) {
return wrapper_CUDA_gather_out_out(self, dim, index, sparse_grad, out);
}
at::Tensor addcmul(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CUDA_addcmul(self, tensor1, tensor2, value);
}
at::Tensor & addcmul_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CUDA_addcmul_out_out(self, tensor1, tensor2, value, out);
}
at::Tensor & addcmul_outf(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
return wrapper_CUDA_addcmul_out_out(self, tensor1, tensor2, value, out);
}
at::Tensor & addcmul_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CUDA_addcmul_(self, tensor1, tensor2, value);
}
at::Tensor addcdiv(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CUDA_addcdiv(self, tensor1, tensor2, value);
}
at::Tensor & addcdiv_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CUDA_addcdiv_out_out(self, tensor1, tensor2, value, out);
}
at::Tensor & addcdiv_outf(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
return wrapper_CUDA_addcdiv_out_out(self, tensor1, tensor2, value, out);
}
at::Tensor & addcdiv_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CUDA_addcdiv_(self, tensor1, tensor2, value);
}
::std::tuple<at::Tensor,at::Tensor> triangular_solve(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular) {
return wrapper_CUDA_triangular_solve(self, A, upper, transpose, unitriangular);
}
::std::tuple<at::Tensor &,at::Tensor &> triangular_solve_out(at::Tensor & X, at::Tensor & M, const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular) {
return wrapper_CUDA_triangular_solve_out_X(self, A, upper, transpose, unitriangular, X, M);
}
::std::tuple<at::Tensor &,at::Tensor &> triangular_solve_outf(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular, at::Tensor & X, at::Tensor & M) {
return wrapper_CUDA_triangular_solve_out_X(self, A, upper, transpose, unitriangular, X, M);
}
at::Tensor linalg_solve_triangular(const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular) {
return wrapper_CUDA__linalg_solve_triangular(self, B, upper, left, unitriangular);
}
at::Tensor & linalg_solve_triangular_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular) {
return wrapper_CUDA_out_linalg_solve_triangular_out(self, B, upper, left, unitriangular, out);
}
at::Tensor & linalg_solve_triangular_outf(const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular, at::Tensor & out) {
return wrapper_CUDA_out_linalg_solve_triangular_out(self, B, upper, left, unitriangular, out);
}
at::Tensor cholesky(const at::Tensor & self, bool upper) {
return wrapper_CUDA__cholesky(self, upper);
}
at::Tensor & cholesky_out(at::Tensor & out, const at::Tensor & self, bool upper) {
return wrapper_CUDA_out_cholesky_out(self, upper, out);
}
at::Tensor & cholesky_outf(const at::Tensor & self, bool upper, at::Tensor & out) {
return wrapper_CUDA_out_cholesky_out(self, upper, out);
}
at::Tensor _cholesky_solve_helper(const at::Tensor & self, const at::Tensor & A, bool upper) {
return wrapper_CUDA___cholesky_solve_helper(self, A, upper);
}
at::Tensor cholesky_inverse(const at::Tensor & self, bool upper) {
return wrapper_CUDA__cholesky_inverse(self, upper);
}
at::Tensor & cholesky_inverse_out(at::Tensor & out, const at::Tensor & self, bool upper) {
return wrapper_CUDA_out_cholesky_inverse_out(self, upper, out);
}
at::Tensor & cholesky_inverse_outf(const at::Tensor & self, bool upper, at::Tensor & out) {
return wrapper_CUDA_out_cholesky_inverse_out(self, upper, out);
}
::std::tuple<at::Tensor,at::Tensor> geqrf(const at::Tensor & self) {
return wrapper_CUDA__geqrf(self);
}
::std::tuple<at::Tensor &,at::Tensor &> geqrf_out(at::Tensor & a, at::Tensor & tau, const at::Tensor & self) {
return wrapper_CUDA_a_geqrf_out(self, a, tau);
}
::std::tuple<at::Tensor &,at::Tensor &> geqrf_outf(const at::Tensor & self, at::Tensor & a, at::Tensor & tau) {
return wrapper_CUDA_a_geqrf_out(self, a, tau);
}
at::Tensor ormqr(const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose) {
return wrapper_CUDA__ormqr(self, input2, input3, left, transpose);
}
at::Tensor & ormqr_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose) {
return wrapper_CUDA_out_ormqr_out(self, input2, input3, left, transpose, out);
}
at::Tensor & ormqr_outf(const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose, at::Tensor & out) {
return wrapper_CUDA_out_ormqr_out(self, input2, input3, left, transpose, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> lu_unpack(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots) {
return wrapper_CUDA_lu_unpack(LU_data, LU_pivots, unpack_data, unpack_pivots);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> lu_unpack_out(at::Tensor & P, at::Tensor & L, at::Tensor & U, const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots) {
return wrapper_CUDA_lu_unpack_out_out(LU_data, LU_pivots, unpack_data, unpack_pivots, P, L, U);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> lu_unpack_outf(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
return wrapper_CUDA_lu_unpack_out_out(LU_data, LU_pivots, unpack_data, unpack_pivots, P, L, U);
}
at::Tensor multinomial(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator) {
return wrapper_CUDA__multinomial(self, num_samples, replacement, generator);
}
at::Tensor & multinomial_out(at::Tensor & out, const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator) {
return wrapper_CUDA_out_multinomial_out(self, num_samples, replacement, generator, out);
}
at::Tensor & multinomial_outf(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CUDA_out_multinomial_out(self, num_samples, replacement, generator, out);
}
at::Tensor lgamma(const at::Tensor & self) {
return wrapper_CUDA_lgamma(self);
}
at::Tensor & lgamma_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_lgamma_out_out(self, out);
}
at::Tensor & lgamma_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_lgamma_out_out(self, out);
}
at::Tensor & lgamma_(at::Tensor & self) {
return wrapper_CUDA_lgamma_(self);
}
at::Tensor polygamma(int64_t n, const at::Tensor & self) {
return wrapper_CUDA_polygamma(n, self);
}
at::Tensor & polygamma_out(at::Tensor & out, int64_t n, const at::Tensor & self) {
return wrapper_CUDA_polygamma_out_out(n, self, out);
}
at::Tensor & polygamma_outf(int64_t n, const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_polygamma_out_out(n, self, out);
}
at::Tensor erfinv(const at::Tensor & self) {
return wrapper_CUDA_erfinv(self);
}
at::Tensor & erfinv_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_erfinv_out_out(self, out);
}
at::Tensor & erfinv_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_erfinv_out_out(self, out);
}
at::Tensor & erfinv_(at::Tensor & self) {
return wrapper_CUDA_erfinv_(self);
}
at::Tensor i0(const at::Tensor & self) {
return wrapper_CUDA_i0(self);
}
at::Tensor & i0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_i0_out_out(self, out);
}
at::Tensor & i0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_i0_out_out(self, out);
}
at::Tensor & i0_(at::Tensor & self) {
return wrapper_CUDA_i0_(self);
}
at::Tensor sign(const at::Tensor & self) {
return wrapper_CUDA_sign(self);
}
at::Tensor & sign_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_sign_out_out(self, out);
}
at::Tensor & sign_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_sign_out_out(self, out);
}
at::Tensor & sign_(at::Tensor & self) {
return wrapper_CUDA_sign_(self);
}
at::Tensor signbit(const at::Tensor & self) {
return wrapper_CUDA_signbit(self);
}
at::Tensor & signbit_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_signbit_out_out(self, out);
}
at::Tensor & signbit_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_signbit_out_out(self, out);
}
at::Tensor atan2(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_atan2(self, other);
}
at::Tensor & atan2_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_atan2_out_out(self, other, out);
}
at::Tensor & atan2_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_atan2_out_out(self, other, out);
}
at::Tensor & atan2_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_atan2_(self, other);
}
at::Tensor histc(const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max) {
return wrapper_CUDA__histc(self, bins, min, max);
}
at::Tensor & histc_out(at::Tensor & out, const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max) {
return wrapper_CUDA_out_histc_out(self, bins, min, max, out);
}
at::Tensor & histc_outf(const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max, at::Tensor & out) {
return wrapper_CUDA_out_histc_out(self, bins, min, max, out);
}
at::Tensor fmod(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_fmod_Tensor(self, other);
}
at::Tensor & fmod_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_fmod_out_Tensor_out(self, other, out);
}
at::Tensor & fmod_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_fmod_out_Tensor_out(self, other, out);
}
at::Tensor & fmod_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_fmod__Tensor(self, other);
}
at::Tensor hypot(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_hypot(self, other);
}
at::Tensor & hypot_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_hypot_out_out(self, other, out);
}
at::Tensor & hypot_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_hypot_out_out(self, other, out);
}
at::Tensor & hypot_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_hypot_(self, other);
}
at::Tensor igamma(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_igamma(self, other);
}
at::Tensor & igamma_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_igamma_out_out(self, other, out);
}
at::Tensor & igamma_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_igamma_out_out(self, other, out);
}
at::Tensor & igamma_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_igamma_(self, other);
}
at::Tensor igammac(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_igammac(self, other);
}
at::Tensor & igammac_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_igammac_out_out(self, other, out);
}
at::Tensor & igammac_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_igammac_out_out(self, other, out);
}
at::Tensor & igammac_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_igammac_(self, other);
}
at::Tensor nextafter(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_nextafter(self, other);
}
at::Tensor & nextafter_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_nextafter_out_out(self, other, out);
}
at::Tensor & nextafter_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_nextafter_out_out(self, other, out);
}
at::Tensor & nextafter_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_nextafter_(self, other);
}
at::Tensor remainder(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_remainder_Tensor(self, other);
}
at::Tensor & remainder_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_remainder_out_Tensor_out(self, other, out);
}
at::Tensor & remainder_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_remainder_out_Tensor_out(self, other, out);
}
at::Tensor & remainder_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_remainder__Tensor(self, other);
}
at::Tensor remainder(const at::Scalar & self, const at::Tensor & other) {
return wrapper_CUDA_Scalar_Tensor_remainder(self, other);
}
at::Tensor min(const at::Tensor & self) {
return wrapper_CUDA__min(self);
}
at::Tensor & min_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_unary_out_min_out(self, out);
}
at::Tensor & min_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_unary_out_min_out(self, out);
}
at::Tensor fmin(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_fmin(self, other);
}
at::Tensor & fmin_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_fmin_out_out(self, other, out);
}
at::Tensor & fmin_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_fmin_out_out(self, other, out);
}
at::Tensor max(const at::Tensor & self) {
return wrapper_CUDA__max(self);
}
at::Tensor & max_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_unary_out_max_out(self, out);
}
at::Tensor & max_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_unary_out_max_out(self, out);
}
at::Tensor fmax(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_fmax(self, other);
}
at::Tensor & fmax_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_fmax_out_out(self, other, out);
}
at::Tensor & fmax_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_fmax_out_out(self, other, out);
}
at::Tensor maximum(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_maximum(self, other);
}
at::Tensor & maximum_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_maximum_out_out(self, other, out);
}
at::Tensor & maximum_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_maximum_out_out(self, other, out);
}
at::Tensor minimum(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_minimum(self, other);
}
at::Tensor & minimum_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_minimum_out_out(self, other, out);
}
at::Tensor & minimum_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_minimum_out_out(self, other, out);
}
::std::tuple<at::Tensor,at::Tensor> sort(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending) {
return wrapper_CUDA_sort_stable(self, stable, dim, descending);
}
::std::tuple<at::Tensor &,at::Tensor &> sort_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending) {
return wrapper_CUDA_sort_out_values_stable(self, stable, dim, descending, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> sort_outf(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending, at::Tensor & values, at::Tensor & indices) {
return wrapper_CUDA_sort_out_values_stable(self, stable, dim, descending, values, indices);
}
at::Tensor argsort(const at::Tensor & self, bool stable, int64_t dim, bool descending) {
return wrapper_CUDA_stable_argsort(self, stable, dim, descending);
}
::std::tuple<at::Tensor,at::Tensor> topk(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) {
return wrapper_CUDA_topk(self, k, dim, largest, sorted);
}
::std::tuple<at::Tensor,at::Tensor> topk_symint(const at::Tensor & self, c10::SymInt k, int64_t dim, bool largest, bool sorted) {
return wrapper_CUDA_topk(self, k.guard_int(__FILE__, __LINE__), dim, largest, sorted);
}
::std::tuple<at::Tensor &,at::Tensor &> topk_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) {
return wrapper_CUDA_topk_out_values(self, k, dim, largest, sorted, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> topk_outf(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted, at::Tensor & values, at::Tensor & indices) {
return wrapper_CUDA_topk_out_values(self, k, dim, largest, sorted, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> topk_symint_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, c10::SymInt k, int64_t dim, bool largest, bool sorted) {
return wrapper_CUDA_topk_out_values(self, k.guard_int(__FILE__, __LINE__), dim, largest, sorted, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> topk_symint_outf(const at::Tensor & self, c10::SymInt k, int64_t dim, bool largest, bool sorted, at::Tensor & values, at::Tensor & indices) {
return wrapper_CUDA_topk_out_values(self, k.guard_int(__FILE__, __LINE__), dim, largest, sorted, values, indices);
}
at::Tensor all(const at::Tensor & self) {
return wrapper_CUDA_all(self);
}
at::Tensor & all_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_all_out_all_out(self, out);
}
at::Tensor & all_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_all_out_all_out(self, out);
}
at::Tensor any(const at::Tensor & self) {
return wrapper_CUDA_any(self);
}
at::Tensor & any_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_any_out_all_out(self, out);
}
at::Tensor & any_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_any_out_all_out(self, out);
}
at::Tensor renorm(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
return wrapper_CUDA_renorm(self, p, dim, maxnorm);
}
at::Tensor & renorm_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
return wrapper_CUDA_renorm_out_out(self, p, dim, maxnorm, out);
}
at::Tensor & renorm_outf(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm, at::Tensor & out) {
return wrapper_CUDA_renorm_out_out(self, p, dim, maxnorm, out);
}
at::Tensor & renorm_(at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
return wrapper_CUDA_renorm_(self, p, dim, maxnorm);
}
at::Tensor unfold(const at::Tensor & self, int64_t dimension, int64_t size, int64_t step) {
return wrapper_CUDA__unfold(self, dimension, size, step);
}
at::Tensor unfold_backward(const at::Tensor & grad_in, at::IntArrayRef input_sizes, int64_t dim, int64_t size, int64_t step) {
return wrapper_CUDA__unfold_backward(grad_in, c10::fromIntArrayRefSlow(input_sizes), dim, size, step);
}
at::Tensor unfold_backward_symint(const at::Tensor & grad_in, c10::SymIntArrayRef input_sizes, int64_t dim, int64_t size, int64_t step) {
return wrapper_CUDA__unfold_backward(grad_in, input_sizes, dim, size, step);
}
bool equal(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA__equal(self, other);
}
at::Tensor pow(const at::Tensor & self, const at::Tensor & exponent) {
return wrapper_CUDA_pow_Tensor_Tensor(self, exponent);
}
at::Tensor & pow_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & exponent) {
return wrapper_CUDA_pow_out_Tensor_Tensor_out(self, exponent, out);
}
at::Tensor & pow_outf(const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
return wrapper_CUDA_pow_out_Tensor_Tensor_out(self, exponent, out);
}
at::Tensor & pow_(at::Tensor & self, const at::Tensor & exponent) {
return wrapper_CUDA_pow__Tensor(self, exponent);
}
at::Tensor pow(const at::Scalar & self, const at::Tensor & exponent) {
return wrapper_CUDA_pow_Scalar(self, exponent);
}
at::Tensor & pow_out(at::Tensor & out, const at::Scalar & self, const at::Tensor & exponent) {
return wrapper_CUDA_pow_out_Scalar_out(self, exponent, out);
}
at::Tensor & pow_outf(const at::Scalar & self, const at::Tensor & exponent, at::Tensor & out) {
return wrapper_CUDA_pow_out_Scalar_out(self, exponent, out);
}
at::Tensor pow(const at::Tensor & self, const at::Scalar & exponent) {
return wrapper_CUDA_pow_Tensor_Scalar(self, exponent);
}
at::Tensor & pow_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & exponent) {
return wrapper_CUDA_pow_out_Tensor_Scalar_out(self, exponent, out);
}
at::Tensor & pow_outf(const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
return wrapper_CUDA_pow_out_Tensor_Scalar_out(self, exponent, out);
}
at::Tensor & pow_(at::Tensor & self, const at::Scalar & exponent) {
return wrapper_CUDA_pow__Scalar(self, exponent);
}
at::Tensor & normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
return wrapper_CUDA__normal_(self, mean, std, generator);
}
at::Tensor normal(const at::Tensor & mean, double std, c10::optional<at::Generator> generator) {
return wrapper_CUDA_Tensor_float_normal(mean, std, generator);
}
at::Tensor & normal_out(at::Tensor & out, const at::Tensor & mean, double std, c10::optional<at::Generator> generator) {
return wrapper_CUDA_Tensor_float_out_normal_out(mean, std, generator, out);
}
at::Tensor & normal_outf(const at::Tensor & mean, double std, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CUDA_Tensor_float_out_normal_out(mean, std, generator, out);
}
at::Tensor normal(double mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
return wrapper_CUDA_float_Tensor_normal(mean, std, generator);
}
at::Tensor & normal_out(at::Tensor & out, double mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
return wrapper_CUDA_float_Tensor_out_normal_out(mean, std, generator, out);
}
at::Tensor & normal_outf(double mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CUDA_float_Tensor_out_normal_out(mean, std, generator, out);
}
at::Tensor normal(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
return wrapper_CUDA_Tensor_Tensor_normal(mean, std, generator);
}
at::Tensor & normal_out(at::Tensor & out, const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
return wrapper_CUDA_Tensor_Tensor_out_normal_out(mean, std, generator, out);
}
at::Tensor & normal_outf(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CUDA_Tensor_Tensor_out_normal_out(mean, std, generator, out);
}
void _amp_foreach_non_finite_check_and_unscale_(at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale) {
return wrapper_CUDA___amp_foreach_non_finite_check_and_unscale_(self, found_inf, inv_scale);
}
at::Tensor & _amp_update_scale_(at::Tensor & self, at::Tensor & growth_tracker, const at::Tensor & found_inf, double scale_growth_factor, double scale_backoff_factor, int64_t growth_interval) {
return wrapper_CUDA___amp_update_scale_(self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
}
::std::vector<at::Tensor> _foreach_add(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_add(self, scalar);
}
void _foreach_add_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_add_(self, scalar);
}
::std::vector<at::Tensor> _foreach_add(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
return wrapper_CUDA_List__foreach_add(self, other, alpha);
}
void _foreach_add_(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
return wrapper_CUDA_List__foreach_add_(self, other, alpha);
}
::std::vector<at::Tensor> _foreach_add(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_add(self, scalars);
}
void _foreach_add_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_add_(self, scalars);
}
::std::vector<at::Tensor> _foreach_add(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CUDA_Tensor__foreach_add(self, other, alpha);
}
void _foreach_add_(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CUDA_Tensor__foreach_add_(self, other, alpha);
}
::std::vector<at::Tensor> _foreach_sub(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_sub(self, scalar);
}
void _foreach_sub_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_sub_(self, scalar);
}
::std::vector<at::Tensor> _foreach_sub(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
return wrapper_CUDA_List__foreach_sub(self, other, alpha);
}
void _foreach_sub_(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
return wrapper_CUDA_List__foreach_sub_(self, other, alpha);
}
::std::vector<at::Tensor> _foreach_sub(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_sub(self, scalars);
}
void _foreach_sub_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_sub_(self, scalars);
}
::std::vector<at::Tensor> _foreach_mul(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_mul(self, scalar);
}
void _foreach_mul_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_mul_(self, scalar);
}
::std::vector<at::Tensor> _foreach_mul(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_mul(self, other);
}
void _foreach_mul_(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_mul_(self, other);
}
::std::vector<at::Tensor> _foreach_mul(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_mul(self, scalars);
}
void _foreach_mul_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_mul_(self, scalars);
}
::std::vector<at::Tensor> _foreach_mul(at::TensorList self, const at::Tensor & other) {
return wrapper_CUDA_Tensor__foreach_mul(self, other);
}
void _foreach_mul_(at::TensorList self, const at::Tensor & other) {
return wrapper_CUDA_Tensor__foreach_mul_(self, other);
}
::std::vector<at::Tensor> _foreach_div(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_div(self, scalar);
}
void _foreach_div_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_div_(self, scalar);
}
::std::vector<at::Tensor> _foreach_div(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_div(self, other);
}
void _foreach_div_(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_div_(self, other);
}
::std::vector<at::Tensor> _foreach_div(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_div(self, scalars);
}
void _foreach_div_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_div_(self, scalars);
}
::std::vector<at::Tensor> _foreach_div(at::TensorList self, const at::Tensor & other) {
return wrapper_CUDA_Tensor__foreach_div(self, other);
}
void _foreach_div_(at::TensorList self, const at::Tensor & other) {
return wrapper_CUDA_Tensor__foreach_div_(self, other);
}
::std::vector<at::Tensor> _foreach_clamp_max(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_clamp_max(self, scalar);
}
void _foreach_clamp_max_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_clamp_max_(self, scalar);
}
::std::vector<at::Tensor> _foreach_clamp_max(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_clamp_max(self, other);
}
void _foreach_clamp_max_(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_clamp_max_(self, other);
}
::std::vector<at::Tensor> _foreach_clamp_max(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_clamp_max(self, scalars);
}
void _foreach_clamp_max_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_clamp_max_(self, scalars);
}
::std::vector<at::Tensor> _foreach_clamp_min(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_clamp_min(self, scalar);
}
void _foreach_clamp_min_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_clamp_min_(self, scalar);
}
::std::vector<at::Tensor> _foreach_clamp_min(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_clamp_min(self, other);
}
void _foreach_clamp_min_(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_clamp_min_(self, other);
}
::std::vector<at::Tensor> _foreach_clamp_min(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_clamp_min(self, scalars);
}
void _foreach_clamp_min_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_clamp_min_(self, scalars);
}
::std::vector<at::Tensor> _foreach_maximum(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_maximum(self, scalar);
}
void _foreach_maximum_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_maximum_(self, scalar);
}
::std::vector<at::Tensor> _foreach_maximum(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_maximum(self, other);
}
void _foreach_maximum_(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_maximum_(self, other);
}
::std::vector<at::Tensor> _foreach_maximum(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_maximum(self, scalars);
}
void _foreach_maximum_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_maximum_(self, scalars);
}
::std::vector<at::Tensor> _foreach_minimum(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_minimum(self, scalar);
}
void _foreach_minimum_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CUDA_Scalar__foreach_minimum_(self, scalar);
}
::std::vector<at::Tensor> _foreach_minimum(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_minimum(self, other);
}
void _foreach_minimum_(at::TensorList self, at::TensorList other) {
return wrapper_CUDA_List__foreach_minimum_(self, other);
}
::std::vector<at::Tensor> _foreach_minimum(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_minimum(self, scalars);
}
void _foreach_minimum_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_minimum_(self, scalars);
}
::std::vector<at::Tensor> _foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
return wrapper_CUDA_Scalar__foreach_addcdiv(self, tensor1, tensor2, value);
}
void _foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
return wrapper_CUDA_Scalar__foreach_addcdiv_(self, tensor1, tensor2, value);
}
::std::vector<at::Tensor> _foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_addcdiv(self, tensor1, tensor2, scalars);
}
void _foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_addcdiv_(self, tensor1, tensor2, scalars);
}
::std::vector<at::Tensor> _foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
return wrapper_CUDA_Tensor__foreach_addcdiv(self, tensor1, tensor2, scalars);
}
void _foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
return wrapper_CUDA_Tensor__foreach_addcdiv_(self, tensor1, tensor2, scalars);
}
::std::vector<at::Tensor> _foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
return wrapper_CUDA_Scalar__foreach_addcmul(self, tensor1, tensor2, value);
}
void _foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
return wrapper_CUDA_Scalar__foreach_addcmul_(self, tensor1, tensor2, value);
}
::std::vector<at::Tensor> _foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_addcmul(self, tensor1, tensor2, scalars);
}
void _foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CUDA_ScalarList__foreach_addcmul_(self, tensor1, tensor2, scalars);
}
::std::vector<at::Tensor> _foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
return wrapper_CUDA_Tensor__foreach_addcmul(self, tensor1, tensor2, scalars);
}
void _foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
return wrapper_CUDA_Tensor__foreach_addcmul_(self, tensor1, tensor2, scalars);
}
::std::vector<at::Tensor> _foreach_abs(at::TensorList self) {
return wrapper_CUDA___foreach_abs(self);
}
void _foreach_abs_(at::TensorList self) {
return wrapper_CUDA___foreach_abs_(self);
}
::std::vector<at::Tensor> _foreach_acos(at::TensorList self) {
return wrapper_CUDA___foreach_acos(self);
}
void _foreach_acos_(at::TensorList self) {
return wrapper_CUDA___foreach_acos_(self);
}
::std::vector<at::Tensor> _foreach_asin(at::TensorList self) {
return wrapper_CUDA___foreach_asin(self);
}
void _foreach_asin_(at::TensorList self) {
return wrapper_CUDA___foreach_asin_(self);
}
::std::vector<at::Tensor> _foreach_atan(at::TensorList self) {
return wrapper_CUDA___foreach_atan(self);
}
void _foreach_atan_(at::TensorList self) {
return wrapper_CUDA___foreach_atan_(self);
}
::std::vector<at::Tensor> _foreach_ceil(at::TensorList self) {
return wrapper_CUDA___foreach_ceil(self);
}
void _foreach_ceil_(at::TensorList self) {
return wrapper_CUDA___foreach_ceil_(self);
}
::std::vector<at::Tensor> _foreach_cos(at::TensorList self) {
return wrapper_CUDA___foreach_cos(self);
}
void _foreach_cos_(at::TensorList self) {
return wrapper_CUDA___foreach_cos_(self);
}
::std::vector<at::Tensor> _foreach_cosh(at::TensorList self) {
return wrapper_CUDA___foreach_cosh(self);
}
void _foreach_cosh_(at::TensorList self) {
return wrapper_CUDA___foreach_cosh_(self);
}
::std::vector<at::Tensor> _foreach_erf(at::TensorList self) {
return wrapper_CUDA___foreach_erf(self);
}
void _foreach_erf_(at::TensorList self) {
return wrapper_CUDA___foreach_erf_(self);
}
::std::vector<at::Tensor> _foreach_erfc(at::TensorList self) {
return wrapper_CUDA___foreach_erfc(self);
}
void _foreach_erfc_(at::TensorList self) {
return wrapper_CUDA___foreach_erfc_(self);
}
::std::vector<at::Tensor> _foreach_exp(at::TensorList self) {
return wrapper_CUDA___foreach_exp(self);
}
void _foreach_exp_(at::TensorList self) {
return wrapper_CUDA___foreach_exp_(self);
}
::std::vector<at::Tensor> _foreach_expm1(at::TensorList self) {
return wrapper_CUDA___foreach_expm1(self);
}
void _foreach_expm1_(at::TensorList self) {
return wrapper_CUDA___foreach_expm1_(self);
}
::std::vector<at::Tensor> _foreach_floor(at::TensorList self) {
return wrapper_CUDA___foreach_floor(self);
}
void _foreach_floor_(at::TensorList self) {
return wrapper_CUDA___foreach_floor_(self);
}
::std::vector<at::Tensor> _foreach_frac(at::TensorList self) {
return wrapper_CUDA___foreach_frac(self);
}
void _foreach_frac_(at::TensorList self) {
return wrapper_CUDA___foreach_frac_(self);
}
::std::vector<at::Tensor> _foreach_lerp(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
return wrapper_CUDA_List__foreach_lerp(self, tensors1, weights);
}
void _foreach_lerp_(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
return wrapper_CUDA_List__foreach_lerp_(self, tensors1, weights);
}
::std::vector<at::Tensor> _foreach_lerp(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
return wrapper_CUDA_Scalar__foreach_lerp(self, tensors1, weight);
}
void _foreach_lerp_(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
return wrapper_CUDA_Scalar__foreach_lerp_(self, tensors1, weight);
}
::std::vector<at::Tensor> _foreach_lgamma(at::TensorList self) {
return wrapper_CUDA___foreach_lgamma(self);
}
void _foreach_lgamma_(at::TensorList self) {
return wrapper_CUDA___foreach_lgamma_(self);
}
::std::vector<at::Tensor> _foreach_log(at::TensorList self) {
return wrapper_CUDA___foreach_log(self);
}
void _foreach_log_(at::TensorList self) {
return wrapper_CUDA___foreach_log_(self);
}
::std::vector<at::Tensor> _foreach_log10(at::TensorList self) {
return wrapper_CUDA___foreach_log10(self);
}
void _foreach_log10_(at::TensorList self) {
return wrapper_CUDA___foreach_log10_(self);
}
::std::vector<at::Tensor> _foreach_log1p(at::TensorList self) {
return wrapper_CUDA___foreach_log1p(self);
}
void _foreach_log1p_(at::TensorList self) {
return wrapper_CUDA___foreach_log1p_(self);
}
::std::vector<at::Tensor> _foreach_log2(at::TensorList self) {
return wrapper_CUDA___foreach_log2(self);
}
void _foreach_log2_(at::TensorList self) {
return wrapper_CUDA___foreach_log2_(self);
}
::std::vector<at::Tensor> _foreach_neg(at::TensorList self) {
return wrapper_CUDA___foreach_neg(self);
}
void _foreach_neg_(at::TensorList self) {
return wrapper_CUDA___foreach_neg_(self);
}
::std::vector<at::Tensor> _foreach_norm(at::TensorList self, const at::Scalar & ord) {
return wrapper_CUDA_Scalar__foreach_norm(self, ord);
}
::std::vector<at::Tensor> _foreach_pow(at::TensorList self, at::TensorList exponent) {
return wrapper_CUDA_List__foreach_pow(self, exponent);
}
void _foreach_pow_(at::TensorList self, at::TensorList exponent) {
return wrapper_CUDA_List__foreach_pow_(self, exponent);
}
::std::vector<at::Tensor> _foreach_pow(at::TensorList self, const at::Scalar & exponent) {
return wrapper_CUDA_Scalar__foreach_pow(self, exponent);
}
void _foreach_pow_(at::TensorList self, const at::Scalar & exponent) {
return wrapper_CUDA_Scalar__foreach_pow_(self, exponent);
}
::std::vector<at::Tensor> _foreach_pow(at::TensorList self, at::ArrayRef<at::Scalar> exponent) {
return wrapper_CUDA_ScalarList__foreach_pow(self, exponent);
}
void _foreach_pow_(at::TensorList self, at::ArrayRef<at::Scalar> exponent) {
return wrapper_CUDA_ScalarList__foreach_pow_(self, exponent);
}
::std::vector<at::Tensor> _foreach_pow(const at::Scalar & self, at::TensorList exponent) {
return wrapper_CUDA_ScalarAndTensor__foreach_pow(self, exponent);
}
::std::vector<at::Tensor> _foreach_reciprocal(at::TensorList self) {
return wrapper_CUDA___foreach_reciprocal(self);
}
void _foreach_reciprocal_(at::TensorList self) {
return wrapper_CUDA___foreach_reciprocal_(self);
}
::std::vector<at::Tensor> _foreach_round(at::TensorList self) {
return wrapper_CUDA___foreach_round(self);
}
void _foreach_round_(at::TensorList self) {
return wrapper_CUDA___foreach_round_(self);
}
::std::vector<at::Tensor> _foreach_sigmoid(at::TensorList self) {
return wrapper_CUDA___foreach_sigmoid(self);
}
void _foreach_sigmoid_(at::TensorList self) {
return wrapper_CUDA___foreach_sigmoid_(self);
}
::std::vector<at::Tensor> _foreach_sign(at::TensorList self) {
return wrapper_CUDA___foreach_sign(self);
}
void _foreach_sign_(at::TensorList self) {
return wrapper_CUDA___foreach_sign_(self);
}
::std::vector<at::Tensor> _foreach_sin(at::TensorList self) {
return wrapper_CUDA___foreach_sin(self);
}
void _foreach_sin_(at::TensorList self) {
return wrapper_CUDA___foreach_sin_(self);
}
::std::vector<at::Tensor> _foreach_sinh(at::TensorList self) {
return wrapper_CUDA___foreach_sinh(self);
}
void _foreach_sinh_(at::TensorList self) {
return wrapper_CUDA___foreach_sinh_(self);
}
::std::vector<at::Tensor> _foreach_sqrt(at::TensorList self) {
return wrapper_CUDA___foreach_sqrt(self);
}
void _foreach_sqrt_(at::TensorList self) {
return wrapper_CUDA___foreach_sqrt_(self);
}
::std::vector<at::Tensor> _foreach_tan(at::TensorList self) {
return wrapper_CUDA___foreach_tan(self);
}
void _foreach_tan_(at::TensorList self) {
return wrapper_CUDA___foreach_tan_(self);
}
::std::vector<at::Tensor> _foreach_tanh(at::TensorList self) {
return wrapper_CUDA___foreach_tanh(self);
}
void _foreach_tanh_(at::TensorList self) {
return wrapper_CUDA___foreach_tanh_(self);
}
::std::vector<at::Tensor> _foreach_trunc(at::TensorList self) {
return wrapper_CUDA___foreach_trunc(self);
}
void _foreach_trunc_(at::TensorList self) {
return wrapper_CUDA___foreach_trunc_(self);
}
void _foreach_zero_(at::TensorList self) {
return wrapper_CUDA___foreach_zero_(self);
}
void _foreach_copy_(at::TensorList self, at::TensorList src, bool non_blocking) {
return wrapper_CUDA___foreach_copy_(self, src, non_blocking);
}
at::Tensor bucketize(const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right) {
return wrapper_CUDA_Tensor_bucketize(self, boundaries, out_int32, right);
}
at::Tensor & bucketize_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right) {
return wrapper_CUDA_Tensor_out_bucketize_out(self, boundaries, out_int32, right, out);
}
at::Tensor & bucketize_outf(const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right, at::Tensor & out) {
return wrapper_CUDA_Tensor_out_bucketize_out(self, boundaries, out_int32, right, out);
}
at::Tensor bucketize(const at::Scalar & self, const at::Tensor & boundaries, bool out_int32, bool right) {
return wrapper_CUDA_Scalar_bucketize(self, boundaries, out_int32, right);
}
at::Tensor searchsorted(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
return wrapper_CUDA_Tensor_searchsorted(sorted_sequence, self, out_int32, right, side, sorter);
}
at::Tensor & searchsorted_out(at::Tensor & out, const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
return wrapper_CUDA_Tensor_out_searchsorted_out(sorted_sequence, self, out_int32, right, side, sorter, out);
}
at::Tensor & searchsorted_outf(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
return wrapper_CUDA_Tensor_out_searchsorted_out(sorted_sequence, self, out_int32, right, side, sorter, out);
}
at::Tensor searchsorted(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
return wrapper_CUDA_Scalar_searchsorted(sorted_sequence, self, out_int32, right, side, sorter);
}
at::Tensor & searchsorted_out(at::Tensor & out, const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
return wrapper_CUDA_Scalar_out_searchsorted_out(sorted_sequence, self, out_int32, right, side, sorter, out);
}
at::Tensor & searchsorted_outf(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
return wrapper_CUDA_Scalar_out_searchsorted_out(sorted_sequence, self, out_int32, right, side, sorter, out);
}
at::Tensor _convert_indices_from_coo_to_csr(const at::Tensor & self, int64_t size, bool out_int32) {
return wrapper_CUDA__convert_indices_from_coo_to_csr(self, size, out_int32);
}
at::Tensor & _convert_indices_from_coo_to_csr_out(at::Tensor & out, const at::Tensor & self, int64_t size, bool out_int32) {
return wrapper_CUDA__convert_indices_from_coo_to_csr_out_out(self, size, out_int32, out);
}
at::Tensor & _convert_indices_from_coo_to_csr_outf(const at::Tensor & self, int64_t size, bool out_int32, at::Tensor & out) {
return wrapper_CUDA__convert_indices_from_coo_to_csr_out_out(self, size, out_int32, out);
}
at::Tensor _convert_indices_from_csr_to_coo(const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose) {
return wrapper_CUDA__convert_indices_from_csr_to_coo(crow_indices, col_indices, out_int32, transpose);
}
at::Tensor & _convert_indices_from_csr_to_coo_out(at::Tensor & out, const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose) {
return wrapper_CUDA__convert_indices_from_csr_to_coo_out_out(crow_indices, col_indices, out_int32, transpose, out);
}
at::Tensor & _convert_indices_from_csr_to_coo_outf(const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose, at::Tensor & out) {
return wrapper_CUDA__convert_indices_from_csr_to_coo_out_out(crow_indices, col_indices, out_int32, transpose, out);
}
at::Tensor mse_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CUDA_mse_loss(self, target, reduction);
}
at::Tensor & mse_loss_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CUDA_mse_loss_out_out(self, target, reduction, out);
}
at::Tensor & mse_loss_outf(const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & out) {
return wrapper_CUDA_mse_loss_out_out(self, target, reduction, out);
}
at::Tensor mse_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CUDA__mse_loss_backward(grad_output, self, target, reduction);
}
at::Tensor & mse_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CUDA_grad_input_mse_loss_backward_out(grad_output, self, target, reduction, grad_input);
}
at::Tensor & mse_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_mse_loss_backward_out(grad_output, self, target, reduction, grad_input);
}
at::Tensor multi_margin_loss(const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CUDA__multi_margin_loss(self, target, p, margin, weight, reduction);
}
at::Tensor & multi_margin_loss_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CUDA_out_multi_margin_loss_out(self, target, p, margin, weight, reduction, out);
}
at::Tensor & multi_margin_loss_outf(const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
return wrapper_CUDA_out_multi_margin_loss_out(self, target, p, margin, weight, reduction, out);
}
at::Tensor multi_margin_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CUDA__multi_margin_loss_backward(grad_output, self, target, p, margin, weight, reduction);
}
at::Tensor & multi_margin_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CUDA_grad_input_multi_margin_loss_backward_out(grad_output, self, target, p, margin, weight, reduction, grad_input);
}
at::Tensor & multi_margin_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_multi_margin_loss_backward_out(grad_output, self, target, p, margin, weight, reduction, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> multilabel_margin_loss_forward(const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CUDA__multilabel_margin_loss_forward(self, target, reduction);
}
::std::tuple<at::Tensor &,at::Tensor &> multilabel_margin_loss_forward_out(at::Tensor & output, at::Tensor & is_target, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CUDA_output_multilabel_margin_loss_forward_out(self, target, reduction, output, is_target);
}
::std::tuple<at::Tensor &,at::Tensor &> multilabel_margin_loss_forward_outf(const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & output, at::Tensor & is_target) {
return wrapper_CUDA_output_multilabel_margin_loss_forward_out(self, target, reduction, output, is_target);
}
at::Tensor multilabel_margin_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target) {
return wrapper_CUDA__multilabel_margin_loss_backward(grad_output, self, target, reduction, is_target);
}
at::Tensor & multilabel_margin_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target) {
return wrapper_CUDA_grad_input_multilabel_margin_loss_backward_out(grad_output, self, target, reduction, is_target, grad_input);
}
at::Tensor & multilabel_margin_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_multilabel_margin_loss_backward_out(grad_output, self, target, reduction, is_target, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> nll_loss_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
return wrapper_CUDA_nll_loss_forward(self, target, weight, reduction, ignore_index);
}
::std::tuple<at::Tensor,at::Tensor> nll_loss_forward_symint(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
return wrapper_CUDA_nll_loss_forward(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__));
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss_forward_out(at::Tensor & output, at::Tensor & total_weight, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
return wrapper_CUDA_nll_loss_forward_out_output(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss_forward_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, at::Tensor & output, at::Tensor & total_weight) {
return wrapper_CUDA_nll_loss_forward_out_output(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss_forward_symint_out(at::Tensor & output, at::Tensor & total_weight, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
return wrapper_CUDA_nll_loss_forward_out_output(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss_forward_symint_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, at::Tensor & output, at::Tensor & total_weight) {
return wrapper_CUDA_nll_loss_forward_out_output(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), output, total_weight);
}
at::Tensor nll_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
return wrapper_CUDA_nll_loss_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
}
at::Tensor nll_loss_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
return wrapper_CUDA_nll_loss_backward(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight);
}
at::Tensor & nll_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
return wrapper_CUDA_nll_loss_backward_out_grad_input(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
return wrapper_CUDA_nll_loss_backward_out_grad_input(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
return wrapper_CUDA_nll_loss_backward_out_grad_input(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight, grad_input);
}
at::Tensor & nll_loss_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
return wrapper_CUDA_nll_loss_backward_out_grad_input(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> nll_loss2d_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
return wrapper_CUDA__nll_loss2d_forward(self, target, weight, reduction, ignore_index);
}
::std::tuple<at::Tensor,at::Tensor> nll_loss2d_forward_symint(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
return wrapper_CUDA__nll_loss2d_forward(self, target, weight, reduction, ignore_index);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss2d_forward_out(at::Tensor & output, at::Tensor & total_weight, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
return wrapper_CUDA_output_nll_loss2d_forward_out(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss2d_forward_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, at::Tensor & output, at::Tensor & total_weight) {
return wrapper_CUDA_output_nll_loss2d_forward_out(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss2d_forward_symint_out(at::Tensor & output, at::Tensor & total_weight, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
return wrapper_CUDA_output_nll_loss2d_forward_out(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss2d_forward_symint_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, at::Tensor & output, at::Tensor & total_weight) {
return wrapper_CUDA_output_nll_loss2d_forward_out(self, target, weight, reduction, ignore_index, output, total_weight);
}
at::Tensor nll_loss2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
return wrapper_CUDA__nll_loss2d_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
}
at::Tensor nll_loss2d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
return wrapper_CUDA__nll_loss2d_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
}
at::Tensor & nll_loss2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
return wrapper_CUDA_grad_input_nll_loss2d_backward_out(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_nll_loss2d_backward_out(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
return wrapper_CUDA_grad_input_nll_loss2d_backward_out(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss2d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_nll_loss2d_backward_out(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor smooth_l1_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
return wrapper_CUDA_smooth_l1_loss(self, target, reduction, beta);
}
at::Tensor & smooth_l1_loss_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
return wrapper_CUDA_smooth_l1_loss_out_out(self, target, reduction, beta, out);
}
at::Tensor & smooth_l1_loss_outf(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & out) {
return wrapper_CUDA_smooth_l1_loss_out_out(self, target, reduction, beta, out);
}
at::Tensor & smooth_l1_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
return wrapper_CUDA_grad_input_smooth_l1_loss_backward_out(grad_output, self, target, reduction, beta, grad_input);
}
at::Tensor & smooth_l1_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_smooth_l1_loss_backward_out(grad_output, self, target, reduction, beta, grad_input);
}
at::Tensor huber_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta) {
return wrapper_CUDA__huber_loss(self, target, reduction, delta);
}
at::Tensor & huber_loss_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta) {
return wrapper_CUDA_out_huber_loss_out(self, target, reduction, delta, out);
}
at::Tensor & huber_loss_outf(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta, at::Tensor & out) {
return wrapper_CUDA_out_huber_loss_out(self, target, reduction, delta, out);
}
at::Tensor & huber_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta) {
return wrapper_CUDA_out_huber_loss_backward_out(grad_output, self, target, reduction, delta, grad_input);
}
at::Tensor & huber_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta, at::Tensor & grad_input) {
return wrapper_CUDA_out_huber_loss_backward_out(grad_output, self, target, reduction, delta, grad_input);
}
at::Tensor elu(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
return wrapper_CUDA_elu(self, alpha, scale, input_scale);
}
at::Tensor & elu_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
return wrapper_CUDA_elu_out_out(self, alpha, scale, input_scale, out);
}
at::Tensor & elu_outf(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, at::Tensor & out) {
return wrapper_CUDA_elu_out_out(self, alpha, scale, input_scale, out);
}
at::Tensor & elu_(at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
return wrapper_CUDA_elu_(self, alpha, scale, input_scale);
}
at::Tensor elu_backward(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
return wrapper_CUDA_elu_backward(grad_output, alpha, scale, input_scale, is_result, self_or_result);
}
at::Tensor & elu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
return wrapper_CUDA_elu_backward_out_grad_input(grad_output, alpha, scale, input_scale, is_result, self_or_result, grad_input);
}
at::Tensor & elu_backward_outf(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result, at::Tensor & grad_input) {
return wrapper_CUDA_elu_backward_out_grad_input(grad_output, alpha, scale, input_scale, is_result, self_or_result, grad_input);
}
at::Tensor glu(const at::Tensor & self, int64_t dim) {
return wrapper_CUDA_glu(self, dim);
}
at::Tensor & glu_out(at::Tensor & out, const at::Tensor & self, int64_t dim) {
return wrapper_CUDA_glu_out_out(self, dim, out);
}
at::Tensor & glu_outf(const at::Tensor & self, int64_t dim, at::Tensor & out) {
return wrapper_CUDA_glu_out_out(self, dim, out);
}
at::Tensor glu_backward(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim) {
return wrapper_CUDA__glu_backward(grad_output, self, dim);
}
at::Tensor & glu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, int64_t dim) {
return wrapper_CUDA_grad_input_glu_backward_out(grad_output, self, dim, grad_input);
}
at::Tensor & glu_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_glu_backward_out(grad_output, self, dim, grad_input);
}
at::Tensor glu_jvp(const at::Tensor & glu, const at::Tensor & x, const at::Tensor & dx, int64_t dim) {
return wrapper_CUDA__glu_jvp(glu, x, dx, dim);
}
at::Tensor glu_backward_jvp(const at::Tensor & grad_x, const at::Tensor & grad_glu, const at::Tensor & x, const at::Tensor & dgrad_glu, const at::Tensor & dx, int64_t dim) {
return wrapper_CUDA__glu_backward_jvp(grad_x, grad_glu, x, dgrad_glu, dx, dim);
}
at::Tensor hardsigmoid(const at::Tensor & self) {
return wrapper_CUDA_hardsigmoid(self);
}
at::Tensor & hardsigmoid_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_hardsigmoid_out_out(self, out);
}
at::Tensor & hardsigmoid_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_hardsigmoid_out_out(self, out);
}
at::Tensor & hardsigmoid_(at::Tensor & self) {
return wrapper_CUDA_hardsigmoid_(self);
}
at::Tensor hardsigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CUDA_hardsigmoid_backward(grad_output, self);
}
at::Tensor & hardsigmoid_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CUDA_hardsigmoid_backward_out_grad_input(grad_output, self, grad_input);
}
at::Tensor & hardsigmoid_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
return wrapper_CUDA_hardsigmoid_backward_out_grad_input(grad_output, self, grad_input);
}
at::Tensor hardtanh(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CUDA__hardtanh(self, min_val, max_val);
}
at::Tensor & hardtanh_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CUDA_out_hardtanh_out(self, min_val, max_val, out);
}
at::Tensor & hardtanh_outf(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & out) {
return wrapper_CUDA_out_hardtanh_out(self, min_val, max_val, out);
}
at::Tensor & hardtanh_(at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CUDA__hardtanh_(self, min_val, max_val);
}
at::Tensor hardtanh_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CUDA__hardtanh_backward(grad_output, self, min_val, max_val);
}
at::Tensor & hardtanh_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CUDA_grad_input_hardtanh_backward_out(grad_output, self, min_val, max_val, grad_input);
}
at::Tensor & hardtanh_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_hardtanh_backward_out(grad_output, self, min_val, max_val, grad_input);
}
at::Tensor hardswish(const at::Tensor & self) {
return wrapper_CUDA__hardswish(self);
}
at::Tensor & hardswish_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_out_hardswish_out(self, out);
}
at::Tensor & hardswish_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_out_hardswish_out(self, out);
}
at::Tensor & hardswish_(at::Tensor & self) {
return wrapper_CUDA__hardswish_(self);
}
at::Tensor hardswish_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CUDA__hardswish_backward(grad_output, self);
}
at::Tensor leaky_relu(const at::Tensor & self, const at::Scalar & negative_slope) {
return wrapper_CUDA_leaky_relu(self, negative_slope);
}
at::Tensor & leaky_relu_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & negative_slope) {
return wrapper_CUDA_leaky_relu_out_out(self, negative_slope, out);
}
at::Tensor & leaky_relu_outf(const at::Tensor & self, const at::Scalar & negative_slope, at::Tensor & out) {
return wrapper_CUDA_leaky_relu_out_out(self, negative_slope, out);
}
at::Tensor & leaky_relu_(at::Tensor & self, const at::Scalar & negative_slope) {
return wrapper_CUDA_leaky_relu_(self, negative_slope);
}
at::Tensor leaky_relu_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
return wrapper_CUDA_leaky_relu_backward(grad_output, self, negative_slope, self_is_result);
}
at::Tensor & leaky_relu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
return wrapper_CUDA_leaky_relu_backward_out_grad_input(grad_output, self, negative_slope, self_is_result, grad_input);
}
at::Tensor & leaky_relu_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result, at::Tensor & grad_input) {
return wrapper_CUDA_leaky_relu_backward_out_grad_input(grad_output, self, negative_slope, self_is_result, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> log_sigmoid_forward(const at::Tensor & self) {
return wrapper_CUDA__log_sigmoid_forward(self);
}
::std::tuple<at::Tensor &,at::Tensor &> log_sigmoid_forward_out(at::Tensor & output, at::Tensor & buffer, const at::Tensor & self) {
return wrapper_CUDA_output_log_sigmoid_forward_out(self, output, buffer);
}
::std::tuple<at::Tensor &,at::Tensor &> log_sigmoid_forward_outf(const at::Tensor & self, at::Tensor & output, at::Tensor & buffer) {
return wrapper_CUDA_output_log_sigmoid_forward_out(self, output, buffer);
}
at::Tensor log_sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer) {
return wrapper_CUDA__log_sigmoid_backward(grad_output, self, buffer);
}
at::Tensor & log_sigmoid_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer) {
return wrapper_CUDA_grad_input_log_sigmoid_backward_out(grad_output, self, buffer, grad_input);
}
at::Tensor & log_sigmoid_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_log_sigmoid_backward_out(grad_output, self, buffer, grad_input);
}
at::Tensor rrelu_with_noise(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
return wrapper_CUDA__rrelu_with_noise(self, noise, lower, upper, training, generator);
}
at::Tensor & rrelu_with_noise_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
return wrapper_CUDA_out_rrelu_with_noise_out(self, noise, lower, upper, training, generator, out);
}
at::Tensor & rrelu_with_noise_outf(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CUDA_out_rrelu_with_noise_out(self, noise, lower, upper, training, generator, out);
}
at::Tensor & rrelu_with_noise_(at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
return wrapper_CUDA__rrelu_with_noise_(self, noise, lower, upper, training, generator);
}
at::Tensor softplus(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
return wrapper_CUDA_softplus(self, beta, threshold);
}
at::Tensor & softplus_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
return wrapper_CUDA_softplus_out_out(self, beta, threshold, out);
}
at::Tensor & softplus_outf(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & out) {
return wrapper_CUDA_softplus_out_out(self, beta, threshold, out);
}
at::Tensor softplus_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
return wrapper_CUDA_softplus_backward(grad_output, self, beta, threshold);
}
at::Tensor & softplus_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
return wrapper_CUDA_softplus_backward_out_grad_input(grad_output, self, beta, threshold, grad_input);
}
at::Tensor & softplus_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & grad_input) {
return wrapper_CUDA_softplus_backward_out_grad_input(grad_output, self, beta, threshold, grad_input);
}
at::Tensor softshrink(const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CUDA_softshrink(self, lambd);
}
at::Tensor & softshrink_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CUDA_softshrink_out_out(self, lambd, out);
}
at::Tensor & softshrink_outf(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
return wrapper_CUDA_softshrink_out_out(self, lambd, out);
}
at::Tensor softshrink_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CUDA_softshrink_backward(grad_output, self, lambd);
}
at::Tensor & softshrink_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CUDA_softshrink_backward_out_grad_input(grad_output, self, lambd, grad_input);
}
at::Tensor & softshrink_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
return wrapper_CUDA_softshrink_backward_out_grad_input(grad_output, self, lambd, grad_input);
}
at::Tensor & adaptive_avg_pool2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CUDA_out_adaptive_avg_pool2d_out(self, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & adaptive_avg_pool2d_outf(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out) {
return wrapper_CUDA_out_adaptive_avg_pool2d_out(self, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & adaptive_avg_pool2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size) {
return wrapper_CUDA_out_adaptive_avg_pool2d_out(self, output_size, out);
}
at::Tensor & adaptive_avg_pool2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
return wrapper_CUDA_out_adaptive_avg_pool2d_out(self, output_size, out);
}
at::Tensor _adaptive_avg_pool2d(const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CUDA___adaptive_avg_pool2d(self, c10::fromIntArrayRefSlow(output_size));
}
at::Tensor _adaptive_avg_pool2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size) {
return wrapper_CUDA___adaptive_avg_pool2d(self, output_size);
}
at::Tensor _adaptive_avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CUDA___adaptive_avg_pool2d_backward(grad_output, self);
}
at::Tensor & adaptive_avg_pool3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CUDA_out_adaptive_avg_pool3d_out(self, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & adaptive_avg_pool3d_outf(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out) {
return wrapper_CUDA_out_adaptive_avg_pool3d_out(self, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & adaptive_avg_pool3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size) {
return wrapper_CUDA_out_adaptive_avg_pool3d_out(self, output_size, out);
}
at::Tensor & adaptive_avg_pool3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
return wrapper_CUDA_out_adaptive_avg_pool3d_out(self, output_size, out);
}
at::Tensor _adaptive_avg_pool3d(const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CUDA___adaptive_avg_pool3d(self, c10::fromIntArrayRefSlow(output_size));
}
at::Tensor _adaptive_avg_pool3d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size) {
return wrapper_CUDA___adaptive_avg_pool3d(self, output_size);
}
at::Tensor & adaptive_avg_pool3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CUDA_grad_input_adaptive_avg_pool3d_backward_out(grad_output, self, grad_input);
}
at::Tensor & adaptive_avg_pool3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_adaptive_avg_pool3d_backward_out(grad_output, self, grad_input);
}
at::Tensor _adaptive_avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CUDA___adaptive_avg_pool3d_backward(grad_output, self);
}
::std::tuple<at::Tensor,at::Tensor> adaptive_max_pool2d(const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CUDA_adaptive_max_pool2d(self, output_size);
}
::std::tuple<at::Tensor &,at::Tensor &> adaptive_max_pool2d_out(at::Tensor & out, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CUDA_adaptive_max_pool2d_out_out(self, output_size, out, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> adaptive_max_pool2d_outf(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out, at::Tensor & indices) {
return wrapper_CUDA_adaptive_max_pool2d_out_out(self, output_size, out, indices);
}
at::Tensor adaptive_max_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
return wrapper_CUDA_adaptive_max_pool2d_backward(grad_output, self, indices);
}
at::Tensor & adaptive_max_pool2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
return wrapper_CUDA_adaptive_max_pool2d_backward_out_grad_input(grad_output, self, indices, grad_input);
}
at::Tensor & adaptive_max_pool2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CUDA_adaptive_max_pool2d_backward_out_grad_input(grad_output, self, indices, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> adaptive_max_pool3d(const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CUDA_adaptive_max_pool3d(self, output_size);
}
::std::tuple<at::Tensor &,at::Tensor &> adaptive_max_pool3d_out(at::Tensor & out, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CUDA_adaptive_max_pool3d_out_out(self, output_size, out, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> adaptive_max_pool3d_outf(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out, at::Tensor & indices) {
return wrapper_CUDA_adaptive_max_pool3d_out_out(self, output_size, out, indices);
}
at::Tensor adaptive_max_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
return wrapper_CUDA_adaptive_max_pool3d_backward(grad_output, self, indices);
}
at::Tensor & adaptive_max_pool3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
return wrapper_CUDA_adaptive_max_pool3d_backward_out_grad_input(grad_output, self, indices, grad_input);
}
at::Tensor & adaptive_max_pool3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CUDA_adaptive_max_pool3d_backward_out_grad_input(grad_output, self, indices, grad_input);
}
at::Tensor avg_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CUDA_avg_pool2d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
at::Tensor & avg_pool2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CUDA_avg_pool2d_out_out(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}
at::Tensor & avg_pool2d_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
return wrapper_CUDA_avg_pool2d_out_out(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}
at::Tensor avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CUDA_avg_pool2d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
at::Tensor & avg_pool2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CUDA_avg_pool2d_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}
at::Tensor & avg_pool2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
return wrapper_CUDA_avg_pool2d_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}
at::Tensor avg_pool3d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CUDA_avg_pool3d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
at::Tensor & avg_pool3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CUDA_avg_pool3d_out_out(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}
at::Tensor & avg_pool3d_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
return wrapper_CUDA_avg_pool3d_out_out(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}
at::Tensor avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CUDA_avg_pool3d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
at::Tensor & avg_pool3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CUDA_avg_pool3d_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}
at::Tensor & avg_pool3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
return wrapper_CUDA_avg_pool3d_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> fractional_max_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
return wrapper_CUDA_fractional_max_pool2d(self, kernel_size, output_size, random_samples);
}
::std::tuple<at::Tensor &,at::Tensor &> fractional_max_pool2d_out(at::Tensor & output, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
return wrapper_CUDA_fractional_max_pool2d_out_output(self, kernel_size, output_size, random_samples, output, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> fractional_max_pool2d_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples, at::Tensor & output, at::Tensor & indices) {
return wrapper_CUDA_fractional_max_pool2d_out_output(self, kernel_size, output_size, random_samples, output, indices);
}
at::Tensor fractional_max_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
return wrapper_CUDA_fractional_max_pool2d_backward(grad_output, self, kernel_size, output_size, indices);
}
at::Tensor & fractional_max_pool2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
return wrapper_CUDA_fractional_max_pool2d_backward_out_grad_input(grad_output, self, kernel_size, output_size, indices, grad_input);
}
at::Tensor & fractional_max_pool2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CUDA_fractional_max_pool2d_backward_out_grad_input(grad_output, self, kernel_size, output_size, indices, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> fractional_max_pool3d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
return wrapper_CUDA_fractional_max_pool3d(self, kernel_size, output_size, random_samples);
}
::std::tuple<at::Tensor &,at::Tensor &> fractional_max_pool3d_out(at::Tensor & output, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
return wrapper_CUDA_fractional_max_pool3d_out_output(self, kernel_size, output_size, random_samples, output, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> fractional_max_pool3d_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples, at::Tensor & output, at::Tensor & indices) {
return wrapper_CUDA_fractional_max_pool3d_out_output(self, kernel_size, output_size, random_samples, output, indices);
}
at::Tensor fractional_max_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
return wrapper_CUDA__fractional_max_pool3d_backward(grad_output, self, kernel_size, output_size, indices);
}
at::Tensor & fractional_max_pool3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
return wrapper_CUDA_grad_input_fractional_max_pool3d_backward_out(grad_output, self, kernel_size, output_size, indices, grad_input);
}
at::Tensor & fractional_max_pool3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_fractional_max_pool3d_backward_out(grad_output, self, kernel_size, output_size, indices, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> max_pool2d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
return wrapper_CUDA_max_pool2d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
}
::std::tuple<at::Tensor &,at::Tensor &> max_pool2d_with_indices_out(at::Tensor & out, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
return wrapper_CUDA_max_pool2d_with_indices_out_out(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> max_pool2d_with_indices_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
return wrapper_CUDA_max_pool2d_with_indices_out_out(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
at::Tensor max_pool2d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
return wrapper_CUDA_max_pool2d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}
at::Tensor & max_pool2d_with_indices_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
return wrapper_CUDA_max_pool2d_with_indices_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
at::Tensor & max_pool2d_with_indices_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CUDA_max_pool2d_with_indices_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> max_pool3d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
return wrapper_CUDA__max_pool3d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
}
::std::tuple<at::Tensor &,at::Tensor &> max_pool3d_with_indices_out(at::Tensor & out, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
return wrapper_CUDA_out_max_pool3d_with_indices_out(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> max_pool3d_with_indices_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
return wrapper_CUDA_out_max_pool3d_with_indices_out(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
at::Tensor max_pool3d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
return wrapper_CUDA__max_pool3d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}
at::Tensor & max_pool3d_with_indices_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
return wrapper_CUDA_grad_input_max_pool3d_with_indices_backward_out(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
at::Tensor & max_pool3d_with_indices_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_max_pool3d_with_indices_backward_out(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
at::Tensor max_unpool2d(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size) {
return wrapper_CUDA__max_unpool2d(self, indices, c10::fromIntArrayRefSlow(output_size));
}
at::Tensor max_unpool2d_symint(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size) {
return wrapper_CUDA__max_unpool2d(self, indices, output_size);
}
at::Tensor & max_unpool2d_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size) {
return wrapper_CUDA_out_max_unpool2d_out(self, indices, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & max_unpool2d_outf(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::Tensor & out) {
return wrapper_CUDA_out_max_unpool2d_out(self, indices, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & max_unpool2d_symint_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size) {
return wrapper_CUDA_out_max_unpool2d_out(self, indices, output_size, out);
}
at::Tensor & max_unpool2d_symint_outf(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::Tensor & out) {
return wrapper_CUDA_out_max_unpool2d_out(self, indices, output_size, out);
}
at::Tensor max_unpool3d(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CUDA__max_unpool3d(self, indices, c10::fromIntArrayRefSlow(output_size), stride, padding);
}
at::Tensor max_unpool3d_symint(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CUDA__max_unpool3d(self, indices, output_size, stride, padding);
}
at::Tensor & max_unpool3d_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CUDA_out_max_unpool3d_out(self, indices, c10::fromIntArrayRefSlow(output_size), stride, padding, out);
}
at::Tensor & max_unpool3d_outf(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_out_max_unpool3d_out(self, indices, c10::fromIntArrayRefSlow(output_size), stride, padding, out);
}
at::Tensor & max_unpool3d_symint_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CUDA_out_max_unpool3d_out(self, indices, output_size, stride, padding, out);
}
at::Tensor & max_unpool3d_symint_outf(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_out_max_unpool3d_out(self, indices, output_size, stride, padding, out);
}
at::Tensor reflection_pad1d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_reflection_pad1d(self, padding);
}
at::Tensor reflection_pad1d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_reflection_pad1d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & reflection_pad1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_reflection_pad1d_out_out(self, padding, out);
}
at::Tensor & reflection_pad1d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_reflection_pad1d_out_out(self, padding, out);
}
at::Tensor & reflection_pad1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_reflection_pad1d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & reflection_pad1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_reflection_pad1d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor reflection_pad1d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_reflection_pad1d_backward(grad_output, self, padding);
}
at::Tensor reflection_pad1d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_reflection_pad1d_backward(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & reflection_pad1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_reflection_pad1d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad1d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_reflection_pad1d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_reflection_pad1d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor & reflection_pad1d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_reflection_pad1d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor reflection_pad2d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA__reflection_pad2d(self, c10::fromIntArrayRefSlow(padding));
}
at::Tensor reflection_pad2d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA__reflection_pad2d(self, padding);
}
at::Tensor & reflection_pad2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_out_reflection_pad2d_out(self, c10::fromIntArrayRefSlow(padding), out);
}
at::Tensor & reflection_pad2d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_out_reflection_pad2d_out(self, c10::fromIntArrayRefSlow(padding), out);
}
at::Tensor & reflection_pad2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_out_reflection_pad2d_out(self, padding, out);
}
at::Tensor & reflection_pad2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_out_reflection_pad2d_out(self, padding, out);
}
at::Tensor reflection_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA__reflection_pad2d_backward(grad_output, self, c10::fromIntArrayRefSlow(padding));
}
at::Tensor reflection_pad2d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA__reflection_pad2d_backward(grad_output, self, padding);
}
at::Tensor & reflection_pad2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_grad_input_reflection_pad2d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & reflection_pad2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_reflection_pad2d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & reflection_pad2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_grad_input_reflection_pad2d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad2d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_reflection_pad2d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor reflection_pad3d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_reflection_pad3d(self, padding);
}
at::Tensor reflection_pad3d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_reflection_pad3d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & reflection_pad3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_reflection_pad3d_out_out(self, padding, out);
}
at::Tensor & reflection_pad3d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_reflection_pad3d_out_out(self, padding, out);
}
at::Tensor & reflection_pad3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_reflection_pad3d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & reflection_pad3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_reflection_pad3d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor reflection_pad3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_reflection_pad3d_backward(grad_output, self, padding);
}
at::Tensor reflection_pad3d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_reflection_pad3d_backward(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & reflection_pad3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_reflection_pad3d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_reflection_pad3d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_reflection_pad3d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor & reflection_pad3d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_reflection_pad3d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor replication_pad1d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_replication_pad1d(self, padding);
}
at::Tensor replication_pad1d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_replication_pad1d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & replication_pad1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_replication_pad1d_out_out(self, padding, out);
}
at::Tensor & replication_pad1d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_replication_pad1d_out_out(self, padding, out);
}
at::Tensor & replication_pad1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_replication_pad1d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & replication_pad1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_replication_pad1d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor replication_pad1d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_replication_pad1d_backward(grad_output, self, padding);
}
at::Tensor replication_pad1d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_replication_pad1d_backward(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & replication_pad1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_replication_pad1d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & replication_pad1d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_replication_pad1d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & replication_pad1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_replication_pad1d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor & replication_pad1d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_replication_pad1d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor replication_pad2d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_replication_pad2d(self, padding);
}
at::Tensor replication_pad2d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_replication_pad2d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & replication_pad2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_replication_pad2d_out_out(self, padding, out);
}
at::Tensor & replication_pad2d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_replication_pad2d_out_out(self, padding, out);
}
at::Tensor & replication_pad2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_replication_pad2d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & replication_pad2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_replication_pad2d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor replication_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA__replication_pad2d_backward(grad_output, self, c10::fromIntArrayRefSlow(padding));
}
at::Tensor replication_pad2d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA__replication_pad2d_backward(grad_output, self, padding);
}
at::Tensor & replication_pad2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_grad_input_replication_pad2d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & replication_pad2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_replication_pad2d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & replication_pad2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_grad_input_replication_pad2d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor & replication_pad2d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_replication_pad2d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor replication_pad3d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_replication_pad3d(self, padding);
}
at::Tensor replication_pad3d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_replication_pad3d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & replication_pad3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_replication_pad3d_out_out(self, padding, out);
}
at::Tensor & replication_pad3d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_replication_pad3d_out_out(self, padding, out);
}
at::Tensor & replication_pad3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_replication_pad3d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & replication_pad3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CUDA_replication_pad3d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor replication_pad3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA__replication_pad3d_backward(grad_output, self, c10::fromIntArrayRefSlow(padding));
}
at::Tensor replication_pad3d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA__replication_pad3d_backward(grad_output, self, padding);
}
at::Tensor & replication_pad3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CUDA_grad_input_replication_pad3d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & replication_pad3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_replication_pad3d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & replication_pad3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CUDA_grad_input_replication_pad3d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor & replication_pad3d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CUDA_grad_input_replication_pad3d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor upsample_linear1d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CUDA_upsample_linear1d(self, output_size, align_corners, scales);
}
at::Tensor upsample_linear1d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CUDA_upsample_linear1d(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales);
}
at::Tensor & upsample_linear1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CUDA_upsample_linear1d_out_out(self, output_size, align_corners, scales, out);
}
at::Tensor & upsample_linear1d_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CUDA_upsample_linear1d_out_out(self, output_size, align_corners, scales, out);
}
at::Tensor & upsample_linear1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CUDA_upsample_linear1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales, out);
}
at::Tensor & upsample_linear1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CUDA_upsample_linear1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales, out);
}
at::Tensor upsample_linear1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CUDA_upsample_linear1d_backward(grad_output, output_size, input_size, align_corners, scales);
}
at::Tensor upsample_linear1d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CUDA_upsample_linear1d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales);
}
at::Tensor & upsample_linear1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CUDA_upsample_linear1d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales, grad_input);
}
at::Tensor & upsample_linear1d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_linear1d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales, grad_input);
}
at::Tensor & upsample_linear1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CUDA_upsample_linear1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales, grad_input);
}
at::Tensor & upsample_linear1d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_linear1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales, grad_input);
}
at::Tensor upsample_bilinear2d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bilinear2d(self, output_size, align_corners, scales_h, scales_w);
}
at::Tensor upsample_bilinear2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bilinear2d(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w);
}
at::Tensor & upsample_bilinear2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bilinear2d_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bilinear2d_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_bilinear2d_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bilinear2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bilinear2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bilinear2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_bilinear2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor upsample_bilinear2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bilinear2d_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}
at::Tensor upsample_bilinear2d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bilinear2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w);
}
at::Tensor & upsample_bilinear2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bilinear2d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bilinear2d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_bilinear2d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bilinear2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bilinear2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bilinear2d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_bilinear2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor _upsample_bilinear2d_aa(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bilinear2d_aa(self, output_size, align_corners, scales_h, scales_w);
}
at::Tensor _upsample_bilinear2d_aa_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bilinear2d_aa(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w);
}
at::Tensor & _upsample_bilinear2d_aa_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bilinear2d_aa_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bilinear2d_aa_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA__upsample_bilinear2d_aa_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bilinear2d_aa_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bilinear2d_aa_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bilinear2d_aa_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA__upsample_bilinear2d_aa_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor _upsample_bilinear2d_aa_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bilinear2d_aa_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}
at::Tensor _upsample_bilinear2d_aa_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bilinear2d_aa_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w);
}
at::Tensor & _upsample_bilinear2d_aa_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bilinear2d_aa_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bilinear2d_aa_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_bilinear2d_aa_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bilinear2d_aa_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bilinear2d_aa_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bilinear2d_aa_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_bilinear2d_aa_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor upsample_bicubic2d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bicubic2d(self, output_size, align_corners, scales_h, scales_w);
}
at::Tensor upsample_bicubic2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bicubic2d(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w);
}
at::Tensor & upsample_bicubic2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bicubic2d_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bicubic2d_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_bicubic2d_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bicubic2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bicubic2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bicubic2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_bicubic2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor upsample_bicubic2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bicubic2d_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}
at::Tensor upsample_bicubic2d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bicubic2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w);
}
at::Tensor & upsample_bicubic2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bicubic2d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bicubic2d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_bicubic2d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bicubic2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_bicubic2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bicubic2d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_bicubic2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor _upsample_bicubic2d_aa(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bicubic2d_aa(self, output_size, align_corners, scales_h, scales_w);
}
at::Tensor _upsample_bicubic2d_aa_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bicubic2d_aa(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w);
}
at::Tensor & _upsample_bicubic2d_aa_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bicubic2d_aa_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bicubic2d_aa_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA__upsample_bicubic2d_aa_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bicubic2d_aa_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bicubic2d_aa_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bicubic2d_aa_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA__upsample_bicubic2d_aa_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor _upsample_bicubic2d_aa_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bicubic2d_aa_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}
at::Tensor _upsample_bicubic2d_aa_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bicubic2d_aa_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w);
}
at::Tensor & _upsample_bicubic2d_aa_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bicubic2d_aa_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bicubic2d_aa_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_bicubic2d_aa_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bicubic2d_aa_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_bicubic2d_aa_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bicubic2d_aa_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_bicubic2d_aa_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor upsample_trilinear3d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_trilinear3d(self, output_size, align_corners, scales_d, scales_h, scales_w);
}
at::Tensor upsample_trilinear3d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_trilinear3d(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_d, scales_h, scales_w);
}
at::Tensor & upsample_trilinear3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_trilinear3d_out_out(self, output_size, align_corners, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_trilinear3d_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_trilinear3d_out_out(self, output_size, align_corners, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_trilinear3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_trilinear3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_trilinear3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_trilinear3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_d, scales_h, scales_w, out);
}
at::Tensor upsample_trilinear3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_trilinear3d_backward(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w);
}
at::Tensor upsample_trilinear3d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_trilinear3d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_d, scales_h, scales_w);
}
at::Tensor & upsample_trilinear3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_trilinear3d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_trilinear3d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_trilinear3d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_trilinear3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_trilinear3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_trilinear3d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_trilinear3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor upsample_nearest1d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CUDA_upsample_nearest1d(self, output_size, scales);
}
at::Tensor upsample_nearest1d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CUDA_upsample_nearest1d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales);
}
at::Tensor & upsample_nearest1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CUDA_upsample_nearest1d_out_out(self, output_size, scales, out);
}
at::Tensor & upsample_nearest1d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CUDA_upsample_nearest1d_out_out(self, output_size, scales, out);
}
at::Tensor & upsample_nearest1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CUDA_upsample_nearest1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales, out);
}
at::Tensor & upsample_nearest1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CUDA_upsample_nearest1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales, out);
}
at::Tensor _upsample_nearest_exact1d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CUDA__upsample_nearest_exact1d(self, output_size, scales);
}
at::Tensor _upsample_nearest_exact1d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CUDA__upsample_nearest_exact1d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales);
}
at::Tensor & _upsample_nearest_exact1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CUDA__upsample_nearest_exact1d_out_out(self, output_size, scales, out);
}
at::Tensor & _upsample_nearest_exact1d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CUDA__upsample_nearest_exact1d_out_out(self, output_size, scales, out);
}
at::Tensor & _upsample_nearest_exact1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CUDA__upsample_nearest_exact1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales, out);
}
at::Tensor & _upsample_nearest_exact1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CUDA__upsample_nearest_exact1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales, out);
}
at::Tensor upsample_nearest1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CUDA_upsample_nearest1d_backward(grad_output, output_size, input_size, scales);
}
at::Tensor upsample_nearest1d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CUDA_upsample_nearest1d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales);
}
at::Tensor & upsample_nearest1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CUDA_upsample_nearest1d_backward_out_grad_input(grad_output, output_size, input_size, scales, grad_input);
}
at::Tensor & upsample_nearest1d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_nearest1d_backward_out_grad_input(grad_output, output_size, input_size, scales, grad_input);
}
at::Tensor & upsample_nearest1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CUDA_upsample_nearest1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales, grad_input);
}
at::Tensor & upsample_nearest1d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_nearest1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales, grad_input);
}
at::Tensor _upsample_nearest_exact1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CUDA__upsample_nearest_exact1d_backward(grad_output, output_size, input_size, scales);
}
at::Tensor _upsample_nearest_exact1d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CUDA__upsample_nearest_exact1d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales);
}
at::Tensor & _upsample_nearest_exact1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CUDA__upsample_nearest_exact1d_backward_out_grad_input(grad_output, output_size, input_size, scales, grad_input);
}
at::Tensor & _upsample_nearest_exact1d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_nearest_exact1d_backward_out_grad_input(grad_output, output_size, input_size, scales, grad_input);
}
at::Tensor & _upsample_nearest_exact1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CUDA__upsample_nearest_exact1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales, grad_input);
}
at::Tensor & _upsample_nearest_exact1d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_nearest_exact1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales, grad_input);
}
at::Tensor upsample_nearest2d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest2d(self, output_size, scales_h, scales_w);
}
at::Tensor upsample_nearest2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest2d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w);
}
at::Tensor & upsample_nearest2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest2d_out_out(self, output_size, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest2d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_nearest2d_out_out(self, output_size, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w, out);
}
at::Tensor & upsample_nearest2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_nearest2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w, out);
}
at::Tensor _upsample_nearest_exact2d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact2d(self, output_size, scales_h, scales_w);
}
at::Tensor _upsample_nearest_exact2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact2d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w);
}
at::Tensor & _upsample_nearest_exact2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact2d_out_out(self, output_size, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact2d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA__upsample_nearest_exact2d_out_out(self, output_size, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA__upsample_nearest_exact2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w, out);
}
at::Tensor upsample_nearest2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest2d_backward(grad_output, output_size, input_size, scales_h, scales_w);
}
at::Tensor upsample_nearest2d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w);
}
at::Tensor & upsample_nearest2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest2d_backward_out_grad_input(grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest2d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_nearest2d_backward_out_grad_input(grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest2d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_nearest2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w, grad_input);
}
at::Tensor _upsample_nearest_exact2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact2d_backward(grad_output, output_size, input_size, scales_h, scales_w);
}
at::Tensor _upsample_nearest_exact2d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w);
}
at::Tensor & _upsample_nearest_exact2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact2d_backward_out_grad_input(grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact2d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_nearest_exact2d_backward_out_grad_input(grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact2d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_nearest_exact2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w, grad_input);
}
at::Tensor upsample_nearest3d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest3d(self, output_size, scales_d, scales_h, scales_w);
}
at::Tensor upsample_nearest3d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest3d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w);
}
at::Tensor & upsample_nearest3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest3d_out_out(self, output_size, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest3d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_nearest3d_out_out(self, output_size, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA_upsample_nearest3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w, out);
}
at::Tensor _upsample_nearest_exact3d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact3d(self, output_size, scales_d, scales_h, scales_w);
}
at::Tensor _upsample_nearest_exact3d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact3d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w);
}
at::Tensor & _upsample_nearest_exact3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact3d_out_out(self, output_size, scales_d, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact3d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA__upsample_nearest_exact3d_out_out(self, output_size, scales_d, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CUDA__upsample_nearest_exact3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w, out);
}
at::Tensor upsample_nearest3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest3d_backward(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
}
at::Tensor upsample_nearest3d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest3d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w);
}
at::Tensor & upsample_nearest3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest3d_backward_out_grad_input(grad_output, output_size, input_size, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest3d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_nearest3d_backward_out_grad_input(grad_output, output_size, input_size, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA_upsample_nearest3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest3d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA_upsample_nearest3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w, grad_input);
}
at::Tensor _upsample_nearest_exact3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact3d_backward(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
}
at::Tensor _upsample_nearest_exact3d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact3d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w);
}
at::Tensor & _upsample_nearest_exact3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact3d_backward_out_grad_input(grad_output, output_size, input_size, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact3d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_nearest_exact3d_backward_out_grad_input(grad_output, output_size, input_size, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CUDA__upsample_nearest_exact3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact3d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CUDA__upsample_nearest_exact3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w, grad_input);
}
at::Tensor sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & output) {
return wrapper_CUDA_sigmoid_backward(grad_output, output);
}
at::Tensor & sigmoid_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & output) {
return wrapper_CUDA_sigmoid_backward_out_grad_input(grad_output, output, grad_input);
}
at::Tensor & sigmoid_backward_outf(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
return wrapper_CUDA_sigmoid_backward_out_grad_input(grad_output, output, grad_input);
}
at::Tensor logit_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps) {
return wrapper_CUDA_logit_backward(grad_output, self, eps);
}
at::Tensor & logit_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps) {
return wrapper_CUDA_logit_backward_out_grad_input(grad_output, self, eps, grad_input);
}
at::Tensor & logit_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps, at::Tensor & grad_input) {
return wrapper_CUDA_logit_backward_out_grad_input(grad_output, self, eps, grad_input);
}
at::Tensor tanh_backward(const at::Tensor & grad_output, const at::Tensor & output) {
return wrapper_CUDA_tanh_backward(grad_output, output);
}
at::Tensor & tanh_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & output) {
return wrapper_CUDA_tanh_backward_out_grad_input(grad_output, output, grad_input);
}
at::Tensor & tanh_backward_outf(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
return wrapper_CUDA_tanh_backward_out_grad_input(grad_output, output, grad_input);
}
at::Tensor slow_conv_transpose2d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
return wrapper_CUDA_slow_conv_transpose2d(self, weight, kernel_size, bias, stride, padding, output_padding, dilation);
}
at::Tensor slow_conv_transpose2d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
return wrapper_CUDA_slow_conv_transpose2d(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
at::Tensor & slow_conv_transpose2d_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
return wrapper_CUDA_slow_conv_transpose2d_out_out(self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}
at::Tensor & slow_conv_transpose2d_outf(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation, at::Tensor & out) {
return wrapper_CUDA_slow_conv_transpose2d_out_out(self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}
at::Tensor & slow_conv_transpose2d_symint_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
return wrapper_CUDA_slow_conv_transpose2d_out_out(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation), out);
}
at::Tensor & slow_conv_transpose2d_symint_outf(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
return wrapper_CUDA_slow_conv_transpose2d_out_out(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation), out);
}
at::Tensor slow_conv_transpose3d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
return wrapper_CUDA__slow_conv_transpose3d(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(output_padding), c10::fromIntArrayRefSlow(dilation));
}
at::Tensor slow_conv_transpose3d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
return wrapper_CUDA__slow_conv_transpose3d(self, weight, kernel_size, bias, stride, padding, output_padding, dilation);
}
at::Tensor & slow_conv_transpose3d_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
return wrapper_CUDA_out_slow_conv_transpose3d_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(output_padding), c10::fromIntArrayRefSlow(dilation), out);
}
at::Tensor & slow_conv_transpose3d_outf(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation, at::Tensor & out) {
return wrapper_CUDA_out_slow_conv_transpose3d_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(output_padding), c10::fromIntArrayRefSlow(dilation), out);
}
at::Tensor & slow_conv_transpose3d_symint_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
return wrapper_CUDA_out_slow_conv_transpose3d_out(self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}
at::Tensor & slow_conv_transpose3d_symint_outf(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
return wrapper_CUDA_out_slow_conv_transpose3d_out(self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}
at::Tensor _slow_conv2d_forward(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CUDA___slow_conv2d_forward(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding));
}
at::Tensor _slow_conv2d_forward_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
return wrapper_CUDA___slow_conv2d_forward(self, weight, kernel_size, bias, stride, padding);
}
at::Tensor & _slow_conv2d_forward_out(at::Tensor & output, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CUDA_output__slow_conv2d_forward_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), output);
}
at::Tensor & _slow_conv2d_forward_outf(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & output) {
return wrapper_CUDA_output__slow_conv2d_forward_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), output);
}
at::Tensor & _slow_conv2d_forward_symint_out(at::Tensor & output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
return wrapper_CUDA_output__slow_conv2d_forward_out(self, weight, kernel_size, bias, stride, padding, output);
}
at::Tensor & _slow_conv2d_forward_symint_outf(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
return wrapper_CUDA_output__slow_conv2d_forward_out(self, weight, kernel_size, bias, stride, padding, output);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _slow_conv2d_backward_out(at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CUDA_grad_input__slow_conv2d_backward_out(grad_output, self, weight, c10::fromIntArrayRefSlow(kernel_size), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), grad_input, grad_weight, grad_bias);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _slow_conv2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias) {
return wrapper_CUDA_grad_input__slow_conv2d_backward_out(grad_output, self, weight, c10::fromIntArrayRefSlow(kernel_size), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), grad_input, grad_weight, grad_bias);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _slow_conv2d_backward_symint_out(at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
return wrapper_CUDA_grad_input__slow_conv2d_backward_out(grad_output, self, weight, kernel_size, stride, padding, grad_input, grad_weight, grad_bias);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _slow_conv2d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias) {
return wrapper_CUDA_grad_input__slow_conv2d_backward_out(grad_output, self, weight, kernel_size, stride, padding, grad_input, grad_weight, grad_bias);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _slow_conv2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, ::std::array<bool,3> output_mask) {
return wrapper_CUDA_output_mask__slow_conv2d_backward(grad_output, self, weight, c10::fromIntArrayRefSlow(kernel_size), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _slow_conv2d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, ::std::array<bool,3> output_mask) {
return wrapper_CUDA_output_mask__slow_conv2d_backward(grad_output, self, weight, kernel_size, stride, padding, output_mask);
}
at::Tensor _conv_depthwise2d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation) {
return wrapper_CUDA___conv_depthwise2d(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation));
}
at::Tensor _conv_depthwise2d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
return wrapper_CUDA___conv_depthwise2d(self, weight, kernel_size, bias, stride, padding, dilation);
}
const at::Tensor & _conv_depthwise2d_out(const at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation) {
return wrapper_CUDA_out__conv_depthwise2d_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation), out);
}
const at::Tensor & _conv_depthwise2d_outf(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, const at::Tensor & out) {
return wrapper_CUDA_out__conv_depthwise2d_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation), out);
}
const at::Tensor & _conv_depthwise2d_symint_out(const at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
return wrapper_CUDA_out__conv_depthwise2d_out(self, weight, kernel_size, bias, stride, padding, dilation, out);
}
const at::Tensor & _conv_depthwise2d_symint_outf(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation, const at::Tensor & out) {
return wrapper_CUDA_out__conv_depthwise2d_out(self, weight, kernel_size, bias, stride, padding, dilation, out);
}
at::Tensor conv_depthwise3d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation) {
return wrapper_CUDA__conv_depthwise3d(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation));
}
at::Tensor conv_depthwise3d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
return wrapper_CUDA__conv_depthwise3d(self, weight, kernel_size, bias, stride, padding, dilation);
}
at::Tensor slow_conv_dilated2d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation) {
return wrapper_CUDA__slow_conv_dilated2d(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation));
}
at::Tensor slow_conv_dilated2d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
return wrapper_CUDA__slow_conv_dilated2d(self, weight, kernel_size, bias, stride, padding, dilation);
}
at::Tensor slow_conv_dilated3d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation) {
return wrapper_CUDA__slow_conv_dilated3d(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation));
}
at::Tensor slow_conv_dilated3d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
return wrapper_CUDA__slow_conv_dilated3d(self, weight, kernel_size, bias, stride, padding, dilation);
}
at::Tensor col2im(const at::Tensor & self, at::IntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CUDA__col2im(self, c10::fromIntArrayRefSlow(output_size), kernel_size, dilation, padding, stride);
}
at::Tensor col2im_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CUDA__col2im(self, output_size, kernel_size, dilation, padding, stride);
}
at::Tensor & col2im_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CUDA_out_col2im_out(self, c10::fromIntArrayRefSlow(output_size), kernel_size, dilation, padding, stride, out);
}
at::Tensor & col2im_outf(const at::Tensor & self, at::IntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
return wrapper_CUDA_out_col2im_out(self, c10::fromIntArrayRefSlow(output_size), kernel_size, dilation, padding, stride, out);
}
at::Tensor & col2im_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CUDA_out_col2im_out(self, output_size, kernel_size, dilation, padding, stride, out);
}
at::Tensor & col2im_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
return wrapper_CUDA_out_col2im_out(self, output_size, kernel_size, dilation, padding, stride, out);
}
at::Tensor im2col(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CUDA__im2col(self, kernel_size, dilation, padding, stride);
}
at::Tensor & im2col_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CUDA_out_im2col_out(self, kernel_size, dilation, padding, stride, out);
}
at::Tensor & im2col_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
return wrapper_CUDA_out_im2col_out(self, kernel_size, dilation, padding, stride, out);
}
void record_stream(at::Tensor & self, at::Stream s) {
return wrapper_CUDA__record_stream(self, s);
}
at::Tensor isposinf(const at::Tensor & self) {
return wrapper_CUDA_isposinf(self);
}
at::Tensor & isposinf_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_isposinf_out_out(self, out);
}
at::Tensor & isposinf_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_isposinf_out_out(self, out);
}
at::Tensor isneginf(const at::Tensor & self) {
return wrapper_CUDA_isneginf(self);
}
at::Tensor & isneginf_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_isneginf_out_out(self, out);
}
at::Tensor & isneginf_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_isneginf_out_out(self, out);
}
at::Tensor special_entr(const at::Tensor & self) {
return wrapper_CUDA_special_entr(self);
}
at::Tensor & special_entr_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_entr_out_out(self, out);
}
at::Tensor & special_entr_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_entr_out_out(self, out);
}
at::Tensor special_ndtri(const at::Tensor & self) {
return wrapper_CUDA_special_ndtri(self);
}
at::Tensor & special_ndtri_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_ndtri_out_out(self, out);
}
at::Tensor & special_ndtri_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_ndtri_out_out(self, out);
}
at::Tensor special_log_ndtr(const at::Tensor & self) {
return wrapper_CUDA_special_log_ndtr(self);
}
at::Tensor & special_log_ndtr_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_log_ndtr_out_out(self, out);
}
at::Tensor & special_log_ndtr_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_log_ndtr_out_out(self, out);
}
at::Tensor special_erfcx(const at::Tensor & self) {
return wrapper_CUDA_special_erfcx(self);
}
at::Tensor & special_erfcx_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_erfcx_out_out(self, out);
}
at::Tensor & special_erfcx_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_erfcx_out_out(self, out);
}
at::Tensor special_xlog1py(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_special_xlog1py(self, other);
}
at::Tensor & special_xlog1py_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_special_xlog1py_out_out(self, other, out);
}
at::Tensor & special_xlog1py_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_special_xlog1py_out_out(self, other, out);
}
at::Tensor special_zeta(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_special_zeta(self, other);
}
at::Tensor & special_zeta_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CUDA_special_zeta_out_out(self, other, out);
}
at::Tensor & special_zeta_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CUDA_special_zeta_out_out(self, other, out);
}
at::Tensor special_i0e(const at::Tensor & self) {
return wrapper_CUDA_special_i0e(self);
}
at::Tensor & special_i0e_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_i0e_out_out(self, out);
}
at::Tensor & special_i0e_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_i0e_out_out(self, out);
}
at::Tensor special_i1(const at::Tensor & self) {
return wrapper_CUDA_special_i1(self);
}
at::Tensor & special_i1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_i1_out_out(self, out);
}
at::Tensor & special_i1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_i1_out_out(self, out);
}
at::Tensor special_i1e(const at::Tensor & self) {
return wrapper_CUDA_special_i1e(self);
}
at::Tensor & special_i1e_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_i1e_out_out(self, out);
}
at::Tensor & special_i1e_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_i1e_out_out(self, out);
}
::std::tuple<at::Tensor,at::Tensor> linalg_cholesky_ex(const at::Tensor & self, bool upper, bool check_errors) {
return wrapper_CUDA_linalg_cholesky_ex(self, upper, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_cholesky_ex_out(at::Tensor & L, at::Tensor & info, const at::Tensor & self, bool upper, bool check_errors) {
return wrapper_CUDA_linalg_cholesky_ex_out_L(self, upper, check_errors, L, info);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_cholesky_ex_outf(const at::Tensor & self, bool upper, bool check_errors, at::Tensor & L, at::Tensor & info) {
return wrapper_CUDA_linalg_cholesky_ex_out_L(self, upper, check_errors, L, info);
}
at::Tensor linalg_cross(const at::Tensor & self, const at::Tensor & other, int64_t dim) {
return wrapper_CUDA_linalg_cross(self, other, dim);
}
at::Tensor & linalg_cross_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, int64_t dim) {
return wrapper_CUDA_linalg_cross_out_out(self, other, dim, out);
}
at::Tensor & linalg_cross_outf(const at::Tensor & self, const at::Tensor & other, int64_t dim, at::Tensor & out) {
return wrapper_CUDA_linalg_cross_out_out(self, other, dim, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_lu_factor_ex(const at::Tensor & A, bool pivot, bool check_errors) {
return wrapper_CUDA_linalg_lu_factor_ex(A, pivot, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_factor_ex_out(at::Tensor & LU, at::Tensor & pivots, at::Tensor & info, const at::Tensor & A, bool pivot, bool check_errors) {
return wrapper_CUDA_linalg_lu_factor_ex_out_out(A, pivot, check_errors, LU, pivots, info);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_factor_ex_outf(const at::Tensor & A, bool pivot, bool check_errors, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
return wrapper_CUDA_linalg_lu_factor_ex_out_out(A, pivot, check_errors, LU, pivots, info);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_lu(const at::Tensor & A, bool pivot) {
return wrapper_CUDA_linalg_lu(A, pivot);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_out(at::Tensor & P, at::Tensor & L, at::Tensor & U, const at::Tensor & A, bool pivot) {
return wrapper_CUDA_linalg_lu_out_out(A, pivot, P, L, U);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_outf(const at::Tensor & A, bool pivot, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
return wrapper_CUDA_linalg_lu_out_out(A, pivot, P, L, U);
}
at::Tensor linalg_lu_solve(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint) {
return wrapper_CUDA_linalg_lu_solve(LU, pivots, B, left, adjoint);
}
at::Tensor & linalg_lu_solve_out(at::Tensor & out, const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint) {
return wrapper_CUDA_linalg_lu_solve_out_out(LU, pivots, B, left, adjoint, out);
}
at::Tensor & linalg_lu_solve_outf(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint, at::Tensor & out) {
return wrapper_CUDA_linalg_lu_solve_out_out(LU, pivots, B, left, adjoint, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _linalg_det(const at::Tensor & A) {
return wrapper_CUDA__linalg_det(A);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_det_out(at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, const at::Tensor & A) {
return wrapper_CUDA__linalg_det_out_result(A, result, LU, pivots);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_det_outf(const at::Tensor & A, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots) {
return wrapper_CUDA__linalg_det_out_result(A, result, LU, pivots);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_ldl_factor_ex(const at::Tensor & self, bool hermitian, bool check_errors) {
return wrapper_CUDA_linalg_ldl_factor_ex(self, hermitian, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_ldl_factor_ex_out(at::Tensor & LD, at::Tensor & pivots, at::Tensor & info, const at::Tensor & self, bool hermitian, bool check_errors) {
return wrapper_CUDA_linalg_ldl_factor_ex_out_out(self, hermitian, check_errors, LD, pivots, info);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_ldl_factor_ex_outf(const at::Tensor & self, bool hermitian, bool check_errors, at::Tensor & LD, at::Tensor & pivots, at::Tensor & info) {
return wrapper_CUDA_linalg_ldl_factor_ex_out_out(self, hermitian, check_errors, LD, pivots, info);
}
at::Tensor linalg_ldl_solve(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian) {
return wrapper_CUDA_linalg_ldl_solve(LD, pivots, B, hermitian);
}
at::Tensor & linalg_ldl_solve_out(at::Tensor & out, const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian) {
return wrapper_CUDA_linalg_ldl_solve_out_out(LD, pivots, B, hermitian, out);
}
at::Tensor & linalg_ldl_solve_outf(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian, at::Tensor & out) {
return wrapper_CUDA_linalg_ldl_solve_out_out(LD, pivots, B, hermitian, out);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> linalg_lstsq_out(at::Tensor & solution, at::Tensor & residuals, at::Tensor & rank, at::Tensor & singular_values, const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver) {
return wrapper_CUDA_out_linalg_lstsq_out(self, b, rcond, driver, solution, residuals, rank, singular_values);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> linalg_lstsq_outf(const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver, at::Tensor & solution, at::Tensor & residuals, at::Tensor & rank, at::Tensor & singular_values) {
return wrapper_CUDA_out_linalg_lstsq_out(self, b, rcond, driver, solution, residuals, rank, singular_values);
}
at::Tensor linalg_matrix_exp(const at::Tensor & self) {
return wrapper_CUDA__linalg_matrix_exp(self);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _linalg_slogdet(const at::Tensor & A) {
return wrapper_CUDA__linalg_slogdet(A);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_slogdet_out(at::Tensor & sign, at::Tensor & logabsdet, at::Tensor & LU, at::Tensor & pivots, const at::Tensor & A) {
return wrapper_CUDA__linalg_slogdet_out_sign(A, sign, logabsdet, LU, pivots);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_slogdet_outf(const at::Tensor & A, at::Tensor & sign, at::Tensor & logabsdet, at::Tensor & LU, at::Tensor & pivots) {
return wrapper_CUDA__linalg_slogdet_out_sign(A, sign, logabsdet, LU, pivots);
}
::std::tuple<at::Tensor,at::Tensor> linalg_eig(const at::Tensor & self) {
return wrapper_CUDA__linalg_eig(self);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_eig_out(at::Tensor & eigenvalues, at::Tensor & eigenvectors, const at::Tensor & self) {
return wrapper_CUDA_out_linalg_eig_out(self, eigenvalues, eigenvectors);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_eig_outf(const at::Tensor & self, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
return wrapper_CUDA_out_linalg_eig_out(self, eigenvalues, eigenvectors);
}
::std::tuple<at::Tensor,at::Tensor> _linalg_eigh(const at::Tensor & A, c10::string_view UPLO, bool compute_v) {
return wrapper_CUDA__linalg_eigh(A, UPLO, compute_v);
}
::std::tuple<at::Tensor &,at::Tensor &> _linalg_eigh_out(at::Tensor & eigenvalues, at::Tensor & eigenvectors, const at::Tensor & A, c10::string_view UPLO, bool compute_v) {
return wrapper_CUDA__linalg_eigh_out_eigenvalues(A, UPLO, compute_v, eigenvalues, eigenvectors);
}
::std::tuple<at::Tensor &,at::Tensor &> _linalg_eigh_outf(const at::Tensor & A, c10::string_view UPLO, bool compute_v, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
return wrapper_CUDA__linalg_eigh_out_eigenvalues(A, UPLO, compute_v, eigenvalues, eigenvectors);
}
at::Tensor linalg_householder_product(const at::Tensor & input, const at::Tensor & tau) {
return wrapper_CUDA__linalg_householder_product(input, tau);
}
at::Tensor & linalg_householder_product_out(at::Tensor & out, const at::Tensor & input, const at::Tensor & tau) {
return wrapper_CUDA_out_linalg_householder_product_out(input, tau, out);
}
at::Tensor & linalg_householder_product_outf(const at::Tensor & input, const at::Tensor & tau, at::Tensor & out) {
return wrapper_CUDA_out_linalg_householder_product_out(input, tau, out);
}
::std::tuple<at::Tensor,at::Tensor> linalg_inv_ex(const at::Tensor & A, bool check_errors) {
return wrapper_CUDA_linalg_inv_ex(A, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_inv_ex_out(at::Tensor & inverse, at::Tensor & info, const at::Tensor & A, bool check_errors) {
return wrapper_CUDA_linalg_inv_ex_out_inverse(A, check_errors, inverse, info);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_inv_ex_outf(const at::Tensor & A, bool check_errors, at::Tensor & inverse, at::Tensor & info) {
return wrapper_CUDA_linalg_inv_ex_out_inverse(A, check_errors, inverse, info);
}
at::Tensor linalg_vector_norm(const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_linalg_vector_norm(self, ord, dim, keepdim, dtype);
}
at::Tensor & linalg_vector_norm_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CUDA_linalg_vector_norm_out_out(self, ord, dim, keepdim, dtype, out);
}
at::Tensor & linalg_vector_norm_outf(const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CUDA_linalg_vector_norm_out_out(self, ord, dim, keepdim, dtype, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _linalg_svd(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver) {
return wrapper_CUDA__linalg_svd(A, full_matrices, compute_uv, driver);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_svd_out(at::Tensor & U, at::Tensor & S, at::Tensor & Vh, const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver) {
return wrapper_CUDA__linalg_svd_out_U(A, full_matrices, compute_uv, driver, U, S, Vh);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_svd_outf(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver, at::Tensor & U, at::Tensor & S, at::Tensor & Vh) {
return wrapper_CUDA__linalg_svd_out_U(A, full_matrices, compute_uv, driver, U, S, Vh);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _linalg_solve_ex(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors) {
return wrapper_CUDA__linalg_solve_ex(A, B, left, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_solve_ex_out(at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info, const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors) {
return wrapper_CUDA__linalg_solve_ex_out_result(A, B, left, check_errors, result, LU, pivots, info);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_solve_ex_outf(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
return wrapper_CUDA__linalg_solve_ex_out_result(A, B, left, check_errors, result, LU, pivots, info);
}
::std::tuple<at::Tensor,at::Tensor> linalg_qr(const at::Tensor & A, c10::string_view mode) {
return wrapper_CUDA_linalg_qr(A, mode);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_qr_out(at::Tensor & Q, at::Tensor & R, const at::Tensor & A, c10::string_view mode) {
return wrapper_CUDA_linalg_qr_out_out(A, mode, Q, R);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_qr_outf(const at::Tensor & A, c10::string_view mode, at::Tensor & Q, at::Tensor & R) {
return wrapper_CUDA_linalg_qr_out_out(A, mode, Q, R);
}
at::Tensor segment_reduce(const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & indices, const c10::optional<at::Tensor> & offsets, int64_t axis, bool unsafe, const c10::optional<at::Scalar> & initial) {
return wrapper_CUDA__segment_reduce(data, reduce, lengths, indices, offsets, axis, unsafe, initial);
}
at::Tensor _segment_reduce_backward(const at::Tensor & grad, const at::Tensor & output, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & offsets, int64_t axis, const c10::optional<at::Scalar> & initial) {
return wrapper_CUDA___segment_reduce_backward(grad, output, data, reduce, lengths, offsets, axis, initial);
}
at::Tensor _transformer_encoder_layer_fwd(const at::Tensor & src, int64_t embed_dim, int64_t num_heads, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, bool use_gelu, bool norm_first, double eps, const at::Tensor & norm_weight_1, const at::Tensor & norm_bias_1, const at::Tensor & norm_weight_2, const at::Tensor & norm_bias_2, const at::Tensor & ffn_weight_1, const at::Tensor & ffn_bias_1, const at::Tensor & ffn_weight_2, const at::Tensor & ffn_bias_2, const c10::optional<at::Tensor> & mask, c10::optional<int64_t> mask_type) {
return wrapper_CUDA___transformer_encoder_layer_fwd(src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, mask_type);
}
::std::tuple<at::Tensor,at::Tensor> _native_multi_head_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, int64_t embed_dim, int64_t num_head, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, const c10::optional<at::Tensor> & mask, bool need_weights, bool average_attn_weights, c10::optional<int64_t> mask_type) {
return wrapper_CUDA___native_multi_head_attention(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, need_weights, average_attn_weights, mask_type);
}
int64_t _fused_sdp_choice(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & attn_mask, double dropout_p, bool is_causal, c10::optional<double> scale) {
return wrapper_CUDA___fused_sdp_choice(query, key, value, attn_mask, dropout_p, is_causal, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,c10::SymInt,c10::SymInt,at::Tensor,at::Tensor,at::Tensor> _scaled_dot_product_flash_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, double dropout_p, bool is_causal, bool return_debug_mask, c10::optional<double> scale) {
return wrapper_CUDA___scaled_dot_product_flash_attention(query, key, value, dropout_p, is_causal, return_debug_mask, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _scaled_dot_product_flash_attention_backward(const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & cum_seq_q, const at::Tensor & cum_seq_k, int64_t max_q, int64_t max_k, double dropout_p, bool is_causal, const at::Tensor & philox_seed, const at::Tensor & philox_offset, c10::optional<double> scale) {
return wrapper_CUDA___scaled_dot_product_flash_attention_backward(grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _scaled_dot_product_flash_attention_backward_symint(const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & cum_seq_q, const at::Tensor & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, const at::Tensor & philox_seed, const at::Tensor & philox_offset, c10::optional<double> scale) {
return wrapper_CUDA___scaled_dot_product_flash_attention_backward(grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _scaled_dot_product_efficient_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & attn_bias, bool compute_log_sumexp, double dropout_p, bool is_causal, c10::optional<double> scale) {
return wrapper_CUDA___scaled_dot_product_efficient_attention(query, key, value, attn_bias, compute_log_sumexp, dropout_p, is_causal, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _scaled_dot_product_efficient_attention_backward(const at::Tensor & grad_out_, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & attn_bias, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & philox_seed, const at::Tensor & philox_offset, double dropout_p, ::std::array<bool,4> grad_input_mask, bool is_causal, c10::optional<double> scale) {
return wrapper_CUDA___scaled_dot_product_efficient_attention_backward(grad_out_, query, key, value, attn_bias, out, logsumexp, philox_seed, philox_offset, dropout_p, grad_input_mask, is_causal, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _flash_attention_forward(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & cum_seq_q, const c10::optional<at::Tensor> & cum_seq_k, int64_t max_q, int64_t max_k, double dropout_p, bool is_causal, bool return_debug_mask, c10::optional<double> scale) {
return wrapper_CUDA___flash_attention_forward(query, key, value, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, return_debug_mask, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> _flash_attention_forward_symint(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & cum_seq_q, const c10::optional<at::Tensor> & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, bool return_debug_mask, c10::optional<double> scale) {
return wrapper_CUDA___flash_attention_forward(query, key, value, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, return_debug_mask, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _flash_attention_backward(const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & cum_seq_q, const at::Tensor & cum_seq_k, int64_t max_q, int64_t max_k, double dropout_p, bool is_causal, const at::Tensor & philox_seed, const at::Tensor & philox_offset, c10::optional<double> scale) {
return wrapper_CUDA___flash_attention_backward(grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _flash_attention_backward_symint(const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, const at::Tensor & cum_seq_q, const at::Tensor & cum_seq_k, c10::SymInt max_q, c10::SymInt max_k, double dropout_p, bool is_causal, const at::Tensor & philox_seed, const at::Tensor & philox_offset, c10::optional<double> scale) {
return wrapper_CUDA___flash_attention_backward(grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,c10::SymInt,c10::SymInt> _efficient_attention_forward(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & cu_seqlens_q, const c10::optional<at::Tensor> & cu_seqlens_k, c10::optional<int64_t> max_seqlen_q, c10::optional<int64_t> max_seqlen_k, double dropout_p, int64_t custom_mask_type, bool compute_log_sumexp, c10::optional<double> scale, const c10::optional<at::Tensor> & causal_diagonal, const c10::optional<at::Tensor> & seqlen_k) {
return wrapper_CUDA___efficient_attention_forward(query, key, value, bias, cu_seqlens_q, cu_seqlens_k, max_seqlen_q, max_seqlen_k, dropout_p, custom_mask_type, compute_log_sumexp, scale, causal_diagonal, seqlen_k);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _efficient_attention_backward(const at::Tensor & grad_out_, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & bias, const at::Tensor & out, const c10::optional<at::Tensor> & cu_seqlens_q, const c10::optional<at::Tensor> & cu_seqlens_k, int64_t max_seqlen_q, int64_t max_seqlen_k, const at::Tensor & logsumexp, double dropout_p, const at::Tensor & philox_seed, const at::Tensor & philox_offset, int64_t custom_mask_type, bool bias_requires_grad, c10::optional<double> scale, c10::optional<int64_t> num_splits_key) {
return wrapper_CUDA___efficient_attention_backward(grad_out_, query, key, value, bias, out, cu_seqlens_q, cu_seqlens_k, max_seqlen_q, max_seqlen_k, logsumexp, dropout_p, philox_seed, philox_offset, custom_mask_type, bias_requires_grad, scale, num_splits_key);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _efficient_attention_backward_symint(const at::Tensor & grad_out_, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & bias, const at::Tensor & out, const c10::optional<at::Tensor> & cu_seqlens_q, const c10::optional<at::Tensor> & cu_seqlens_k, c10::SymInt max_seqlen_q, c10::SymInt max_seqlen_k, const at::Tensor & logsumexp, double dropout_p, const at::Tensor & philox_seed, const at::Tensor & philox_offset, int64_t custom_mask_type, bool bias_requires_grad, c10::optional<double> scale, c10::optional<int64_t> num_splits_key) {
return wrapper_CUDA___efficient_attention_backward(grad_out_, query, key, value, bias, out, cu_seqlens_q, cu_seqlens_k, max_seqlen_q, max_seqlen_k, logsumexp, dropout_p, philox_seed, philox_offset, custom_mask_type, bias_requires_grad, scale, num_splits_key);
}
at::Tensor _triton_scaled_dot_attention(const at::Tensor & q, const at::Tensor & k, const at::Tensor & v, double dropout_p) {
return wrapper_CUDA___triton_scaled_dot_attention(q, k, v, dropout_p);
}
at::Tensor & _fill_mem_eff_dropout_mask_(at::Tensor & self, double dropout_p, int64_t seed, int64_t offset) {
return wrapper_CUDA___fill_mem_eff_dropout_mask_(self, dropout_p, seed, offset);
}
at::Tensor _triton_multi_head_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, int64_t embed_dim, int64_t num_head, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, const c10::optional<at::Tensor> & mask) {
return wrapper_CUDA___triton_multi_head_attention(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask);
}
at::Tensor special_airy_ai(const at::Tensor & x) {
return wrapper_CUDA_special_airy_ai(x);
}
at::Tensor & special_airy_ai_out(at::Tensor & out, const at::Tensor & x) {
return wrapper_CUDA_special_airy_ai_out_out(x, out);
}
at::Tensor & special_airy_ai_outf(const at::Tensor & x, at::Tensor & out) {
return wrapper_CUDA_special_airy_ai_out_out(x, out);
}
at::Tensor special_bessel_j0(const at::Tensor & self) {
return wrapper_CUDA_special_bessel_j0(self);
}
at::Tensor & special_bessel_j0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_bessel_j0_out_out(self, out);
}
at::Tensor & special_bessel_j0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_bessel_j0_out_out(self, out);
}
at::Tensor special_bessel_j1(const at::Tensor & self) {
return wrapper_CUDA_special_bessel_j1(self);
}
at::Tensor & special_bessel_j1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_bessel_j1_out_out(self, out);
}
at::Tensor & special_bessel_j1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_bessel_j1_out_out(self, out);
}
at::Tensor special_bessel_y0(const at::Tensor & self) {
return wrapper_CUDA_special_bessel_y0(self);
}
at::Tensor & special_bessel_y0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_bessel_y0_out_out(self, out);
}
at::Tensor & special_bessel_y0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_bessel_y0_out_out(self, out);
}
at::Tensor special_bessel_y1(const at::Tensor & self) {
return wrapper_CUDA_special_bessel_y1(self);
}
at::Tensor & special_bessel_y1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_bessel_y1_out_out(self, out);
}
at::Tensor & special_bessel_y1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_bessel_y1_out_out(self, out);
}
at::Tensor special_chebyshev_polynomial_t(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_chebyshev_polynomial_t(x, n);
}
at::Tensor & special_chebyshev_polynomial_t_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_chebyshev_polynomial_t_out_out(x, n, out);
}
at::Tensor & special_chebyshev_polynomial_t_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_chebyshev_polynomial_t_out_out(x, n, out);
}
at::Tensor special_chebyshev_polynomial_u(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_chebyshev_polynomial_u(x, n);
}
at::Tensor & special_chebyshev_polynomial_u_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_chebyshev_polynomial_u_out_out(x, n, out);
}
at::Tensor & special_chebyshev_polynomial_u_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_chebyshev_polynomial_u_out_out(x, n, out);
}
at::Tensor special_chebyshev_polynomial_v(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_chebyshev_polynomial_v(x, n);
}
at::Tensor & special_chebyshev_polynomial_v_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_chebyshev_polynomial_v_out_out(x, n, out);
}
at::Tensor & special_chebyshev_polynomial_v_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_chebyshev_polynomial_v_out_out(x, n, out);
}
at::Tensor special_chebyshev_polynomial_w(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_chebyshev_polynomial_w(x, n);
}
at::Tensor & special_chebyshev_polynomial_w_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_chebyshev_polynomial_w_out_out(x, n, out);
}
at::Tensor & special_chebyshev_polynomial_w_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_chebyshev_polynomial_w_out_out(x, n, out);
}
at::Tensor special_hermite_polynomial_h(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_hermite_polynomial_h(x, n);
}
at::Tensor & special_hermite_polynomial_h_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_hermite_polynomial_h_out_out(x, n, out);
}
at::Tensor & special_hermite_polynomial_h_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_hermite_polynomial_h_out_out(x, n, out);
}
at::Tensor special_hermite_polynomial_he(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_hermite_polynomial_he(x, n);
}
at::Tensor & special_hermite_polynomial_he_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_hermite_polynomial_he_out_out(x, n, out);
}
at::Tensor & special_hermite_polynomial_he_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_hermite_polynomial_he_out_out(x, n, out);
}
at::Tensor special_laguerre_polynomial_l(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_laguerre_polynomial_l(x, n);
}
at::Tensor & special_laguerre_polynomial_l_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_laguerre_polynomial_l_out_out(x, n, out);
}
at::Tensor & special_laguerre_polynomial_l_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_laguerre_polynomial_l_out_out(x, n, out);
}
at::Tensor special_legendre_polynomial_p(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_legendre_polynomial_p(x, n);
}
at::Tensor & special_legendre_polynomial_p_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_legendre_polynomial_p_out_out(x, n, out);
}
at::Tensor & special_legendre_polynomial_p_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_legendre_polynomial_p_out_out(x, n, out);
}
at::Tensor special_modified_bessel_i0(const at::Tensor & self) {
return wrapper_CUDA_special_modified_bessel_i0(self);
}
at::Tensor & special_modified_bessel_i0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_modified_bessel_i0_out_out(self, out);
}
at::Tensor & special_modified_bessel_i0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_modified_bessel_i0_out_out(self, out);
}
at::Tensor special_modified_bessel_i1(const at::Tensor & self) {
return wrapper_CUDA_special_modified_bessel_i1(self);
}
at::Tensor & special_modified_bessel_i1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_modified_bessel_i1_out_out(self, out);
}
at::Tensor & special_modified_bessel_i1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_modified_bessel_i1_out_out(self, out);
}
at::Tensor special_modified_bessel_k0(const at::Tensor & self) {
return wrapper_CUDA_special_modified_bessel_k0(self);
}
at::Tensor & special_modified_bessel_k0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_modified_bessel_k0_out_out(self, out);
}
at::Tensor & special_modified_bessel_k0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_modified_bessel_k0_out_out(self, out);
}
at::Tensor special_modified_bessel_k1(const at::Tensor & self) {
return wrapper_CUDA_special_modified_bessel_k1(self);
}
at::Tensor & special_modified_bessel_k1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CUDA_special_modified_bessel_k1_out_out(self, out);
}
at::Tensor & special_modified_bessel_k1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CUDA_special_modified_bessel_k1_out_out(self, out);
}
at::Tensor special_scaled_modified_bessel_k0(const at::Tensor & x) {
return wrapper_CUDA_special_scaled_modified_bessel_k0(x);
}
at::Tensor & special_scaled_modified_bessel_k0_out(at::Tensor & out, const at::Tensor & x) {
return wrapper_CUDA_special_scaled_modified_bessel_k0_out_out(x, out);
}
at::Tensor & special_scaled_modified_bessel_k0_outf(const at::Tensor & x, at::Tensor & out) {
return wrapper_CUDA_special_scaled_modified_bessel_k0_out_out(x, out);
}
at::Tensor special_scaled_modified_bessel_k1(const at::Tensor & x) {
return wrapper_CUDA_special_scaled_modified_bessel_k1(x);
}
at::Tensor & special_scaled_modified_bessel_k1_out(at::Tensor & out, const at::Tensor & x) {
return wrapper_CUDA_special_scaled_modified_bessel_k1_out_out(x, out);
}
at::Tensor & special_scaled_modified_bessel_k1_outf(const at::Tensor & x, at::Tensor & out) {
return wrapper_CUDA_special_scaled_modified_bessel_k1_out_out(x, out);
}
at::Tensor special_shifted_chebyshev_polynomial_t(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_t(x, n);
}
at::Tensor & special_shifted_chebyshev_polynomial_t_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_t_out_out(x, n, out);
}
at::Tensor & special_shifted_chebyshev_polynomial_t_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_t_out_out(x, n, out);
}
at::Tensor special_shifted_chebyshev_polynomial_u(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_u(x, n);
}
at::Tensor & special_shifted_chebyshev_polynomial_u_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_u_out_out(x, n, out);
}
at::Tensor & special_shifted_chebyshev_polynomial_u_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_u_out_out(x, n, out);
}
at::Tensor special_shifted_chebyshev_polynomial_v(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_v(x, n);
}
at::Tensor & special_shifted_chebyshev_polynomial_v_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_v_out_out(x, n, out);
}
at::Tensor & special_shifted_chebyshev_polynomial_v_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_v_out_out(x, n, out);
}
at::Tensor special_shifted_chebyshev_polynomial_w(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_w(x, n);
}
at::Tensor & special_shifted_chebyshev_polynomial_w_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_w_out_out(x, n, out);
}
at::Tensor & special_shifted_chebyshev_polynomial_w_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CUDA_special_shifted_chebyshev_polynomial_w_out_out(x, n, out);
}
at::Tensor special_spherical_bessel_j0(const at::Tensor & x) {
return wrapper_CUDA_special_spherical_bessel_j0(x);
}
at::Tensor & special_spherical_bessel_j0_out(at::Tensor & out, const at::Tensor & x) {
return wrapper_CUDA_special_spherical_bessel_j0_out_out(x, out);
}
at::Tensor & special_spherical_bessel_j0_outf(const at::Tensor & x, at::Tensor & out) {
return wrapper_CUDA_special_spherical_bessel_j0_out_out(x, out);
}
void _fused_adam_(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, double lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
return wrapper_CUDA___fused_adam_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
}
void _fused_adam_(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, const at::Tensor & lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
return wrapper_CUDA_tensor_lr__fused_adam_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
}
void _fused_adamw_(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, double lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
return wrapper_CUDA___fused_adamw_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
}
void _fused_adamw_(at::TensorList self, at::TensorList grads, at::TensorList exp_avgs, at::TensorList exp_avg_sqs, at::TensorList max_exp_avg_sqs, at::TensorList state_steps, const at::Tensor & lr, double beta1, double beta2, double weight_decay, double eps, bool amsgrad, bool maximize, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
return wrapper_CUDA_tensor_lr__fused_adamw_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf);
}
void _fused_sgd_(at::TensorList self, at::TensorList grads, at::TensorList momentum_buffer_list, double weight_decay, double momentum, double lr, double dampening, bool nesterov, bool maximize, bool is_first_step, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
return wrapper_CUDA___fused_sgd_(self, grads, momentum_buffer_list, weight_decay, momentum, lr, dampening, nesterov, maximize, is_first_step, grad_scale, found_inf);
}
void _fused_sgd_(at::TensorList self, at::TensorList grads, at::TensorList momentum_buffer_list, double weight_decay, double momentum, const at::Tensor & lr, double dampening, bool nesterov, bool maximize, bool is_first_step, const c10::optional<at::Tensor> & grad_scale, const c10::optional<at::Tensor> & found_inf) {
return wrapper_CUDA_tensor_lr__fused_sgd_(self, grads, momentum_buffer_list, weight_decay, momentum, lr, dampening, nesterov, maximize, is_first_step, grad_scale, found_inf);
}
} // namespace cuda
} // namespace at
