// required for old g++ to compile PRId64 macros, see
// https://github.com/pytorch/pytorch/issues/3571
// for context
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

// an external backend might generate file within its code tree
// and check all the source files within the tree with clang-format.
// so, disable it since the backend might have a different config.
// clang-format off

// NOTE: This condition is true for all PyTorch internal libraries, it
//       just excludes external projects such as torch_xla which
//       re-use some of the PyTorch codegen machinery.
#if defined(CAFFE2_BUILD_MAIN_LIB)        || \
    defined(TORCH_CUDA_BUILD_MAIN_LIB)    || \
    defined(TORCH_HIP_BUILD_MAIN_LIB)     || \
    defined(TORCH_CUDA_CU_BUILD_MAIN_LIB) || \
    defined(TORCH_CUDA_CPP_BUILD_MAIN_LIB)
#define TORCH_ASSERT_ONLY_METHOD_OPERATORS
#endif

// @generated by torchgen/gen.py from RegisterDispatchKey.cpp

#include <c10/core/TensorImpl.h>
#include <c10/core/Allocator.h>
#include <ATen/DeviceGuard.h>
#include <ATen/NamedTensorUtils.h>
#include <ATen/Utils.h>
#include <ATen/WrapDimUtils.h>
#include <ATen/Dispatch.h>
#include <c10/util/ExclusivelyOwned.h>
#include <c10/util/Half.h>
#include <c10/core/UndefinedTensorImpl.h>
#include <c10/util/Optional.h>
#include <ATen/Tensor.h>
#include <ATen/native/Resize.h>

#include <cstddef>
#include <functional>
#include <memory>
#include <utility>

#include <ATen/Config.h>
#include <ATen/core/op_registration/adaption.h>
#include <torch/library.h>


#include <ATen/NativeFunctions.h>
#include <ATen/EmptyTensor.h>
#include <ATen/NativeFunctions.h>
#include <ATen/CPUFunctions.h>

// See template file RegisterDispatchDefinitions.ini
namespace at {
// NB: TORCH_LIBRARY_IMPL must be in an anonymous namespace to avoid
// ambiguity with conflicting identifiers that may have been defined in
// at namespace already.
namespace {
Tensor create_out(IntArrayRef sizes, IntArrayRef strides, const TensorOptions &options) {
  if (strides.empty()) {
      return at::detail::empty_cpu(sizes, options);
  } else {
      return at::detail::empty_strided_cpu(sizes, strides, options);
  }
}
void resize_out(const Tensor &out, IntArrayRef sizes, IntArrayRef strides, const TensorOptions &options) {
  TORCH_CHECK(options.dtype() == out.dtype(),
      "Expected out tensor to have dtype ", options.dtype(), ", but got ", out.dtype(), " instead");
  TORCH_CHECK(options.device() == out.device(),
      "Expected out tensor to have device ", options.device(), ", but got ", out.device(), " instead");
  const bool resized = at::native::resize_output(out, sizes);
  // Only restride if a resize occurred; otherwise we ignore the (advisory)
  // strides from the meta function and directly use the output tensor's
  // preexisting strides
  if (resized) {
    if (!strides.empty()) {
      TORCH_INTERNAL_ASSERT(!options.memory_format_opt().has_value());
      // TODO: avoid the redispatch here
      out.as_strided_(sizes, strides);
    } else if (options.memory_format_opt().has_value()) {
      out.unsafeGetTensorImpl()->empty_tensor_restride(*options.memory_format_opt());
    }
  }
}
void check_inplace(const Tensor &self, IntArrayRef sizes, const TensorOptions &options) {
  // These checks are needed on those operators that:
  //   1) don't use 'TensorIterator' (e.g. 'addmm' and 'baddbmm')
  //   2) have particular typing rules (e.g. 'cumsum' and 'cumprod')
  // For other operators (e.g. 'add'), 'TensorIterator' already checks
  // these things separately.
  TORCH_CHECK(options.dtype() == self.dtype(),
      "Bad in-place call: ",
      "input tensor dtype ", self.dtype(), " and output tensor dtype ", options.dtype(), " should match");
  TORCH_CHECK(options.device() == self.device(),
      "Bad in-place call: ",
      "input tensor device ", self.device(), " and output tensor device ", options.device(), " should match");
  TORCH_CHECK(sizes == self.sizes(),
      "Bad in-place call: ",
      "input tensor size ", self.sizes(), " and output tensor size ", sizes, " should match");
}
c10::optional<Tensor> maybe_create_proxy(const Tensor &out, IntArrayRef sizes, IntArrayRef strides, const TensorOptions &options) {
  if (out.strides() != strides) {
    return at::detail::empty_strided_cpu(sizes, strides, options);
  }
  return c10::nullopt;
}
namespace {
void wrapper_CPU___assert_async(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::_assert_async_cpu(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU_msg__assert_async(const at::Tensor & self, c10::string_view assert_msg) {
    // No device check
  // DeviceGuard omitted
  return at::native::_assert_async_msg_cpu(self, assert_msg);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_msg__functional_assert_async(const at::Tensor & self, c10::string_view assert_msg, const at::Tensor & dep_token) {
    // No device check
  // DeviceGuard omitted
  return at::native::_functional_assert_async_msg_cpu(self, assert_msg, dep_token);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___make_dep_token(c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
    // No device check
  // DeviceGuard omitted
  return at::native::_make_dep_token_cpu(dtype, layout, device, pin_memory, memory_format);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__native_dropout(const at::Tensor & input, double p, c10::optional<bool> train) {
    // No device check
  // DeviceGuard omitted
  return at::native::native_dropout_cpu(input, p, train);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__native_dropout_backward(const at::Tensor & grad_output, const at::Tensor & mask, double scale) {
    // No device check
  // DeviceGuard omitted
  return at::native::native_dropout_backward(grad_output, mask, scale);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_abs_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::abs_out(self, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__angle(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::angle(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_angle_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::angle_out(self, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__view_as_real(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::view_as_real(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__view_as_complex(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::view_as_complex(self);
}
} // anonymous namespace
struct structured_sgn_out_functional final : public at::native::structured_sgn_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sgn(const at::Tensor & self) {
structured_sgn_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sgn_out_out final : public at::native::structured_sgn_out {
    structured_sgn_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sgn_out_out(const at::Tensor & self, at::Tensor & out) {
structured_sgn_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sgn_out_inplace final : public at::native::structured_sgn_out {
    structured_sgn_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sgn_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sgn_(at::Tensor & self) {
structured_sgn_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU_out_conj_physical_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::conj_physical_out(self, out);
}
} // anonymous namespace
struct structured_acos_out_functional final : public at::native::structured_acos_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_acos(const at::Tensor & self) {
structured_acos_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_acos_out_out final : public at::native::structured_acos_out {
    structured_acos_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_acos_out_out(const at::Tensor & self, at::Tensor & out) {
structured_acos_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_acos_out_inplace final : public at::native::structured_acos_out {
    structured_acos_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_acos_(at::Tensor & self) {
structured_acos_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_ufunc_add_CPU_functional final : public at::native::structured_ufunc_add_CPU {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CPU::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CPU::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_add_Tensor(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
structured_ufunc_add_CPU_functional op;
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ufunc_add_CPU_out final : public at::native::structured_ufunc_add_CPU {
    structured_ufunc_add_CPU_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CPU::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CPU::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_add_out_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
structured_ufunc_add_CPU_out op(out);
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ufunc_add_CPU_inplace final : public at::native::structured_ufunc_add_CPU {
    structured_ufunc_add_CPU_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CPU::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ufunc_add_CPU::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_add__Tensor(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
structured_ufunc_add_CPU_inplace op(self);
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU_Tensor__add_relu(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::add_relu(self, other, alpha);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out__add_relu_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::add_relu_out(self, other, alpha, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor__add_relu_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::add_relu_(self, other, alpha);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Scalar__add_relu(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::add_relu(self, other, alpha);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Scalar__add_relu_(at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::add_relu_(self, other, alpha);
}
} // anonymous namespace
struct structured_addmv_out_cpu_functional final : public at::native::structured_addmv_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_addmv(const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
structured_addmv_out_cpu_functional op;
op.meta(self, mat, vec, beta, alpha);
op.impl(self, mat, vec, beta, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addmv_out_cpu_out final : public at::native::structured_addmv_out_cpu {
    structured_addmv_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_addmv_out_out(const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
structured_addmv_out_cpu_out op(out);
op.meta(self, mat, vec, beta, alpha);
op.impl(self, mat, vec, beta, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addmv_out_cpu_inplace final : public at::native::structured_addmv_out_cpu {
    structured_addmv_out_cpu_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_addmv_(at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
structured_addmv_out_cpu_inplace op(self);
op.meta(self, mat, vec, beta, alpha);
op.impl(self, mat, vec, beta, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__addr(const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::addr(self, vec1, vec2, beta, alpha);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_addr_out(const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::addr_out(self, vec1, vec2, beta, alpha, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___test_functorch_fallback(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::_test_functorch_fallback(self, other);
}
} // anonymous namespace
struct structured_all_out_functional final : public at::native::structured_all_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_all_dim(const at::Tensor & self, int64_t dim, bool keepdim) {
structured_all_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_all_out_out final : public at::native::structured_all_out {
    structured_all_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_all_out_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
structured_all_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_all_dims_out_functional final : public at::native::structured_all_dims_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_all_dims(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
structured_all_dims_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_all_dims_out_out final : public at::native::structured_all_dims_out {
    structured_all_dims_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_all_out_dims_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
structured_all_dims_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_any_out_functional final : public at::native::structured_any_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_any_dim(const at::Tensor & self, int64_t dim, bool keepdim) {
structured_any_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_any_out_out final : public at::native::structured_any_out {
    structured_any_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_any_out_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
structured_any_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_any_dims_out_functional final : public at::native::structured_any_dims_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_any_dims(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
structured_any_dims_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_any_dims_out_out final : public at::native::structured_any_dims_out {
    structured_any_dims_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_any_out_dims_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
structured_any_dims_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor & wrapper_CPU_start_out_arange_out(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::arange_out(start, end, step, out);
}
} // anonymous namespace
struct structured_argmax_out_functional final : public at::native::structured_argmax_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_argmax(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
structured_argmax_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_argmax_out_out final : public at::native::structured_argmax_out {
    structured_argmax_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_argmax_out_out(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
structured_argmax_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_argmin_out_functional final : public at::native::structured_argmin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_argmin(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
structured_argmin_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_argmin_out_out final : public at::native::structured_argmin_out {
    structured_argmin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_argmin_out_out(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
structured_argmin_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_acosh_out_functional final : public at::native::structured_acosh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_acosh(const at::Tensor & self) {
structured_acosh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_acosh_out_out final : public at::native::structured_acosh_out {
    structured_acosh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_acosh_out_out(const at::Tensor & self, at::Tensor & out) {
structured_acosh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_acosh_out_inplace final : public at::native::structured_acosh_out {
    structured_acosh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_acosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_acosh_(at::Tensor & self) {
structured_acosh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_asinh_out_functional final : public at::native::structured_asinh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_asinh(const at::Tensor & self) {
structured_asinh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_asinh_out_out final : public at::native::structured_asinh_out {
    structured_asinh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_asinh_out_out(const at::Tensor & self, at::Tensor & out) {
structured_asinh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_asinh_out_inplace final : public at::native::structured_asinh_out {
    structured_asinh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_asinh_(at::Tensor & self) {
structured_asinh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_atanh_out_functional final : public at::native::structured_atanh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_atanh(const at::Tensor & self) {
structured_atanh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_atanh_out_out final : public at::native::structured_atanh_out {
    structured_atanh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_atanh_out_out(const at::Tensor & self, at::Tensor & out) {
structured_atanh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_atanh_out_inplace final : public at::native::structured_atanh_out {
    structured_atanh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_atanh_(at::Tensor & self) {
structured_atanh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__as_strided(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
    // No device check
  // DeviceGuard omitted
  return at::native::as_strided_tensorimpl(self, C10_AS_INTARRAYREF_SLOW(size), C10_AS_INTARRAYREF_SLOW(stride), storage_offset.has_value() ? c10::make_optional(storage_offset->guard_int(__FILE__, __LINE__)) : c10::nullopt);
}
} // anonymous namespace
struct structured_asin_out_functional final : public at::native::structured_asin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_asin(const at::Tensor & self) {
structured_asin_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_asin_out_out final : public at::native::structured_asin_out {
    structured_asin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_asin_out_out(const at::Tensor & self, at::Tensor & out) {
structured_asin_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_asin_out_inplace final : public at::native::structured_asin_out {
    structured_asin_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_asin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_asin_(at::Tensor & self) {
structured_asin_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_atan_out_functional final : public at::native::structured_atan_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_atan(const at::Tensor & self) {
structured_atan_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_atan_out_out final : public at::native::structured_atan_out {
    structured_atan_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_atan_out_out(const at::Tensor & self, at::Tensor & out) {
structured_atan_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_atan_out_inplace final : public at::native::structured_atan_out {
    structured_atan_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_atan_(at::Tensor & self) {
structured_atan_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_baddbmm_out_cpu_functional final : public at::native::structured_baddbmm_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_baddbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
structured_baddbmm_out_cpu_functional op;
op.meta(self, batch1, batch2, beta, alpha);
op.impl(self, batch1, batch2, beta, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_baddbmm_out_cpu_out final : public at::native::structured_baddbmm_out_cpu {
    structured_baddbmm_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_baddbmm_out_out(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
structured_baddbmm_out_cpu_out op(out);
op.meta(self, batch1, batch2, beta, alpha);
op.impl(self, batch1, batch2, beta, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_baddbmm_out_cpu_inplace final : public at::native::structured_baddbmm_out_cpu {
    structured_baddbmm_out_cpu_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_baddbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
structured_baddbmm_out_cpu_inplace op(self);
op.meta(self, batch1, batch2, beta, alpha);
op.impl(self, batch1, batch2, beta, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU_out_bernoulli_out(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::bernoulli_out(self, generator, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor_bernoulli_(at::Tensor & self, const at::Tensor & p, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::bernoulli_(self, p, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_float_bernoulli_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::bernoulli_(self, p, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__binary_cross_entropy(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    // No device check
  // DeviceGuard omitted
  return at::native::binary_cross_entropy_cpu(self, target, weight, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_binary_cross_entropy_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::binary_cross_entropy_out_cpu(self, target, weight, reduction, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__binary_cross_entropy_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    // No device check
  // DeviceGuard omitted
  return at::native::binary_cross_entropy_backward_cpu(grad_output, self, target, weight, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_binary_cross_entropy_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::binary_cross_entropy_backward_out_cpu(grad_output, self, target, weight, reduction, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__bincount(const at::Tensor & self, const c10::optional<at::Tensor> & weights, int64_t minlength) {
    // No device check
  // DeviceGuard omitted
  return at::native::_bincount_cpu(self, weights, minlength);
}
} // anonymous namespace
struct structured_bitwise_not_out_functional final : public at::native::structured_bitwise_not_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_bitwise_not(const at::Tensor & self) {
structured_bitwise_not_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_not_out_out final : public at::native::structured_bitwise_not_out {
    structured_bitwise_not_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_not_out_out(const at::Tensor & self, at::Tensor & out) {
structured_bitwise_not_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_not_out_inplace final : public at::native::structured_bitwise_not_out {
    structured_bitwise_not_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_not_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_not_(at::Tensor & self) {
structured_bitwise_not_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_copysign_out_functional final : public at::native::structured_copysign_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_copysign_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_copysign_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_copysign_out_out final : public at::native::structured_copysign_out {
    structured_copysign_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_copysign_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_copysign_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_copysign_out_inplace final : public at::native::structured_copysign_out {
    structured_copysign_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_copysign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_copysign__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_copysign_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU_out_logical_not_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::logical_not_out(self, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_logical_xor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::logical_xor_out(self, other, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_logical_and_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::logical_and_out(self, other, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_logical_or_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::logical_or_out(self, other, out);
}
} // anonymous namespace
struct structured_bmm_out_cpu_functional final : public at::native::structured_bmm_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_bmm(const at::Tensor & self, const at::Tensor & mat2) {
structured_bmm_out_cpu_functional op;
op.meta(self, mat2);
op.impl(self, mat2, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bmm_out_cpu_out final : public at::native::structured_bmm_out_cpu {
    structured_bmm_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bmm_out_out(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
structured_bmm_out_cpu_out op(out);
op.meta(self, mat2);
op.impl(self, mat2, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cat_out_cpu_functional final : public at::native::structured_cat_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_cat(const at::ITensorListRef & tensors, int64_t dim) {
structured_cat_out_cpu_functional op;
auto precompute = op.meta(tensors, dim);
(void)precompute;
op.impl(tensors, precompute.dim, precompute.valid, precompute.all_contiguous, precompute.all_same_dtype, precompute.all_same_sizes_and_stride, precompute.memory_format, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cat_out_cpu_out final : public at::native::structured_cat_out_cpu {
    structured_cat_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_cat_out_out(const at::ITensorListRef & tensors, int64_t dim, at::Tensor & out) {
structured_cat_out_cpu_out op(out);
auto precompute = op.meta(tensors, dim);
(void)precompute;
op.impl(tensors, precompute.dim, precompute.valid, precompute.all_contiguous, precompute.all_same_dtype, precompute.all_same_sizes_and_stride, precompute.memory_format, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ceil_out_functional final : public at::native::structured_ceil_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_ceil(const at::Tensor & self) {
structured_ceil_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ceil_out_out final : public at::native::structured_ceil_out {
    structured_ceil_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ceil_out_out(const at::Tensor & self, at::Tensor & out) {
structured_ceil_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ceil_out_inplace final : public at::native::structured_ceil_out {
    structured_ceil_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ceil_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ceil_(at::Tensor & self) {
structured_ceil_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_out_functional final : public at::native::structured_clamp_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_clamp(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
structured_clamp_out_functional op;
op.meta(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()));
op.impl(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()), op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_out_out final : public at::native::structured_clamp_out {
    structured_clamp_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_out_out(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max, at::Tensor & out) {
structured_clamp_out_out op(out);
op.meta(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()));
op.impl(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()), op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_out_inplace final : public at::native::structured_clamp_out {
    structured_clamp_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_(at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
structured_clamp_out_inplace op(self);
op.meta(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()));
op.impl(self, (min.has_value() ? at::OptionalScalarRef(&(min.value())) : at::OptionalScalarRef()), (max.has_value() ? at::OptionalScalarRef(&(max.value())) : at::OptionalScalarRef()), op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_Tensor_out_functional final : public at::native::structured_clamp_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_clamp_Tensor(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
structured_clamp_Tensor_out_functional op;
op.meta(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()));
op.impl(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()), op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_Tensor_out_out final : public at::native::structured_clamp_Tensor_out {
    structured_clamp_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_out_Tensor_out(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max, at::Tensor & out) {
structured_clamp_Tensor_out_out op(out);
op.meta(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()));
op.impl(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()), op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_Tensor_out_inplace final : public at::native::structured_clamp_Tensor_out {
    structured_clamp_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp__Tensor(at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
structured_clamp_Tensor_out_inplace op(self);
op.meta(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()));
op.impl(self, ((min.has_value() && (*min).defined()) ? at::OptionalTensorRef(*min) : at::OptionalTensorRef()), ((max.has_value() && (*max).defined()) ? at::OptionalTensorRef(*max) : at::OptionalTensorRef()), op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_max_out_functional final : public at::native::structured_clamp_max_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_clamp_max(const at::Tensor & self, const at::Scalar & max) {
structured_clamp_max_out_functional op;
op.meta(self, max);
op.impl(self, max, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_max_out_out final : public at::native::structured_clamp_max_out {
    structured_clamp_max_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_max_out_out(const at::Tensor & self, const at::Scalar & max, at::Tensor & out) {
structured_clamp_max_out_out op(out);
op.meta(self, max);
op.impl(self, max, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_max_out_inplace final : public at::native::structured_clamp_max_out {
    structured_clamp_max_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_max_(at::Tensor & self, const at::Scalar & max) {
structured_clamp_max_out_inplace op(self);
op.meta(self, max);
op.impl(self, max, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_max_Tensor_out_functional final : public at::native::structured_clamp_max_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_clamp_max_Tensor(const at::Tensor & self, const at::Tensor & max) {
structured_clamp_max_Tensor_out_functional op;
op.meta(self, max);
op.impl(self, max, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_max_Tensor_out_out final : public at::native::structured_clamp_max_Tensor_out {
    structured_clamp_max_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_max_out_Tensor_out(const at::Tensor & self, const at::Tensor & max, at::Tensor & out) {
structured_clamp_max_Tensor_out_out op(out);
op.meta(self, max);
op.impl(self, max, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_max_Tensor_out_inplace final : public at::native::structured_clamp_max_Tensor_out {
    structured_clamp_max_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_max_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_max__Tensor(at::Tensor & self, const at::Tensor & max) {
structured_clamp_max_Tensor_out_inplace op(self);
op.meta(self, max);
op.impl(self, max, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_min_out_functional final : public at::native::structured_clamp_min_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_clamp_min(const at::Tensor & self, const at::Scalar & min) {
structured_clamp_min_out_functional op;
op.meta(self, min);
op.impl(self, min, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_min_out_out final : public at::native::structured_clamp_min_out {
    structured_clamp_min_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_min_out_out(const at::Tensor & self, const at::Scalar & min, at::Tensor & out) {
structured_clamp_min_out_out op(out);
op.meta(self, min);
op.impl(self, min, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_min_out_inplace final : public at::native::structured_clamp_min_out {
    structured_clamp_min_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_min_(at::Tensor & self, const at::Scalar & min) {
structured_clamp_min_out_inplace op(self);
op.meta(self, min);
op.impl(self, min, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_clamp_min_Tensor_out_functional final : public at::native::structured_clamp_min_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_clamp_min_Tensor(const at::Tensor & self, const at::Tensor & min) {
structured_clamp_min_Tensor_out_functional op;
op.meta(self, min);
op.impl(self, min, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_clamp_min_Tensor_out_out final : public at::native::structured_clamp_min_Tensor_out {
    structured_clamp_min_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_min_out_Tensor_out(const at::Tensor & self, const at::Tensor & min, at::Tensor & out) {
structured_clamp_min_Tensor_out_out op(out);
op.meta(self, min);
op.impl(self, min, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_clamp_min_Tensor_out_inplace final : public at::native::structured_clamp_min_Tensor_out {
    structured_clamp_min_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_clamp_min_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_clamp_min__Tensor(at::Tensor & self, const at::Tensor & min) {
structured_clamp_min_Tensor_out_inplace op(self);
op.meta(self, min);
op.impl(self, min, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU_out_complex_out(const at::Tensor & real, const at::Tensor & imag, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::complex_out(real, imag, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_polar_out(const at::Tensor & abs, const at::Tensor & angle, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::polar_out(abs, angle, out);
}
} // anonymous namespace
struct structured_cos_out_functional final : public at::native::structured_cos_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_cos(const at::Tensor & self) {
structured_cos_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cos_out_out final : public at::native::structured_cos_out {
    structured_cos_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_cos_out_out(const at::Tensor & self, at::Tensor & out) {
structured_cos_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cos_out_inplace final : public at::native::structured_cos_out {
    structured_cos_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cos_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_cos_(at::Tensor & self) {
structured_cos_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_cosh_out_functional final : public at::native::structured_cosh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_cosh(const at::Tensor & self) {
structured_cosh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cosh_out_out final : public at::native::structured_cosh_out {
    structured_cosh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_cosh_out_out(const at::Tensor & self, at::Tensor & out) {
structured_cosh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cosh_out_inplace final : public at::native::structured_cosh_out {
    structured_cosh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_cosh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_cosh_(at::Tensor & self) {
structured_cosh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU_dim_IntList_count_nonzero(const at::Tensor & self, at::IntArrayRef dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::count_nonzero_cpu(self, dim);
}
} // anonymous namespace
namespace {
void wrapper_CPU___cummax_helper(const at::Tensor & self, at::Tensor & values, at::Tensor & indices, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::cummax_helper_cpu(self, values, indices, dim);
}
} // anonymous namespace
namespace {
void wrapper_CPU___cummin_helper(const at::Tensor & self, at::Tensor & values, at::Tensor & indices, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::cummin_helper_cpu(self, values, indices, dim);
}
} // anonymous namespace
struct structured_cumprod_out_functional final : public at::native::structured_cumprod_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_cumprod(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
structured_cumprod_out_functional op;
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cumprod_out_out final : public at::native::structured_cumprod_out {
    structured_cumprod_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_cumprod_out_out(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
structured_cumprod_out_out op(out);
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cumprod_out_inplace final : public at::native::structured_cumprod_out {
    structured_cumprod_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_cumprod_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
structured_cumprod_out_inplace op(self);
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_cumsum_out_functional final : public at::native::structured_cumsum_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_cumsum(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
structured_cumsum_out_functional op;
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_cumsum_out_out final : public at::native::structured_cumsum_out {
    structured_cumsum_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_cumsum_out_out(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
structured_cumsum_out_out op(out);
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_cumsum_out_inplace final : public at::native::structured_cumsum_out {
    structured_cumsum_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_cumsum_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
structured_cumsum_out_inplace op(self);
op.meta(self, dim, dtype);
op.impl(self, dim, dtype, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool zero_infinity) {
    // No device check
  // DeviceGuard omitted
  return at::native::ctc_loss_cpu(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_Tensor__ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool zero_infinity) {
    // No device check
  // DeviceGuard omitted
  return at::native::ctc_loss_tensor(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___ctc_loss_backward(const at::Tensor & grad, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, const at::Tensor & neg_log_likelihood, const at::Tensor & log_alpha, int64_t blank, bool zero_infinity) {
    // No device check
  // DeviceGuard omitted
  return at::native::ctc_loss_backward_cpu(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Tensor__ctc_loss_backward(const at::Tensor & grad, const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, const at::Tensor & neg_log_likelihood, const at::Tensor & log_alpha, int64_t blank, bool zero_infinity) {
    // No device check
  // DeviceGuard omitted
  return at::native::ctc_loss_backward_tensor(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity);
}
} // anonymous namespace
struct structured_div_out_functional final : public at::native::structured_div_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_div_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_div_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_div_out_out final : public at::native::structured_div_out {
    structured_div_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_div_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_div_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_div_out_inplace final : public at::native::structured_div_out {
    structured_div_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_div__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_div_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_div_out_mode_functional final : public at::native::structured_div_out_mode {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_div_Tensor_mode(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
structured_div_out_mode_functional op;
op.meta(self, other, rounding_mode);
op.impl(self, other, rounding_mode, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_div_out_mode_out final : public at::native::structured_div_out_mode {
    structured_div_out_mode_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_div_out_out_mode(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode, at::Tensor & out) {
structured_div_out_mode_out op(out);
op.meta(self, other, rounding_mode);
op.impl(self, other, rounding_mode, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_div_out_mode_inplace final : public at::native::structured_div_out_mode {
    structured_div_out_mode_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_div_out_mode::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_div__Tensor_mode(at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
structured_div_out_mode_inplace op(self);
op.meta(self, other, rounding_mode);
op.impl(self, other, rounding_mode, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__dot(const at::Tensor & self, const at::Tensor & tensor) {
    // No device check
  // DeviceGuard omitted
  return at::native::dot(self, tensor);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__vdot(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::vdot(self, other);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__embedding_dense_backward(const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq) {
    // No device check
  // DeviceGuard omitted
  return at::native::embedding_dense_backward_cpu(grad_output, indices, num_weights.guard_int(__FILE__, __LINE__), padding_idx.guard_int(__FILE__, __LINE__), scale_grad_by_freq);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__embedding_renorm_(at::Tensor & self, const at::Tensor & indices, double max_norm, double norm_type) {
    // No device check
  // DeviceGuard omitted
  return at::native::embedding_renorm_cpu_(self, indices, max_norm, norm_type);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CPU___embedding_bag_forward_only(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
    // No device check
  // DeviceGuard omitted
  return at::native::_embedding_bag_forward_only_cpu(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CPU___embedding_bag(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
    // No device check
  // DeviceGuard omitted
  return at::native::_embedding_bag_cpu(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___embedding_bag_dense_backward(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
    // No device check
  // DeviceGuard omitted
  return at::native::_embedding_bag_dense_backward_cpu(grad, indices, offset2bag, bag_size, maximum_indices, num_weights.guard_int(__FILE__, __LINE__), scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___embedding_bag_per_sample_weights_backward(const at::Tensor & grad, const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, const at::Tensor & offset2bag, int64_t mode, int64_t padding_idx) {
    // No device check
  // DeviceGuard omitted
  return at::native::_embedding_bag_per_sample_weights_backward_cpu(grad, weight, indices, offsets, offset2bag, mode, padding_idx);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_memory_format_empty(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
    // No device check
  // DeviceGuard omitted
  return at::native::empty_cpu(C10_AS_INTARRAYREF_SLOW(size), dtype, layout, device, pin_memory, memory_format);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___empty_affine_quantized(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, double scale, int64_t zero_point, c10::optional<at::MemoryFormat> memory_format) {
    // No device check
  // DeviceGuard omitted
  return at::native::empty_affine_quantized_other_backends_stub(C10_AS_INTARRAYREF_SLOW(size), dtype, layout, device, pin_memory, scale, zero_point, memory_format);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___empty_per_channel_affine_quantized(c10::SymIntArrayRef size, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
    // No device check
  // DeviceGuard omitted
  return at::native::empty_per_channel_affine_quantized_other_backends_stub(C10_AS_INTARRAYREF_SLOW(size), scales, zero_points, axis, dtype, layout, device, pin_memory, memory_format);
}
} // anonymous namespace
namespace {
const at::Tensor & wrapper_CPU__resize_(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
    // No device check
  // DeviceGuard omitted
  return at::native::resize_(self, C10_AS_INTARRAYREF_SLOW(size), memory_format);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__empty_strided(c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    // No device check
  // DeviceGuard omitted
  return at::native::empty_strided_cpu(C10_AS_INTARRAYREF_SLOW(size), C10_AS_INTARRAYREF_SLOW(stride), dtype, layout, device, pin_memory);
}
} // anonymous namespace
struct structured_erf_out_functional final : public at::native::structured_erf_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_erf(const at::Tensor & self) {
structured_erf_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_erf_out_out final : public at::native::structured_erf_out {
    structured_erf_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_erf_out_out(const at::Tensor & self, at::Tensor & out) {
structured_erf_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_erf_out_inplace final : public at::native::structured_erf_out {
    structured_erf_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_erf_(at::Tensor & self) {
structured_erf_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_erfc_out_functional final : public at::native::structured_erfc_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_erfc(const at::Tensor & self) {
structured_erfc_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_erfc_out_out final : public at::native::structured_erfc_out {
    structured_erfc_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_erfc_out_out(const at::Tensor & self, at::Tensor & out) {
structured_erfc_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_erfc_out_inplace final : public at::native::structured_erfc_out {
    structured_erfc_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_erfc_(at::Tensor & self) {
structured_erfc_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_exp_out_functional final : public at::native::structured_exp_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_exp(const at::Tensor & self) {
structured_exp_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_exp_out_out final : public at::native::structured_exp_out {
    structured_exp_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_exp_out_out(const at::Tensor & self, at::Tensor & out) {
structured_exp_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_exp_out_inplace final : public at::native::structured_exp_out {
    structured_exp_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_exp_(at::Tensor & self) {
structured_exp_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_exp2_out_functional final : public at::native::structured_exp2_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_exp2(const at::Tensor & self) {
structured_exp2_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_exp2_out_out final : public at::native::structured_exp2_out {
    structured_exp2_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_exp2_out_out(const at::Tensor & self, at::Tensor & out) {
structured_exp2_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_exp2_out_inplace final : public at::native::structured_exp2_out {
    structured_exp2_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_exp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_exp2_(at::Tensor & self) {
structured_exp2_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_expm1_out_functional final : public at::native::structured_expm1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_expm1(const at::Tensor & self) {
structured_expm1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_expm1_out_out final : public at::native::structured_expm1_out {
    structured_expm1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_expm1_out_out(const at::Tensor & self, at::Tensor & out) {
structured_expm1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_expm1_out_inplace final : public at::native::structured_expm1_out {
    structured_expm1_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_expm1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_expm1_(at::Tensor & self) {
structured_expm1_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU_out_eye_out(c10::SymInt n, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::eye_out_cpu(n.guard_int(__FILE__, __LINE__), out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_m_out_eye_out(c10::SymInt n, c10::SymInt m, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::eye_out_cpu(n.guard_int(__FILE__, __LINE__), m.guard_int(__FILE__, __LINE__), out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Scalar_fill_(at::Tensor & self, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::fill_(self, value);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor_fill_(at::Tensor & self, const at::Tensor & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::fill_(self, value);
}
} // anonymous namespace
struct structured_floor_out_functional final : public at::native::structured_floor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_floor(const at::Tensor & self) {
structured_floor_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_floor_out_out final : public at::native::structured_floor_out {
    structured_floor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_floor_out_out(const at::Tensor & self, at::Tensor & out) {
structured_floor_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_floor_out_inplace final : public at::native::structured_floor_out {
    structured_floor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_floor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_floor_(at::Tensor & self) {
structured_floor_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__floor_divide(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::floor_divide(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_floor_divide_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::floor_divide_out(self, other, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor_floor_divide_(at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::floor_divide_(self, other);
}
} // anonymous namespace
struct structured_frac_out_functional final : public at::native::structured_frac_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_frac(const at::Tensor & self) {
structured_frac_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_frac_out_out final : public at::native::structured_frac_out {
    structured_frac_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_frac_out_out(const at::Tensor & self, at::Tensor & out) {
structured_frac_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_frac_out_inplace final : public at::native::structured_frac_out {
    structured_frac_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_frac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_frac_(at::Tensor & self) {
structured_frac_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__from_file(c10::string_view filename, c10::optional<bool> shared, c10::optional<int64_t> size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    // No device check
  // DeviceGuard omitted
  return at::native::from_file(filename, shared, size, dtype, layout, device, pin_memory);
}
} // anonymous namespace
struct structured_gcd_out_functional final : public at::native::structured_gcd_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_gcd(const at::Tensor & self, const at::Tensor & other) {
structured_gcd_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gcd_out_out final : public at::native::structured_gcd_out {
    structured_gcd_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gcd_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_gcd_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_gcd_out_inplace final : public at::native::structured_gcd_out {
    structured_gcd_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gcd_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gcd_(at::Tensor & self, const at::Tensor & other) {
structured_gcd_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lcm_out_functional final : public at::native::structured_lcm_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_lcm(const at::Tensor & self, const at::Tensor & other) {
structured_lcm_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lcm_out_out final : public at::native::structured_lcm_out {
    structured_lcm_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lcm_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_lcm_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lcm_out_inplace final : public at::native::structured_lcm_out {
    structured_lcm_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lcm_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lcm_(at::Tensor & self, const at::Tensor & other) {
structured_lcm_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__grid_sampler_2d(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
    // No device check
  // DeviceGuard omitted
  return at::native::grid_sampler_2d_cpu(input, grid, interpolation_mode, padding_mode, align_corners);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__grid_sampler_2d_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
    // No device check
  // DeviceGuard omitted
  return at::native::grid_sampler_2d_backward_cpu(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__grid_sampler_3d(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
    // No device check
  // DeviceGuard omitted
  return at::native::grid_sampler_3d_cpu(input, grid, interpolation_mode, padding_mode, align_corners);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__grid_sampler_3d_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
    // No device check
  // DeviceGuard omitted
  return at::native::grid_sampler_3d_backward_cpu(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__native_group_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, double eps) {
    // No device check
  // DeviceGuard omitted
  return at::native::native_group_norm(input, weight, bias, N.guard_int(__FILE__, __LINE__), C.guard_int(__FILE__, __LINE__), HxW.guard_int(__FILE__, __LINE__), group, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__native_group_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, ::std::array<bool,3> output_mask) {
    // No device check
  // DeviceGuard omitted
  return at::native::native_group_norm_backward(grad_out, input, mean, rstd, weight, N.guard_int(__FILE__, __LINE__), C.guard_int(__FILE__, __LINE__), HxW.guard_int(__FILE__, __LINE__), group, output_mask);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___fft_r2c(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fft_r2c_mkl(self, dim, normalization, onesided);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out__fft_r2c_out(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fft_r2c_mkl_out(self, dim, normalization, onesided, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___fft_c2r(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fft_c2r_mkl(self, dim, normalization, last_dim_size.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out__fft_c2r_out(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fft_c2r_mkl_out(self, dim, normalization, last_dim_size.guard_int(__FILE__, __LINE__), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___fft_c2c(const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fft_c2c_mkl(self, C10_AS_INTARRAYREF_SLOW(dim), normalization, forward);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out__fft_c2c_out(const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fft_c2c_mkl_out(self, C10_AS_INTARRAYREF_SLOW(dim), normalization, forward, out);
}
} // anonymous namespace
namespace {
void wrapper_CPU___validate_compressed_sparse_indices(bool is_crow, const at::Tensor & compressed_idx, const at::Tensor & plain_idx, int64_t cdim, int64_t dim, int64_t nnz) {
    // No device check
  // DeviceGuard omitted
  return at::native::_validate_compressed_sparse_indices_cpu(is_crow, compressed_idx, plain_idx, cdim, dim, nnz);
}
} // anonymous namespace
struct structured_index_out_functional final : public at::native::structured_index_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_index_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_index_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_index_Tensor(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices) {
structured_index_out_functional op;
auto precompute = op.meta(self, at::IOptTensorListRef(indices));
(void)precompute;
op.impl(self, precompute.sizes, precompute.strides, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_index_out_out final : public at::native::structured_index_out {
    structured_index_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_index_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_index_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_index_out_Tensor_out(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, at::Tensor & out) {
structured_index_out_out op(out);
auto precompute = op.meta(self, at::IOptTensorListRef(indices));
(void)precompute;
op.impl(self, precompute.sizes, precompute.strides, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_index_copy_out_functional final : public at::native::structured_index_copy_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_index_copy(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
structured_index_copy_out_functional op;
auto precompute = op.meta(self, dim, index, source);
(void)precompute;
op.impl(self, precompute.dim, index, source, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_index_copy_out_out final : public at::native::structured_index_copy_out {
    structured_index_copy_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_index_copy_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, at::Tensor & out) {
structured_index_copy_out_out op(out);
auto precompute = op.meta(self, dim, index, source);
(void)precompute;
op.impl(self, precompute.dim, index, source, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_index_copy_out_inplace final : public at::native::structured_index_copy_out {
    structured_index_copy_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_index_copy_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
structured_index_copy_out_inplace op(self);
auto precompute = op.meta(self, dim, index, source);
(void)precompute;
op.impl(self, precompute.dim, index, source, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU___index_put_impl_(at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
    // No device check
  // DeviceGuard omitted
  return at::native::_index_put_impl_(self, indices, values, accumulate, unsafe);
}
} // anonymous namespace
struct structured_isin_Tensor_Tensor_out_functional final : public at::native::structured_isin_Tensor_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_isin_Tensor_Tensor(const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert) {
structured_isin_Tensor_Tensor_out_functional op;
op.meta(elements, test_elements, assume_unique, invert);
op.impl(elements, test_elements, assume_unique, invert, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isin_Tensor_Tensor_out_out final : public at::native::structured_isin_Tensor_Tensor_out {
    structured_isin_Tensor_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_isin_out_Tensor_Tensor_out(const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert, at::Tensor & out) {
structured_isin_Tensor_Tensor_out_out op(out);
op.meta(elements, test_elements, assume_unique, invert);
op.impl(elements, test_elements, assume_unique, invert, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_isin_Tensor_Scalar_out_functional final : public at::native::structured_isin_Tensor_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_isin_Tensor_Scalar(const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert) {
structured_isin_Tensor_Scalar_out_functional op;
op.meta(elements, test_element, assume_unique, invert);
op.impl(elements, test_element, assume_unique, invert, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isin_Tensor_Scalar_out_out final : public at::native::structured_isin_Tensor_Scalar_out {
    structured_isin_Tensor_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_isin_out_Tensor_Scalar_out(const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert, at::Tensor & out) {
structured_isin_Tensor_Scalar_out_out op(out);
op.meta(elements, test_element, assume_unique, invert);
op.impl(elements, test_element, assume_unique, invert, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_isin_Scalar_Tensor_out_functional final : public at::native::structured_isin_Scalar_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_isin_Scalar_Tensor(const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert) {
structured_isin_Scalar_Tensor_out_functional op;
op.meta(element, test_elements, assume_unique, invert);
op.impl(element, test_elements, assume_unique, invert, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isin_Scalar_Tensor_out_out final : public at::native::structured_isin_Scalar_Tensor_out {
    structured_isin_Scalar_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_isin_out_Scalar_Tensor_out(const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert, at::Tensor & out) {
structured_isin_Scalar_Tensor_out_out op(out);
op.meta(element, test_elements, assume_unique, invert);
op.impl(element, test_elements, assume_unique, invert, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU__isnan(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::isnan(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_values_kthvalue_out(const at::Tensor & self, int64_t k, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    // No device check
  // DeviceGuard omitted
  return at::native::kthvalue_out_cpu(self, k, dim, keepdim, values, indices);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__native_layer_norm(const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps) {
    // No device check
  // DeviceGuard omitted
  return at::native::layer_norm_cpu(input, C10_AS_INTARRAYREF_SLOW(normalized_shape), weight, bias, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__native_layer_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, ::std::array<bool,3> output_mask) {
    // No device check
  // DeviceGuard omitted
  return at::native::layer_norm_backward_cpu(grad_out, input, C10_AS_INTARRAYREF_SLOW(normalized_shape), mean, rstd, weight, bias, output_mask);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_nan_to_num_out(const at::Tensor & self, c10::optional<double> nan, c10::optional<double> posinf, c10::optional<double> neginf, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::nan_to_num_out(self, nan, posinf, neginf, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_linspace_out(const at::Scalar & start, const at::Scalar & end, int64_t steps, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::linspace_out(start, end, steps, out);
}
} // anonymous namespace
struct structured_log_out_functional final : public at::native::structured_log_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_log(const at::Tensor & self) {
structured_log_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log_out_out final : public at::native::structured_log_out {
    structured_log_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_log_out_out(const at::Tensor & self, at::Tensor & out) {
structured_log_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log_out_inplace final : public at::native::structured_log_out {
    structured_log_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_log_(at::Tensor & self) {
structured_log_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_log10_out_functional final : public at::native::structured_log10_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_log10(const at::Tensor & self) {
structured_log10_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log10_out_out final : public at::native::structured_log10_out {
    structured_log10_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_log10_out_out(const at::Tensor & self, at::Tensor & out) {
structured_log10_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log10_out_inplace final : public at::native::structured_log10_out {
    structured_log10_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log10_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_log10_(at::Tensor & self) {
structured_log10_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_log1p_out_functional final : public at::native::structured_log1p_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_log1p(const at::Tensor & self) {
structured_log1p_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log1p_out_out final : public at::native::structured_log1p_out {
    structured_log1p_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_log1p_out_out(const at::Tensor & self, at::Tensor & out) {
structured_log1p_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log1p_out_inplace final : public at::native::structured_log1p_out {
    structured_log1p_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log1p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_log1p_(at::Tensor & self) {
structured_log1p_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_log2_out_functional final : public at::native::structured_log2_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_log2(const at::Tensor & self) {
structured_log2_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log2_out_out final : public at::native::structured_log2_out {
    structured_log2_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_log2_out_out(const at::Tensor & self, at::Tensor & out) {
structured_log2_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log2_out_inplace final : public at::native::structured_log2_out {
    structured_log2_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_log2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_log2_(at::Tensor & self) {
structured_log2_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_logaddexp_out_functional final : public at::native::structured_logaddexp_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_logaddexp(const at::Tensor & self, const at::Tensor & other) {
structured_logaddexp_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_logaddexp_out_out final : public at::native::structured_logaddexp_out {
    structured_logaddexp_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_logaddexp_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_logaddexp_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_logaddexp2_out_functional final : public at::native::structured_logaddexp2_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_logaddexp2(const at::Tensor & self, const at::Tensor & other) {
structured_logaddexp2_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_logaddexp2_out_out final : public at::native::structured_logaddexp2_out {
    structured_logaddexp2_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logaddexp2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_logaddexp2_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_logaddexp2_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_xlogy_out_functional final : public at::native::structured_xlogy_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_xlogy_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_xlogy_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_xlogy_out_out final : public at::native::structured_xlogy_out {
    structured_xlogy_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_xlogy_out_OutTensor(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_xlogy_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_xlogy_out_inplace final : public at::native::structured_xlogy_out {
    structured_xlogy_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_xlogy_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_xlogy__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_xlogy_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU_out_logspace_out(const at::Scalar & start, const at::Scalar & end, int64_t steps, double base, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::logspace_out(start, end, steps, base, out);
}
} // anonymous namespace
struct structured_log_softmax_cpu_out_functional final : public at::native::structured_log_softmax_cpu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__log_softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
structured_log_softmax_cpu_out_functional op;
op.meta(self, dim, half_to_float);
op.impl(self, dim, half_to_float, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log_softmax_cpu_out_out final : public at::native::structured_log_softmax_cpu_out {
    structured_log_softmax_cpu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__log_softmax_out_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
structured_log_softmax_cpu_out_out op(out);
op.meta(self, dim, half_to_float);
op.impl(self, dim, half_to_float, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_log_softmax_backward_cpu_out_functional final : public at::native::structured_log_softmax_backward_cpu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__log_softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
structured_log_softmax_backward_cpu_out_functional op;
op.meta(grad_output, output, dim, input_dtype);
op.impl(grad_output, output, dim, input_dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_log_softmax_backward_cpu_out_out final : public at::native::structured_log_softmax_backward_cpu_out {
    structured_log_softmax_backward_cpu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__log_softmax_backward_data_out_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & out) {
structured_log_softmax_backward_cpu_out_out op(out);
op.meta(grad_output, output, dim, input_dtype);
op.impl(grad_output, output, dim, input_dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU___logcumsumexp(const at::Tensor & self, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::_logcumsumexp_cpu(self, dim);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out__logcumsumexp_out(const at::Tensor & self, int64_t dim, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::_logcumsumexp_out_cpu(self, dim, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___aminmax(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::_aminmax_all(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_dim__aminmax(const at::Tensor & self, int64_t dim, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return at::native::_aminmax(self, dim, keepdim);
}
} // anonymous namespace
struct structured_aminmax_out_functional final : public at::native::structured_aminmax_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_aminmax(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
structured_aminmax_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_aminmax_out_out final : public at::native::structured_aminmax_out {
    structured_aminmax_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_aminmax_out_out(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & min, at::Tensor & max) {
structured_aminmax_out_out op(min, max);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(min, max);
}
namespace {
at::Tensor wrapper_CPU___compute_linear_combination(const at::Tensor & input, const at::Tensor & coefficients) {
    // No device check
  // DeviceGuard omitted
  return at::native::_compute_linear_combination(input, coefficients);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out__compute_linear_combination_out(const at::Tensor & input, const at::Tensor & coefficients, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::_compute_linear_combination_out(input, coefficients, out);
}
} // anonymous namespace
struct structured_max_out_functional final : public at::native::structured_max_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_max_dim(const at::Tensor & self, int64_t dim, bool keepdim) {
structured_max_out_functional op;
auto precompute = op.meta(self, dim, keepdim);
(void)precompute;
op.impl(self, precompute.dim, keepdim, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_max_out_out final : public at::native::structured_max_out {
    structured_max_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_max_out_dim_max(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
structured_max_out_out op(max, max_values);
auto precompute = op.meta(self, dim, keepdim);
(void)precompute;
op.impl(self, precompute.dim, keepdim, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(max, max_values);
}
struct structured_amax_out_functional final : public at::native::structured_amax_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_amax(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
structured_amax_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_amax_out_out final : public at::native::structured_amax_out {
    structured_amax_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_amax_out_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
structured_amax_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_mean_out_functional final : public at::native::structured_mean_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_mean_dim(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
structured_mean_out_functional op;
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mean_out_out final : public at::native::structured_mean_out {
    structured_mean_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_mean_out_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
structured_mean_out_out op(out);
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU__median(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::median_cpu(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_dim_values_median_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    // No device check
  // DeviceGuard omitted
  return at::native::median_out_cpu(self, dim, keepdim, values, indices);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__nanmedian(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::nanmedian_cpu(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_dim_values_nanmedian_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
    // No device check
  // DeviceGuard omitted
  return at::native::nanmedian_out_cpu(self, dim, keepdim, values, indices);
}
} // anonymous namespace
struct structured_min_out_functional final : public at::native::structured_min_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_min_dim(const at::Tensor & self, int64_t dim, bool keepdim) {
structured_min_out_functional op;
auto precompute = op.meta(self, dim, keepdim);
(void)precompute;
op.impl(self, precompute.dim, keepdim, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_min_out_out final : public at::native::structured_min_out {
    structured_min_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_min_out_dim_min(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & min, at::Tensor & min_indices) {
structured_min_out_out op(min, min_indices);
auto precompute = op.meta(self, dim, keepdim);
(void)precompute;
op.impl(self, precompute.dim, keepdim, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(min, min_indices);
}
struct structured_amin_out_functional final : public at::native::structured_amin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_amin(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
structured_amin_out_functional op;
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_amin_out_out final : public at::native::structured_amin_out {
    structured_amin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_amin_out_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
structured_amin_out_out op(out);
op.meta(self, dim, keepdim);
op.impl(self, dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__mkldnn_rnn_layer(const at::Tensor & input, const at::Tensor & weight0, const at::Tensor & weight1, const at::Tensor & weight2, const at::Tensor & weight3, const at::Tensor & hx_, const at::Tensor & cx_, bool reverse, at::IntArrayRef batch_sizes, int64_t mode, int64_t hidden_size, int64_t num_layers, bool has_biases, bool bidirectional, bool batch_first, bool train) {
    // No device check
  // DeviceGuard omitted
  return at::native::mkldnn_rnn_layer(input, weight0, weight1, weight2, weight3, hx_, cx_, reverse, batch_sizes, mode, hidden_size, num_layers, has_biases, bidirectional, batch_first, train);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__mkldnn_rnn_layer_backward(const at::Tensor & input, const at::Tensor & weight1, const at::Tensor & weight2, const at::Tensor & weight3, const at::Tensor & weight4, const at::Tensor & hx_, const at::Tensor & cx_tmp, const at::Tensor & output, const at::Tensor & hy_, const at::Tensor & cy_, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, bool reverse, int64_t mode, int64_t hidden_size, int64_t num_layers, bool has_biases, bool train, bool bidirectional, at::IntArrayRef batch_sizes, bool batch_first, const at::Tensor & workspace) {
    // No device check
  // DeviceGuard omitted
  return at::native::mkldnn_rnn_layer_backward(input, weight1, weight2, weight3, weight4, hx_, cx_tmp, output, hy_, cy_, grad_output, grad_hy, grad_cy, reverse, mode, hidden_size, num_layers, has_biases, train, bidirectional, batch_sizes, batch_first, workspace);
}
} // anonymous namespace
struct structured_mm_out_cpu_functional final : public at::native::structured_mm_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_mm(const at::Tensor & self, const at::Tensor & mat2) {
structured_mm_out_cpu_functional op;
op.meta(self, mat2);
op.impl(self, mat2, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mm_out_cpu_out final : public at::native::structured_mm_out_cpu {
    structured_mm_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_mm_out_out(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
structured_mm_out_cpu_out op(out);
op.meta(self, mat2);
op.impl(self, mat2, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__mode(const at::Tensor & self, int64_t dim, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return at::native::mode(self, dim, keepdim);
}
} // anonymous namespace
struct structured_mul_out_functional final : public at::native::structured_mul_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_mul_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_mul_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mul_out_out final : public at::native::structured_mul_out {
    structured_mul_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_mul_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_mul_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_mul_out_inplace final : public at::native::structured_mul_out {
    structured_mul_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_mul__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_mul_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU_out_mvlgamma_out(const at::Tensor & self, int64_t p, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::mvlgamma_out(self, p, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__narrow_copy(const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length) {
    // No device check
  // DeviceGuard omitted
  return at::native::narrow_copy_dense_cpu(self, dim, start.guard_int(__FILE__, __LINE__), length.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_narrow_copy_out(const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::narrow_copy_dense_cpu_out(self, dim, start.guard_int(__FILE__, __LINE__), length.guard_int(__FILE__, __LINE__), out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__native_batch_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps) {
    // No device check
  // DeviceGuard omitted
  return at::native::batch_norm_cpu(input, weight, bias, running_mean, running_var, training, momentum, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU_out_native_batch_norm_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
    // No device check
  // DeviceGuard omitted
  return at::native::batch_norm_cpu_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU_out__native_batch_norm_legit_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
    // No device check
  // DeviceGuard omitted
  return at::native::_batch_norm_legit_cpu_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU___native_batch_norm_legit(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps) {
    // No device check
  // DeviceGuard omitted
  return at::native::_batch_norm_legit_cpu(input, weight, bias, running_mean, running_var, training, momentum, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU_no_stats__native_batch_norm_legit(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps) {
    // No device check
  // DeviceGuard omitted
  return at::native::_batch_norm_legit_no_stats_cpu(input, weight, bias, training, momentum, eps);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU_no_stats_out__native_batch_norm_legit_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
    // No device check
  // DeviceGuard omitted
  return at::native::_batch_norm_legit_no_stats_cpu_out(input, weight, bias, training, momentum, eps, out, save_mean, save_invstd);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__native_batch_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_invstd, bool train, double eps, ::std::array<bool,3> output_mask) {
    // No device check
  // DeviceGuard omitted
  return at::native::batch_norm_backward_cpu(grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__batch_norm_update_stats(const at::Tensor & input, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum) {
    // No device check
  // DeviceGuard omitted
  return at::native::batch_norm_update_stats_cpu(input, running_mean, running_var, momentum);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___cdist_forward(const at::Tensor & x1, const at::Tensor & x2, double p, c10::optional<int64_t> compute_mode) {
    // No device check
  // DeviceGuard omitted
  return at::native::_cdist_forward(x1, x2, p, compute_mode);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___cdist_backward(const at::Tensor & grad, const at::Tensor & x1, const at::Tensor & x2, double p, const at::Tensor & cdist) {
    // No device check
  // DeviceGuard omitted
  return at::native::_cdist_backward(grad, x1, x2, p, cdist);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___pdist_forward(const at::Tensor & self, double p) {
    // No device check
  // DeviceGuard omitted
  return at::native::_pdist_forward(self, p);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___pdist_backward(const at::Tensor & grad, const at::Tensor & self, double p, const at::Tensor & pdist) {
    // No device check
  // DeviceGuard omitted
  return at::native::_pdist_backward(grad, self, p, pdist);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__pixel_shuffle(const at::Tensor & self, int64_t upscale_factor) {
    // No device check
  // DeviceGuard omitted
  return at::native::pixel_shuffle_cpu(self, upscale_factor);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__pixel_unshuffle(const at::Tensor & self, int64_t downscale_factor) {
    // No device check
  // DeviceGuard omitted
  return at::native::pixel_unshuffle_cpu(self, downscale_factor);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__channel_shuffle(const at::Tensor & self, c10::SymInt groups) {
    // No device check
  // DeviceGuard omitted
  return at::native::channel_shuffle(self, groups.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__native_channel_shuffle(const at::Tensor & self, c10::SymInt groups) {
    // No device check
  // DeviceGuard omitted
  return at::native::channel_shuffle_cpu(self, groups.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_generator_out_randperm_out(c10::SymInt n, c10::optional<at::Generator> generator, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::randperm_out_cpu(n.guard_int(__FILE__, __LINE__), generator, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_range_out(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::range_out(start, end, step, out);
}
} // anonymous namespace
struct structured_reciprocal_out_functional final : public at::native::structured_reciprocal_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_reciprocal(const at::Tensor & self) {
structured_reciprocal_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reciprocal_out_out final : public at::native::structured_reciprocal_out {
    structured_reciprocal_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_reciprocal_out_out(const at::Tensor & self, at::Tensor & out) {
structured_reciprocal_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_reciprocal_out_inplace final : public at::native::structured_reciprocal_out {
    structured_reciprocal_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_reciprocal_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_reciprocal_(at::Tensor & self) {
structured_reciprocal_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_neg_out_functional final : public at::native::structured_neg_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_neg(const at::Tensor & self) {
structured_neg_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_neg_out_out final : public at::native::structured_neg_out {
    structured_neg_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_neg_out_out(const at::Tensor & self, at::Tensor & out) {
structured_neg_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_neg_out_inplace final : public at::native::structured_neg_out {
    structured_neg_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_neg_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_neg_(at::Tensor & self) {
structured_neg_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU_Tensor_repeat_interleave(const at::Tensor & repeats, c10::optional<c10::SymInt> output_size) {
    // No device check
  // DeviceGuard omitted
  return at::native::repeat_interleave_cpu(repeats, output_size.has_value() ? c10::make_optional(output_size->guard_int(__FILE__, __LINE__)) : c10::nullopt);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___reshape_alias(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
    // No device check
  // DeviceGuard omitted
  return at::native::_reshape_alias(self, C10_AS_INTARRAYREF_SLOW(size), C10_AS_INTARRAYREF_SLOW(stride));
}
} // anonymous namespace
struct structured_round_out_functional final : public at::native::structured_round_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_round(const at::Tensor & self) {
structured_round_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_round_out_out final : public at::native::structured_round_out {
    structured_round_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_round_out_out(const at::Tensor & self, at::Tensor & out) {
structured_round_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_round_out_inplace final : public at::native::structured_round_out {
    structured_round_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_round_(at::Tensor & self) {
structured_round_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_round_decimals_out_functional final : public at::native::structured_round_decimals_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_round_decimals(const at::Tensor & self, int64_t decimals) {
structured_round_decimals_out_functional op;
op.meta(self, decimals);
op.impl(self, decimals, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_round_decimals_out_out final : public at::native::structured_round_decimals_out {
    structured_round_decimals_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_round_out_decimals_out(const at::Tensor & self, int64_t decimals, at::Tensor & out) {
structured_round_decimals_out_out op(out);
op.meta(self, decimals);
op.impl(self, decimals, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_round_decimals_out_inplace final : public at::native::structured_round_decimals_out {
    structured_round_decimals_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_round_decimals_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_round__decimals(at::Tensor & self, int64_t decimals) {
structured_round_decimals_out_inplace op(self);
op.meta(self, decimals);
op.impl(self, decimals, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__relu(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::relu(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__relu_(at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::relu_(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___prelu_kernel(const at::Tensor & self, const at::Tensor & weight) {
    // No device check
  // DeviceGuard omitted
  return at::native::_prelu_kernel(self, weight);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___prelu_kernel_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight) {
    // No device check
  // DeviceGuard omitted
  return at::native::_prelu_kernel_backward(grad_output, self, weight);
}
} // anonymous namespace
struct structured_gelu_out_cpu_functional final : public at::native::structured_gelu_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_gelu(const at::Tensor & self, c10::string_view approximate) {
structured_gelu_out_cpu_functional op;
op.meta(self, approximate);
op.impl(self, approximate, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gelu_out_cpu_out final : public at::native::structured_gelu_out_cpu {
    structured_gelu_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gelu_out_out(const at::Tensor & self, c10::string_view approximate, at::Tensor & out) {
structured_gelu_out_cpu_out op(out);
op.meta(self, approximate);
op.impl(self, approximate, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_gelu_out_cpu_inplace final : public at::native::structured_gelu_out_cpu {
    structured_gelu_out_cpu_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gelu_(at::Tensor & self, c10::string_view approximate) {
structured_gelu_out_cpu_inplace op(self);
op.meta(self, approximate);
op.impl(self, approximate, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_gelu_backward_out_cpu_functional final : public at::native::structured_gelu_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_backward_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_backward_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_gelu_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
structured_gelu_backward_out_cpu_functional op;
op.meta(grad_output, self, approximate);
op.impl(grad_output, self, approximate, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gelu_backward_out_cpu_out final : public at::native::structured_gelu_backward_out_cpu {
    structured_gelu_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_backward_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gelu_backward_out_cpu::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gelu_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate, at::Tensor & grad_input) {
structured_gelu_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, approximate);
op.impl(grad_output, self, approximate, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_hardshrink_out_functional final : public at::native::structured_hardshrink_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_hardshrink(const at::Tensor & self, const at::Scalar & lambd) {
structured_hardshrink_out_functional op;
op.meta(self, lambd);
op.impl(self, lambd, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hardshrink_out_out final : public at::native::structured_hardshrink_out {
    structured_hardshrink_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_hardshrink_out_out(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
structured_hardshrink_out_out op(out);
op.meta(self, lambd);
op.impl(self, lambd, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_hardshrink_backward_out_functional final : public at::native::structured_hardshrink_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_hardshrink_backward(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd) {
structured_hardshrink_backward_out_functional op;
op.meta(grad_out, self, lambd);
op.impl(grad_out, self, lambd, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hardshrink_backward_out_out final : public at::native::structured_hardshrink_backward_out {
    structured_hardshrink_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_hardshrink_backward_out_grad_input(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
structured_hardshrink_backward_out_out op(grad_input);
op.meta(grad_out, self, lambd);
op.impl(grad_out, self, lambd, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_rsqrt_out_functional final : public at::native::structured_rsqrt_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_rsqrt(const at::Tensor & self) {
structured_rsqrt_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_rsqrt_out_out final : public at::native::structured_rsqrt_out {
    structured_rsqrt_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_rsqrt_out_out(const at::Tensor & self, at::Tensor & out) {
structured_rsqrt_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_rsqrt_out_inplace final : public at::native::structured_rsqrt_out {
    structured_rsqrt_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_rsqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_rsqrt_(at::Tensor & self) {
structured_rsqrt_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_silu_out_functional final : public at::native::structured_silu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_silu(const at::Tensor & self) {
structured_silu_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_silu_out_out final : public at::native::structured_silu_out {
    structured_silu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_silu_out_out(const at::Tensor & self, at::Tensor & out) {
structured_silu_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_silu_out_inplace final : public at::native::structured_silu_out {
    structured_silu_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_silu_(at::Tensor & self) {
structured_silu_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_silu_backward_out_functional final : public at::native::structured_silu_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_silu_backward(const at::Tensor & grad_output, const at::Tensor & self) {
structured_silu_backward_out_functional op;
op.meta(grad_output, self);
op.impl(grad_output, self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_silu_backward_out_out final : public at::native::structured_silu_backward_out {
    structured_silu_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_silu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_silu_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
structured_silu_backward_out_out op(grad_input);
op.meta(grad_output, self);
op.impl(grad_output, self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_mish_out_functional final : public at::native::structured_mish_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_mish(const at::Tensor & self) {
structured_mish_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mish_out_out final : public at::native::structured_mish_out {
    structured_mish_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_mish_out_out(const at::Tensor & self, at::Tensor & out) {
structured_mish_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_mish_out_inplace final : public at::native::structured_mish_out {
    structured_mish_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mish_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_mish_(at::Tensor & self) {
structured_mish_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__mish_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::mish_backward(grad_output, self);
}
} // anonymous namespace
struct structured_sigmoid_out_functional final : public at::native::structured_sigmoid_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sigmoid(const at::Tensor & self) {
structured_sigmoid_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sigmoid_out_out final : public at::native::structured_sigmoid_out {
    structured_sigmoid_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sigmoid_out_out(const at::Tensor & self, at::Tensor & out) {
structured_sigmoid_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sigmoid_out_inplace final : public at::native::structured_sigmoid_out {
    structured_sigmoid_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sigmoid_(at::Tensor & self) {
structured_sigmoid_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__logit(const at::Tensor & self, c10::optional<double> eps) {
    // No device check
  // DeviceGuard omitted
  return at::native::logit(self, eps);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_logit_out(const at::Tensor & self, c10::optional<double> eps, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::logit_out(self, eps, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__logit_(at::Tensor & self, c10::optional<double> eps) {
    // No device check
  // DeviceGuard omitted
  return at::native::logit_(self, eps);
}
} // anonymous namespace
struct structured_sin_out_functional final : public at::native::structured_sin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sin(const at::Tensor & self) {
structured_sin_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sin_out_out final : public at::native::structured_sin_out {
    structured_sin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sin_out_out(const at::Tensor & self, at::Tensor & out) {
structured_sin_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sin_out_inplace final : public at::native::structured_sin_out {
    structured_sin_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sin_(at::Tensor & self) {
structured_sin_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_sinc_out_functional final : public at::native::structured_sinc_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sinc(const at::Tensor & self) {
structured_sinc_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sinc_out_out final : public at::native::structured_sinc_out {
    structured_sinc_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sinc_out_out(const at::Tensor & self, at::Tensor & out) {
structured_sinc_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sinc_out_inplace final : public at::native::structured_sinc_out {
    structured_sinc_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sinc_(at::Tensor & self) {
structured_sinc_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_sinh_out_functional final : public at::native::structured_sinh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sinh(const at::Tensor & self) {
structured_sinh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sinh_out_out final : public at::native::structured_sinh_out {
    structured_sinh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sinh_out_out(const at::Tensor & self, at::Tensor & out) {
structured_sinh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sinh_out_inplace final : public at::native::structured_sinh_out {
    structured_sinh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sinh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sinh_(at::Tensor & self) {
structured_sinh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_softmax_cpu_out_functional final : public at::native::structured_softmax_cpu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
structured_softmax_cpu_out_functional op;
op.meta(self, dim, half_to_float);
op.impl(self, dim, half_to_float, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softmax_cpu_out_out final : public at::native::structured_softmax_cpu_out {
    structured_softmax_cpu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__softmax_out_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
structured_softmax_cpu_out_out op(out);
op.meta(self, dim, half_to_float);
op.impl(self, dim, half_to_float, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_softmax_backward_cpu_out_functional final : public at::native::structured_softmax_backward_cpu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
structured_softmax_backward_cpu_out_functional op;
op.meta(grad_output, output, dim, input_dtype);
op.impl(grad_output, output, dim, input_dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softmax_backward_cpu_out_out final : public at::native::structured_softmax_backward_cpu_out {
    structured_softmax_backward_cpu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__softmax_backward_data_out_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & grad_input) {
structured_softmax_backward_cpu_out_out op(grad_input);
op.meta(grad_output, output, dim, input_dtype);
op.impl(grad_output, output, dim, input_dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor & wrapper_CPU_out_sspaddmm_out(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::_sspaddmm_out_only_sparse(self, mat1, mat2, beta, alpha, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___stack(at::TensorList tensors, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::_stack_cpu(tensors, dim);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out__stack_out(at::TensorList tensors, int64_t dim, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::_stack_out_cpu(tensors, dim, out);
}
} // anonymous namespace
struct structured_sum_out_functional final : public at::native::structured_sum_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sum_dim_IntList(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
structured_sum_out_functional op;
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sum_out_out final : public at::native::structured_sum_out {
    structured_sum_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sum_out_IntList_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
structured_sum_out_out op(out);
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU__nansum(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    // No device check
  // DeviceGuard omitted
  return at::native::nansum(self, dim, keepdim, dtype);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_nansum_out(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::nansum_out(self, dim, keepdim, dtype, out);
}
} // anonymous namespace
struct structured_sqrt_out_functional final : public at::native::structured_sqrt_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sqrt(const at::Tensor & self) {
structured_sqrt_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sqrt_out_out final : public at::native::structured_sqrt_out {
    structured_sqrt_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sqrt_out_out(const at::Tensor & self, at::Tensor & out) {
structured_sqrt_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sqrt_out_inplace final : public at::native::structured_sqrt_out {
    structured_sqrt_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sqrt_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sqrt_(at::Tensor & self) {
structured_sqrt_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU_correction_std(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return at::native::std(self, dim, correction, keepdim);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_correction_out_std_out(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::std_out(self, dim, correction, keepdim, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_correction_std_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return at::native::std_mean(self, dim, correction, keepdim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__prod(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    // No device check
  // DeviceGuard omitted
  return at::native::prod(self, dtype);
}
} // anonymous namespace
struct structured_prod_out_functional final : public at::native::structured_prod_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_prod_dim_int(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
structured_prod_out_functional op;
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_prod_out_out final : public at::native::structured_prod_out {
    structured_prod_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_prod_out_int_out(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
structured_prod_out_out op(out);
op.meta(self, dim, keepdim, dtype);
op.impl(self, dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_tan_out_functional final : public at::native::structured_tan_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_tan(const at::Tensor & self) {
structured_tan_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_tan_out_out final : public at::native::structured_tan_out {
    structured_tan_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_tan_out_out(const at::Tensor & self, at::Tensor & out) {
structured_tan_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_tan_out_inplace final : public at::native::structured_tan_out {
    structured_tan_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tan_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_tan_(at::Tensor & self) {
structured_tan_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_tanh_out_functional final : public at::native::structured_tanh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_tanh(const at::Tensor & self) {
structured_tanh_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_tanh_out_out final : public at::native::structured_tanh_out {
    structured_tanh_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_tanh_out_out(const at::Tensor & self, at::Tensor & out) {
structured_tanh_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_tanh_out_inplace final : public at::native::structured_tanh_out {
    structured_tanh_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_tanh_(at::Tensor & self) {
structured_tanh_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_threshold_out_functional final : public at::native::structured_threshold_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_threshold(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
structured_threshold_out_functional op;
op.meta(self, threshold, value);
op.impl(self, threshold, value, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_threshold_out_out final : public at::native::structured_threshold_out {
    structured_threshold_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_threshold_out_out(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value, at::Tensor & out) {
structured_threshold_out_out op(out);
op.meta(self, threshold, value);
op.impl(self, threshold, value, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_threshold_out_inplace final : public at::native::structured_threshold_out {
    structured_threshold_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_threshold_(at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
structured_threshold_out_inplace op(self);
op.meta(self, threshold, value);
op.impl(self, threshold, value, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_threshold_backward_out_functional final : public at::native::structured_threshold_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_threshold_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
structured_threshold_backward_out_functional op;
op.meta(grad_output, self, threshold);
op.impl(grad_output, self, threshold, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_threshold_backward_out_out final : public at::native::structured_threshold_backward_out {
    structured_threshold_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_threshold_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_threshold_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold, at::Tensor & grad_input) {
structured_threshold_backward_out_out op(grad_input);
op.meta(grad_output, self, threshold);
op.impl(grad_output, self, threshold, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor wrapper_CPU__flip(const at::Tensor & self, at::IntArrayRef dims) {
    // No device check
  // DeviceGuard omitted
  return at::native::flip(self, dims);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__roll(const at::Tensor & self, c10::SymIntArrayRef shifts, at::IntArrayRef dims) {
    // No device check
  // DeviceGuard omitted
  return at::native::roll(self, C10_AS_INTARRAYREF_SLOW(shifts), dims);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU___transform_bias_rescale_qkv(const at::Tensor & qkv, const at::Tensor & qkv_bias, int64_t num_heads) {
    // No device check
  // DeviceGuard omitted
  return at::native::transform_bias_rescale_qkv_cpu(qkv, qkv_bias, num_heads);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___nested_tensor_from_mask(const at::Tensor & t, const at::Tensor & mask, bool mask_check) {
    // No device check
  // DeviceGuard omitted
  return at::native::NestedTensor_nested_tensor_from_mask(t, mask, mask_check);
}
} // anonymous namespace
namespace {
bool wrapper_CPU___nested_tensor_from_mask_left_aligned(const at::Tensor & t, const at::Tensor & mask) {
    // No device check
  // DeviceGuard omitted
  return at::native::NestedTensor_nested_tensor_from_mask_left_aligned(t, mask);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___nested_from_padded(const at::Tensor & padded, const at::Tensor & cpu_nested_shape_example, bool fuse_transform_0213) {
    // No device check
  // DeviceGuard omitted
  return at::native::nested_from_padded_generic(padded, cpu_nested_shape_example, fuse_transform_0213);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___nested_view_from_buffer(const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets) {
    // No device check
  // DeviceGuard omitted
  return at::native::_nested_view_from_buffer(self, nested_size, nested_strides, offsets);
}
} // anonymous namespace
struct structured_trunc_out_functional final : public at::native::structured_trunc_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_trunc(const at::Tensor & self) {
structured_trunc_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_trunc_out_out final : public at::native::structured_trunc_out {
    structured_trunc_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_trunc_out_out(const at::Tensor & self, at::Tensor & out) {
structured_trunc_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_trunc_out_inplace final : public at::native::structured_trunc_out {
    structured_trunc_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_trunc_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_trunc_(at::Tensor & self) {
structured_trunc_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___unique(const at::Tensor & self, bool sorted, bool return_inverse) {
    // No device check
  // DeviceGuard omitted
  return at::native::_unique_cpu(self, sorted, return_inverse);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__unique_dim(const at::Tensor & self, int64_t dim, bool sorted, bool return_inverse, bool return_counts) {
    // No device check
  // DeviceGuard omitted
  return at::native::unique_dim_cpu(self, dim, sorted, return_inverse, return_counts);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__unique_consecutive(const at::Tensor & self, bool return_inverse, bool return_counts, c10::optional<int64_t> dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::unique_consecutive_cpu(self, return_inverse, return_counts, dim);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__unique_dim_consecutive(const at::Tensor & self, int64_t dim, bool return_inverse, bool return_counts) {
    // No device check
  // DeviceGuard omitted
  return at::native::unique_dim_consecutive_cpu(self, dim, return_inverse, return_counts);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU___unique2(const at::Tensor & self, bool sorted, bool return_inverse, bool return_counts) {
    // No device check
  // DeviceGuard omitted
  return at::native::_unique2_cpu(self, sorted, return_inverse, return_counts);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_correction_var(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return at::native::var(self, dim, correction, keepdim);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_correction_out_var_out(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::var_out(self, dim, correction, keepdim, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_correction_var_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
    // No device check
  // DeviceGuard omitted
  return at::native::var_mean(self, dim, correction, keepdim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_self_where(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::where(condition, self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_self_out_where_out(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::where_self_out(condition, self, other, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___weight_norm_interface(const at::Tensor & v, const at::Tensor & g, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::weight_norm_cpu(v, g, dim);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___weight_norm_interface_backward(const at::Tensor & grad_w, const at::Tensor & saved_v, const at::Tensor & saved_g, const at::Tensor & saved_norms, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::weight_norm_backward_cpu(grad_w, saved_v, saved_g, saved_norms, dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___efficientzerotensor(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    // No device check
  // DeviceGuard omitted
  return at::native::_efficientzerotensor(C10_AS_INTARRAYREF_SLOW(size), dtype, layout, device, pin_memory);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___standard_gamma_grad(const at::Tensor & self, const at::Tensor & output) {
    // No device check
  // DeviceGuard omitted
  return at::native::_standard_gamma_grad_cpu(self, output);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___standard_gamma(const at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::_s_gamma_cpu(self, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___dirichlet_grad(const at::Tensor & x, const at::Tensor & alpha, const at::Tensor & total) {
    // No device check
  // DeviceGuard omitted
  return at::native::_dirichlet_grad_cpu(x, alpha, total);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___sample_dirichlet(const at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::_s_dirichlet_cpu(self, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__poisson(const at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::_s_poisson_cpu(self, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__binomial(const at::Tensor & count, const at::Tensor & prob, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::_s_binomial_cpu(count, prob, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___spdiags(const at::Tensor & diagonals, const at::Tensor & offsets, at::IntArrayRef shape, c10::optional<at::Layout> layout) {
    // No device check
  // DeviceGuard omitted
  return at::native::spdiags(diagonals, offsets, shape, layout);
}
} // anonymous namespace
struct structured_norm_dtype_out_functional final : public at::native::structured_norm_dtype_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_norm_ScalarOpt_dim_dtype(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype) {
structured_norm_dtype_out_functional op;
op.meta(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, dtype);
op.impl(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_norm_dtype_out_out final : public at::native::structured_norm_dtype_out {
    structured_norm_dtype_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_norm_out_dtype_out(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype, at::Tensor & out) {
structured_norm_dtype_out_out op(out);
op.meta(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, dtype);
op.impl(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_norm_out_functional final : public at::native::structured_norm_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_norm_ScalarOpt_dim(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim) {
structured_norm_out_functional op;
op.meta(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim);
op.impl(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_norm_out_out final : public at::native::structured_norm_out {
    structured_norm_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_norm_out_out(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
structured_norm_out_out op(out);
op.meta(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim);
op.impl(self, (p.has_value() ? at::OptionalScalarRef(&(p.value())) : at::OptionalScalarRef()), dim, keepdim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_Tensor_out_frexp_out(const at::Tensor & self, at::Tensor & mantissa, at::Tensor & exponent) {
    // No device check
  // DeviceGuard omitted
  return at::native::frexp_out(self, mantissa, exponent);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__zero_(at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::zero_(self);
}
} // anonymous namespace
struct structured_sub_out_functional final : public at::native::structured_sub_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sub_Tensor(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
structured_sub_out_functional op;
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sub_out_out final : public at::native::structured_sub_out {
    structured_sub_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sub_out_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
structured_sub_out_out op(out);
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sub_out_inplace final : public at::native::structured_sub_out {
    structured_sub_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sub_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sub__Tensor(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
structured_sub_out_inplace op(self);
op.meta(self, other, alpha);
op.impl(self, other, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU_Tensor_rsub(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::rsub(self, other, alpha);
}
} // anonymous namespace
struct structured_heaviside_out_functional final : public at::native::structured_heaviside_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_heaviside(const at::Tensor & self, const at::Tensor & values) {
structured_heaviside_out_functional op;
op.meta(self, values);
op.impl(self, values, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_heaviside_out_out final : public at::native::structured_heaviside_out {
    structured_heaviside_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_heaviside_out_out(const at::Tensor & self, const at::Tensor & values, at::Tensor & out) {
structured_heaviside_out_out op(out);
op.meta(self, values);
op.impl(self, values, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_heaviside_out_inplace final : public at::native::structured_heaviside_out {
    structured_heaviside_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_heaviside_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_heaviside_(at::Tensor & self, const at::Tensor & values) {
structured_heaviside_out_inplace op(self);
op.meta(self, values);
op.impl(self, values, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_addmm_out_cpu_functional final : public at::native::structured_addmm_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_addmm(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
structured_addmm_out_cpu_functional op;
op.meta(self, mat1, mat2, beta, alpha);
op.impl(self, mat1, mat2, beta, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addmm_out_cpu_out final : public at::native::structured_addmm_out_cpu {
    structured_addmm_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_addmm_out_out(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
structured_addmm_out_cpu_out op(out);
op.meta(self, mat1, mat2, beta, alpha);
op.impl(self, mat1, mat2, beta, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addmm_out_cpu_inplace final : public at::native::structured_addmm_out_cpu {
    structured_addmm_out_cpu_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_addmm_(at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
structured_addmm_out_cpu_inplace op(self);
op.meta(self, mat1, mat2, beta, alpha);
op.impl(self, mat1, mat2, beta, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_addmm_activation_out_cpu_functional final : public at::native::structured_addmm_activation_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__addmm_activation(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu) {
structured_addmm_activation_out_cpu_functional op;
op.meta(self, mat1, mat2, beta, alpha, use_gelu);
op.impl(self, mat1, mat2, beta, alpha, use_gelu, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addmm_activation_out_cpu_out final : public at::native::structured_addmm_activation_out_cpu {
    structured_addmm_activation_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__addmm_activation_out_out(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu, at::Tensor & out) {
structured_addmm_activation_out_cpu_out op(out);
op.meta(self, mat1, mat2, beta, alpha, use_gelu);
op.impl(self, mat1, mat2, beta, alpha, use_gelu, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
int64_t wrapper_CPU__sparse_dim(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::sparse_dim_strided(self);
}
} // anonymous namespace
namespace {
int64_t wrapper_CPU__dense_dim(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::dense_dim_strided(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_sparse_dim__to_sparse(const at::Tensor & self, int64_t sparse_dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::dense_to_sparse(self, sparse_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___to_sparse(const at::Tensor & self, c10::optional<at::Layout> layout, at::OptionalIntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::dense_to_sparse(self, layout, blocksize, dense_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___to_sparse_csr(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::dense_to_sparse_csr(self, dense_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___to_sparse_csc(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::dense_to_sparse_csc(self, dense_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___to_sparse_bsr(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::dense_to_sparse_bsr(self, blocksize, dense_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___to_sparse_bsc(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::dense_to_sparse_bsc(self, blocksize, dense_dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__to_mkldnn(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    // No device check
  // DeviceGuard omitted
  return at::native::dense_to_mkldnn(self, dtype);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__quantize_per_tensor_dynamic(const at::Tensor & self, at::ScalarType dtype, bool reduce_range) {
    // No device check
  // DeviceGuard omitted
  return at::native::quantize_per_tensor_dynamic(self, dtype, reduce_range);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__quantize_per_tensor(const at::Tensor & self, double scale, int64_t zero_point, at::ScalarType dtype) {
    // No device check
  // DeviceGuard omitted
  return at::native::quantize_per_tensor(self, scale, zero_point, dtype);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_tensor_qparams_quantize_per_tensor(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, at::ScalarType dtype) {
    // No device check
  // DeviceGuard omitted
  return at::native::quantize_per_tensor_tensor_qparams(self, scale, zero_point, dtype);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_tensors_quantize_per_tensor(at::TensorList tensors, const at::Tensor & scales, const at::Tensor & zero_points, at::ScalarType dtype) {
    // No device check
  // DeviceGuard omitted
  return at::native::quantize_per_tensor_list_cpu(tensors, scales, zero_points, dtype);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__quantize_per_channel(const at::Tensor & self, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, at::ScalarType dtype) {
    // No device check
  // DeviceGuard omitted
  return at::native::quantize_per_channel(self, scales, zero_points, axis, dtype);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_self_dequantize(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::dequantize_cpu_or_cuda(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___make_per_tensor_quantized_tensor(const at::Tensor & self, double scale, int64_t zero_point) {
    // No device check
  // DeviceGuard omitted
  return at::native::make_per_tensor_quantized_tensor_cpu(self, scale, zero_point);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___make_per_channel_quantized_tensor(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis) {
    // No device check
  // DeviceGuard omitted
  return at::native::make_per_channel_quantized_tensor_cpu(self, scale, zero_point, axis);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__fake_quantize_per_tensor_affine_cachemask(const at::Tensor & self, double scale, int64_t zero_point, int64_t quant_min, int64_t quant_max) {
    // No device check
  // DeviceGuard omitted
  return at::native::fake_quantize_per_tensor_affine_cachemask(self, scale, zero_point, quant_min, quant_max);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___fake_quantize_per_tensor_affine_cachemask_tensor_qparams(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, const at::Tensor & fake_quant_enabled, int64_t quant_min, int64_t quant_max) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fake_quantize_per_tensor_affine_cachemask_tensor_qparams(self, scale, zero_point, fake_quant_enabled, quant_min, quant_max);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___fake_quantize_learnable_per_tensor_affine(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t quant_min, int64_t quant_max, double grad_factor) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fake_quantize_learnable_per_tensor_affine(self, scale, zero_point, quant_min, quant_max, grad_factor);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU___fake_quantize_learnable_per_tensor_affine_backward(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t quant_min, int64_t quant_max, double grad_factor) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fake_quantize_learnable_per_tensor_affine_backward(grad, self, scale, zero_point, quant_min, quant_max, grad_factor);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__fake_quantize_per_channel_affine_cachemask(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
    // No device check
  // DeviceGuard omitted
  return at::native::fake_quantize_per_channel_affine_cachemask(self, scale, zero_point, axis, quant_min, quant_max);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___fake_quantize_learnable_per_channel_affine(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, double grad_factor) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fake_quantize_learnable_per_channel_affine(self, scale, zero_point, axis, quant_min, quant_max, grad_factor);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU___fake_quantize_learnable_per_channel_affine_backward(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, double grad_factor) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fake_quantize_learnable_per_channel_affine_backward(grad, self, scale, zero_point, axis, quant_min, quant_max, grad_factor);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___fused_moving_avg_obs_fq_helper(const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, at::Tensor & running_min, at::Tensor & running_max, at::Tensor & scale, at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant) {
    // No device check
  // DeviceGuard omitted
  return at::native::fused_moving_avg_obs_fake_quant_cpu(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
}
} // anonymous namespace
namespace {
at::Scalar wrapper_CPU___local_scalar_dense(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::_local_scalar_dense_cpu(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_source_Storage_set_(at::Tensor & self, at::Storage source) {
    // No device check
  // DeviceGuard omitted
  return at::native::set_(self, source);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_source_Storage_storage_offset_set_(at::Tensor & self, at::Storage source, c10::SymInt storage_offset, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
    // No device check
  // DeviceGuard omitted
  return at::native::set_storage_cpu_(self, source, storage_offset.guard_int(__FILE__, __LINE__), C10_AS_INTARRAYREF_SLOW(size), C10_AS_INTARRAYREF_SLOW(stride));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_source_Tensor_set_(at::Tensor & self, const at::Tensor & source) {
    // No device check
  // DeviceGuard omitted
  return at::native::set_tensor_(self, source);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__set_(at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::set_cpu_(self);
}
} // anonymous namespace
namespace {
bool wrapper_CPU__is_set_to(const at::Tensor & self, const at::Tensor & tensor) {
    // No device check
  // DeviceGuard omitted
  return at::native::is_set_to(self, tensor);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Scalar_masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::masked_fill__cpu(self, mask, value);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor_masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::masked_fill__cpu(self, mask, value);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__masked_scatter_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & source) {
    // No device check
  // DeviceGuard omitted
  return at::native::masked_scatter__cpu(self, mask, source);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___masked_softmax(const at::Tensor & self, const at::Tensor & mask, c10::optional<int64_t> dim, c10::optional<int64_t> mask_type) {
    // No device check
  // DeviceGuard omitted
  return at::native::masked_softmax_cpu(self, mask, dim, mask_type);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___masked_softmax_backward(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & mask, c10::optional<int64_t> dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::masked_softmax_backward_cpu(grad_output, output, mask, dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__view(const at::Tensor & self, c10::SymIntArrayRef size) {
    // No device check
  // DeviceGuard omitted
  return at::native::view(self, C10_AS_INTARRAYREF_SLOW(size));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__put_(at::Tensor & self, const at::Tensor & index, const at::Tensor & source, bool accumulate) {
    // No device check
  // DeviceGuard omitted
  return at::native::put_(self, index, source, accumulate);
}
} // anonymous namespace
struct structured_index_add_cpu_out_functional final : public at::native::structured_index_add_cpu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_index_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
structured_index_add_cpu_out_functional op;
auto precompute = op.meta(self, dim, index, source, alpha);
(void)precompute;
op.impl(self, precompute.dim, index, source, alpha, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_index_add_cpu_out_out final : public at::native::structured_index_add_cpu_out {
    structured_index_add_cpu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_index_add_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha, at::Tensor & out) {
structured_index_add_cpu_out_out op(out);
auto precompute = op.meta(self, dim, index, source, alpha);
(void)precompute;
op.impl(self, precompute.dim, index, source, alpha, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_index_add_cpu_out_inplace final : public at::native::structured_index_add_cpu_out {
    structured_index_add_cpu_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_index_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
structured_index_add_cpu_out_inplace op(self);
auto precompute = op.meta(self, dim, index, source, alpha);
(void)precompute;
op.impl(self, precompute.dim, index, source, alpha, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_index_reduce_cpu_out_functional final : public at::native::structured_index_reduce_cpu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_index_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
structured_index_reduce_cpu_out_functional op;
auto precompute = op.meta(self, dim, index, source, reduce, include_self);
(void)precompute;
op.impl(self, precompute.dim, index, source, reduce, include_self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_index_reduce_cpu_out_out final : public at::native::structured_index_reduce_cpu_out {
    structured_index_reduce_cpu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_index_reduce_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self, at::Tensor & out) {
structured_index_reduce_cpu_out_out op(out);
auto precompute = op.meta(self, dim, index, source, reduce, include_self);
(void)precompute;
op.impl(self, precompute.dim, index, source, reduce, include_self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_index_reduce_cpu_out_inplace final : public at::native::structured_index_reduce_cpu_out {
    structured_index_reduce_cpu_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_index_reduce_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
structured_index_reduce_cpu_out_inplace op(self);
auto precompute = op.meta(self, dim, index, source, reduce, include_self);
(void)precompute;
op.impl(self, precompute.dim, index, source, reduce, include_self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU_int_Scalar_index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::index_fill_(self, dim, index, value);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_int_Tensor_index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::index_fill_(self, dim, index, value);
}
} // anonymous namespace
struct structured_scatter_src_out_functional final : public at::native::structured_scatter_src_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_scatter_src(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
structured_scatter_src_out_functional op;
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_src_out_out final : public at::native::structured_scatter_src_out {
    structured_scatter_src_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter_out_src_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
structured_scatter_src_out_out op(out);
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_src_out_inplace final : public at::native::structured_scatter_src_out {
    structured_scatter_src_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter__src(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
structured_scatter_src_out_inplace op(self);
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_value_out_functional final : public at::native::structured_scatter_value_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_scatter_value(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
structured_scatter_value_out_functional op;
op.meta(self, dim, index, value);
op.impl(self, dim, index, value, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_value_out_out final : public at::native::structured_scatter_value_out {
    structured_scatter_value_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter_out_value_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, at::Tensor & out) {
structured_scatter_value_out_out op(out);
op.meta(self, dim, index, value);
op.impl(self, dim, index, value, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_value_out_inplace final : public at::native::structured_scatter_value_out {
    structured_scatter_value_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter__value(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
structured_scatter_value_out_inplace op(self);
op.meta(self, dim, index, value);
op.impl(self, dim, index, value, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_reduce_out_functional final : public at::native::structured_scatter_reduce_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_scatter_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
structured_scatter_reduce_out_functional op;
op.meta(self, dim, index, src, reduce);
op.impl(self, dim, index, src, reduce, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_reduce_out_out final : public at::native::structured_scatter_reduce_out {
    structured_scatter_reduce_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter_out_reduce_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, at::Tensor & out) {
structured_scatter_reduce_out_out op(out);
op.meta(self, dim, index, src, reduce);
op.impl(self, dim, index, src, reduce, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_reduce_out_inplace final : public at::native::structured_scatter_reduce_out {
    structured_scatter_reduce_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter__reduce(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
structured_scatter_reduce_out_inplace op(self);
op.meta(self, dim, index, src, reduce);
op.impl(self, dim, index, src, reduce, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_value_reduce_out_functional final : public at::native::structured_scatter_value_reduce_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_scatter_value_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
structured_scatter_value_reduce_out_functional op;
op.meta(self, dim, index, value, reduce);
op.impl(self, dim, index, value, reduce, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_value_reduce_out_out final : public at::native::structured_scatter_value_reduce_out {
    structured_scatter_value_reduce_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter_out_value_reduce_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce, at::Tensor & out) {
structured_scatter_value_reduce_out_out op(out);
op.meta(self, dim, index, value, reduce);
op.impl(self, dim, index, value, reduce, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_value_reduce_out_inplace final : public at::native::structured_scatter_value_reduce_out {
    structured_scatter_value_reduce_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter__value_reduce(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
structured_scatter_value_reduce_out_inplace op(self);
op.meta(self, dim, index, value, reduce);
op.impl(self, dim, index, value, reduce, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_add_functional final : public at::native::structured_scatter_add {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_scatter_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
structured_scatter_add_functional op;
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_add_out final : public at::native::structured_scatter_add {
    structured_scatter_add_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter_add_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
structured_scatter_add_out op(out);
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_add_inplace final : public at::native::structured_scatter_add {
    structured_scatter_add_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
structured_scatter_add_inplace op(self);
op.meta(self, dim, index, src);
op.impl(self, dim, index, src, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_scatter_reduce_two_functional final : public at::native::structured_scatter_reduce_two {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_scatter_reduce_two(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
structured_scatter_reduce_two_functional op;
op.meta(self, dim, index, src, reduce, include_self);
op.impl(self, dim, index, src, reduce, include_self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_scatter_reduce_two_out final : public at::native::structured_scatter_reduce_two {
    structured_scatter_reduce_two_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter_reduce_out_two_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self, at::Tensor & out) {
structured_scatter_reduce_two_out op(out);
op.meta(self, dim, index, src, reduce, include_self);
op.impl(self, dim, index, src, reduce, include_self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_scatter_reduce_two_inplace final : public at::native::structured_scatter_reduce_two {
    structured_scatter_reduce_two_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_scatter_reduce__two(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
structured_scatter_reduce_two_inplace op(self);
op.meta(self, dim, index, src, reduce, include_self);
op.impl(self, dim, index, src, reduce, include_self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_eq_Scalar_out_functional final : public at::native::structured_eq_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_eq_Scalar(const at::Tensor & self, const at::Scalar & other) {
structured_eq_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_eq_Scalar_out_out final : public at::native::structured_eq_Scalar_out {
    structured_eq_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_eq_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
structured_eq_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_eq_Scalar_out_inplace final : public at::native::structured_eq_Scalar_out {
    structured_eq_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_eq__Scalar(at::Tensor & self, const at::Scalar & other) {
structured_eq_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_eq_Tensor_out_functional final : public at::native::structured_eq_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_eq_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_eq_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_eq_Tensor_out_out final : public at::native::structured_eq_Tensor_out {
    structured_eq_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_eq_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_eq_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_eq_Tensor_out_inplace final : public at::native::structured_eq_Tensor_out {
    structured_eq_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_eq_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_eq__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_eq_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_bitwise_and_out_functional final : public at::native::structured_bitwise_and_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_bitwise_and_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_bitwise_and_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_and_out_out final : public at::native::structured_bitwise_and_out {
    structured_bitwise_and_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_and_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_bitwise_and_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_and_out_inplace final : public at::native::structured_bitwise_and_out {
    structured_bitwise_and_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_and_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_and__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_bitwise_and_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_bitwise_or_out_functional final : public at::native::structured_bitwise_or_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_bitwise_or_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_bitwise_or_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_or_out_out final : public at::native::structured_bitwise_or_out {
    structured_bitwise_or_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_or_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_bitwise_or_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_or_out_inplace final : public at::native::structured_bitwise_or_out {
    structured_bitwise_or_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_or_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_or__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_bitwise_or_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_bitwise_xor_out_functional final : public at::native::structured_bitwise_xor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_bitwise_xor_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_bitwise_xor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_xor_out_out final : public at::native::structured_bitwise_xor_out {
    structured_bitwise_xor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_xor_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_bitwise_xor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_xor_out_inplace final : public at::native::structured_bitwise_xor_out {
    structured_bitwise_xor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_xor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_xor__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_bitwise_xor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU_Scalar___lshift__(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::__lshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Scalar___ilshift__(at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::__ilshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Tensor___lshift__(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::__lshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor___ilshift__(at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::__ilshift__(self, other);
}
} // anonymous namespace
struct structured_bitwise_left_shift_out_functional final : public at::native::structured_bitwise_left_shift_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_bitwise_left_shift_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_bitwise_left_shift_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_left_shift_out_out final : public at::native::structured_bitwise_left_shift_out {
    structured_bitwise_left_shift_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_left_shift_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_bitwise_left_shift_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_left_shift_out_inplace final : public at::native::structured_bitwise_left_shift_out {
    structured_bitwise_left_shift_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_left_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_left_shift__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_bitwise_left_shift_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU_Scalar___rshift__(const at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::__rshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Scalar___irshift__(at::Tensor & self, const at::Scalar & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::__irshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Tensor___rshift__(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::__rshift__(self, other);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor___irshift__(at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::__irshift__(self, other);
}
} // anonymous namespace
struct structured_bitwise_right_shift_out_functional final : public at::native::structured_bitwise_right_shift_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_bitwise_right_shift_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_bitwise_right_shift_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_bitwise_right_shift_out_out final : public at::native::structured_bitwise_right_shift_out {
    structured_bitwise_right_shift_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_right_shift_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_bitwise_right_shift_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_bitwise_right_shift_out_inplace final : public at::native::structured_bitwise_right_shift_out {
    structured_bitwise_right_shift_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_bitwise_right_shift_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_bitwise_right_shift__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_bitwise_right_shift_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_tril_cpu_functional final : public at::native::structured_tril_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_tril(const at::Tensor & self, int64_t diagonal) {
structured_tril_cpu_functional op;
op.meta(self, diagonal);
op.impl(self, diagonal, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_tril_cpu_out final : public at::native::structured_tril_cpu {
    structured_tril_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_tril_out_out(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
structured_tril_cpu_out op(out);
op.meta(self, diagonal);
op.impl(self, diagonal, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_tril_cpu_inplace final : public at::native::structured_tril_cpu {
    structured_tril_cpu_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_tril_(at::Tensor & self, int64_t diagonal) {
structured_tril_cpu_inplace op(self);
op.meta(self, diagonal);
op.impl(self, diagonal, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_triu_cpu_functional final : public at::native::structured_triu_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_triu(const at::Tensor & self, int64_t diagonal) {
structured_triu_cpu_functional op;
op.meta(self, diagonal);
op.impl(self, diagonal, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_triu_cpu_out final : public at::native::structured_triu_cpu {
    structured_triu_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_triu_out_out(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
structured_triu_cpu_out op(out);
op.meta(self, diagonal);
op.impl(self, diagonal, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_triu_cpu_inplace final : public at::native::structured_triu_cpu {
    structured_triu_cpu_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_triu_(at::Tensor & self, int64_t diagonal) {
structured_triu_cpu_inplace op(self);
op.meta(self, diagonal);
op.impl(self, diagonal, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_digamma_out_functional final : public at::native::structured_digamma_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_digamma(const at::Tensor & self) {
structured_digamma_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_digamma_out_out final : public at::native::structured_digamma_out {
    structured_digamma_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_digamma_out_out(const at::Tensor & self, at::Tensor & out) {
structured_digamma_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_digamma_out_inplace final : public at::native::structured_digamma_out {
    structured_digamma_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_digamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_digamma_(at::Tensor & self) {
structured_digamma_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lerp_Scalar_functional final : public at::native::structured_lerp_Scalar {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_lerp_Scalar(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
structured_lerp_Scalar_functional op;
op.meta(self, end, weight);
op.impl(self, end, weight, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lerp_Scalar_out final : public at::native::structured_lerp_Scalar {
    structured_lerp_Scalar_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lerp_out_Scalar_out(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight, at::Tensor & out) {
structured_lerp_Scalar_out op(out);
op.meta(self, end, weight);
op.impl(self, end, weight, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lerp_Scalar_inplace final : public at::native::structured_lerp_Scalar {
    structured_lerp_Scalar_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Scalar::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lerp__Scalar(at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
structured_lerp_Scalar_inplace op(self);
op.meta(self, end, weight);
op.impl(self, end, weight, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lerp_Tensor_functional final : public at::native::structured_lerp_Tensor {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_lerp_Tensor(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
structured_lerp_Tensor_functional op;
op.meta(self, end, weight);
op.impl(self, end, weight, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lerp_Tensor_out final : public at::native::structured_lerp_Tensor {
    structured_lerp_Tensor_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lerp_out_Tensor_out(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight, at::Tensor & out) {
structured_lerp_Tensor_out op(out);
op.meta(self, end, weight);
op.impl(self, end, weight, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lerp_Tensor_inplace final : public at::native::structured_lerp_Tensor {
    structured_lerp_Tensor_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lerp_Tensor::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lerp__Tensor(at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
structured_lerp_Tensor_inplace op(self);
op.meta(self, end, weight);
op.impl(self, end, weight, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__addbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::addbmm(self, batch1, batch2, beta, alpha);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_addbmm_out(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::addbmm_out(self, batch1, batch2, beta, alpha, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__addbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::addbmm_(self, batch1, batch2, beta, alpha);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_from_random_(at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::random_(self, from, to, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_to_random_(at::Tensor & self, int64_t to, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::random_(self, to, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__random_(at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::random_(self, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__uniform_(at::Tensor & self, double from, double to, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::uniform_(self, from, to, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__cauchy_(at::Tensor & self, double median, double sigma, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::cauchy_(self, median, sigma, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__log_normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::log_normal_(self, mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__exponential_(at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::exponential_(self, lambd, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__geometric_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::geometric_(self, p, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__tril_indices(int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    // No device check
  // DeviceGuard omitted
  return at::native::tril_indices_cpu(row, col, offset, dtype, layout, device, pin_memory);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__triu_indices(int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    // No device check
  // DeviceGuard omitted
  return at::native::triu_indices_cpu(row, col, offset, dtype, layout, device, pin_memory);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__trace(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::trace_cpu(self);
}
} // anonymous namespace
struct structured_ne_Scalar_out_functional final : public at::native::structured_ne_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_ne_Scalar(const at::Tensor & self, const at::Scalar & other) {
structured_ne_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ne_Scalar_out_out final : public at::native::structured_ne_Scalar_out {
    structured_ne_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ne_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
structured_ne_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ne_Scalar_out_inplace final : public at::native::structured_ne_Scalar_out {
    structured_ne_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ne__Scalar(at::Tensor & self, const at::Scalar & other) {
structured_ne_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_ne_Tensor_out_functional final : public at::native::structured_ne_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_ne_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_ne_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ne_Tensor_out_out final : public at::native::structured_ne_Tensor_out {
    structured_ne_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ne_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_ne_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ne_Tensor_out_inplace final : public at::native::structured_ne_Tensor_out {
    structured_ne_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ne_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ne__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_ne_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_ge_Scalar_out_functional final : public at::native::structured_ge_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_ge_Scalar(const at::Tensor & self, const at::Scalar & other) {
structured_ge_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ge_Scalar_out_out final : public at::native::structured_ge_Scalar_out {
    structured_ge_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ge_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
structured_ge_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ge_Scalar_out_inplace final : public at::native::structured_ge_Scalar_out {
    structured_ge_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ge__Scalar(at::Tensor & self, const at::Scalar & other) {
structured_ge_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_ge_Tensor_out_functional final : public at::native::structured_ge_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_ge_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_ge_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_ge_Tensor_out_out final : public at::native::structured_ge_Tensor_out {
    structured_ge_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ge_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_ge_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_ge_Tensor_out_inplace final : public at::native::structured_ge_Tensor_out {
    structured_ge_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_ge_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_ge__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_ge_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_le_Scalar_out_functional final : public at::native::structured_le_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_le_Scalar(const at::Tensor & self, const at::Scalar & other) {
structured_le_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_le_Scalar_out_out final : public at::native::structured_le_Scalar_out {
    structured_le_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_le_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
structured_le_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_le_Scalar_out_inplace final : public at::native::structured_le_Scalar_out {
    structured_le_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_le__Scalar(at::Tensor & self, const at::Scalar & other) {
structured_le_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_le_Tensor_out_functional final : public at::native::structured_le_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_le_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_le_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_le_Tensor_out_out final : public at::native::structured_le_Tensor_out {
    structured_le_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_le_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_le_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_le_Tensor_out_inplace final : public at::native::structured_le_Tensor_out {
    structured_le_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_le_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_le__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_le_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_gt_Scalar_out_functional final : public at::native::structured_gt_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_gt_Scalar(const at::Tensor & self, const at::Scalar & other) {
structured_gt_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gt_Scalar_out_out final : public at::native::structured_gt_Scalar_out {
    structured_gt_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gt_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
structured_gt_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_gt_Scalar_out_inplace final : public at::native::structured_gt_Scalar_out {
    structured_gt_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gt__Scalar(at::Tensor & self, const at::Scalar & other) {
structured_gt_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_gt_Tensor_out_functional final : public at::native::structured_gt_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_gt_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_gt_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gt_Tensor_out_out final : public at::native::structured_gt_Tensor_out {
    structured_gt_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gt_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_gt_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_gt_Tensor_out_inplace final : public at::native::structured_gt_Tensor_out {
    structured_gt_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_gt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gt__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_gt_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lt_Scalar_out_functional final : public at::native::structured_lt_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_lt_Scalar(const at::Tensor & self, const at::Scalar & other) {
structured_lt_Scalar_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lt_Scalar_out_out final : public at::native::structured_lt_Scalar_out {
    structured_lt_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lt_out_Scalar_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
structured_lt_Scalar_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lt_Scalar_out_inplace final : public at::native::structured_lt_Scalar_out {
    structured_lt_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lt__Scalar(at::Tensor & self, const at::Scalar & other) {
structured_lt_Scalar_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_lt_Tensor_out_functional final : public at::native::structured_lt_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_lt_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_lt_Tensor_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lt_Tensor_out_out final : public at::native::structured_lt_Tensor_out {
    structured_lt_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lt_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_lt_Tensor_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lt_Tensor_out_inplace final : public at::native::structured_lt_Tensor_out {
    structured_lt_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lt_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lt__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_lt_Tensor_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__take(const at::Tensor & self, const at::Tensor & index) {
    // No device check
  // DeviceGuard omitted
  return at::native::take(self, index);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_take_out(const at::Tensor & self, const at::Tensor & index, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::take_out(self, index, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__index_select(const at::Tensor & self, int64_t dim, const at::Tensor & index) {
    // No device check
  // DeviceGuard omitted
  return at::native::index_select_cpu_(self, dim, index);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_index_select_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::index_select_out_cpu_(self, dim, index, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__masked_select(const at::Tensor & self, const at::Tensor & mask) {
    // No device check
  // DeviceGuard omitted
  return at::native::masked_select_cpu(self, mask);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_masked_select_out(const at::Tensor & self, const at::Tensor & mask, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::masked_select_out_cpu(self, mask, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__nonzero(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::nonzero_cpu(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_nonzero_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::nonzero_out_cpu(self, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__nonzero_static(const at::Tensor & self, int64_t size, int64_t fill_value) {
    // No device check
  // DeviceGuard omitted
  return at::native::nonzero_static_cpu(self, size, fill_value);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_nonzero_static_out(const at::Tensor & self, int64_t size, int64_t fill_value, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::nonzero_static_out_cpu(self, size, fill_value, out);
}
} // anonymous namespace
struct structured_gather_out_functional final : public at::native::structured_gather_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_gather(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad) {
structured_gather_out_functional op;
op.meta(self, dim, index, sparse_grad);
op.impl(self, dim, index, sparse_grad, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_gather_out_out final : public at::native::structured_gather_out {
    structured_gather_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_gather_out_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad, at::Tensor & out) {
structured_gather_out_out op(out);
op.meta(self, dim, index, sparse_grad);
op.impl(self, dim, index, sparse_grad, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addcmul_out_functional final : public at::native::structured_addcmul_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_addcmul(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
structured_addcmul_out_functional op;
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addcmul_out_out final : public at::native::structured_addcmul_out {
    structured_addcmul_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_addcmul_out_out(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
structured_addcmul_out_out op(out);
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addcmul_out_inplace final : public at::native::structured_addcmul_out {
    structured_addcmul_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcmul_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_addcmul_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
structured_addcmul_out_inplace op(self);
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_addcdiv_out_functional final : public at::native::structured_addcdiv_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_addcdiv(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
structured_addcdiv_out_functional op;
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_addcdiv_out_out final : public at::native::structured_addcdiv_out {
    structured_addcdiv_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_addcdiv_out_out(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
structured_addcdiv_out_out op(out);
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_addcdiv_out_inplace final : public at::native::structured_addcdiv_out {
    structured_addcdiv_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_addcdiv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_addcdiv_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
structured_addcdiv_out_inplace op(self);
op.meta(self, tensor1, tensor2, value);
op.impl(self, tensor1, tensor2, value, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_triangular_solve_out_functional final : public at::native::structured_triangular_solve_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_triangular_solve(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular) {
structured_triangular_solve_out_functional op;
op.meta(self, A, upper, transpose, unitriangular);
op.impl(self, A, upper, transpose, unitriangular, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_triangular_solve_out_out final : public at::native::structured_triangular_solve_out {
    structured_triangular_solve_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_triangular_solve_out_X(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular, at::Tensor & X, at::Tensor & M) {
structured_triangular_solve_out_out op(X, M);
op.meta(self, A, upper, transpose, unitriangular);
op.impl(self, A, upper, transpose, unitriangular, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(X, M);
}
namespace {
at::Tensor wrapper_CPU__linalg_solve_triangular(const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular) {
    // No device check
  // DeviceGuard omitted
  return at::native::linalg_solve_triangular(self, B, upper, left, unitriangular);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_linalg_solve_triangular_out(const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::linalg_solve_triangular_out(self, B, upper, left, unitriangular, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__cholesky(const at::Tensor & self, bool upper) {
    // No device check
  // DeviceGuard omitted
  return at::native::cholesky(self, upper);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_cholesky_out(const at::Tensor & self, bool upper, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::cholesky_out(self, upper, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___cholesky_solve_helper(const at::Tensor & self, const at::Tensor & A, bool upper) {
    // No device check
  // DeviceGuard omitted
  return at::native::_cholesky_solve_helper_cpu(self, A, upper);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__cholesky_inverse(const at::Tensor & self, bool upper) {
    // No device check
  // DeviceGuard omitted
  return at::native::cholesky_inverse(self, upper);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_cholesky_inverse_out(const at::Tensor & self, bool upper, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::cholesky_inverse_out(self, upper, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__geqrf(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::geqrf(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_a_geqrf_out(const at::Tensor & self, at::Tensor & a, at::Tensor & tau) {
    // No device check
  // DeviceGuard omitted
  return at::native::geqrf_out(self, a, tau);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__ormqr(const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose) {
    // No device check
  // DeviceGuard omitted
  return at::native::ormqr(self, input2, input3, left, transpose);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_ormqr_out(const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::ormqr_out(self, input2, input3, left, transpose, out);
}
} // anonymous namespace
struct structured_lu_unpack_out_functional final : public at::native::structured_lu_unpack_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU_lu_unpack(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots) {
structured_lu_unpack_out_functional op;
op.meta(LU_data, LU_pivots, unpack_data, unpack_pivots);
op.impl(LU_data, LU_pivots, unpack_data, unpack_pivots, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured_lu_unpack_out_out final : public at::native::structured_lu_unpack_out {
    structured_lu_unpack_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU_lu_unpack_out_out(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
structured_lu_unpack_out_out op(P, L, U);
op.meta(LU_data, LU_pivots, unpack_data, unpack_pivots);
op.impl(LU_data, LU_pivots, unpack_data, unpack_pivots, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(P, L, U);
}
namespace {
at::Tensor wrapper_CPU__multinomial(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::multinomial(self, num_samples, replacement, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_multinomial_out(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::multinomial_out(self, num_samples, replacement, generator, out);
}
} // anonymous namespace
struct structured_lgamma_out_functional final : public at::native::structured_lgamma_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_lgamma(const at::Tensor & self) {
structured_lgamma_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_lgamma_out_out final : public at::native::structured_lgamma_out {
    structured_lgamma_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lgamma_out_out(const at::Tensor & self, at::Tensor & out) {
structured_lgamma_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_lgamma_out_inplace final : public at::native::structured_lgamma_out {
    structured_lgamma_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_lgamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_lgamma_(at::Tensor & self) {
structured_lgamma_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_polygamma_out_functional final : public at::native::structured_polygamma_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_polygamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_polygamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_polygamma(int64_t n, const at::Tensor & self) {
structured_polygamma_out_functional op;
op.meta(n, self);
op.impl(n, self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_polygamma_out_out final : public at::native::structured_polygamma_out {
    structured_polygamma_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_polygamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_polygamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_polygamma_out_out(int64_t n, const at::Tensor & self, at::Tensor & out) {
structured_polygamma_out_out op(out);
op.meta(n, self);
op.impl(n, self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_erfinv_out_functional final : public at::native::structured_erfinv_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_erfinv(const at::Tensor & self) {
structured_erfinv_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_erfinv_out_out final : public at::native::structured_erfinv_out {
    structured_erfinv_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_erfinv_out_out(const at::Tensor & self, at::Tensor & out) {
structured_erfinv_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_erfinv_out_inplace final : public at::native::structured_erfinv_out {
    structured_erfinv_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_erfinv_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_erfinv_(at::Tensor & self) {
structured_erfinv_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_i0_out_functional final : public at::native::structured_i0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_i0(const at::Tensor & self) {
structured_i0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_i0_out_out final : public at::native::structured_i0_out {
    structured_i0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_i0_out_out(const at::Tensor & self, at::Tensor & out) {
structured_i0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_i0_out_inplace final : public at::native::structured_i0_out {
    structured_i0_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_i0_(at::Tensor & self) {
structured_i0_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_sign_out_functional final : public at::native::structured_sign_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sign(const at::Tensor & self) {
structured_sign_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sign_out_out final : public at::native::structured_sign_out {
    structured_sign_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sign_out_out(const at::Tensor & self, at::Tensor & out) {
structured_sign_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sign_out_inplace final : public at::native::structured_sign_out {
    structured_sign_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sign_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sign_(at::Tensor & self) {
structured_sign_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_signbit_out_functional final : public at::native::structured_signbit_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_signbit_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_signbit_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_signbit(const at::Tensor & self) {
structured_signbit_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_signbit_out_out final : public at::native::structured_signbit_out {
    structured_signbit_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_signbit_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_signbit_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_signbit_out_out(const at::Tensor & self, at::Tensor & out) {
structured_signbit_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_atan2_out_functional final : public at::native::structured_atan2_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_atan2(const at::Tensor & self, const at::Tensor & other) {
structured_atan2_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_atan2_out_out final : public at::native::structured_atan2_out {
    structured_atan2_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_atan2_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_atan2_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_atan2_out_inplace final : public at::native::structured_atan2_out {
    structured_atan2_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_atan2_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_atan2_(at::Tensor & self, const at::Tensor & other) {
structured_atan2_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__histc(const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max) {
    // No device check
  // DeviceGuard omitted
  return at::native::histogram_histc(self, bins, min, max);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_histc_out(const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::histogram_histc_out(self, bins, min, max, out);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_bins_tensor_histogram(const at::Tensor & self, const at::Tensor & bins, const c10::optional<at::Tensor> & weight, bool density) {
    // No device check
  // DeviceGuard omitted
  return at::native::histogram(self, bins, weight, density);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_bins_tensor_out_histogram_out(const at::Tensor & self, const at::Tensor & bins, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & hist, at::Tensor & bin_edges) {
    // No device check
  // DeviceGuard omitted
  return at::native::histogram_out(self, bins, weight, density, hist, bin_edges);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_bin_ct_histogram(const at::Tensor & self, int64_t bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
    // No device check
  // DeviceGuard omitted
  return at::native::histogram(self, bins, range, weight, density);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_bin_ct_out_histogram_out(const at::Tensor & self, int64_t bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & hist, at::Tensor & bin_edges) {
    // No device check
  // DeviceGuard omitted
  return at::native::histogram_out(self, bins, range, weight, density, hist, bin_edges);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___histogramdd_bin_edges(const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
    // No device check
  // DeviceGuard omitted
  return at::native::histogramdd_bin_edges(self, bins, range, weight, density);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___histogramdd_from_bin_cts(const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
    // No device check
  // DeviceGuard omitted
  return at::native::_histogramdd(self, bins, range, weight, density);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___histogramdd_from_bin_tensors(const at::Tensor & self, at::TensorList bins, const c10::optional<at::Tensor> & weight, bool density) {
    // No device check
  // DeviceGuard omitted
  return at::native::_histogramdd(self, bins, weight, density);
}
} // anonymous namespace
struct structured_fmod_out_functional final : public at::native::structured_fmod_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_fmod_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_fmod_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_fmod_out_out final : public at::native::structured_fmod_out {
    structured_fmod_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_fmod_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_fmod_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_fmod_out_inplace final : public at::native::structured_fmod_out {
    structured_fmod_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmod_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_fmod__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_fmod_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_hypot_out_functional final : public at::native::structured_hypot_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_hypot(const at::Tensor & self, const at::Tensor & other) {
structured_hypot_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hypot_out_out final : public at::native::structured_hypot_out {
    structured_hypot_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_hypot_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_hypot_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_hypot_out_inplace final : public at::native::structured_hypot_out {
    structured_hypot_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hypot_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_hypot_(at::Tensor & self, const at::Tensor & other) {
structured_hypot_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_igamma_out_functional final : public at::native::structured_igamma_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_igamma(const at::Tensor & self, const at::Tensor & other) {
structured_igamma_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_igamma_out_out final : public at::native::structured_igamma_out {
    structured_igamma_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_igamma_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_igamma_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_igamma_out_inplace final : public at::native::structured_igamma_out {
    structured_igamma_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igamma_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_igamma_(at::Tensor & self, const at::Tensor & other) {
structured_igamma_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_igammac_out_functional final : public at::native::structured_igammac_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_igammac(const at::Tensor & self, const at::Tensor & other) {
structured_igammac_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_igammac_out_out final : public at::native::structured_igammac_out {
    structured_igammac_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_igammac_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_igammac_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_igammac_out_inplace final : public at::native::structured_igammac_out {
    structured_igammac_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_igammac_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_igammac_(at::Tensor & self, const at::Tensor & other) {
structured_igammac_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_nextafter_out_functional final : public at::native::structured_nextafter_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_nextafter(const at::Tensor & self, const at::Tensor & other) {
structured_nextafter_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_nextafter_out_out final : public at::native::structured_nextafter_out {
    structured_nextafter_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_nextafter_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_nextafter_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_nextafter_out_inplace final : public at::native::structured_nextafter_out {
    structured_nextafter_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_nextafter_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_nextafter_(at::Tensor & self, const at::Tensor & other) {
structured_nextafter_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_remainder_out_functional final : public at::native::structured_remainder_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_remainder_Tensor(const at::Tensor & self, const at::Tensor & other) {
structured_remainder_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_remainder_out_out final : public at::native::structured_remainder_out {
    structured_remainder_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_remainder_out_Tensor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_remainder_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_remainder_out_inplace final : public at::native::structured_remainder_out {
    structured_remainder_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_remainder_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_remainder__Tensor(at::Tensor & self, const at::Tensor & other) {
structured_remainder_out_inplace op(self);
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU_Scalar_Tensor_remainder(const at::Scalar & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::remainder(self, other);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__min(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::min(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_unary_out_min_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::min_unary_out(self, out);
}
} // anonymous namespace
struct structured_fmin_out_functional final : public at::native::structured_fmin_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_fmin(const at::Tensor & self, const at::Tensor & other) {
structured_fmin_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_fmin_out_out final : public at::native::structured_fmin_out {
    structured_fmin_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmin_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_fmin_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_fmin_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU__max(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::max(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_unary_out_max_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::max_unary_out(self, out);
}
} // anonymous namespace
struct structured_fmax_out_functional final : public at::native::structured_fmax_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmax_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmax_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_fmax(const at::Tensor & self, const at::Tensor & other) {
structured_fmax_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_fmax_out_out final : public at::native::structured_fmax_out {
    structured_fmax_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmax_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_fmax_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_fmax_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_fmax_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_maximum_out_functional final : public at::native::structured_maximum_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_maximum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_maximum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_maximum(const at::Tensor & self, const at::Tensor & other) {
structured_maximum_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_maximum_out_out final : public at::native::structured_maximum_out {
    structured_maximum_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_maximum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_maximum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_maximum_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_maximum_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_minimum_out_functional final : public at::native::structured_minimum_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_minimum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_minimum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_minimum(const at::Tensor & self, const at::Tensor & other) {
structured_minimum_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_minimum_out_out final : public at::native::structured_minimum_out {
    structured_minimum_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_minimum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_minimum_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_minimum_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_minimum_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_sort_stable_out_functional final : public at::native::structured_sort_stable_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_sort_stable(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending) {
structured_sort_stable_out_functional op;
op.meta(self, stable, dim, descending);
op.impl(self, stable, dim, descending, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_sort_stable_out_out final : public at::native::structured_sort_stable_out {
    structured_sort_stable_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_sort_out_values_stable(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending, at::Tensor & values, at::Tensor & indices) {
structured_sort_stable_out_out op(values, indices);
op.meta(self, stable, dim, descending);
op.impl(self, stable, dim, descending, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(values, indices);
}
namespace {
at::Tensor wrapper_CPU_stable_argsort(const at::Tensor & self, bool stable, int64_t dim, bool descending) {
    // No device check
  // DeviceGuard omitted
  return at::native::argsort_stable(self, stable, dim, descending);
}
} // anonymous namespace
struct structured_topk_out_cpu_functional final : public at::native::structured_topk_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_topk(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) {
structured_topk_out_cpu_functional op;
op.meta(self, k, dim, largest, sorted);
op.impl(self, k, dim, largest, sorted, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_topk_out_cpu_out final : public at::native::structured_topk_out_cpu {
    structured_topk_out_cpu_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_topk_out_values(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted, at::Tensor & values, at::Tensor & indices) {
structured_topk_out_cpu_out op(values, indices);
op.meta(self, k, dim, largest, sorted);
op.impl(self, k, dim, largest, sorted, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(values, indices);
}
struct structured_all_all_out_functional final : public at::native::structured_all_all_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_all(const at::Tensor & self) {
structured_all_all_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_all_all_out_out final : public at::native::structured_all_all_out {
    structured_all_all_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_all_out_all_out(const at::Tensor & self, at::Tensor & out) {
structured_all_all_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_any_all_out_functional final : public at::native::structured_any_all_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_any(const at::Tensor & self) {
structured_any_all_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_any_all_out_out final : public at::native::structured_any_all_out {
    structured_any_all_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_any_out_all_out(const at::Tensor & self, at::Tensor & out) {
structured_any_all_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_renorm_out_functional final : public at::native::structured_renorm_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_renorm(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
structured_renorm_out_functional op;
op.meta(self, p, dim, maxnorm);
op.impl(self, p, dim, maxnorm, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_renorm_out_out final : public at::native::structured_renorm_out {
    structured_renorm_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_renorm_out_out(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm, at::Tensor & out) {
structured_renorm_out_out op(out);
op.meta(self, p, dim, maxnorm);
op.impl(self, p, dim, maxnorm, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_renorm_out_inplace final : public at::native::structured_renorm_out {
    structured_renorm_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_renorm_(at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
structured_renorm_out_inplace op(self);
op.meta(self, p, dim, maxnorm);
op.impl(self, p, dim, maxnorm, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor wrapper_CPU__unfold(const at::Tensor & self, int64_t dimension, int64_t size, int64_t step) {
    // No device check
  // DeviceGuard omitted
  return at::native::unfold(self, dimension, size, step);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__unfold_backward(const at::Tensor & grad_in, c10::SymIntArrayRef input_sizes, int64_t dim, int64_t size, int64_t step) {
    // No device check
  // DeviceGuard omitted
  return at::native::unfold_backward(grad_in, C10_AS_INTARRAYREF_SLOW(input_sizes), dim, size, step);
}
} // anonymous namespace
namespace {
bool wrapper_CPU__equal(const at::Tensor & self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::cpu_equal(self, other);
}
} // anonymous namespace
struct structured_pow_Tensor_Tensor_out_functional final : public at::native::structured_pow_Tensor_Tensor_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_pow_Tensor_Tensor(const at::Tensor & self, const at::Tensor & exponent) {
structured_pow_Tensor_Tensor_out_functional op;
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_pow_Tensor_Tensor_out_out final : public at::native::structured_pow_Tensor_Tensor_out {
    structured_pow_Tensor_Tensor_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_pow_out_Tensor_Tensor_out(const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
structured_pow_Tensor_Tensor_out_out op(out);
op.meta(self, exponent);
op.impl(self, exponent, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_pow_Tensor_Tensor_out_inplace final : public at::native::structured_pow_Tensor_Tensor_out {
    structured_pow_Tensor_Tensor_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Tensor_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_pow__Tensor(at::Tensor & self, const at::Tensor & exponent) {
structured_pow_Tensor_Tensor_out_inplace op(self);
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_pow_Scalar_out_functional final : public at::native::structured_pow_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_pow_Scalar(const at::Scalar & self, const at::Tensor & exponent) {
structured_pow_Scalar_out_functional op;
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_pow_Scalar_out_out final : public at::native::structured_pow_Scalar_out {
    structured_pow_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_pow_out_Scalar_out(const at::Scalar & self, const at::Tensor & exponent, at::Tensor & out) {
structured_pow_Scalar_out_out op(out);
op.meta(self, exponent);
op.impl(self, exponent, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_pow_Tensor_Scalar_out_functional final : public at::native::structured_pow_Tensor_Scalar_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_pow_Tensor_Scalar(const at::Tensor & self, const at::Scalar & exponent) {
structured_pow_Tensor_Scalar_out_functional op;
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_pow_Tensor_Scalar_out_out final : public at::native::structured_pow_Tensor_Scalar_out {
    structured_pow_Tensor_Scalar_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_pow_out_Tensor_Scalar_out(const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
structured_pow_Tensor_Scalar_out_out op(out);
op.meta(self, exponent);
op.impl(self, exponent, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_pow_Tensor_Scalar_out_inplace final : public at::native::structured_pow_Tensor_Scalar_out {
    structured_pow_Tensor_Scalar_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_pow_Tensor_Scalar_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_pow__Scalar(at::Tensor & self, const at::Scalar & exponent) {
structured_pow_Tensor_Scalar_out_inplace op(self);
op.meta(self, exponent);
op.impl(self, exponent, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
namespace {
at::Tensor & wrapper_CPU__normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::normal_(self, mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Tensor_float_normal(const at::Tensor & mean, double std, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::normal(mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor_float_out_normal_out(const at::Tensor & mean, double std, c10::optional<at::Generator> generator, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::normal_out(mean, std, generator, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_float_Tensor_normal(double mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::normal(mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_float_Tensor_out_normal_out(double mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::normal_out(mean, std, generator, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Tensor_Tensor_normal(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::normal(mean, std, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor_Tensor_out_normal_out(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::normal_out(mean, std, generator, out);
}
} // anonymous namespace
namespace {
void wrapper_CPU___amp_foreach_non_finite_check_and_unscale_(at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale) {
    // No device check
  // DeviceGuard omitted
  return at::native::_amp_foreach_non_finite_check_and_unscale_cpu_(self, found_inf, inv_scale);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU___amp_update_scale_(at::Tensor & self, at::Tensor & growth_tracker, const at::Tensor & found_inf, double scale_growth_factor, double scale_backoff_factor, int64_t growth_interval) {
    // No device check
  // DeviceGuard omitted
  return at::native::_amp_update_scale_cpu_(self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_add(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_add_scalar_kernel_slow(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_add_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_add_scalar_kernel_slow_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_add(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_add_list_kernel_slow(self, other, alpha);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_add_(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_add_list_kernel_slow_(self, other, alpha);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_add(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_add_scalarlist_kernel_slow(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_add_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_add_scalarlist_kernel_slow_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Tensor__foreach_add(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_add_tensor_kernel_slow(self, other, alpha);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Tensor__foreach_add_(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_add_tensor_kernel_slow_(self, other, alpha);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_sub(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sub_scalar_kernel_slow(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_sub_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sub_scalar_kernel_slow_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_sub(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sub_list_kernel_slow(self, other, alpha);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_sub_(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sub_list_kernel_slow_(self, other, alpha);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_sub(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sub_scalarlist_kernel_slow(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_sub_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sub_scalarlist_kernel_slow_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_mul(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_mul_scalar_kernel_slow(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_mul_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_mul_scalar_kernel_slow_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_mul(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_mul_list_kernel_slow(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_mul_(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_mul_list_kernel_slow_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_mul(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_mul_scalarlist_kernel_slow(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_mul_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_mul_scalarlist_kernel_slow_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Tensor__foreach_mul(at::TensorList self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_mul_tensor_kernel_slow(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Tensor__foreach_mul_(at::TensorList self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_mul_tensor_kernel_slow_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_div(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_div_scalar_kernel_slow(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_div_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_div_scalar_kernel_slow_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_div(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_div_list_kernel_slow(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_div_(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_div_list_kernel_slow_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_div(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_div_scalarlist_kernel_slow(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_div_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_div_scalarlist_kernel_slow_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Tensor__foreach_div(at::TensorList self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_div_tensor_kernel_slow(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Tensor__foreach_div_(at::TensorList self, const at::Tensor & other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_div_tensor_kernel_slow_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_clamp_max(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_scalar_kernel_slow(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_clamp_max_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_scalar_kernel_slow_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_clamp_max(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_list_kernel_slow(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_clamp_max_(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_list_kernel_slow_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_clamp_max(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_scalarlist_kernel_slow(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_clamp_max_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_scalarlist_kernel_slow_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_clamp_min(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_scalar_kernel_slow(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_clamp_min_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_scalar_kernel_slow_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_clamp_min(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_list_kernel_slow(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_clamp_min_(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_list_kernel_slow_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_clamp_min(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_scalarlist_kernel_slow(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_clamp_min_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_scalarlist_kernel_slow_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_maximum(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_scalar_kernel_slow(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_maximum_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_scalar_kernel_slow_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_maximum(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_list_kernel_slow(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_maximum_(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_list_kernel_slow_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_maximum(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_scalarlist_kernel_slow(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_maximum_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_min_scalarlist_kernel_slow_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_minimum(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_scalar_kernel_slow(self, scalar);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_minimum_(at::TensorList self, const at::Scalar & scalar) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_scalar_kernel_slow_(self, scalar);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_minimum(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_list_kernel_slow(self, other);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_minimum_(at::TensorList self, at::TensorList other) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_list_kernel_slow_(self, other);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_minimum(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_scalarlist_kernel_slow(self, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_minimum_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_clamp_max_scalarlist_kernel_slow_(self, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcdiv_scalar_slow(self, tensor1, tensor2, value);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcdiv_scalar_slow_(self, tensor1, tensor2, value);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcdiv_scalarlist_slow(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcdiv_scalarlist_slow_(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Tensor__foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcdiv_tensor_slow(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Tensor__foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcdiv_tensor_slow_(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcmul_scalar_slow(self, tensor1, tensor2, value);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcmul_scalar_slow_(self, tensor1, tensor2, value);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcmul_scalarlist_slow(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcmul_scalarlist_slow_(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Tensor__foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcmul_tensor_slow(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Tensor__foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_addcmul_tensor_slow_(self, tensor1, tensor2, scalars);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_abs(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_abs_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_abs_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_abs_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_acos(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_acos_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_acos_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_acos_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_asin(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_asin_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_asin_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_asin_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_atan(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_atan_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_atan_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_atan_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_ceil(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_ceil_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_ceil_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_ceil_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_cos(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_cos_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_cos_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_cos_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_cosh(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_cosh_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_cosh_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_cosh_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_erf(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_erf_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_erf_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_erf_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_erfc(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_erfc_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_erfc_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_erfc_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_exp(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_exp_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_exp_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_exp_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_expm1(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_expm1_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_expm1_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_expm1_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_floor(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_floor_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_floor_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_floor_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_frac(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_frac_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_frac_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_frac_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_lerp(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_ternary_lerp_slow(self, tensors1, weights);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_lerp_(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_ternary_lerp_slow_(self, tensors1, weights);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_lerp(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_lerp_list_kernel_slow(self, tensors1, weight);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_lerp_(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_lerp_list_kernel_slow_(self, tensors1, weight);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_lgamma(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_lgamma_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_lgamma_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_lgamma_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_log(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_log_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_log_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_log_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_log10(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_log10_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_log10_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_log10_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_log1p(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_log1p_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_log1p_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_log1p_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_log2(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_log2_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_log2_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_log2_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_neg(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_neg_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_neg_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_neg_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_norm(at::TensorList self, const at::Scalar & ord) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_norm_slow(self, ord);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_List__foreach_pow(at::TensorList self, at::TensorList exponent) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_pow_list_kernel_slow(self, exponent);
}
} // anonymous namespace
namespace {
void wrapper_CPU_List__foreach_pow_(at::TensorList self, at::TensorList exponent) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_pow_list_kernel_slow_(self, exponent);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_Scalar__foreach_pow(at::TensorList self, const at::Scalar & exponent) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_pow_scalar_kernel_slow(self, exponent);
}
} // anonymous namespace
namespace {
void wrapper_CPU_Scalar__foreach_pow_(at::TensorList self, const at::Scalar & exponent) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_pow_scalar_kernel_slow_(self, exponent);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarList__foreach_pow(at::TensorList self, at::ArrayRef<at::Scalar> exponent) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_pow_scalarlist_kernel_slow(self, exponent);
}
} // anonymous namespace
namespace {
void wrapper_CPU_ScalarList__foreach_pow_(at::TensorList self, at::ArrayRef<at::Scalar> exponent) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_pow_scalarlist_kernel_slow_(self, exponent);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU_ScalarAndTensor__foreach_pow(const at::Scalar & self, at::TensorList exponent) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_scalar_pow_list_kernel_slow(self, exponent);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_reciprocal(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_reciprocal_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_reciprocal_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_reciprocal_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_round(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_round_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_round_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_round_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_sigmoid(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sigmoid_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_sigmoid_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sigmoid_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_sign(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sign_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_sign_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sign_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_sin(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sin_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_sin_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sin_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_sinh(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sinh_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_sinh_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sinh_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_sqrt(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sqrt_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_sqrt_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_sqrt_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_tan(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_tan_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_tan_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_tan_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_tanh(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_tanh_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_tanh_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_tanh_slow_(self);
}
} // anonymous namespace
namespace {
::std::vector<at::Tensor> wrapper_CPU___foreach_trunc(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_trunc_slow(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_trunc_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_trunc_slow_(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_zero_(at::TensorList self) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_zero_slow_(self);
}
} // anonymous namespace
namespace {
void wrapper_CPU___foreach_copy_(at::TensorList self, at::TensorList src, bool non_blocking) {
    // No device check
  // DeviceGuard omitted
  return at::native::foreach_tensor_copy_list_kernel_slow_(self, src, non_blocking);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Tensor_bucketize(const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right) {
    // No device check
  // DeviceGuard omitted
  return at::native::bucketize_cpu(self, boundaries, out_int32, right);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor_out_bucketize_out(const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::bucketize_out_cpu(self, boundaries, out_int32, right, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Scalar_bucketize(const at::Scalar & self, const at::Tensor & boundaries, bool out_int32, bool right) {
    // No device check
  // DeviceGuard omitted
  return at::native::bucketize_cpu(self, boundaries, out_int32, right);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Tensor_searchsorted(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
    // No device check
  // DeviceGuard omitted
  return at::native::searchsorted_cpu(sorted_sequence, self, out_int32, right, side, sorter);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Tensor_out_searchsorted_out(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::searchsorted_out_cpu(sorted_sequence, self, out_int32, right, side, sorter, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU_Scalar_searchsorted(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
    // No device check
  // DeviceGuard omitted
  return at::native::searchsorted_cpu(sorted_sequence, self, out_int32, right, side, sorter);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_Scalar_out_searchsorted_out(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::searchsorted_out_cpu(sorted_sequence, self, out_int32, right, side, sorter, out);
}
} // anonymous namespace
struct structured__convert_indices_from_coo_to_csr_structured_cpu_functional final : public at::native::structured__convert_indices_from_coo_to_csr_structured_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__convert_indices_from_coo_to_csr(const at::Tensor & self, int64_t size, bool out_int32) {
structured__convert_indices_from_coo_to_csr_structured_cpu_functional op;
op.meta(self, size, out_int32);
op.impl(self, size, out_int32, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__convert_indices_from_coo_to_csr_structured_cpu_out final : public at::native::structured__convert_indices_from_coo_to_csr_structured_cpu {
    structured__convert_indices_from_coo_to_csr_structured_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__convert_indices_from_coo_to_csr_out_out(const at::Tensor & self, int64_t size, bool out_int32, at::Tensor & out) {
structured__convert_indices_from_coo_to_csr_structured_cpu_out op(out);
op.meta(self, size, out_int32);
op.impl(self, size, out_int32, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__convert_indices_from_csr_to_coo_structured_cpu_functional final : public at::native::structured__convert_indices_from_csr_to_coo_structured_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__convert_indices_from_csr_to_coo(const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose) {
structured__convert_indices_from_csr_to_coo_structured_cpu_functional op;
op.meta(crow_indices, col_indices, out_int32, transpose);
op.impl(crow_indices, col_indices, out_int32, transpose, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__convert_indices_from_csr_to_coo_structured_cpu_out final : public at::native::structured__convert_indices_from_csr_to_coo_structured_cpu {
    structured__convert_indices_from_csr_to_coo_structured_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__convert_indices_from_csr_to_coo_out_out(const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose, at::Tensor & out) {
structured__convert_indices_from_csr_to_coo_structured_cpu_out op(out);
op.meta(crow_indices, col_indices, out_int32, transpose);
op.impl(crow_indices, col_indices, out_int32, transpose, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_mse_loss_out_functional final : public at::native::structured_mse_loss_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mse_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mse_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_mse_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
structured_mse_loss_out_functional op;
op.meta(self, target, reduction);
op.impl(self, target, reduction, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_mse_loss_out_out final : public at::native::structured_mse_loss_out {
    structured_mse_loss_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mse_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_mse_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_mse_loss_out_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & out) {
structured_mse_loss_out_out op(out);
op.meta(self, target, reduction);
op.impl(self, target, reduction, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU__mse_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
    // No device check
  // DeviceGuard omitted
  return at::native::mse_loss_backward(grad_output, self, target, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_mse_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::mse_loss_backward_out(grad_output, self, target, reduction, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__multi_margin_loss(const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    // No device check
  // DeviceGuard omitted
  return at::native::multi_margin_loss_cpu(self, target, p, margin, weight, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_multi_margin_loss_out(const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::multi_margin_loss_cpu_out(self, target, p, margin, weight, reduction, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__multi_margin_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    // No device check
  // DeviceGuard omitted
  return at::native::multi_margin_loss_cpu_backward(grad_output, self, target, p, margin, weight, reduction);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_multi_margin_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::multi_margin_loss_cpu_backward_out(grad_output, self, target, p, margin, weight, reduction, grad_input);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__multilabel_margin_loss_forward(const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
    // No device check
  // DeviceGuard omitted
  return at::native::multilabel_margin_loss_forward_cpu(self, target, reduction);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_output_multilabel_margin_loss_forward_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & output, at::Tensor & is_target) {
    // No device check
  // DeviceGuard omitted
  return at::native::multilabel_margin_loss_forward_out_cpu(self, target, reduction, output, is_target);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__multilabel_margin_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target) {
    // No device check
  // DeviceGuard omitted
  return at::native::multilabel_margin_loss_backward_cpu(grad_output, self, target, reduction, is_target);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_multilabel_margin_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::multilabel_margin_loss_backward_cpu_out(grad_output, self, target, reduction, is_target, grad_input);
}
} // anonymous namespace
struct structured_nll_loss_forward_out_cpu_functional final : public at::native::structured_nll_loss_forward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_nll_loss_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
structured_nll_loss_forward_out_cpu_functional op;
op.meta(self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index);
op.impl(self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_nll_loss_forward_out_cpu_out final : public at::native::structured_nll_loss_forward_out_cpu {
    structured_nll_loss_forward_out_cpu_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_nll_loss_forward_out_output(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, at::Tensor & output, at::Tensor & total_weight) {
structured_nll_loss_forward_out_cpu_out op(output, total_weight);
op.meta(self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index);
op.impl(self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(output, total_weight);
}
struct structured_nll_loss_backward_out_cpu_functional final : public at::native::structured_nll_loss_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_nll_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
structured_nll_loss_backward_out_cpu_functional op;
op.meta(grad_output, self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, total_weight);
op.impl(grad_output, self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, total_weight, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_nll_loss_backward_out_cpu_out final : public at::native::structured_nll_loss_backward_out_cpu {
    structured_nll_loss_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_nll_loss_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
structured_nll_loss_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, total_weight);
op.impl(grad_output, self, target, ((weight.has_value() && (*weight).defined()) ? at::OptionalTensorRef(*weight) : at::OptionalTensorRef()), reduction, ignore_index, total_weight, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__nll_loss2d_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
    // No device check
  // DeviceGuard omitted
  return at::native::nll_loss2d_forward_cpu(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__));
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_output_nll_loss2d_forward_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, at::Tensor & output, at::Tensor & total_weight) {
    // No device check
  // DeviceGuard omitted
  return at::native::nll_loss2d_forward_out_cpu(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), output, total_weight);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__nll_loss2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
    // No device check
  // DeviceGuard omitted
  return at::native::nll_loss2d_backward_cpu(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_nll_loss2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::nll_loss2d_backward_out_cpu(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight, grad_input);
}
} // anonymous namespace
struct structured_smooth_l1_loss_out_functional final : public at::native::structured_smooth_l1_loss_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_smooth_l1_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_smooth_l1_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_smooth_l1_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
structured_smooth_l1_loss_out_functional op;
op.meta(self, target, reduction, beta);
op.impl(self, target, reduction, beta, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_smooth_l1_loss_out_out final : public at::native::structured_smooth_l1_loss_out {
    structured_smooth_l1_loss_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_smooth_l1_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_smooth_l1_loss_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_smooth_l1_loss_out_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & out) {
structured_smooth_l1_loss_out_out op(out);
op.meta(self, target, reduction, beta);
op.impl(self, target, reduction, beta, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor & wrapper_CPU_grad_input_smooth_l1_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::smooth_l1_loss_backward_out(grad_output, self, target, reduction, beta, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__huber_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta) {
    // No device check
  // DeviceGuard omitted
  return at::native::huber_loss(self, target, reduction, delta);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_huber_loss_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::huber_loss_out(self, target, reduction, delta, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_huber_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::huber_loss_backward_out(grad_output, self, target, reduction, delta, grad_input);
}
} // anonymous namespace
struct structured_elu_out_functional final : public at::native::structured_elu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_elu(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
structured_elu_out_functional op;
op.meta(self, alpha, scale, input_scale);
op.impl(self, alpha, scale, input_scale, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_elu_out_out final : public at::native::structured_elu_out {
    structured_elu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_elu_out_out(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, at::Tensor & out) {
structured_elu_out_out op(out);
op.meta(self, alpha, scale, input_scale);
op.impl(self, alpha, scale, input_scale, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_elu_out_inplace final : public at::native::structured_elu_out {
    structured_elu_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_elu_(at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
structured_elu_out_inplace op(self);
op.meta(self, alpha, scale, input_scale);
op.impl(self, alpha, scale, input_scale, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_elu_backward_out_functional final : public at::native::structured_elu_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_elu_backward(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
structured_elu_backward_out_functional op;
op.meta(grad_output, alpha, scale, input_scale, is_result, self_or_result);
op.impl(grad_output, alpha, scale, input_scale, is_result, self_or_result, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_elu_backward_out_out final : public at::native::structured_elu_backward_out {
    structured_elu_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_elu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_elu_backward_out_grad_input(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result, at::Tensor & grad_input) {
structured_elu_backward_out_out op(grad_input);
op.meta(grad_output, alpha, scale, input_scale, is_result, self_or_result);
op.impl(grad_output, alpha, scale, input_scale, is_result, self_or_result, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_glu_out_functional final : public at::native::structured_glu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_glu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_glu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_glu(const at::Tensor & self, int64_t dim) {
structured_glu_out_functional op;
op.meta(self, dim);
op.impl(self, dim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_glu_out_out final : public at::native::structured_glu_out {
    structured_glu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_glu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_glu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_glu_out_out(const at::Tensor & self, int64_t dim, at::Tensor & out) {
structured_glu_out_out op(out);
op.meta(self, dim);
op.impl(self, dim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU__glu_backward(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::glu_backward_cpu(grad_output, self, dim);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_glu_backward_out(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::glu_backward_cpu_out(grad_output, self, dim, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__glu_jvp(const at::Tensor & glu, const at::Tensor & x, const at::Tensor & dx, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::glu_jvp(glu, x, dx, dim);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__glu_backward_jvp(const at::Tensor & grad_x, const at::Tensor & grad_glu, const at::Tensor & x, const at::Tensor & dgrad_glu, const at::Tensor & dx, int64_t dim) {
    // No device check
  // DeviceGuard omitted
  return at::native::glu_backward_jvp(grad_x, grad_glu, x, dgrad_glu, dx, dim);
}
} // anonymous namespace
struct structured_hardsigmoid_out_functional final : public at::native::structured_hardsigmoid_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_hardsigmoid(const at::Tensor & self) {
structured_hardsigmoid_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hardsigmoid_out_out final : public at::native::structured_hardsigmoid_out {
    structured_hardsigmoid_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_hardsigmoid_out_out(const at::Tensor & self, at::Tensor & out) {
structured_hardsigmoid_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_hardsigmoid_out_inplace final : public at::native::structured_hardsigmoid_out {
    structured_hardsigmoid_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_hardsigmoid_(at::Tensor & self) {
structured_hardsigmoid_out_inplace op(self);
op.meta(self);
op.impl(self, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_hardsigmoid_backward_out_functional final : public at::native::structured_hardsigmoid_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_hardsigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self) {
structured_hardsigmoid_backward_out_functional op;
op.meta(grad_output, self);
op.impl(grad_output, self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_hardsigmoid_backward_out_out final : public at::native::structured_hardsigmoid_backward_out {
    structured_hardsigmoid_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_hardsigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_hardsigmoid_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
structured_hardsigmoid_backward_out_out op(grad_input);
op.meta(grad_output, self);
op.impl(grad_output, self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor wrapper_CPU__hardtanh(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
    // No device check
  // DeviceGuard omitted
  return at::native::hardtanh(self, min_val, max_val);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_hardtanh_out(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::hardtanh_out(self, min_val, max_val, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__hardtanh_(at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
    // No device check
  // DeviceGuard omitted
  return at::native::hardtanh_(self, min_val, max_val);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__hardtanh_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
    // No device check
  // DeviceGuard omitted
  return at::native::hardtanh_backward(grad_output, self, min_val, max_val);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_hardtanh_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::hardtanh_backward_out(grad_output, self, min_val, max_val, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__hardswish(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::hardswish(self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_hardswish_out(const at::Tensor & self, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::hardswish_out(self, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__hardswish_(at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::hardswish_(self);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__hardswish_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::hardswish_backward(grad_output, self);
}
} // anonymous namespace
struct structured_leaky_relu_out_functional final : public at::native::structured_leaky_relu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_leaky_relu(const at::Tensor & self, const at::Scalar & negative_slope) {
structured_leaky_relu_out_functional op;
op.meta(self, negative_slope);
op.impl(self, negative_slope, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_leaky_relu_out_out final : public at::native::structured_leaky_relu_out {
    structured_leaky_relu_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_leaky_relu_out_out(const at::Tensor & self, const at::Scalar & negative_slope, at::Tensor & out) {
structured_leaky_relu_out_out op(out);
op.meta(self, negative_slope);
op.impl(self, negative_slope, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_leaky_relu_out_inplace final : public at::native::structured_leaky_relu_out {
    structured_leaky_relu_out_inplace(Tensor& self) : outputs_{std::ref(self)} {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        check_inplace(out, sizes, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_leaky_relu_(at::Tensor & self, const at::Scalar & negative_slope) {
structured_leaky_relu_out_inplace op(self);
op.meta(self, negative_slope);
op.impl(self, negative_slope, op.outputs_[0]);
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return self;
}
struct structured_leaky_relu_backward_out_functional final : public at::native::structured_leaky_relu_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_leaky_relu_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
structured_leaky_relu_backward_out_functional op;
op.meta(grad_output, self, negative_slope, self_is_result);
op.impl(grad_output, self, negative_slope, self_is_result, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_leaky_relu_backward_out_out final : public at::native::structured_leaky_relu_backward_out {
    structured_leaky_relu_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_leaky_relu_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_leaky_relu_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result, at::Tensor & grad_input) {
structured_leaky_relu_backward_out_out op(grad_input);
op.meta(grad_output, self, negative_slope, self_is_result);
op.impl(grad_output, self, negative_slope, self_is_result, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__log_sigmoid_forward(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::log_sigmoid_forward_cpu(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_output_log_sigmoid_forward_out(const at::Tensor & self, at::Tensor & output, at::Tensor & buffer) {
    // No device check
  // DeviceGuard omitted
  return at::native::log_sigmoid_forward_out_cpu(self, output, buffer);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__log_sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer) {
    // No device check
  // DeviceGuard omitted
  return at::native::log_sigmoid_backward_cpu(grad_output, self, buffer);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_log_sigmoid_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::log_sigmoid_backward_cpu_out(grad_output, self, buffer, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__rrelu_with_noise(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::rrelu_with_noise_cpu(self, noise, lower, upper, training, generator);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_rrelu_with_noise_out(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::rrelu_with_noise_out_cpu(self, noise, lower, upper, training, generator, out);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU__rrelu_with_noise_(at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
    // No device check
  // DeviceGuard omitted
  return at::native::rrelu_with_noise_cpu_(self, noise, lower, upper, training, generator);
}
} // anonymous namespace
struct structured_softplus_out_functional final : public at::native::structured_softplus_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_softplus(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
structured_softplus_out_functional op;
op.meta(self, beta, threshold);
op.impl(self, beta, threshold, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softplus_out_out final : public at::native::structured_softplus_out {
    structured_softplus_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_softplus_out_out(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & out) {
structured_softplus_out_out op(out);
op.meta(self, beta, threshold);
op.impl(self, beta, threshold, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_softplus_backward_out_functional final : public at::native::structured_softplus_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_softplus_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
structured_softplus_backward_out_functional op;
op.meta(grad_output, self, beta, threshold);
op.impl(grad_output, self, beta, threshold, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softplus_backward_out_out final : public at::native::structured_softplus_backward_out {
    structured_softplus_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softplus_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_softplus_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & grad_input) {
structured_softplus_backward_out_out op(grad_input);
op.meta(grad_output, self, beta, threshold);
op.impl(grad_output, self, beta, threshold, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_softshrink_out_functional final : public at::native::structured_softshrink_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_softshrink(const at::Tensor & self, const at::Scalar & lambd) {
structured_softshrink_out_functional op;
op.meta(self, lambd);
op.impl(self, lambd, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softshrink_out_out final : public at::native::structured_softshrink_out {
    structured_softshrink_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_softshrink_out_out(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
structured_softshrink_out_out op(out);
op.meta(self, lambd);
op.impl(self, lambd, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_softshrink_backward_out_functional final : public at::native::structured_softshrink_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_softshrink_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd) {
structured_softshrink_backward_out_functional op;
op.meta(grad_output, self, lambd);
op.impl(grad_output, self, lambd, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_softshrink_backward_out_out final : public at::native::structured_softshrink_backward_out {
    structured_softshrink_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_softshrink_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_softshrink_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
structured_softshrink_backward_out_out op(grad_input);
op.meta(grad_output, self, lambd);
op.impl(grad_output, self, lambd, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor & wrapper_CPU_out_adaptive_avg_pool2d_out(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::adaptive_avg_pool2d_out_cpu(self, C10_AS_INTARRAYREF_SLOW(output_size), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___adaptive_avg_pool2d(const at::Tensor & self, c10::SymIntArrayRef output_size) {
    // No device check
  // DeviceGuard omitted
  return at::native::adaptive_avg_pool2d_cpu(self, C10_AS_INTARRAYREF_SLOW(output_size));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___adaptive_avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::adaptive_avg_pool2d_backward_cpu(grad_output, self);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_adaptive_avg_pool3d_out(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::adaptive_avg_pool3d_out_cpu(self, C10_AS_INTARRAYREF_SLOW(output_size), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___adaptive_avg_pool3d(const at::Tensor & self, c10::SymIntArrayRef output_size) {
    // No device check
  // DeviceGuard omitted
  return at::native::adaptive_avg_pool3d_cpu(self, C10_AS_INTARRAYREF_SLOW(output_size));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_adaptive_avg_pool3d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::adaptive_avg_pool3d_backward_out_cpu(grad_output, self, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___adaptive_avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::adaptive_avg_pool3d_backward_cpu(grad_output, self);
}
} // anonymous namespace
struct structured_adaptive_max_pool2d_out_cpu_functional final : public at::native::structured_adaptive_max_pool2d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_adaptive_max_pool2d(const at::Tensor & self, at::IntArrayRef output_size) {
structured_adaptive_max_pool2d_out_cpu_functional op;
op.meta(self, output_size);
op.impl(self, output_size, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_adaptive_max_pool2d_out_cpu_out final : public at::native::structured_adaptive_max_pool2d_out_cpu {
    structured_adaptive_max_pool2d_out_cpu_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_adaptive_max_pool2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out, at::Tensor & indices) {
structured_adaptive_max_pool2d_out_cpu_out op(out, indices);
op.meta(self, output_size);
op.impl(self, output_size, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(out, indices);
}
struct structured_adaptive_max_pool2d_backward_out_cpu_functional final : public at::native::structured_adaptive_max_pool2d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_adaptive_max_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
structured_adaptive_max_pool2d_backward_out_cpu_functional op;
op.meta(grad_output, self, indices);
op.impl(grad_output, self, indices, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_adaptive_max_pool2d_backward_out_cpu_out final : public at::native::structured_adaptive_max_pool2d_backward_out_cpu {
    structured_adaptive_max_pool2d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_adaptive_max_pool2d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices, at::Tensor & grad_input) {
structured_adaptive_max_pool2d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, indices);
op.impl(grad_output, self, indices, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_adaptive_max_pool3d_out_cpu_functional final : public at::native::structured_adaptive_max_pool3d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_adaptive_max_pool3d(const at::Tensor & self, at::IntArrayRef output_size) {
structured_adaptive_max_pool3d_out_cpu_functional op;
op.meta(self, output_size);
op.impl(self, output_size, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_adaptive_max_pool3d_out_cpu_out final : public at::native::structured_adaptive_max_pool3d_out_cpu {
    structured_adaptive_max_pool3d_out_cpu_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_adaptive_max_pool3d_out_out(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out, at::Tensor & indices) {
structured_adaptive_max_pool3d_out_cpu_out op(out, indices);
op.meta(self, output_size);
op.impl(self, output_size, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(out, indices);
}
struct structured_adaptive_max_pool3d_backward_out_cpu_functional final : public at::native::structured_adaptive_max_pool3d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_adaptive_max_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
structured_adaptive_max_pool3d_backward_out_cpu_functional op;
op.meta(grad_output, self, indices);
op.impl(grad_output, self, indices, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_adaptive_max_pool3d_backward_out_cpu_out final : public at::native::structured_adaptive_max_pool3d_backward_out_cpu {
    structured_adaptive_max_pool3d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_adaptive_max_pool3d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices, at::Tensor & grad_input) {
structured_adaptive_max_pool3d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, indices);
op.impl(grad_output, self, indices, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_avg_pool2d_out_cpu_functional final : public at::native::structured_avg_pool2d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_avg_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
structured_avg_pool2d_out_cpu_functional op;
auto precompute = op.meta(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
(void)precompute;
op.impl(self, precompute.kH, precompute.kW, precompute.dH, precompute.dW, precompute.padH, precompute.padW, ceil_mode, count_include_pad, divisor_override, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_avg_pool2d_out_cpu_out final : public at::native::structured_avg_pool2d_out_cpu {
    structured_avg_pool2d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_avg_pool2d_out_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
structured_avg_pool2d_out_cpu_out op(out);
auto precompute = op.meta(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
(void)precompute;
op.impl(self, precompute.kH, precompute.kW, precompute.dH, precompute.dW, precompute.padH, precompute.padW, ceil_mode, count_include_pad, divisor_override, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_avg_pool2d_backward_out_cpu_functional final : public at::native::structured_avg_pool2d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
structured_avg_pool2d_backward_out_cpu_functional op;
op.meta(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_avg_pool2d_backward_out_cpu_out final : public at::native::structured_avg_pool2d_backward_out_cpu {
    structured_avg_pool2d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_avg_pool2d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
structured_avg_pool2d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_avg_pool3d_out_cpu_functional final : public at::native::structured_avg_pool3d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_avg_pool3d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
structured_avg_pool3d_out_cpu_functional op;
op.meta(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_avg_pool3d_out_cpu_out final : public at::native::structured_avg_pool3d_out_cpu {
    structured_avg_pool3d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_avg_pool3d_out_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
structured_avg_pool3d_out_cpu_out op(out);
op.meta(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_avg_pool3d_backward_out_cpu_functional final : public at::native::structured_avg_pool3d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
structured_avg_pool3d_backward_out_cpu_functional op;
op.meta(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_avg_pool3d_backward_out_cpu_out final : public at::native::structured_avg_pool3d_backward_out_cpu {
    structured_avg_pool3d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_avg_pool3d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
structured_avg_pool3d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
op.impl(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_fractional_max_pool2d_out_cpu_functional final : public at::native::structured_fractional_max_pool2d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_fractional_max_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
structured_fractional_max_pool2d_out_cpu_functional op;
op.meta(self, kernel_size, output_size, random_samples);
op.impl(self, kernel_size, output_size, random_samples, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_fractional_max_pool2d_out_cpu_out final : public at::native::structured_fractional_max_pool2d_out_cpu {
    structured_fractional_max_pool2d_out_cpu_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_fractional_max_pool2d_out_output(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples, at::Tensor & output, at::Tensor & indices) {
structured_fractional_max_pool2d_out_cpu_out op(output, indices);
op.meta(self, kernel_size, output_size, random_samples);
op.impl(self, kernel_size, output_size, random_samples, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(output, indices);
}
struct structured_fractional_max_pool2d_backward_cpu_functional final : public at::native::structured_fractional_max_pool2d_backward_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_fractional_max_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
structured_fractional_max_pool2d_backward_cpu_functional op;
op.meta(grad_output, self, kernel_size, output_size, indices);
op.impl(grad_output, self, kernel_size, output_size, indices, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_fractional_max_pool2d_backward_cpu_out final : public at::native::structured_fractional_max_pool2d_backward_cpu {
    structured_fractional_max_pool2d_backward_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_fractional_max_pool2d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
structured_fractional_max_pool2d_backward_cpu_out op(grad_input);
op.meta(grad_output, self, kernel_size, output_size, indices);
op.impl(grad_output, self, kernel_size, output_size, indices, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_fractional_max_pool3d_out_cpu_functional final : public at::native::structured_fractional_max_pool3d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_fractional_max_pool3d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
structured_fractional_max_pool3d_out_cpu_functional op;
auto precompute = op.meta(self, kernel_size, output_size, random_samples);
(void)precompute;
op.impl(self, precompute.poolSizeT, precompute.poolSizeH, precompute.poolSizeW, precompute.outputT, precompute.outputH, precompute.outputW, random_samples, precompute.numBatch, precompute.numPlanes, precompute.inputT, precompute.inputH, precompute.inputW, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_fractional_max_pool3d_out_cpu_out final : public at::native::structured_fractional_max_pool3d_out_cpu {
    structured_fractional_max_pool3d_out_cpu_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_fractional_max_pool3d_out_output(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples, at::Tensor & output, at::Tensor & indices) {
structured_fractional_max_pool3d_out_cpu_out op(output, indices);
auto precompute = op.meta(self, kernel_size, output_size, random_samples);
(void)precompute;
op.impl(self, precompute.poolSizeT, precompute.poolSizeH, precompute.poolSizeW, precompute.outputT, precompute.outputH, precompute.outputW, random_samples, precompute.numBatch, precompute.numPlanes, precompute.inputT, precompute.inputH, precompute.inputW, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(output, indices);
}
namespace {
at::Tensor wrapper_CPU__fractional_max_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
    // No device check
  // DeviceGuard omitted
  return at::native::fractional_max_pool3d_backward_cpu(grad_output, self, kernel_size, output_size, indices);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_fractional_max_pool3d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::fractional_max_pool3d_backward_out_cpu(grad_output, self, kernel_size, output_size, indices, grad_input);
}
} // anonymous namespace
struct structured_max_pool2d_with_indices_out_cpu_functional final : public at::native::structured_max_pool2d_with_indices_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_max_pool2d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
structured_max_pool2d_with_indices_out_cpu_functional op;
op.meta(self, kernel_size, stride, padding, dilation, ceil_mode);
op.impl(self, kernel_size, stride, padding, dilation, ceil_mode, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_max_pool2d_with_indices_out_cpu_out final : public at::native::structured_max_pool2d_with_indices_out_cpu {
    structured_max_pool2d_with_indices_out_cpu_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_max_pool2d_with_indices_out_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
structured_max_pool2d_with_indices_out_cpu_out op(out, indices);
op.meta(self, kernel_size, stride, padding, dilation, ceil_mode);
op.impl(self, kernel_size, stride, padding, dilation, ceil_mode, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(out, indices);
}
struct structured_max_pool2d_with_indices_backward_out_cpu_functional final : public at::native::structured_max_pool2d_with_indices_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_max_pool2d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
structured_max_pool2d_with_indices_backward_out_cpu_functional op;
op.meta(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
op.impl(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_max_pool2d_with_indices_backward_out_cpu_out final : public at::native::structured_max_pool2d_with_indices_backward_out_cpu {
    structured_max_pool2d_with_indices_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_max_pool2d_with_indices_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
structured_max_pool2d_with_indices_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
op.impl(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__max_pool3d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    // No device check
  // DeviceGuard omitted
  return at::native::max_pool3d_with_indices_cpu(self, kernel_size, stride, padding, dilation, ceil_mode);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_out_max_pool3d_with_indices_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
    // No device check
  // DeviceGuard omitted
  return at::native::max_pool3d_with_indices_out_cpu(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__max_pool3d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
    // No device check
  // DeviceGuard omitted
  return at::native::max_pool3d_with_indices_backward_cpu(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_max_pool3d_with_indices_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::max_pool3d_with_indices_backward_out_cpu(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__max_unpool2d(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size) {
    // No device check
  // DeviceGuard omitted
  return at::native::max_unpooling2d_forward_cpu(self, indices, C10_AS_INTARRAYREF_SLOW(output_size));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_max_unpool2d_out(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::max_unpooling2d_forward_out_cpu(self, indices, C10_AS_INTARRAYREF_SLOW(output_size), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__max_unpool3d(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
    // No device check
  // DeviceGuard omitted
  return at::native::max_unpooling3d_forward_cpu(self, indices, C10_AS_INTARRAYREF_SLOW(output_size), stride, padding);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_max_unpool3d_out(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::max_unpooling3d_forward_out_cpu(self, indices, C10_AS_INTARRAYREF_SLOW(output_size), stride, padding, out);
}
} // anonymous namespace
struct structured_reflection_pad1d_out_cpu_functional final : public at::native::structured_reflection_pad1d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_reflection_pad1d(const at::Tensor & self, at::IntArrayRef padding) {
structured_reflection_pad1d_out_cpu_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reflection_pad1d_out_cpu_out final : public at::native::structured_reflection_pad1d_out_cpu {
    structured_reflection_pad1d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_reflection_pad1d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
structured_reflection_pad1d_out_cpu_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_reflection_pad1d_backward_out_cpu_functional final : public at::native::structured_reflection_pad1d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_reflection_pad1d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
structured_reflection_pad1d_backward_out_cpu_functional op;
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reflection_pad1d_backward_out_cpu_out final : public at::native::structured_reflection_pad1d_backward_out_cpu {
    structured_reflection_pad1d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_reflection_pad1d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
structured_reflection_pad1d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
namespace {
at::Tensor wrapper_CPU__reflection_pad2d(const at::Tensor & self, c10::SymIntArrayRef padding) {
    // No device check
  // DeviceGuard omitted
  return at::native::reflection_pad2d_cpu(self, C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_reflection_pad2d_out(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::reflection_pad2d_out_cpu(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__reflection_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
    // No device check
  // DeviceGuard omitted
  return at::native::reflection_pad2d_backward_cpu(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_reflection_pad2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::reflection_pad2d_backward_out_cpu(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
} // anonymous namespace
struct structured_reflection_pad3d_out_cpu_functional final : public at::native::structured_reflection_pad3d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_reflection_pad3d(const at::Tensor & self, at::IntArrayRef padding) {
structured_reflection_pad3d_out_cpu_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reflection_pad3d_out_cpu_out final : public at::native::structured_reflection_pad3d_out_cpu {
    structured_reflection_pad3d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_reflection_pad3d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
structured_reflection_pad3d_out_cpu_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_reflection_pad3d_backward_out_cpu_functional final : public at::native::structured_reflection_pad3d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_reflection_pad3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
structured_reflection_pad3d_backward_out_cpu_functional op;
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_reflection_pad3d_backward_out_cpu_out final : public at::native::structured_reflection_pad3d_backward_out_cpu {
    structured_reflection_pad3d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_reflection_pad3d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
structured_reflection_pad3d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_replication_pad1d_out_cpu_functional final : public at::native::structured_replication_pad1d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_replication_pad1d(const at::Tensor & self, at::IntArrayRef padding) {
structured_replication_pad1d_out_cpu_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_replication_pad1d_out_cpu_out final : public at::native::structured_replication_pad1d_out_cpu {
    structured_replication_pad1d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_replication_pad1d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
structured_replication_pad1d_out_cpu_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_replication_pad1d_backward_out_cpu_functional final : public at::native::structured_replication_pad1d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_replication_pad1d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
structured_replication_pad1d_backward_out_cpu_functional op;
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_replication_pad1d_backward_out_cpu_out final : public at::native::structured_replication_pad1d_backward_out_cpu {
    structured_replication_pad1d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_replication_pad1d_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
structured_replication_pad1d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, self, padding);
op.impl(grad_output, self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_replication_pad2d_out_cpu_functional final : public at::native::structured_replication_pad2d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_replication_pad2d(const at::Tensor & self, at::IntArrayRef padding) {
structured_replication_pad2d_out_cpu_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_replication_pad2d_out_cpu_out final : public at::native::structured_replication_pad2d_out_cpu {
    structured_replication_pad2d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_replication_pad2d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
structured_replication_pad2d_out_cpu_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU__replication_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
    // No device check
  // DeviceGuard omitted
  return at::native::replication_pad2d_backward_cpu(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_replication_pad2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::replication_pad2d_backward_out_cpu(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
} // anonymous namespace
struct structured_replication_pad3d_out_cpu_functional final : public at::native::structured_replication_pad3d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_replication_pad3d(const at::Tensor & self, at::IntArrayRef padding) {
structured_replication_pad3d_out_cpu_functional op;
op.meta(self, padding);
op.impl(self, padding, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_replication_pad3d_out_cpu_out final : public at::native::structured_replication_pad3d_out_cpu {
    structured_replication_pad3d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_replication_pad3d_out_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
structured_replication_pad3d_out_cpu_out op(out);
op.meta(self, padding);
op.impl(self, padding, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU__replication_pad3d_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
    // No device check
  // DeviceGuard omitted
  return at::native::replication_pad3d_backward_cpu(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_grad_input_replication_pad3d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
    // No device check
  // DeviceGuard omitted
  return at::native::replication_pad3d_backward_out_cpu(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
} // anonymous namespace
struct structured_upsample_linear1d_out_cpu_functional final : public at::native::structured_upsample_linear1d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_linear1d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
structured_upsample_linear1d_out_cpu_functional op;
op.meta(self, output_size, align_corners, scales);
op.impl(self, output_size, align_corners, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_linear1d_out_cpu_out final : public at::native::structured_upsample_linear1d_out_cpu {
    structured_upsample_linear1d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_linear1d_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales, at::Tensor & out) {
structured_upsample_linear1d_out_cpu_out op(out);
op.meta(self, output_size, align_corners, scales);
op.impl(self, output_size, align_corners, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_linear1d_backward_out_cpu_functional final : public at::native::structured_upsample_linear1d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_linear1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
structured_upsample_linear1d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales);
op.impl(grad_output, output_size, input_size, align_corners, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_linear1d_backward_out_cpu_out final : public at::native::structured_upsample_linear1d_backward_out_cpu {
    structured_upsample_linear1d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_linear1d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales, at::Tensor & grad_input) {
structured_upsample_linear1d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales);
op.impl(grad_output, output_size, input_size, align_corners, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_bilinear2d_out_cpu_functional final : public at::native::structured_upsample_bilinear2d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_bilinear2d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_bilinear2d_out_cpu_functional op;
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_bilinear2d_out_cpu_out final : public at::native::structured_upsample_bilinear2d_out_cpu {
    structured_upsample_bilinear2d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_bilinear2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
structured_upsample_bilinear2d_out_cpu_out op(out);
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_bilinear2d_backward_out_cpu_functional final : public at::native::structured_upsample_bilinear2d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_bilinear2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_bilinear2d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_bilinear2d_backward_out_cpu_out final : public at::native::structured_upsample_bilinear2d_backward_out_cpu {
    structured_upsample_bilinear2d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_bilinear2d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
structured_upsample_bilinear2d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_bilinear2d_aa_out_cpu_functional final : public at::native::structured__upsample_bilinear2d_aa_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_bilinear2d_aa(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured__upsample_bilinear2d_aa_out_cpu_functional op;
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_bilinear2d_aa_out_cpu_out final : public at::native::structured__upsample_bilinear2d_aa_out_cpu {
    structured__upsample_bilinear2d_aa_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_bilinear2d_aa_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
structured__upsample_bilinear2d_aa_out_cpu_out op(out);
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_bilinear2d_aa_backward_out_cpu_functional final : public at::native::structured__upsample_bilinear2d_aa_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_bilinear2d_aa_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured__upsample_bilinear2d_aa_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_bilinear2d_aa_backward_out_cpu_out final : public at::native::structured__upsample_bilinear2d_aa_backward_out_cpu {
    structured__upsample_bilinear2d_aa_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_bilinear2d_aa_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
structured__upsample_bilinear2d_aa_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_bicubic2d_out_cpu_functional final : public at::native::structured_upsample_bicubic2d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_bicubic2d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_bicubic2d_out_cpu_functional op;
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_bicubic2d_out_cpu_out final : public at::native::structured_upsample_bicubic2d_out_cpu {
    structured_upsample_bicubic2d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_bicubic2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
structured_upsample_bicubic2d_out_cpu_out op(out);
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_bicubic2d_backward_out_cpu_functional final : public at::native::structured_upsample_bicubic2d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_bicubic2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_bicubic2d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_bicubic2d_backward_out_cpu_out final : public at::native::structured_upsample_bicubic2d_backward_out_cpu {
    structured_upsample_bicubic2d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_bicubic2d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
structured_upsample_bicubic2d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_bicubic2d_aa_out_cpu_functional final : public at::native::structured__upsample_bicubic2d_aa_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_bicubic2d_aa(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured__upsample_bicubic2d_aa_out_cpu_functional op;
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_bicubic2d_aa_out_cpu_out final : public at::native::structured__upsample_bicubic2d_aa_out_cpu {
    structured__upsample_bicubic2d_aa_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_bicubic2d_aa_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
structured__upsample_bicubic2d_aa_out_cpu_out op(out);
op.meta(self, output_size, align_corners, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_bicubic2d_aa_backward_out_cpu_functional final : public at::native::structured__upsample_bicubic2d_aa_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_bicubic2d_aa_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured__upsample_bicubic2d_aa_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_bicubic2d_aa_backward_out_cpu_out final : public at::native::structured__upsample_bicubic2d_aa_backward_out_cpu {
    structured__upsample_bicubic2d_aa_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_bicubic2d_aa_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
structured__upsample_bicubic2d_aa_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_trilinear3d_out_cpu_functional final : public at::native::structured_upsample_trilinear3d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_trilinear3d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_trilinear3d_out_cpu_functional op;
op.meta(self, output_size, align_corners, scales_d, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_trilinear3d_out_cpu_out final : public at::native::structured_upsample_trilinear3d_out_cpu {
    structured_upsample_trilinear3d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_trilinear3d_out_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
structured_upsample_trilinear3d_out_cpu_out op(out);
op.meta(self, output_size, align_corners, scales_d, scales_h, scales_w);
op.impl(self, output_size, align_corners, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_trilinear3d_backward_out_cpu_functional final : public at::native::structured_upsample_trilinear3d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_trilinear3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_trilinear3d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_trilinear3d_backward_out_cpu_out final : public at::native::structured_upsample_trilinear3d_backward_out_cpu {
    structured_upsample_trilinear3d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_trilinear3d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
structured_upsample_trilinear3d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_nearest1d_out_cpu_functional final : public at::native::structured_upsample_nearest1d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_nearest1d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
structured_upsample_nearest1d_out_cpu_functional op;
op.meta(self, output_size, scales);
op.impl(self, output_size, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest1d_out_cpu_out final : public at::native::structured_upsample_nearest1d_out_cpu {
    structured_upsample_nearest1d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_nearest1d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
structured_upsample_nearest1d_out_cpu_out op(out);
op.meta(self, output_size, scales);
op.impl(self, output_size, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_nearest_exact1d_out_cpu_functional final : public at::native::structured__upsample_nearest_exact1d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_nearest_exact1d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
structured__upsample_nearest_exact1d_out_cpu_functional op;
op.meta(self, output_size, scales);
op.impl(self, output_size, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact1d_out_cpu_out final : public at::native::structured__upsample_nearest_exact1d_out_cpu {
    structured__upsample_nearest_exact1d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_nearest_exact1d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
structured__upsample_nearest_exact1d_out_cpu_out op(out);
op.meta(self, output_size, scales);
op.impl(self, output_size, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_nearest1d_backward_out_cpu_functional final : public at::native::structured_upsample_nearest1d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_nearest1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
structured_upsample_nearest1d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, scales);
op.impl(grad_output, output_size, input_size, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest1d_backward_out_cpu_out final : public at::native::structured_upsample_nearest1d_backward_out_cpu {
    structured_upsample_nearest1d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_nearest1d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
structured_upsample_nearest1d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales);
op.impl(grad_output, output_size, input_size, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_nearest_exact1d_backward_out_cpu_functional final : public at::native::structured__upsample_nearest_exact1d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_nearest_exact1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
structured__upsample_nearest_exact1d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, scales);
op.impl(grad_output, output_size, input_size, scales, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact1d_backward_out_cpu_out final : public at::native::structured__upsample_nearest_exact1d_backward_out_cpu {
    structured__upsample_nearest_exact1d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_nearest_exact1d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
structured__upsample_nearest_exact1d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales);
op.impl(grad_output, output_size, input_size, scales, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_nearest2d_out_cpu_functional final : public at::native::structured_upsample_nearest2d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_nearest2d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_nearest2d_out_cpu_functional op;
op.meta(self, output_size, scales_h, scales_w);
op.impl(self, output_size, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest2d_out_cpu_out final : public at::native::structured_upsample_nearest2d_out_cpu {
    structured_upsample_nearest2d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_nearest2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
structured_upsample_nearest2d_out_cpu_out op(out);
op.meta(self, output_size, scales_h, scales_w);
op.impl(self, output_size, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_nearest_exact2d_out_cpu_functional final : public at::native::structured__upsample_nearest_exact2d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_nearest_exact2d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured__upsample_nearest_exact2d_out_cpu_functional op;
op.meta(self, output_size, scales_h, scales_w);
op.impl(self, output_size, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact2d_out_cpu_out final : public at::native::structured__upsample_nearest_exact2d_out_cpu {
    structured__upsample_nearest_exact2d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_nearest_exact2d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
structured__upsample_nearest_exact2d_out_cpu_out op(out);
op.meta(self, output_size, scales_h, scales_w);
op.impl(self, output_size, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_nearest2d_backward_out_cpu_functional final : public at::native::structured_upsample_nearest2d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_nearest2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_nearest2d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest2d_backward_out_cpu_out final : public at::native::structured_upsample_nearest2d_backward_out_cpu {
    structured_upsample_nearest2d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_nearest2d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
structured_upsample_nearest2d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_nearest_exact2d_backward_out_cpu_functional final : public at::native::structured__upsample_nearest_exact2d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_nearest_exact2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured__upsample_nearest_exact2d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact2d_backward_out_cpu_out final : public at::native::structured__upsample_nearest_exact2d_backward_out_cpu {
    structured__upsample_nearest_exact2d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_nearest_exact2d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
structured__upsample_nearest_exact2d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_upsample_nearest3d_out_cpu_functional final : public at::native::structured_upsample_nearest3d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_nearest3d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_nearest3d_out_cpu_functional op;
op.meta(self, output_size, scales_d, scales_h, scales_w);
op.impl(self, output_size, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest3d_out_cpu_out final : public at::native::structured_upsample_nearest3d_out_cpu {
    structured_upsample_nearest3d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_nearest3d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
structured_upsample_nearest3d_out_cpu_out op(out);
op.meta(self, output_size, scales_d, scales_h, scales_w);
op.impl(self, output_size, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__upsample_nearest_exact3d_out_cpu_functional final : public at::native::structured__upsample_nearest_exact3d_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_nearest_exact3d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured__upsample_nearest_exact3d_out_cpu_functional op;
op.meta(self, output_size, scales_d, scales_h, scales_w);
op.impl(self, output_size, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact3d_out_cpu_out final : public at::native::structured__upsample_nearest_exact3d_out_cpu {
    structured__upsample_nearest_exact3d_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_nearest_exact3d_out_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
structured__upsample_nearest_exact3d_out_cpu_out op(out);
op.meta(self, output_size, scales_d, scales_h, scales_w);
op.impl(self, output_size, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_upsample_nearest3d_backward_out_cpu_functional final : public at::native::structured_upsample_nearest3d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_upsample_nearest3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured_upsample_nearest3d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_upsample_nearest3d_backward_out_cpu_out final : public at::native::structured_upsample_nearest3d_backward_out_cpu {
    structured_upsample_nearest3d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_upsample_nearest3d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
structured_upsample_nearest3d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured__upsample_nearest_exact3d_backward_out_cpu_functional final : public at::native::structured__upsample_nearest_exact3d_backward_out_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU__upsample_nearest_exact3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
structured__upsample_nearest_exact3d_backward_out_cpu_functional op;
op.meta(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_d, scales_h, scales_w, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured__upsample_nearest_exact3d_backward_out_cpu_out final : public at::native::structured__upsample_nearest_exact3d_backward_out_cpu {
    structured__upsample_nearest_exact3d_backward_out_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU__upsample_nearest_exact3d_backward_out_grad_input(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
structured__upsample_nearest_exact3d_backward_out_cpu_out op(grad_input);
op.meta(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
op.impl(grad_output, output_size, input_size, scales_d, scales_h, scales_w, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_sigmoid_backward_out_functional final : public at::native::structured_sigmoid_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & output) {
structured_sigmoid_backward_out_functional op;
op.meta(grad_output, output);
op.impl(grad_output, output, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_sigmoid_backward_out_out final : public at::native::structured_sigmoid_backward_out {
    structured_sigmoid_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_sigmoid_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_sigmoid_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
structured_sigmoid_backward_out_out op(grad_input);
op.meta(grad_output, output);
op.impl(grad_output, output, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_logit_backward_out_functional final : public at::native::structured_logit_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logit_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logit_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_logit_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps) {
structured_logit_backward_out_functional op;
op.meta(grad_output, self, eps);
op.impl(grad_output, self, eps, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_logit_backward_out_out final : public at::native::structured_logit_backward_out {
    structured_logit_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logit_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_logit_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_logit_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps, at::Tensor & grad_input) {
structured_logit_backward_out_out op(grad_input);
op.meta(grad_output, self, eps);
op.impl(grad_output, self, eps, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_tanh_backward_out_functional final : public at::native::structured_tanh_backward_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_tanh_backward(const at::Tensor & grad_output, const at::Tensor & output) {
structured_tanh_backward_out_functional op;
op.meta(grad_output, output);
op.impl(grad_output, output, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_tanh_backward_out_out final : public at::native::structured_tanh_backward_out {
    structured_tanh_backward_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_tanh_backward_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_tanh_backward_out_grad_input(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
structured_tanh_backward_out_out op(grad_input);
op.meta(grad_output, output);
op.impl(grad_output, output, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return grad_input;
}
struct structured_slow_conv_transpose2d_structured_cpu_functional final : public at::native::structured_slow_conv_transpose2d_structured_cpu {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_slow_conv_transpose2d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
structured_slow_conv_transpose2d_structured_cpu_functional op;
op.meta(self, weight, kernel_size, ((bias.has_value() && (*bias).defined()) ? at::OptionalTensorRef(*bias) : at::OptionalTensorRef()), stride, padding, output_padding, dilation);
op.impl(self, weight, kernel_size, ((bias.has_value() && (*bias).defined()) ? at::OptionalTensorRef(*bias) : at::OptionalTensorRef()), stride, padding, output_padding, dilation, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_slow_conv_transpose2d_structured_cpu_out final : public at::native::structured_slow_conv_transpose2d_structured_cpu {
    structured_slow_conv_transpose2d_structured_cpu_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_slow_conv_transpose2d_out_out(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation, at::Tensor & out) {
structured_slow_conv_transpose2d_structured_cpu_out op(out);
op.meta(self, weight, kernel_size, ((bias.has_value() && (*bias).defined()) ? at::OptionalTensorRef(*bias) : at::OptionalTensorRef()), stride, padding, output_padding, dilation);
op.impl(self, weight, kernel_size, ((bias.has_value() && (*bias).defined()) ? at::OptionalTensorRef(*bias) : at::OptionalTensorRef()), stride, padding, output_padding, dilation, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU__slow_conv_transpose3d(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv_transpose3d_cpu(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_slow_conv_transpose3d_out(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv_transpose3d_out_cpu(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation), out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___slow_conv2d_forward(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv2d_forward_cpu(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_output__slow_conv2d_forward_out(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv2d_forward_out_cpu(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), output);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU_grad_input__slow_conv2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv2d_backward_out_cpu(grad_output, self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), grad_input, grad_weight, grad_bias);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU_output_mask__slow_conv2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, ::std::array<bool,3> output_mask) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv2d_backward_cpu(grad_output, self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), output_mask);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__slow_conv3d_forward(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv3d_forward_cpu(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding));
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_output_slow_conv3d_forward_out(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv3d_forward_out_cpu(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), output);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__slow_conv_dilated2d(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv_dilated2d_cpu(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__slow_conv_dilated3d(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
    // No device check
  // DeviceGuard omitted
  return at::native::slow_conv_dilated3d_cpu(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__col2im(const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
    // No device check
  // DeviceGuard omitted
  return at::native::col2im_cpu(self, C10_AS_INTARRAYREF_SLOW(output_size), kernel_size, dilation, padding, stride);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_col2im_out(const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::col2im_out_cpu(self, C10_AS_INTARRAYREF_SLOW(output_size), kernel_size, dilation, padding, stride, out);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__im2col(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
    // No device check
  // DeviceGuard omitted
  return at::native::im2col_cpu(self, kernel_size, dilation, padding, stride);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_im2col_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::im2col_out_cpu(self, kernel_size, dilation, padding, stride, out);
}
} // anonymous namespace
struct structured_isposinf_out_functional final : public at::native::structured_isposinf_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isposinf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isposinf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_isposinf(const at::Tensor & self) {
structured_isposinf_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isposinf_out_out final : public at::native::structured_isposinf_out {
    structured_isposinf_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isposinf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isposinf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_isposinf_out_out(const at::Tensor & self, at::Tensor & out) {
structured_isposinf_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_isneginf_out_functional final : public at::native::structured_isneginf_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isneginf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isneginf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_isneginf(const at::Tensor & self) {
structured_isneginf_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_isneginf_out_out final : public at::native::structured_isneginf_out {
    structured_isneginf_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isneginf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_isneginf_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_isneginf_out_out(const at::Tensor & self, at::Tensor & out) {
structured_isneginf_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_entr_out_functional final : public at::native::structured_special_entr_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_entr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_entr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_entr(const at::Tensor & self) {
structured_special_entr_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_entr_out_out final : public at::native::structured_special_entr_out {
    structured_special_entr_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_entr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_entr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_entr_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_entr_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_ndtri_out_functional final : public at::native::structured_special_ndtri_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_ndtri_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_ndtri_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_ndtri(const at::Tensor & self) {
structured_special_ndtri_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_ndtri_out_out final : public at::native::structured_special_ndtri_out {
    structured_special_ndtri_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_ndtri_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_ndtri_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_ndtri_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_ndtri_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_log_ndtr_out_functional final : public at::native::structured_special_log_ndtr_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_log_ndtr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_log_ndtr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_log_ndtr(const at::Tensor & self) {
structured_special_log_ndtr_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_log_ndtr_out_out final : public at::native::structured_special_log_ndtr_out {
    structured_special_log_ndtr_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_log_ndtr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_log_ndtr_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_log_ndtr_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_log_ndtr_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_erfcx_out_functional final : public at::native::structured_special_erfcx_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_erfcx_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_erfcx_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_erfcx(const at::Tensor & self) {
structured_special_erfcx_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_erfcx_out_out final : public at::native::structured_special_erfcx_out {
    structured_special_erfcx_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_erfcx_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_erfcx_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_erfcx_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_erfcx_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_xlog1py_out_functional final : public at::native::structured_special_xlog1py_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_xlog1py_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_xlog1py_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_xlog1py(const at::Tensor & self, const at::Tensor & other) {
structured_special_xlog1py_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_xlog1py_out_out final : public at::native::structured_special_xlog1py_out {
    structured_special_xlog1py_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_xlog1py_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_xlog1py_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_xlog1py_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_special_xlog1py_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_zeta_out_functional final : public at::native::structured_special_zeta_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_zeta_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_zeta_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_zeta(const at::Tensor & self, const at::Tensor & other) {
structured_special_zeta_out_functional op;
op.meta(self, other);
op.impl(self, other, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_zeta_out_out final : public at::native::structured_special_zeta_out {
    structured_special_zeta_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_zeta_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_zeta_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_zeta_out_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
structured_special_zeta_out_out op(out);
op.meta(self, other);
op.impl(self, other, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_i0e_out_functional final : public at::native::structured_special_i0e_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i0e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i0e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_i0e(const at::Tensor & self) {
structured_special_i0e_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_i0e_out_out final : public at::native::structured_special_i0e_out {
    structured_special_i0e_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i0e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i0e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_i0e_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_i0e_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_i1_out_functional final : public at::native::structured_special_i1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_i1(const at::Tensor & self) {
structured_special_i1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_i1_out_out final : public at::native::structured_special_i1_out {
    structured_special_i1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_i1_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_i1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_i1e_out_functional final : public at::native::structured_special_i1e_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_i1e(const at::Tensor & self) {
structured_special_i1e_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_i1e_out_out final : public at::native::structured_special_i1e_out {
    structured_special_i1e_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_i1e_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_i1e_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_i1e_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_linalg_cholesky_ex_out_functional final : public at::native::structured_linalg_cholesky_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_linalg_cholesky_ex(const at::Tensor & self, bool upper, bool check_errors) {
structured_linalg_cholesky_ex_out_functional op;
op.meta(self, upper, check_errors);
op.impl(self, upper, check_errors, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_linalg_cholesky_ex_out_out final : public at::native::structured_linalg_cholesky_ex_out {
    structured_linalg_cholesky_ex_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_linalg_cholesky_ex_out_L(const at::Tensor & self, bool upper, bool check_errors, at::Tensor & L, at::Tensor & info) {
structured_linalg_cholesky_ex_out_out op(L, info);
op.meta(self, upper, check_errors);
op.impl(self, upper, check_errors, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(L, info);
}
struct structured_linalg_cross_out_functional final : public at::native::structured_linalg_cross_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_linalg_cross(const at::Tensor & self, const at::Tensor & other, int64_t dim) {
structured_linalg_cross_out_functional op;
op.meta(self, other, dim);
op.impl(self, other, dim, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_linalg_cross_out_out final : public at::native::structured_linalg_cross_out {
    structured_linalg_cross_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_linalg_cross_out_out(const at::Tensor & self, const at::Tensor & other, int64_t dim, at::Tensor & out) {
structured_linalg_cross_out_out op(out);
op.meta(self, other, dim);
op.impl(self, other, dim, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_linalg_lu_factor_ex_out_functional final : public at::native::structured_linalg_lu_factor_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU_linalg_lu_factor_ex(const at::Tensor & A, bool pivot, bool check_errors) {
structured_linalg_lu_factor_ex_out_functional op;
op.meta(A, pivot, check_errors);
op.impl(A, pivot, check_errors, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured_linalg_lu_factor_ex_out_out final : public at::native::structured_linalg_lu_factor_ex_out {
    structured_linalg_lu_factor_ex_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU_linalg_lu_factor_ex_out_out(const at::Tensor & A, bool pivot, bool check_errors, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
structured_linalg_lu_factor_ex_out_out op(LU, pivots, info);
op.meta(A, pivot, check_errors);
op.impl(A, pivot, check_errors, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(LU, pivots, info);
}
struct structured_linalg_lu_out_functional final : public at::native::structured_linalg_lu_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU_linalg_lu(const at::Tensor & A, bool pivot) {
structured_linalg_lu_out_functional op;
op.meta(A, pivot);
op.impl(A, pivot, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured_linalg_lu_out_out final : public at::native::structured_linalg_lu_out {
    structured_linalg_lu_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU_linalg_lu_out_out(const at::Tensor & A, bool pivot, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
structured_linalg_lu_out_out op(P, L, U);
op.meta(A, pivot);
op.impl(A, pivot, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(P, L, U);
}
struct structured_linalg_lu_solve_out_functional final : public at::native::structured_linalg_lu_solve_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_linalg_lu_solve(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint) {
structured_linalg_lu_solve_out_functional op;
op.meta(LU, pivots, B, left, adjoint);
op.impl(LU, pivots, B, left, adjoint, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_linalg_lu_solve_out_out final : public at::native::structured_linalg_lu_solve_out {
    structured_linalg_lu_solve_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_linalg_lu_solve_out_out(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint, at::Tensor & out) {
structured_linalg_lu_solve_out_out op(out);
op.meta(LU, pivots, B, left, adjoint);
op.impl(LU, pivots, B, left, adjoint, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__linalg_det_out_functional final : public at::native::structured__linalg_det_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__linalg_det(const at::Tensor & A) {
structured__linalg_det_out_functional op;
op.meta(A);
op.impl(A, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured__linalg_det_out_out final : public at::native::structured__linalg_det_out {
    structured__linalg_det_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU__linalg_det_out_result(const at::Tensor & A, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots) {
structured__linalg_det_out_out op(result, LU, pivots);
op.meta(A);
op.impl(A, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(result, LU, pivots);
}
struct structured_linalg_ldl_factor_ex_out_functional final : public at::native::structured_linalg_ldl_factor_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU_linalg_ldl_factor_ex(const at::Tensor & self, bool hermitian, bool check_errors) {
structured_linalg_ldl_factor_ex_out_functional op;
op.meta(self, hermitian, check_errors);
op.impl(self, hermitian, check_errors, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured_linalg_ldl_factor_ex_out_out final : public at::native::structured_linalg_ldl_factor_ex_out {
    structured_linalg_ldl_factor_ex_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU_linalg_ldl_factor_ex_out_out(const at::Tensor & self, bool hermitian, bool check_errors, at::Tensor & LD, at::Tensor & pivots, at::Tensor & info) {
structured_linalg_ldl_factor_ex_out_out op(LD, pivots, info);
op.meta(self, hermitian, check_errors);
op.impl(self, hermitian, check_errors, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(LD, pivots, info);
}
struct structured_linalg_ldl_solve_out_functional final : public at::native::structured_linalg_ldl_solve_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_linalg_ldl_solve(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian) {
structured_linalg_ldl_solve_out_functional op;
op.meta(LD, pivots, B, hermitian);
op.impl(LD, pivots, B, hermitian, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_linalg_ldl_solve_out_out final : public at::native::structured_linalg_ldl_solve_out {
    structured_linalg_ldl_solve_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_linalg_ldl_solve_out_out(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian, at::Tensor & out) {
structured_linalg_ldl_solve_out_out op(out);
op.meta(LD, pivots, B, hermitian);
op.impl(LD, pivots, B, hermitian, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU_out_linalg_lstsq_out(const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver, at::Tensor & solution, at::Tensor & residuals, at::Tensor & rank, at::Tensor & singular_values) {
    // No device check
  // DeviceGuard omitted
  return at::native::linalg_lstsq_out(self, b, rcond, driver, solution, residuals, rank, singular_values);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__linalg_matrix_exp(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::linalg_matrix_exp(self);
}
} // anonymous namespace
struct structured__linalg_slogdet_out_functional final : public at::native::structured__linalg_slogdet_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 4> outputs_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__linalg_slogdet(const at::Tensor & A) {
structured__linalg_slogdet_out_functional op;
op.meta(A);
op.impl(A, op.outputs_[0], op.outputs_[1], op.outputs_[2], op.outputs_[3]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]), std::move(op.outputs_[3]));
}
struct structured__linalg_slogdet_out_out final : public at::native::structured__linalg_slogdet_out {
    structured__linalg_slogdet_out_out(Tensor& out0, Tensor& out1, Tensor& out2, Tensor& out3) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2), std::ref(out3) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 4> outputs_;
    std::array<c10::optional<Tensor>, 4> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU__linalg_slogdet_out_sign(const at::Tensor & A, at::Tensor & sign, at::Tensor & logabsdet, at::Tensor & LU, at::Tensor & pivots) {
structured__linalg_slogdet_out_out op(sign, logabsdet, LU, pivots);
op.meta(A);
op.impl(A, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2), op.maybe_get_output(3));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
if (op.proxy_outputs_[3].has_value()) op.outputs_[3].get().copy_(*op.proxy_outputs_[3]);
return std::forward_as_tuple(sign, logabsdet, LU, pivots);
}
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__linalg_eig(const at::Tensor & self) {
    // No device check
  // DeviceGuard omitted
  return at::native::linalg_eig(self);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_out_linalg_eig_out(const at::Tensor & self, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
    // No device check
  // DeviceGuard omitted
  return at::native::linalg_eig_out(self, eigenvalues, eigenvectors);
}
} // anonymous namespace
struct structured__linalg_eigh_out_functional final : public at::native::structured__linalg_eigh_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU__linalg_eigh(const at::Tensor & A, c10::string_view UPLO, bool compute_v) {
structured__linalg_eigh_out_functional op;
op.meta(A, UPLO, compute_v);
op.impl(A, UPLO, compute_v, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured__linalg_eigh_out_out final : public at::native::structured__linalg_eigh_out {
    structured__linalg_eigh_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU__linalg_eigh_out_eigenvalues(const at::Tensor & A, c10::string_view UPLO, bool compute_v, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
structured__linalg_eigh_out_out op(eigenvalues, eigenvectors);
op.meta(A, UPLO, compute_v);
op.impl(A, UPLO, compute_v, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(eigenvalues, eigenvectors);
}
namespace {
at::Tensor wrapper_CPU__linalg_householder_product(const at::Tensor & input, const at::Tensor & tau) {
    // No device check
  // DeviceGuard omitted
  return at::native::linalg_householder_product(input, tau);
}
} // anonymous namespace
namespace {
at::Tensor & wrapper_CPU_out_linalg_householder_product_out(const at::Tensor & input, const at::Tensor & tau, at::Tensor & out) {
    // No device check
  // DeviceGuard omitted
  return at::native::linalg_householder_product_out(input, tau, out);
}
} // anonymous namespace
struct structured_linalg_inv_ex_out_functional final : public at::native::structured_linalg_inv_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_linalg_inv_ex(const at::Tensor & A, bool check_errors) {
structured_linalg_inv_ex_out_functional op;
op.meta(A, check_errors);
op.impl(A, check_errors, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_linalg_inv_ex_out_out final : public at::native::structured_linalg_inv_ex_out {
    structured_linalg_inv_ex_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_linalg_inv_ex_out_inverse(const at::Tensor & A, bool check_errors, at::Tensor & inverse, at::Tensor & info) {
structured_linalg_inv_ex_out_out op(inverse, info);
op.meta(A, check_errors);
op.impl(A, check_errors, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(inverse, info);
}
struct structured_linalg_vector_norm_out_functional final : public at::native::structured_linalg_vector_norm_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_linalg_vector_norm(const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
structured_linalg_vector_norm_out_functional op;
op.meta(self, ord, dim, keepdim, dtype);
op.impl(self, ord, dim, keepdim, dtype, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_linalg_vector_norm_out_out final : public at::native::structured_linalg_vector_norm_out {
    structured_linalg_vector_norm_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_linalg_vector_norm_out_out(const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
structured_linalg_vector_norm_out_out op(out);
op.meta(self, ord, dim, keepdim, dtype);
op.impl(self, ord, dim, keepdim, dtype, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured__linalg_svd_out_functional final : public at::native::structured__linalg_svd_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 3> outputs_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__linalg_svd(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver) {
structured__linalg_svd_out_functional op;
op.meta(A, full_matrices, compute_uv, driver);
op.impl(A, full_matrices, compute_uv, driver, op.outputs_[0], op.outputs_[1], op.outputs_[2]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]));
}
struct structured__linalg_svd_out_out final : public at::native::structured__linalg_svd_out {
    structured__linalg_svd_out_out(Tensor& out0, Tensor& out1, Tensor& out2) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 3> outputs_;
    std::array<c10::optional<Tensor>, 3> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU__linalg_svd_out_U(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver, at::Tensor & U, at::Tensor & S, at::Tensor & Vh) {
structured__linalg_svd_out_out op(U, S, Vh);
op.meta(A, full_matrices, compute_uv, driver);
op.impl(A, full_matrices, compute_uv, driver, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
return std::forward_as_tuple(U, S, Vh);
}
struct structured__linalg_solve_ex_out_functional final : public at::native::structured__linalg_solve_ex_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 4> outputs_;
};
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> wrapper_CPU__linalg_solve_ex(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors) {
structured__linalg_solve_ex_out_functional op;
op.meta(A, B, left, check_errors);
op.impl(A, B, left, check_errors, op.outputs_[0], op.outputs_[1], op.outputs_[2], op.outputs_[3]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]), std::move(op.outputs_[2]), std::move(op.outputs_[3]));
}
struct structured__linalg_solve_ex_out_out final : public at::native::structured__linalg_solve_ex_out {
    structured__linalg_solve_ex_out_out(Tensor& out0, Tensor& out1, Tensor& out2, Tensor& out3) : outputs_{ std::ref(out0), std::ref(out1), std::ref(out2), std::ref(out3) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 4> outputs_;
    std::array<c10::optional<Tensor>, 4> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> wrapper_CPU__linalg_solve_ex_out_result(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
structured__linalg_solve_ex_out_out op(result, LU, pivots, info);
op.meta(A, B, left, check_errors);
op.impl(A, B, left, check_errors, op.maybe_get_output(0), op.maybe_get_output(1), op.maybe_get_output(2), op.maybe_get_output(3));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
if (op.proxy_outputs_[2].has_value()) op.outputs_[2].get().copy_(*op.proxy_outputs_[2]);
if (op.proxy_outputs_[3].has_value()) op.outputs_[3].get().copy_(*op.proxy_outputs_[3]);
return std::forward_as_tuple(result, LU, pivots, info);
}
struct structured_linalg_qr_out_functional final : public at::native::structured_linalg_qr_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 2> outputs_;
};
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU_linalg_qr(const at::Tensor & A, c10::string_view mode) {
structured_linalg_qr_out_functional op;
op.meta(A, mode);
op.impl(A, mode, op.outputs_[0], op.outputs_[1]);
return std::make_tuple(std::move(op.outputs_[0]), std::move(op.outputs_[1]));
}
struct structured_linalg_qr_out_out final : public at::native::structured_linalg_qr_out {
    structured_linalg_qr_out_out(Tensor& out0, Tensor& out1) : outputs_{ std::ref(out0), std::ref(out1) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 2> outputs_;
    std::array<c10::optional<Tensor>, 2> proxy_outputs_;
};
::std::tuple<at::Tensor &,at::Tensor &> wrapper_CPU_linalg_qr_out_out(const at::Tensor & A, c10::string_view mode, at::Tensor & Q, at::Tensor & R) {
structured_linalg_qr_out_out op(Q, R);
op.meta(A, mode);
op.impl(A, mode, op.maybe_get_output(0), op.maybe_get_output(1));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
if (op.proxy_outputs_[1].has_value()) op.outputs_[1].get().copy_(*op.proxy_outputs_[1]);
return std::forward_as_tuple(Q, R);
}
namespace {
at::Tensor wrapper_CPU___test_optional_intlist(const at::Tensor & values, at::OptionalIntArrayRef addends) {
    // No device check
  // DeviceGuard omitted
  return at::native::_test_optional_intlist(values, addends);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___test_optional_filled_intlist(const at::Tensor & values, at::OptionalIntArrayRef addends) {
    // No device check
  // DeviceGuard omitted
  return at::native::_test_optional_intlist(values, addends);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___test_optional_floatlist(const at::Tensor & values, c10::optional<at::ArrayRef<double>> addends) {
    // No device check
  // DeviceGuard omitted
  return at::native::_test_optional_floatlist(values, addends);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU__segment_reduce(const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & indices, const c10::optional<at::Tensor> & offsets, int64_t axis, bool unsafe, const c10::optional<at::Scalar> & initial) {
    // No device check
  // DeviceGuard omitted
  return at::native::segment_reduce_kernel(data, reduce, lengths, indices, offsets, axis, unsafe, initial);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___segment_reduce_backward(const at::Tensor & grad, const at::Tensor & output, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & offsets, int64_t axis, const c10::optional<at::Scalar> & initial) {
    // No device check
  // DeviceGuard omitted
  return at::native::_segment_reduce_backward_kernel(grad, output, data, reduce, lengths, offsets, axis, initial);
}
} // anonymous namespace
namespace {
at::Tensor wrapper_CPU___transformer_encoder_layer_fwd(const at::Tensor & src, int64_t embed_dim, int64_t num_heads, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, bool use_gelu, bool norm_first, double eps, const at::Tensor & norm_weight_1, const at::Tensor & norm_bias_1, const at::Tensor & norm_weight_2, const at::Tensor & norm_bias_2, const at::Tensor & ffn_weight_1, const at::Tensor & ffn_bias_1, const at::Tensor & ffn_weight_2, const at::Tensor & ffn_bias_2, const c10::optional<at::Tensor> & mask, c10::optional<int64_t> mask_type) {
    // No device check
  // DeviceGuard omitted
  return at::native::transformer_encoder_layer_forward(src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, mask_type);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___native_multi_head_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, int64_t embed_dim, int64_t num_head, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, const c10::optional<at::Tensor> & mask, bool need_weights, bool average_attn_weights, c10::optional<int64_t> mask_type) {
    // No device check
  // DeviceGuard omitted
  return at::native::native_multi_head_attention_cpu(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, need_weights, average_attn_weights, mask_type);
}
} // anonymous namespace
namespace {
int64_t wrapper_CPU___fused_sdp_choice(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & attn_mask, double dropout_p, bool is_causal, c10::optional<double> scale) {
    // No device check
  // DeviceGuard omitted
  return at::native::_fused_sdp_choice_cpp(query, key, value, attn_mask, dropout_p, is_causal, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor> wrapper_CPU___scaled_dot_product_flash_attention_for_cpu(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, double dropout_p, bool is_causal, const c10::optional<at::Tensor> & attn_mask, c10::optional<double> scale) {
    // No device check
  // DeviceGuard omitted
  return at::native::_scaled_dot_product_flash_attention_cpu(query, key, value, dropout_p, is_causal, attn_mask, scale);
}
} // anonymous namespace
namespace {
::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper_CPU___scaled_dot_product_flash_attention_for_cpu_backward(const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, double dropout_p, bool is_causal, const c10::optional<at::Tensor> & attn_mask, c10::optional<double> scale) {
    // No device check
  // DeviceGuard omitted
  return at::native::_scaled_dot_product_flash_attention_cpu_backward(grad_out, query, key, value, out, logsumexp, dropout_p, is_causal, attn_mask, scale);
}
} // anonymous namespace
struct structured_special_airy_ai_out_functional final : public at::native::structured_special_airy_ai_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_airy_ai_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_airy_ai_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_airy_ai(const at::Tensor & x) {
structured_special_airy_ai_out_functional op;
op.meta(x);
op.impl(x, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_airy_ai_out_out final : public at::native::structured_special_airy_ai_out {
    structured_special_airy_ai_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_airy_ai_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_airy_ai_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_airy_ai_out_out(const at::Tensor & x, at::Tensor & out) {
structured_special_airy_ai_out_out op(out);
op.meta(x);
op.impl(x, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_bessel_j0_out_functional final : public at::native::structured_special_bessel_j0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_bessel_j0(const at::Tensor & self) {
structured_special_bessel_j0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_bessel_j0_out_out final : public at::native::structured_special_bessel_j0_out {
    structured_special_bessel_j0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_bessel_j0_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_bessel_j0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_bessel_j1_out_functional final : public at::native::structured_special_bessel_j1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_bessel_j1(const at::Tensor & self) {
structured_special_bessel_j1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_bessel_j1_out_out final : public at::native::structured_special_bessel_j1_out {
    structured_special_bessel_j1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_j1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_bessel_j1_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_bessel_j1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_bessel_y0_out_functional final : public at::native::structured_special_bessel_y0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_bessel_y0(const at::Tensor & self) {
structured_special_bessel_y0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_bessel_y0_out_out final : public at::native::structured_special_bessel_y0_out {
    structured_special_bessel_y0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_bessel_y0_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_bessel_y0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_bessel_y1_out_functional final : public at::native::structured_special_bessel_y1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_bessel_y1(const at::Tensor & self) {
structured_special_bessel_y1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_bessel_y1_out_out final : public at::native::structured_special_bessel_y1_out {
    structured_special_bessel_y1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_bessel_y1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_bessel_y1_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_bessel_y1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_chebyshev_polynomial_t_out_functional final : public at::native::structured_special_chebyshev_polynomial_t_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_chebyshev_polynomial_t(const at::Tensor & x, const at::Tensor & n) {
structured_special_chebyshev_polynomial_t_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_chebyshev_polynomial_t_out_out final : public at::native::structured_special_chebyshev_polynomial_t_out {
    structured_special_chebyshev_polynomial_t_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_chebyshev_polynomial_t_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_chebyshev_polynomial_t_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_chebyshev_polynomial_u_out_functional final : public at::native::structured_special_chebyshev_polynomial_u_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_chebyshev_polynomial_u(const at::Tensor & x, const at::Tensor & n) {
structured_special_chebyshev_polynomial_u_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_chebyshev_polynomial_u_out_out final : public at::native::structured_special_chebyshev_polynomial_u_out {
    structured_special_chebyshev_polynomial_u_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_chebyshev_polynomial_u_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_chebyshev_polynomial_u_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_chebyshev_polynomial_v_out_functional final : public at::native::structured_special_chebyshev_polynomial_v_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_chebyshev_polynomial_v(const at::Tensor & x, const at::Tensor & n) {
structured_special_chebyshev_polynomial_v_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_chebyshev_polynomial_v_out_out final : public at::native::structured_special_chebyshev_polynomial_v_out {
    structured_special_chebyshev_polynomial_v_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_chebyshev_polynomial_v_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_chebyshev_polynomial_v_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_chebyshev_polynomial_w_out_functional final : public at::native::structured_special_chebyshev_polynomial_w_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_chebyshev_polynomial_w(const at::Tensor & x, const at::Tensor & n) {
structured_special_chebyshev_polynomial_w_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_chebyshev_polynomial_w_out_out final : public at::native::structured_special_chebyshev_polynomial_w_out {
    structured_special_chebyshev_polynomial_w_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_chebyshev_polynomial_w_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_chebyshev_polynomial_w_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_hermite_polynomial_h_out_functional final : public at::native::structured_special_hermite_polynomial_h_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_h_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_h_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_hermite_polynomial_h(const at::Tensor & x, const at::Tensor & n) {
structured_special_hermite_polynomial_h_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_hermite_polynomial_h_out_out final : public at::native::structured_special_hermite_polynomial_h_out {
    structured_special_hermite_polynomial_h_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_h_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_h_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_hermite_polynomial_h_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_hermite_polynomial_h_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_hermite_polynomial_he_out_functional final : public at::native::structured_special_hermite_polynomial_he_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_he_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_he_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_hermite_polynomial_he(const at::Tensor & x, const at::Tensor & n) {
structured_special_hermite_polynomial_he_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_hermite_polynomial_he_out_out final : public at::native::structured_special_hermite_polynomial_he_out {
    structured_special_hermite_polynomial_he_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_he_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_hermite_polynomial_he_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_hermite_polynomial_he_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_hermite_polynomial_he_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_laguerre_polynomial_l_out_functional final : public at::native::structured_special_laguerre_polynomial_l_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_laguerre_polynomial_l_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_laguerre_polynomial_l_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_laguerre_polynomial_l(const at::Tensor & x, const at::Tensor & n) {
structured_special_laguerre_polynomial_l_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_laguerre_polynomial_l_out_out final : public at::native::structured_special_laguerre_polynomial_l_out {
    structured_special_laguerre_polynomial_l_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_laguerre_polynomial_l_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_laguerre_polynomial_l_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_laguerre_polynomial_l_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_laguerre_polynomial_l_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_legendre_polynomial_p_out_functional final : public at::native::structured_special_legendre_polynomial_p_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_legendre_polynomial_p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_legendre_polynomial_p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_legendre_polynomial_p(const at::Tensor & x, const at::Tensor & n) {
structured_special_legendre_polynomial_p_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_legendre_polynomial_p_out_out final : public at::native::structured_special_legendre_polynomial_p_out {
    structured_special_legendre_polynomial_p_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_legendre_polynomial_p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_legendre_polynomial_p_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_legendre_polynomial_p_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_legendre_polynomial_p_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_modified_bessel_i0_out_functional final : public at::native::structured_special_modified_bessel_i0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_modified_bessel_i0(const at::Tensor & self) {
structured_special_modified_bessel_i0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_modified_bessel_i0_out_out final : public at::native::structured_special_modified_bessel_i0_out {
    structured_special_modified_bessel_i0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_modified_bessel_i0_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_modified_bessel_i0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_modified_bessel_i1_out_functional final : public at::native::structured_special_modified_bessel_i1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_modified_bessel_i1(const at::Tensor & self) {
structured_special_modified_bessel_i1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_modified_bessel_i1_out_out final : public at::native::structured_special_modified_bessel_i1_out {
    structured_special_modified_bessel_i1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_i1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_modified_bessel_i1_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_modified_bessel_i1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_modified_bessel_k0_out_functional final : public at::native::structured_special_modified_bessel_k0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_modified_bessel_k0(const at::Tensor & self) {
structured_special_modified_bessel_k0_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_modified_bessel_k0_out_out final : public at::native::structured_special_modified_bessel_k0_out {
    structured_special_modified_bessel_k0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_modified_bessel_k0_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_modified_bessel_k0_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_modified_bessel_k1_out_functional final : public at::native::structured_special_modified_bessel_k1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_modified_bessel_k1(const at::Tensor & self) {
structured_special_modified_bessel_k1_out_functional op;
op.meta(self);
op.impl(self, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_modified_bessel_k1_out_out final : public at::native::structured_special_modified_bessel_k1_out {
    structured_special_modified_bessel_k1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_modified_bessel_k1_out_out(const at::Tensor & self, at::Tensor & out) {
structured_special_modified_bessel_k1_out_out op(out);
op.meta(self);
op.impl(self, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_scaled_modified_bessel_k0_out_functional final : public at::native::structured_special_scaled_modified_bessel_k0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_scaled_modified_bessel_k0(const at::Tensor & x) {
structured_special_scaled_modified_bessel_k0_out_functional op;
op.meta(x);
op.impl(x, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_scaled_modified_bessel_k0_out_out final : public at::native::structured_special_scaled_modified_bessel_k0_out {
    structured_special_scaled_modified_bessel_k0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_scaled_modified_bessel_k0_out_out(const at::Tensor & x, at::Tensor & out) {
structured_special_scaled_modified_bessel_k0_out_out op(out);
op.meta(x);
op.impl(x, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_scaled_modified_bessel_k1_out_functional final : public at::native::structured_special_scaled_modified_bessel_k1_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_scaled_modified_bessel_k1(const at::Tensor & x) {
structured_special_scaled_modified_bessel_k1_out_functional op;
op.meta(x);
op.impl(x, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_scaled_modified_bessel_k1_out_out final : public at::native::structured_special_scaled_modified_bessel_k1_out {
    structured_special_scaled_modified_bessel_k1_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_scaled_modified_bessel_k1_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_scaled_modified_bessel_k1_out_out(const at::Tensor & x, at::Tensor & out) {
structured_special_scaled_modified_bessel_k1_out_out op(out);
op.meta(x);
op.impl(x, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_shifted_chebyshev_polynomial_t_out_functional final : public at::native::structured_special_shifted_chebyshev_polynomial_t_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_shifted_chebyshev_polynomial_t(const at::Tensor & x, const at::Tensor & n) {
structured_special_shifted_chebyshev_polynomial_t_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_shifted_chebyshev_polynomial_t_out_out final : public at::native::structured_special_shifted_chebyshev_polynomial_t_out {
    structured_special_shifted_chebyshev_polynomial_t_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_t_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_shifted_chebyshev_polynomial_t_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_shifted_chebyshev_polynomial_t_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_shifted_chebyshev_polynomial_u_out_functional final : public at::native::structured_special_shifted_chebyshev_polynomial_u_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_shifted_chebyshev_polynomial_u(const at::Tensor & x, const at::Tensor & n) {
structured_special_shifted_chebyshev_polynomial_u_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_shifted_chebyshev_polynomial_u_out_out final : public at::native::structured_special_shifted_chebyshev_polynomial_u_out {
    structured_special_shifted_chebyshev_polynomial_u_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_u_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_shifted_chebyshev_polynomial_u_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_shifted_chebyshev_polynomial_u_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_shifted_chebyshev_polynomial_v_out_functional final : public at::native::structured_special_shifted_chebyshev_polynomial_v_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_shifted_chebyshev_polynomial_v(const at::Tensor & x, const at::Tensor & n) {
structured_special_shifted_chebyshev_polynomial_v_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_shifted_chebyshev_polynomial_v_out_out final : public at::native::structured_special_shifted_chebyshev_polynomial_v_out {
    structured_special_shifted_chebyshev_polynomial_v_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_v_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_shifted_chebyshev_polynomial_v_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_shifted_chebyshev_polynomial_v_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_shifted_chebyshev_polynomial_w_out_functional final : public at::native::structured_special_shifted_chebyshev_polynomial_w_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_shifted_chebyshev_polynomial_w(const at::Tensor & x, const at::Tensor & n) {
structured_special_shifted_chebyshev_polynomial_w_out_functional op;
op.meta(x, n);
op.impl(x, n, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_shifted_chebyshev_polynomial_w_out_out final : public at::native::structured_special_shifted_chebyshev_polynomial_w_out {
    structured_special_shifted_chebyshev_polynomial_w_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_shifted_chebyshev_polynomial_w_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_shifted_chebyshev_polynomial_w_out_out(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
structured_special_shifted_chebyshev_polynomial_w_out_out op(out);
op.meta(x, n);
op.impl(x, n, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
struct structured_special_spherical_bessel_j0_out_functional final : public at::native::structured_special_spherical_bessel_j0_out {
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_spherical_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        outputs_[output_idx] = create_out(sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_spherical_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return outputs_[output_idx];
    }
    std::array<Tensor, 1> outputs_;
};
at::Tensor wrapper_CPU_special_spherical_bessel_j0(const at::Tensor & x) {
structured_special_spherical_bessel_j0_out_functional op;
op.meta(x);
op.impl(x, op.outputs_[0]);
return std::move(op.outputs_[0]);
}
struct structured_special_spherical_bessel_j0_out_out final : public at::native::structured_special_spherical_bessel_j0_out {
    structured_special_spherical_bessel_j0_out_out(Tensor& out0) : outputs_{ std::ref(out0) } {}
    void set_output_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        auto maybe_proxy = maybe_create_proxy(out, sizes, strides, options);
        if (C10_UNLIKELY(maybe_proxy.has_value())) {
            proxy_outputs_[output_idx] = std::move(maybe_proxy).value();
        }
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_spherical_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    void set_output_raw_strided(
        int64_t output_idx, IntArrayRef sizes, IntArrayRef strides,
        TensorOptions options, DimnameList names
    ) override {
        const auto& out = outputs_[output_idx].get();
        resize_out(out, sizes, strides, options);
        if (!names.empty()) {
          namedinference::propagate_names(outputs_[output_idx], names);
        }
        // super must happen after, so that downstream can use maybe_get_output
        // to retrieve the output
        at::native::structured_special_spherical_bessel_j0_out::set_output_raw_strided(output_idx, sizes, strides, options, names);
    }
    const Tensor& maybe_get_output(int64_t output_idx) override {
      return proxy_outputs_[output_idx].has_value() ? *proxy_outputs_[output_idx] : outputs_[output_idx].get();
    }
    std::array<std::reference_wrapper<Tensor>, 1> outputs_;
    std::array<c10::optional<Tensor>, 1> proxy_outputs_;
};
at::Tensor & wrapper_CPU_special_spherical_bessel_j0_out_out(const at::Tensor & x, at::Tensor & out) {
structured_special_spherical_bessel_j0_out_out op(out);
op.meta(x);
op.impl(x, op.maybe_get_output(0));
if (op.proxy_outputs_[0].has_value()) op.outputs_[0].get().copy_(*op.proxy_outputs_[0]);
return out;
}
namespace {
at::Tensor wrapper_CPU___foobar(const at::Tensor & self, bool arg1, bool arg2, bool arg3) {
    // No device check
  // DeviceGuard omitted
  return at::native::foobar(self, arg1, arg2, arg3);
}
} // anonymous namespace
TORCH_LIBRARY_IMPL(aten, CPU, m) {
    m.impl("_assert_async",
TORCH_FN(wrapper_CPU___assert_async));
m.impl("_assert_async.msg",
TORCH_FN(wrapper_CPU_msg__assert_async));
m.impl("_functional_assert_async.msg",
TORCH_FN(wrapper_CPU_msg__functional_assert_async));
m.impl("_make_dep_token",
TORCH_FN(wrapper_CPU___make_dep_token));
m.impl("native_dropout",
TORCH_FN(wrapper_CPU__native_dropout));
m.impl("native_dropout_backward",
TORCH_FN(wrapper_CPU__native_dropout_backward));
m.impl("abs.out",
TORCH_FN(wrapper_CPU_out_abs_out));
m.impl("angle",
TORCH_FN(wrapper_CPU__angle));
m.impl("angle.out",
TORCH_FN(wrapper_CPU_out_angle_out));
m.impl("view_as_real",
TORCH_FN(wrapper_CPU__view_as_real));
m.impl("view_as_complex",
TORCH_FN(wrapper_CPU__view_as_complex));
m.impl("sgn", TORCH_FN(wrapper_CPU_sgn));
m.impl("sgn.out", TORCH_FN(wrapper_CPU_sgn_out_out));
m.impl("sgn_", TORCH_FN(wrapper_CPU_sgn_));
m.impl("conj_physical.out",
TORCH_FN(wrapper_CPU_out_conj_physical_out));
m.impl("acos", TORCH_FN(wrapper_CPU_acos));
m.impl("acos.out", TORCH_FN(wrapper_CPU_acos_out_out));
m.impl("acos_", TORCH_FN(wrapper_CPU_acos_));
m.impl("add.Tensor", TORCH_FN(wrapper_CPU_add_Tensor));
m.impl("add.out", TORCH_FN(wrapper_CPU_add_out_out));
m.impl("add_.Tensor", TORCH_FN(wrapper_CPU_add__Tensor));
m.impl("_add_relu.Tensor",
TORCH_FN(wrapper_CPU_Tensor__add_relu));
m.impl("_add_relu.out",
TORCH_FN(wrapper_CPU_out__add_relu_out));
m.impl("_add_relu_.Tensor",
TORCH_FN(wrapper_CPU_Tensor__add_relu_));
m.impl("_add_relu.Scalar",
TORCH_FN(wrapper_CPU_Scalar__add_relu));
m.impl("_add_relu_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__add_relu_));
m.impl("addmv", TORCH_FN(wrapper_CPU_addmv));
m.impl("addmv.out", TORCH_FN(wrapper_CPU_addmv_out_out));
m.impl("addmv_", TORCH_FN(wrapper_CPU_addmv_));
m.impl("addr",
TORCH_FN(wrapper_CPU__addr));
m.impl("addr.out",
TORCH_FN(wrapper_CPU_out_addr_out));
m.impl("_test_functorch_fallback",
TORCH_FN(wrapper_CPU___test_functorch_fallback));
m.impl("all.dim", TORCH_FN(wrapper_CPU_all_dim));
m.impl("all.out", TORCH_FN(wrapper_CPU_all_out_out));
m.impl("all.dims", TORCH_FN(wrapper_CPU_all_dims));
m.impl("all.dims_out", TORCH_FN(wrapper_CPU_all_out_dims_out));
m.impl("any.dim", TORCH_FN(wrapper_CPU_any_dim));
m.impl("any.out", TORCH_FN(wrapper_CPU_any_out_out));
m.impl("any.dims", TORCH_FN(wrapper_CPU_any_dims));
m.impl("any.dims_out", TORCH_FN(wrapper_CPU_any_out_dims_out));
m.impl("arange.start_out",
TORCH_FN(wrapper_CPU_start_out_arange_out));
m.impl("argmax", TORCH_FN(wrapper_CPU_argmax));
m.impl("argmax.out", TORCH_FN(wrapper_CPU_argmax_out_out));
m.impl("argmin", TORCH_FN(wrapper_CPU_argmin));
m.impl("argmin.out", TORCH_FN(wrapper_CPU_argmin_out_out));
m.impl("acosh", TORCH_FN(wrapper_CPU_acosh));
m.impl("acosh.out", TORCH_FN(wrapper_CPU_acosh_out_out));
m.impl("acosh_", TORCH_FN(wrapper_CPU_acosh_));
m.impl("asinh", TORCH_FN(wrapper_CPU_asinh));
m.impl("asinh.out", TORCH_FN(wrapper_CPU_asinh_out_out));
m.impl("asinh_", TORCH_FN(wrapper_CPU_asinh_));
m.impl("atanh", TORCH_FN(wrapper_CPU_atanh));
m.impl("atanh.out", TORCH_FN(wrapper_CPU_atanh_out_out));
m.impl("atanh_", TORCH_FN(wrapper_CPU_atanh_));
m.impl("as_strided",
TORCH_FN(wrapper_CPU__as_strided));
m.impl("asin", TORCH_FN(wrapper_CPU_asin));
m.impl("asin.out", TORCH_FN(wrapper_CPU_asin_out_out));
m.impl("asin_", TORCH_FN(wrapper_CPU_asin_));
m.impl("atan", TORCH_FN(wrapper_CPU_atan));
m.impl("atan.out", TORCH_FN(wrapper_CPU_atan_out_out));
m.impl("atan_", TORCH_FN(wrapper_CPU_atan_));
m.impl("baddbmm", TORCH_FN(wrapper_CPU_baddbmm));
m.impl("baddbmm.out", TORCH_FN(wrapper_CPU_baddbmm_out_out));
m.impl("baddbmm_", TORCH_FN(wrapper_CPU_baddbmm_));
m.impl("bernoulli.out",
TORCH_FN(wrapper_CPU_out_bernoulli_out));
m.impl("bernoulli_.Tensor",
TORCH_FN(wrapper_CPU_Tensor_bernoulli_));
m.impl("bernoulli_.float",
TORCH_FN(wrapper_CPU_float_bernoulli_));
m.impl("binary_cross_entropy",
TORCH_FN(wrapper_CPU__binary_cross_entropy));
m.impl("binary_cross_entropy.out",
TORCH_FN(wrapper_CPU_out_binary_cross_entropy_out));
m.impl("binary_cross_entropy_backward",
TORCH_FN(wrapper_CPU__binary_cross_entropy_backward));
m.impl("binary_cross_entropy_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_binary_cross_entropy_backward_out));
m.impl("bincount",
TORCH_FN(wrapper_CPU__bincount));
m.impl("bitwise_not", TORCH_FN(wrapper_CPU_bitwise_not));
m.impl("bitwise_not.out", TORCH_FN(wrapper_CPU_bitwise_not_out_out));
m.impl("bitwise_not_", TORCH_FN(wrapper_CPU_bitwise_not_));
m.impl("copysign.Tensor", TORCH_FN(wrapper_CPU_copysign_Tensor));
m.impl("copysign.out", TORCH_FN(wrapper_CPU_copysign_out_out));
m.impl("copysign_.Tensor", TORCH_FN(wrapper_CPU_copysign__Tensor));
m.impl("logical_not.out",
TORCH_FN(wrapper_CPU_out_logical_not_out));
m.impl("logical_xor.out",
TORCH_FN(wrapper_CPU_out_logical_xor_out));
m.impl("logical_and.out",
TORCH_FN(wrapper_CPU_out_logical_and_out));
m.impl("logical_or.out",
TORCH_FN(wrapper_CPU_out_logical_or_out));
m.impl("bmm", TORCH_FN(wrapper_CPU_bmm));
m.impl("bmm.out", TORCH_FN(wrapper_CPU_bmm_out_out));
m.impl("cat", TORCH_FN(wrapper_CPU_cat));
m.impl("cat.out", TORCH_FN(wrapper_CPU_cat_out_out));
m.impl("ceil", TORCH_FN(wrapper_CPU_ceil));
m.impl("ceil.out", TORCH_FN(wrapper_CPU_ceil_out_out));
m.impl("ceil_", TORCH_FN(wrapper_CPU_ceil_));
m.impl("clamp", TORCH_FN(wrapper_CPU_clamp));
m.impl("clamp.out", TORCH_FN(wrapper_CPU_clamp_out_out));
m.impl("clamp_", TORCH_FN(wrapper_CPU_clamp_));
m.impl("clamp.Tensor", TORCH_FN(wrapper_CPU_clamp_Tensor));
m.impl("clamp.Tensor_out", TORCH_FN(wrapper_CPU_clamp_out_Tensor_out));
m.impl("clamp_.Tensor", TORCH_FN(wrapper_CPU_clamp__Tensor));
m.impl("clamp_max", TORCH_FN(wrapper_CPU_clamp_max));
m.impl("clamp_max.out", TORCH_FN(wrapper_CPU_clamp_max_out_out));
m.impl("clamp_max_", TORCH_FN(wrapper_CPU_clamp_max_));
m.impl("clamp_max.Tensor", TORCH_FN(wrapper_CPU_clamp_max_Tensor));
m.impl("clamp_max.Tensor_out", TORCH_FN(wrapper_CPU_clamp_max_out_Tensor_out));
m.impl("clamp_max_.Tensor", TORCH_FN(wrapper_CPU_clamp_max__Tensor));
m.impl("clamp_min", TORCH_FN(wrapper_CPU_clamp_min));
m.impl("clamp_min.out", TORCH_FN(wrapper_CPU_clamp_min_out_out));
m.impl("clamp_min_", TORCH_FN(wrapper_CPU_clamp_min_));
m.impl("clamp_min.Tensor", TORCH_FN(wrapper_CPU_clamp_min_Tensor));
m.impl("clamp_min.Tensor_out", TORCH_FN(wrapper_CPU_clamp_min_out_Tensor_out));
m.impl("clamp_min_.Tensor", TORCH_FN(wrapper_CPU_clamp_min__Tensor));
m.impl("complex.out",
TORCH_FN(wrapper_CPU_out_complex_out));
m.impl("polar.out",
TORCH_FN(wrapper_CPU_out_polar_out));
m.impl("cos", TORCH_FN(wrapper_CPU_cos));
m.impl("cos.out", TORCH_FN(wrapper_CPU_cos_out_out));
m.impl("cos_", TORCH_FN(wrapper_CPU_cos_));
m.impl("cosh", TORCH_FN(wrapper_CPU_cosh));
m.impl("cosh.out", TORCH_FN(wrapper_CPU_cosh_out_out));
m.impl("cosh_", TORCH_FN(wrapper_CPU_cosh_));
m.impl("count_nonzero.dim_IntList",
TORCH_FN(wrapper_CPU_dim_IntList_count_nonzero));
m.impl("_cummax_helper",
TORCH_FN(wrapper_CPU___cummax_helper));
m.impl("_cummin_helper",
TORCH_FN(wrapper_CPU___cummin_helper));
m.impl("cumprod", TORCH_FN(wrapper_CPU_cumprod));
m.impl("cumprod.out", TORCH_FN(wrapper_CPU_cumprod_out_out));
m.impl("cumprod_", TORCH_FN(wrapper_CPU_cumprod_));
m.impl("cumsum", TORCH_FN(wrapper_CPU_cumsum));
m.impl("cumsum.out", TORCH_FN(wrapper_CPU_cumsum_out_out));
m.impl("cumsum_", TORCH_FN(wrapper_CPU_cumsum_));
m.impl("_ctc_loss",
TORCH_FN(wrapper_CPU___ctc_loss));
m.impl("_ctc_loss.Tensor",
TORCH_FN(wrapper_CPU_Tensor__ctc_loss));
m.impl("_ctc_loss_backward",
TORCH_FN(wrapper_CPU___ctc_loss_backward));
m.impl("_ctc_loss_backward.Tensor",
TORCH_FN(wrapper_CPU_Tensor__ctc_loss_backward));
m.impl("div.Tensor", TORCH_FN(wrapper_CPU_div_Tensor));
m.impl("div.out", TORCH_FN(wrapper_CPU_div_out_out));
m.impl("div_.Tensor", TORCH_FN(wrapper_CPU_div__Tensor));
m.impl("div.Tensor_mode", TORCH_FN(wrapper_CPU_div_Tensor_mode));
m.impl("div.out_mode", TORCH_FN(wrapper_CPU_div_out_out_mode));
m.impl("div_.Tensor_mode", TORCH_FN(wrapper_CPU_div__Tensor_mode));
m.impl("dot",
TORCH_FN(wrapper_CPU__dot));
m.impl("vdot",
TORCH_FN(wrapper_CPU__vdot));
m.impl("embedding_dense_backward",
TORCH_FN(wrapper_CPU__embedding_dense_backward));
m.impl("embedding_renorm_",
TORCH_FN(wrapper_CPU__embedding_renorm_));
m.impl("_embedding_bag_forward_only",
TORCH_FN(wrapper_CPU___embedding_bag_forward_only));
m.impl("_embedding_bag",
TORCH_FN(wrapper_CPU___embedding_bag));
m.impl("_embedding_bag_dense_backward",
TORCH_FN(wrapper_CPU___embedding_bag_dense_backward));
m.impl("_embedding_bag_per_sample_weights_backward",
TORCH_FN(wrapper_CPU___embedding_bag_per_sample_weights_backward));
m.impl("empty.memory_format",
TORCH_FN(wrapper_CPU_memory_format_empty));
m.impl("_empty_affine_quantized",
TORCH_FN(wrapper_CPU___empty_affine_quantized));
m.impl("_empty_per_channel_affine_quantized",
TORCH_FN(wrapper_CPU___empty_per_channel_affine_quantized));
m.impl("resize_",
TORCH_FN(wrapper_CPU__resize_));
m.impl("empty_strided",
TORCH_FN(wrapper_CPU__empty_strided));
m.impl("erf", TORCH_FN(wrapper_CPU_erf));
m.impl("erf.out", TORCH_FN(wrapper_CPU_erf_out_out));
m.impl("erf_", TORCH_FN(wrapper_CPU_erf_));
m.impl("erfc", TORCH_FN(wrapper_CPU_erfc));
m.impl("erfc.out", TORCH_FN(wrapper_CPU_erfc_out_out));
m.impl("erfc_", TORCH_FN(wrapper_CPU_erfc_));
m.impl("exp", TORCH_FN(wrapper_CPU_exp));
m.impl("exp.out", TORCH_FN(wrapper_CPU_exp_out_out));
m.impl("exp_", TORCH_FN(wrapper_CPU_exp_));
m.impl("exp2", TORCH_FN(wrapper_CPU_exp2));
m.impl("exp2.out", TORCH_FN(wrapper_CPU_exp2_out_out));
m.impl("exp2_", TORCH_FN(wrapper_CPU_exp2_));
m.impl("expm1", TORCH_FN(wrapper_CPU_expm1));
m.impl("expm1.out", TORCH_FN(wrapper_CPU_expm1_out_out));
m.impl("expm1_", TORCH_FN(wrapper_CPU_expm1_));
m.impl("eye.out",
TORCH_FN(wrapper_CPU_out_eye_out));
m.impl("eye.m_out",
TORCH_FN(wrapper_CPU_m_out_eye_out));
m.impl("fill_.Scalar",
TORCH_FN(wrapper_CPU_Scalar_fill_));
m.impl("fill_.Tensor",
TORCH_FN(wrapper_CPU_Tensor_fill_));
m.impl("floor", TORCH_FN(wrapper_CPU_floor));
m.impl("floor.out", TORCH_FN(wrapper_CPU_floor_out_out));
m.impl("floor_", TORCH_FN(wrapper_CPU_floor_));
m.impl("floor_divide",
TORCH_FN(wrapper_CPU__floor_divide));
m.impl("floor_divide.out",
TORCH_FN(wrapper_CPU_out_floor_divide_out));
m.impl("floor_divide_.Tensor",
TORCH_FN(wrapper_CPU_Tensor_floor_divide_));
m.impl("frac", TORCH_FN(wrapper_CPU_frac));
m.impl("frac.out", TORCH_FN(wrapper_CPU_frac_out_out));
m.impl("frac_", TORCH_FN(wrapper_CPU_frac_));
m.impl("from_file",
TORCH_FN(wrapper_CPU__from_file));
m.impl("gcd", TORCH_FN(wrapper_CPU_gcd));
m.impl("gcd.out", TORCH_FN(wrapper_CPU_gcd_out_out));
m.impl("gcd_", TORCH_FN(wrapper_CPU_gcd_));
m.impl("lcm", TORCH_FN(wrapper_CPU_lcm));
m.impl("lcm.out", TORCH_FN(wrapper_CPU_lcm_out_out));
m.impl("lcm_", TORCH_FN(wrapper_CPU_lcm_));
m.impl("grid_sampler_2d",
TORCH_FN(wrapper_CPU__grid_sampler_2d));
m.impl("grid_sampler_2d_backward",
TORCH_FN(wrapper_CPU__grid_sampler_2d_backward));
m.impl("grid_sampler_3d",
TORCH_FN(wrapper_CPU__grid_sampler_3d));
m.impl("grid_sampler_3d_backward",
TORCH_FN(wrapper_CPU__grid_sampler_3d_backward));
m.impl("native_group_norm",
TORCH_FN(wrapper_CPU__native_group_norm));
m.impl("native_group_norm_backward",
TORCH_FN(wrapper_CPU__native_group_norm_backward));
m.impl("_fft_r2c",
TORCH_FN(wrapper_CPU___fft_r2c));
m.impl("_fft_r2c.out",
TORCH_FN(wrapper_CPU_out__fft_r2c_out));
m.impl("_fft_c2r",
TORCH_FN(wrapper_CPU___fft_c2r));
m.impl("_fft_c2r.out",
TORCH_FN(wrapper_CPU_out__fft_c2r_out));
m.impl("_fft_c2c",
TORCH_FN(wrapper_CPU___fft_c2c));
m.impl("_fft_c2c.out",
TORCH_FN(wrapper_CPU_out__fft_c2c_out));
m.impl("_validate_compressed_sparse_indices",
TORCH_FN(wrapper_CPU___validate_compressed_sparse_indices));
m.impl("index.Tensor", TORCH_FN(wrapper_CPU_index_Tensor));
m.impl("index.Tensor_out", TORCH_FN(wrapper_CPU_index_out_Tensor_out));
m.impl("index_copy", TORCH_FN(wrapper_CPU_index_copy));
m.impl("index_copy.out", TORCH_FN(wrapper_CPU_index_copy_out_out));
m.impl("index_copy_", TORCH_FN(wrapper_CPU_index_copy_));
m.impl("_index_put_impl_",
TORCH_FN(wrapper_CPU___index_put_impl_));
m.impl("isin.Tensor_Tensor", TORCH_FN(wrapper_CPU_isin_Tensor_Tensor));
m.impl("isin.Tensor_Tensor_out", TORCH_FN(wrapper_CPU_isin_out_Tensor_Tensor_out));
m.impl("isin.Tensor_Scalar", TORCH_FN(wrapper_CPU_isin_Tensor_Scalar));
m.impl("isin.Tensor_Scalar_out", TORCH_FN(wrapper_CPU_isin_out_Tensor_Scalar_out));
m.impl("isin.Scalar_Tensor", TORCH_FN(wrapper_CPU_isin_Scalar_Tensor));
m.impl("isin.Scalar_Tensor_out", TORCH_FN(wrapper_CPU_isin_out_Scalar_Tensor_out));
m.impl("isnan",
TORCH_FN(wrapper_CPU__isnan));
m.impl("kthvalue.values",
TORCH_FN(wrapper_CPU_values_kthvalue_out));
m.impl("native_layer_norm",
TORCH_FN(wrapper_CPU__native_layer_norm));
m.impl("native_layer_norm_backward",
TORCH_FN(wrapper_CPU__native_layer_norm_backward));
m.impl("nan_to_num.out",
TORCH_FN(wrapper_CPU_out_nan_to_num_out));
m.impl("linspace.out",
TORCH_FN(wrapper_CPU_out_linspace_out));
m.impl("log", TORCH_FN(wrapper_CPU_log));
m.impl("log.out", TORCH_FN(wrapper_CPU_log_out_out));
m.impl("log_", TORCH_FN(wrapper_CPU_log_));
m.impl("log10", TORCH_FN(wrapper_CPU_log10));
m.impl("log10.out", TORCH_FN(wrapper_CPU_log10_out_out));
m.impl("log10_", TORCH_FN(wrapper_CPU_log10_));
m.impl("log1p", TORCH_FN(wrapper_CPU_log1p));
m.impl("log1p.out", TORCH_FN(wrapper_CPU_log1p_out_out));
m.impl("log1p_", TORCH_FN(wrapper_CPU_log1p_));
m.impl("log2", TORCH_FN(wrapper_CPU_log2));
m.impl("log2.out", TORCH_FN(wrapper_CPU_log2_out_out));
m.impl("log2_", TORCH_FN(wrapper_CPU_log2_));
m.impl("logaddexp", TORCH_FN(wrapper_CPU_logaddexp));
m.impl("logaddexp.out", TORCH_FN(wrapper_CPU_logaddexp_out_out));
m.impl("logaddexp2", TORCH_FN(wrapper_CPU_logaddexp2));
m.impl("logaddexp2.out", TORCH_FN(wrapper_CPU_logaddexp2_out_out));
m.impl("xlogy.Tensor", TORCH_FN(wrapper_CPU_xlogy_Tensor));
m.impl("xlogy.OutTensor", TORCH_FN(wrapper_CPU_xlogy_out_OutTensor));
m.impl("xlogy_.Tensor", TORCH_FN(wrapper_CPU_xlogy__Tensor));
m.impl("logspace.out",
TORCH_FN(wrapper_CPU_out_logspace_out));
m.impl("_log_softmax", TORCH_FN(wrapper_CPU__log_softmax));
m.impl("_log_softmax.out", TORCH_FN(wrapper_CPU__log_softmax_out_out));
m.impl("_log_softmax_backward_data", TORCH_FN(wrapper_CPU__log_softmax_backward_data));
m.impl("_log_softmax_backward_data.out", TORCH_FN(wrapper_CPU__log_softmax_backward_data_out_out));
m.impl("_logcumsumexp",
TORCH_FN(wrapper_CPU___logcumsumexp));
m.impl("_logcumsumexp.out",
TORCH_FN(wrapper_CPU_out__logcumsumexp_out));
m.impl("_aminmax",
TORCH_FN(wrapper_CPU___aminmax));
m.impl("_aminmax.dim",
TORCH_FN(wrapper_CPU_dim__aminmax));
m.impl("aminmax", TORCH_FN(wrapper_CPU_aminmax));
m.impl("aminmax.out", TORCH_FN(wrapper_CPU_aminmax_out_out));
m.impl("_compute_linear_combination",
TORCH_FN(wrapper_CPU___compute_linear_combination));
m.impl("_compute_linear_combination.out",
TORCH_FN(wrapper_CPU_out__compute_linear_combination_out));
m.impl("max.dim", TORCH_FN(wrapper_CPU_max_dim));
m.impl("max.dim_max", TORCH_FN(wrapper_CPU_max_out_dim_max));
m.impl("amax", TORCH_FN(wrapper_CPU_amax));
m.impl("amax.out", TORCH_FN(wrapper_CPU_amax_out_out));
m.impl("mean.dim", TORCH_FN(wrapper_CPU_mean_dim));
m.impl("mean.out", TORCH_FN(wrapper_CPU_mean_out_out));
m.impl("median",
TORCH_FN(wrapper_CPU__median));
m.impl("median.dim_values",
TORCH_FN(wrapper_CPU_dim_values_median_out));
m.impl("nanmedian",
TORCH_FN(wrapper_CPU__nanmedian));
m.impl("nanmedian.dim_values",
TORCH_FN(wrapper_CPU_dim_values_nanmedian_out));
m.impl("min.dim", TORCH_FN(wrapper_CPU_min_dim));
m.impl("min.dim_min", TORCH_FN(wrapper_CPU_min_out_dim_min));
m.impl("amin", TORCH_FN(wrapper_CPU_amin));
m.impl("amin.out", TORCH_FN(wrapper_CPU_amin_out_out));
m.impl("mkldnn_rnn_layer",
TORCH_FN(wrapper_CPU__mkldnn_rnn_layer));
m.impl("mkldnn_rnn_layer_backward",
TORCH_FN(wrapper_CPU__mkldnn_rnn_layer_backward));
m.impl("mm", TORCH_FN(wrapper_CPU_mm));
m.impl("mm.out", TORCH_FN(wrapper_CPU_mm_out_out));
m.impl("mode",
TORCH_FN(wrapper_CPU__mode));
m.impl("mul.Tensor", TORCH_FN(wrapper_CPU_mul_Tensor));
m.impl("mul.out", TORCH_FN(wrapper_CPU_mul_out_out));
m.impl("mul_.Tensor", TORCH_FN(wrapper_CPU_mul__Tensor));
m.impl("mvlgamma.out",
TORCH_FN(wrapper_CPU_out_mvlgamma_out));
m.impl("narrow_copy",
TORCH_FN(wrapper_CPU__narrow_copy));
m.impl("narrow_copy.out",
TORCH_FN(wrapper_CPU_out_narrow_copy_out));
m.impl("native_batch_norm",
TORCH_FN(wrapper_CPU__native_batch_norm));
m.impl("native_batch_norm.out",
TORCH_FN(wrapper_CPU_out_native_batch_norm_out));
m.impl("_native_batch_norm_legit.out",
TORCH_FN(wrapper_CPU_out__native_batch_norm_legit_out));
m.impl("_native_batch_norm_legit",
TORCH_FN(wrapper_CPU___native_batch_norm_legit));
m.impl("_native_batch_norm_legit.no_stats",
TORCH_FN(wrapper_CPU_no_stats__native_batch_norm_legit));
m.impl("_native_batch_norm_legit.no_stats_out",
TORCH_FN(wrapper_CPU_no_stats_out__native_batch_norm_legit_out));
m.impl("native_batch_norm_backward",
TORCH_FN(wrapper_CPU__native_batch_norm_backward));
m.impl("batch_norm_update_stats",
TORCH_FN(wrapper_CPU__batch_norm_update_stats));
m.impl("_cdist_forward",
TORCH_FN(wrapper_CPU___cdist_forward));
m.impl("_cdist_backward",
TORCH_FN(wrapper_CPU___cdist_backward));
m.impl("_pdist_forward",
TORCH_FN(wrapper_CPU___pdist_forward));
m.impl("_pdist_backward",
TORCH_FN(wrapper_CPU___pdist_backward));
m.impl("pixel_shuffle",
TORCH_FN(wrapper_CPU__pixel_shuffle));
m.impl("pixel_unshuffle",
TORCH_FN(wrapper_CPU__pixel_unshuffle));
m.impl("channel_shuffle",
TORCH_FN(wrapper_CPU__channel_shuffle));
m.impl("native_channel_shuffle",
TORCH_FN(wrapper_CPU__native_channel_shuffle));
m.impl("randperm.generator_out",
TORCH_FN(wrapper_CPU_generator_out_randperm_out));
m.impl("range.out",
TORCH_FN(wrapper_CPU_out_range_out));
m.impl("reciprocal", TORCH_FN(wrapper_CPU_reciprocal));
m.impl("reciprocal.out", TORCH_FN(wrapper_CPU_reciprocal_out_out));
m.impl("reciprocal_", TORCH_FN(wrapper_CPU_reciprocal_));
m.impl("neg", TORCH_FN(wrapper_CPU_neg));
m.impl("neg.out", TORCH_FN(wrapper_CPU_neg_out_out));
m.impl("neg_", TORCH_FN(wrapper_CPU_neg_));
m.impl("repeat_interleave.Tensor",
TORCH_FN(wrapper_CPU_Tensor_repeat_interleave));
m.impl("_reshape_alias",
TORCH_FN(wrapper_CPU___reshape_alias));
m.impl("round", TORCH_FN(wrapper_CPU_round));
m.impl("round.out", TORCH_FN(wrapper_CPU_round_out_out));
m.impl("round_", TORCH_FN(wrapper_CPU_round_));
m.impl("round.decimals", TORCH_FN(wrapper_CPU_round_decimals));
m.impl("round.decimals_out", TORCH_FN(wrapper_CPU_round_out_decimals_out));
m.impl("round_.decimals", TORCH_FN(wrapper_CPU_round__decimals));
m.impl("relu",
TORCH_FN(wrapper_CPU__relu));
m.impl("relu_",
TORCH_FN(wrapper_CPU__relu_));
m.impl("_prelu_kernel",
TORCH_FN(wrapper_CPU___prelu_kernel));
m.impl("_prelu_kernel_backward",
TORCH_FN(wrapper_CPU___prelu_kernel_backward));
m.impl("gelu", TORCH_FN(wrapper_CPU_gelu));
m.impl("gelu.out", TORCH_FN(wrapper_CPU_gelu_out_out));
m.impl("gelu_", TORCH_FN(wrapper_CPU_gelu_));
m.impl("gelu_backward", TORCH_FN(wrapper_CPU_gelu_backward));
m.impl("gelu_backward.grad_input", TORCH_FN(wrapper_CPU_gelu_backward_out_grad_input));
m.impl("hardshrink", TORCH_FN(wrapper_CPU_hardshrink));
m.impl("hardshrink.out", TORCH_FN(wrapper_CPU_hardshrink_out_out));
m.impl("hardshrink_backward", TORCH_FN(wrapper_CPU_hardshrink_backward));
m.impl("hardshrink_backward.grad_input", TORCH_FN(wrapper_CPU_hardshrink_backward_out_grad_input));
m.impl("rsqrt", TORCH_FN(wrapper_CPU_rsqrt));
m.impl("rsqrt.out", TORCH_FN(wrapper_CPU_rsqrt_out_out));
m.impl("rsqrt_", TORCH_FN(wrapper_CPU_rsqrt_));
m.impl("silu", TORCH_FN(wrapper_CPU_silu));
m.impl("silu.out", TORCH_FN(wrapper_CPU_silu_out_out));
m.impl("silu_", TORCH_FN(wrapper_CPU_silu_));
m.impl("silu_backward", TORCH_FN(wrapper_CPU_silu_backward));
m.impl("silu_backward.grad_input", TORCH_FN(wrapper_CPU_silu_backward_out_grad_input));
m.impl("mish", TORCH_FN(wrapper_CPU_mish));
m.impl("mish.out", TORCH_FN(wrapper_CPU_mish_out_out));
m.impl("mish_", TORCH_FN(wrapper_CPU_mish_));
m.impl("mish_backward",
TORCH_FN(wrapper_CPU__mish_backward));
m.impl("sigmoid", TORCH_FN(wrapper_CPU_sigmoid));
m.impl("sigmoid.out", TORCH_FN(wrapper_CPU_sigmoid_out_out));
m.impl("sigmoid_", TORCH_FN(wrapper_CPU_sigmoid_));
m.impl("logit",
TORCH_FN(wrapper_CPU__logit));
m.impl("logit.out",
TORCH_FN(wrapper_CPU_out_logit_out));
m.impl("logit_",
TORCH_FN(wrapper_CPU__logit_));
m.impl("sin", TORCH_FN(wrapper_CPU_sin));
m.impl("sin.out", TORCH_FN(wrapper_CPU_sin_out_out));
m.impl("sin_", TORCH_FN(wrapper_CPU_sin_));
m.impl("sinc", TORCH_FN(wrapper_CPU_sinc));
m.impl("sinc.out", TORCH_FN(wrapper_CPU_sinc_out_out));
m.impl("sinc_", TORCH_FN(wrapper_CPU_sinc_));
m.impl("sinh", TORCH_FN(wrapper_CPU_sinh));
m.impl("sinh.out", TORCH_FN(wrapper_CPU_sinh_out_out));
m.impl("sinh_", TORCH_FN(wrapper_CPU_sinh_));
m.impl("_softmax", TORCH_FN(wrapper_CPU__softmax));
m.impl("_softmax.out", TORCH_FN(wrapper_CPU__softmax_out_out));
m.impl("_softmax_backward_data", TORCH_FN(wrapper_CPU__softmax_backward_data));
m.impl("_softmax_backward_data.out", TORCH_FN(wrapper_CPU__softmax_backward_data_out_out));
m.impl("sspaddmm.out",
TORCH_FN(wrapper_CPU_out_sspaddmm_out));
m.impl("_stack",
TORCH_FN(wrapper_CPU___stack));
m.impl("_stack.out",
TORCH_FN(wrapper_CPU_out__stack_out));
m.impl("sum.dim_IntList", TORCH_FN(wrapper_CPU_sum_dim_IntList));
m.impl("sum.IntList_out", TORCH_FN(wrapper_CPU_sum_out_IntList_out));
m.impl("nansum",
TORCH_FN(wrapper_CPU__nansum));
m.impl("nansum.out",
TORCH_FN(wrapper_CPU_out_nansum_out));
m.impl("sqrt", TORCH_FN(wrapper_CPU_sqrt));
m.impl("sqrt.out", TORCH_FN(wrapper_CPU_sqrt_out_out));
m.impl("sqrt_", TORCH_FN(wrapper_CPU_sqrt_));
m.impl("std.correction",
TORCH_FN(wrapper_CPU_correction_std));
m.impl("std.correction_out",
TORCH_FN(wrapper_CPU_correction_out_std_out));
m.impl("std_mean.correction",
TORCH_FN(wrapper_CPU_correction_std_mean));
m.impl("prod",
TORCH_FN(wrapper_CPU__prod));
m.impl("prod.dim_int", TORCH_FN(wrapper_CPU_prod_dim_int));
m.impl("prod.int_out", TORCH_FN(wrapper_CPU_prod_out_int_out));
m.impl("tan", TORCH_FN(wrapper_CPU_tan));
m.impl("tan.out", TORCH_FN(wrapper_CPU_tan_out_out));
m.impl("tan_", TORCH_FN(wrapper_CPU_tan_));
m.impl("tanh", TORCH_FN(wrapper_CPU_tanh));
m.impl("tanh.out", TORCH_FN(wrapper_CPU_tanh_out_out));
m.impl("tanh_", TORCH_FN(wrapper_CPU_tanh_));
m.impl("threshold", TORCH_FN(wrapper_CPU_threshold));
m.impl("threshold.out", TORCH_FN(wrapper_CPU_threshold_out_out));
m.impl("threshold_", TORCH_FN(wrapper_CPU_threshold_));
m.impl("threshold_backward", TORCH_FN(wrapper_CPU_threshold_backward));
m.impl("threshold_backward.grad_input", TORCH_FN(wrapper_CPU_threshold_backward_out_grad_input));
m.impl("flip",
TORCH_FN(wrapper_CPU__flip));
m.impl("roll",
TORCH_FN(wrapper_CPU__roll));
m.impl("_transform_bias_rescale_qkv",
TORCH_FN(wrapper_CPU___transform_bias_rescale_qkv));
m.impl("_nested_tensor_from_mask",
TORCH_FN(wrapper_CPU___nested_tensor_from_mask));
m.impl("_nested_tensor_from_mask_left_aligned",
TORCH_FN(wrapper_CPU___nested_tensor_from_mask_left_aligned));
m.impl("_nested_from_padded",
TORCH_FN(wrapper_CPU___nested_from_padded));
m.impl("_nested_view_from_buffer",
TORCH_FN(wrapper_CPU___nested_view_from_buffer));
m.impl("trunc", TORCH_FN(wrapper_CPU_trunc));
m.impl("trunc.out", TORCH_FN(wrapper_CPU_trunc_out_out));
m.impl("trunc_", TORCH_FN(wrapper_CPU_trunc_));
m.impl("_unique",
TORCH_FN(wrapper_CPU___unique));
m.impl("unique_dim",
TORCH_FN(wrapper_CPU__unique_dim));
m.impl("unique_consecutive",
TORCH_FN(wrapper_CPU__unique_consecutive));
m.impl("unique_dim_consecutive",
TORCH_FN(wrapper_CPU__unique_dim_consecutive));
m.impl("_unique2",
TORCH_FN(wrapper_CPU___unique2));
m.impl("var.correction",
TORCH_FN(wrapper_CPU_correction_var));
m.impl("var.correction_out",
TORCH_FN(wrapper_CPU_correction_out_var_out));
m.impl("var_mean.correction",
TORCH_FN(wrapper_CPU_correction_var_mean));
m.impl("where.self",
TORCH_FN(wrapper_CPU_self_where));
m.impl("where.self_out",
TORCH_FN(wrapper_CPU_self_out_where_out));
m.impl("_weight_norm_interface",
TORCH_FN(wrapper_CPU___weight_norm_interface));
m.impl("_weight_norm_interface_backward",
TORCH_FN(wrapper_CPU___weight_norm_interface_backward));
m.impl("_efficientzerotensor",
TORCH_FN(wrapper_CPU___efficientzerotensor));
m.impl("_standard_gamma_grad",
TORCH_FN(wrapper_CPU___standard_gamma_grad));
m.impl("_standard_gamma",
TORCH_FN(wrapper_CPU___standard_gamma));
m.impl("_dirichlet_grad",
TORCH_FN(wrapper_CPU___dirichlet_grad));
m.impl("_sample_dirichlet",
TORCH_FN(wrapper_CPU___sample_dirichlet));
m.impl("poisson",
TORCH_FN(wrapper_CPU__poisson));
m.impl("binomial",
TORCH_FN(wrapper_CPU__binomial));
m.impl("_spdiags",
TORCH_FN(wrapper_CPU___spdiags));
m.impl("norm.ScalarOpt_dim_dtype", TORCH_FN(wrapper_CPU_norm_ScalarOpt_dim_dtype));
m.impl("norm.dtype_out", TORCH_FN(wrapper_CPU_norm_out_dtype_out));
m.impl("norm.ScalarOpt_dim", TORCH_FN(wrapper_CPU_norm_ScalarOpt_dim));
m.impl("norm.out", TORCH_FN(wrapper_CPU_norm_out_out));
m.impl("frexp.Tensor_out",
TORCH_FN(wrapper_CPU_Tensor_out_frexp_out));
m.impl("zero_",
TORCH_FN(wrapper_CPU__zero_));
m.impl("sub.Tensor", TORCH_FN(wrapper_CPU_sub_Tensor));
m.impl("sub.out", TORCH_FN(wrapper_CPU_sub_out_out));
m.impl("sub_.Tensor", TORCH_FN(wrapper_CPU_sub__Tensor));
m.impl("rsub.Tensor",
TORCH_FN(wrapper_CPU_Tensor_rsub));
m.impl("heaviside", TORCH_FN(wrapper_CPU_heaviside));
m.impl("heaviside.out", TORCH_FN(wrapper_CPU_heaviside_out_out));
m.impl("heaviside_", TORCH_FN(wrapper_CPU_heaviside_));
m.impl("addmm", TORCH_FN(wrapper_CPU_addmm));
m.impl("addmm.out", TORCH_FN(wrapper_CPU_addmm_out_out));
m.impl("addmm_", TORCH_FN(wrapper_CPU_addmm_));
m.impl("_addmm_activation", TORCH_FN(wrapper_CPU__addmm_activation));
m.impl("_addmm_activation.out", TORCH_FN(wrapper_CPU__addmm_activation_out_out));
m.impl("sparse_dim",
TORCH_FN(wrapper_CPU__sparse_dim));
m.impl("dense_dim",
TORCH_FN(wrapper_CPU__dense_dim));
m.impl("_to_sparse.sparse_dim",
TORCH_FN(wrapper_CPU_sparse_dim__to_sparse));
m.impl("_to_sparse",
TORCH_FN(wrapper_CPU___to_sparse));
m.impl("_to_sparse_csr",
TORCH_FN(wrapper_CPU___to_sparse_csr));
m.impl("_to_sparse_csc",
TORCH_FN(wrapper_CPU___to_sparse_csc));
m.impl("_to_sparse_bsr",
TORCH_FN(wrapper_CPU___to_sparse_bsr));
m.impl("_to_sparse_bsc",
TORCH_FN(wrapper_CPU___to_sparse_bsc));
m.impl("to_mkldnn",
TORCH_FN(wrapper_CPU__to_mkldnn));
m.impl("quantize_per_tensor_dynamic",
TORCH_FN(wrapper_CPU__quantize_per_tensor_dynamic));
m.impl("quantize_per_tensor",
TORCH_FN(wrapper_CPU__quantize_per_tensor));
m.impl("quantize_per_tensor.tensor_qparams",
TORCH_FN(wrapper_CPU_tensor_qparams_quantize_per_tensor));
m.impl("quantize_per_tensor.tensors",
TORCH_FN(wrapper_CPU_tensors_quantize_per_tensor));
m.impl("quantize_per_channel",
TORCH_FN(wrapper_CPU__quantize_per_channel));
m.impl("dequantize.self",
TORCH_FN(wrapper_CPU_self_dequantize));
m.impl("_make_per_tensor_quantized_tensor",
TORCH_FN(wrapper_CPU___make_per_tensor_quantized_tensor));
m.impl("_make_per_channel_quantized_tensor",
TORCH_FN(wrapper_CPU___make_per_channel_quantized_tensor));
m.impl("fake_quantize_per_tensor_affine_cachemask",
TORCH_FN(wrapper_CPU__fake_quantize_per_tensor_affine_cachemask));
m.impl("_fake_quantize_per_tensor_affine_cachemask_tensor_qparams",
TORCH_FN(wrapper_CPU___fake_quantize_per_tensor_affine_cachemask_tensor_qparams));
m.impl("_fake_quantize_learnable_per_tensor_affine",
TORCH_FN(wrapper_CPU___fake_quantize_learnable_per_tensor_affine));
m.impl("_fake_quantize_learnable_per_tensor_affine_backward",
TORCH_FN(wrapper_CPU___fake_quantize_learnable_per_tensor_affine_backward));
m.impl("fake_quantize_per_channel_affine_cachemask",
TORCH_FN(wrapper_CPU__fake_quantize_per_channel_affine_cachemask));
m.impl("_fake_quantize_learnable_per_channel_affine",
TORCH_FN(wrapper_CPU___fake_quantize_learnable_per_channel_affine));
m.impl("_fake_quantize_learnable_per_channel_affine_backward",
TORCH_FN(wrapper_CPU___fake_quantize_learnable_per_channel_affine_backward));
m.impl("_fused_moving_avg_obs_fq_helper",
TORCH_FN(wrapper_CPU___fused_moving_avg_obs_fq_helper));
m.impl("_local_scalar_dense",
TORCH_FN(wrapper_CPU___local_scalar_dense));
m.impl("set_.source_Storage",
TORCH_FN(wrapper_CPU_source_Storage_set_));
m.impl("set_.source_Storage_storage_offset",
TORCH_FN(wrapper_CPU_source_Storage_storage_offset_set_));
m.impl("set_.source_Tensor",
TORCH_FN(wrapper_CPU_source_Tensor_set_));
m.impl("set_",
TORCH_FN(wrapper_CPU__set_));
m.impl("is_set_to",
TORCH_FN(wrapper_CPU__is_set_to));
m.impl("masked_fill_.Scalar",
TORCH_FN(wrapper_CPU_Scalar_masked_fill_));
m.impl("masked_fill_.Tensor",
TORCH_FN(wrapper_CPU_Tensor_masked_fill_));
m.impl("masked_scatter_",
TORCH_FN(wrapper_CPU__masked_scatter_));
m.impl("_masked_softmax",
TORCH_FN(wrapper_CPU___masked_softmax));
m.impl("_masked_softmax_backward",
TORCH_FN(wrapper_CPU___masked_softmax_backward));
m.impl("view",
TORCH_FN(wrapper_CPU__view));
m.impl("put_",
TORCH_FN(wrapper_CPU__put_));
m.impl("index_add", TORCH_FN(wrapper_CPU_index_add));
m.impl("index_add.out", TORCH_FN(wrapper_CPU_index_add_out_out));
m.impl("index_add_", TORCH_FN(wrapper_CPU_index_add_));
m.impl("index_reduce", TORCH_FN(wrapper_CPU_index_reduce));
m.impl("index_reduce.out", TORCH_FN(wrapper_CPU_index_reduce_out_out));
m.impl("index_reduce_", TORCH_FN(wrapper_CPU_index_reduce_));
m.impl("index_fill_.int_Scalar",
TORCH_FN(wrapper_CPU_int_Scalar_index_fill_));
m.impl("index_fill_.int_Tensor",
TORCH_FN(wrapper_CPU_int_Tensor_index_fill_));
m.impl("scatter.src", TORCH_FN(wrapper_CPU_scatter_src));
m.impl("scatter.src_out", TORCH_FN(wrapper_CPU_scatter_out_src_out));
m.impl("scatter_.src", TORCH_FN(wrapper_CPU_scatter__src));
m.impl("scatter.value", TORCH_FN(wrapper_CPU_scatter_value));
m.impl("scatter.value_out", TORCH_FN(wrapper_CPU_scatter_out_value_out));
m.impl("scatter_.value", TORCH_FN(wrapper_CPU_scatter__value));
m.impl("scatter.reduce", TORCH_FN(wrapper_CPU_scatter_reduce));
m.impl("scatter.reduce_out", TORCH_FN(wrapper_CPU_scatter_out_reduce_out));
m.impl("scatter_.reduce", TORCH_FN(wrapper_CPU_scatter__reduce));
m.impl("scatter.value_reduce", TORCH_FN(wrapper_CPU_scatter_value_reduce));
m.impl("scatter.value_reduce_out", TORCH_FN(wrapper_CPU_scatter_out_value_reduce_out));
m.impl("scatter_.value_reduce", TORCH_FN(wrapper_CPU_scatter__value_reduce));
m.impl("scatter_add", TORCH_FN(wrapper_CPU_scatter_add));
m.impl("scatter_add.out", TORCH_FN(wrapper_CPU_scatter_add_out_out));
m.impl("scatter_add_", TORCH_FN(wrapper_CPU_scatter_add_));
m.impl("scatter_reduce.two", TORCH_FN(wrapper_CPU_scatter_reduce_two));
m.impl("scatter_reduce.two_out", TORCH_FN(wrapper_CPU_scatter_reduce_out_two_out));
m.impl("scatter_reduce_.two", TORCH_FN(wrapper_CPU_scatter_reduce__two));
m.impl("eq.Scalar", TORCH_FN(wrapper_CPU_eq_Scalar));
m.impl("eq.Scalar_out", TORCH_FN(wrapper_CPU_eq_out_Scalar_out));
m.impl("eq_.Scalar", TORCH_FN(wrapper_CPU_eq__Scalar));
m.impl("eq.Tensor", TORCH_FN(wrapper_CPU_eq_Tensor));
m.impl("eq.Tensor_out", TORCH_FN(wrapper_CPU_eq_out_Tensor_out));
m.impl("eq_.Tensor", TORCH_FN(wrapper_CPU_eq__Tensor));
m.impl("bitwise_and.Tensor", TORCH_FN(wrapper_CPU_bitwise_and_Tensor));
m.impl("bitwise_and.Tensor_out", TORCH_FN(wrapper_CPU_bitwise_and_out_Tensor_out));
m.impl("bitwise_and_.Tensor", TORCH_FN(wrapper_CPU_bitwise_and__Tensor));
m.impl("bitwise_or.Tensor", TORCH_FN(wrapper_CPU_bitwise_or_Tensor));
m.impl("bitwise_or.Tensor_out", TORCH_FN(wrapper_CPU_bitwise_or_out_Tensor_out));
m.impl("bitwise_or_.Tensor", TORCH_FN(wrapper_CPU_bitwise_or__Tensor));
m.impl("bitwise_xor.Tensor", TORCH_FN(wrapper_CPU_bitwise_xor_Tensor));
m.impl("bitwise_xor.Tensor_out", TORCH_FN(wrapper_CPU_bitwise_xor_out_Tensor_out));
m.impl("bitwise_xor_.Tensor", TORCH_FN(wrapper_CPU_bitwise_xor__Tensor));
m.impl("__lshift__.Scalar",
TORCH_FN(wrapper_CPU_Scalar___lshift__));
m.impl("__ilshift__.Scalar",
TORCH_FN(wrapper_CPU_Scalar___ilshift__));
m.impl("__lshift__.Tensor",
TORCH_FN(wrapper_CPU_Tensor___lshift__));
m.impl("__ilshift__.Tensor",
TORCH_FN(wrapper_CPU_Tensor___ilshift__));
m.impl("bitwise_left_shift.Tensor", TORCH_FN(wrapper_CPU_bitwise_left_shift_Tensor));
m.impl("bitwise_left_shift.Tensor_out", TORCH_FN(wrapper_CPU_bitwise_left_shift_out_Tensor_out));
m.impl("bitwise_left_shift_.Tensor", TORCH_FN(wrapper_CPU_bitwise_left_shift__Tensor));
m.impl("__rshift__.Scalar",
TORCH_FN(wrapper_CPU_Scalar___rshift__));
m.impl("__irshift__.Scalar",
TORCH_FN(wrapper_CPU_Scalar___irshift__));
m.impl("__rshift__.Tensor",
TORCH_FN(wrapper_CPU_Tensor___rshift__));
m.impl("__irshift__.Tensor",
TORCH_FN(wrapper_CPU_Tensor___irshift__));
m.impl("bitwise_right_shift.Tensor", TORCH_FN(wrapper_CPU_bitwise_right_shift_Tensor));
m.impl("bitwise_right_shift.Tensor_out", TORCH_FN(wrapper_CPU_bitwise_right_shift_out_Tensor_out));
m.impl("bitwise_right_shift_.Tensor", TORCH_FN(wrapper_CPU_bitwise_right_shift__Tensor));
m.impl("tril", TORCH_FN(wrapper_CPU_tril));
m.impl("tril.out", TORCH_FN(wrapper_CPU_tril_out_out));
m.impl("tril_", TORCH_FN(wrapper_CPU_tril_));
m.impl("triu", TORCH_FN(wrapper_CPU_triu));
m.impl("triu.out", TORCH_FN(wrapper_CPU_triu_out_out));
m.impl("triu_", TORCH_FN(wrapper_CPU_triu_));
m.impl("digamma", TORCH_FN(wrapper_CPU_digamma));
m.impl("digamma.out", TORCH_FN(wrapper_CPU_digamma_out_out));
m.impl("digamma_", TORCH_FN(wrapper_CPU_digamma_));
m.impl("lerp.Scalar", TORCH_FN(wrapper_CPU_lerp_Scalar));
m.impl("lerp.Scalar_out", TORCH_FN(wrapper_CPU_lerp_out_Scalar_out));
m.impl("lerp_.Scalar", TORCH_FN(wrapper_CPU_lerp__Scalar));
m.impl("lerp.Tensor", TORCH_FN(wrapper_CPU_lerp_Tensor));
m.impl("lerp.Tensor_out", TORCH_FN(wrapper_CPU_lerp_out_Tensor_out));
m.impl("lerp_.Tensor", TORCH_FN(wrapper_CPU_lerp__Tensor));
m.impl("addbmm",
TORCH_FN(wrapper_CPU__addbmm));
m.impl("addbmm.out",
TORCH_FN(wrapper_CPU_out_addbmm_out));
m.impl("addbmm_",
TORCH_FN(wrapper_CPU__addbmm_));
m.impl("random_.from",
TORCH_FN(wrapper_CPU_from_random_));
m.impl("random_.to",
TORCH_FN(wrapper_CPU_to_random_));
m.impl("random_",
TORCH_FN(wrapper_CPU__random_));
m.impl("uniform_",
TORCH_FN(wrapper_CPU__uniform_));
m.impl("cauchy_",
TORCH_FN(wrapper_CPU__cauchy_));
m.impl("log_normal_",
TORCH_FN(wrapper_CPU__log_normal_));
m.impl("exponential_",
TORCH_FN(wrapper_CPU__exponential_));
m.impl("geometric_",
TORCH_FN(wrapper_CPU__geometric_));
m.impl("tril_indices",
TORCH_FN(wrapper_CPU__tril_indices));
m.impl("triu_indices",
TORCH_FN(wrapper_CPU__triu_indices));
m.impl("trace",
TORCH_FN(wrapper_CPU__trace));
m.impl("ne.Scalar", TORCH_FN(wrapper_CPU_ne_Scalar));
m.impl("ne.Scalar_out", TORCH_FN(wrapper_CPU_ne_out_Scalar_out));
m.impl("ne_.Scalar", TORCH_FN(wrapper_CPU_ne__Scalar));
m.impl("ne.Tensor", TORCH_FN(wrapper_CPU_ne_Tensor));
m.impl("ne.Tensor_out", TORCH_FN(wrapper_CPU_ne_out_Tensor_out));
m.impl("ne_.Tensor", TORCH_FN(wrapper_CPU_ne__Tensor));
m.impl("ge.Scalar", TORCH_FN(wrapper_CPU_ge_Scalar));
m.impl("ge.Scalar_out", TORCH_FN(wrapper_CPU_ge_out_Scalar_out));
m.impl("ge_.Scalar", TORCH_FN(wrapper_CPU_ge__Scalar));
m.impl("ge.Tensor", TORCH_FN(wrapper_CPU_ge_Tensor));
m.impl("ge.Tensor_out", TORCH_FN(wrapper_CPU_ge_out_Tensor_out));
m.impl("ge_.Tensor", TORCH_FN(wrapper_CPU_ge__Tensor));
m.impl("le.Scalar", TORCH_FN(wrapper_CPU_le_Scalar));
m.impl("le.Scalar_out", TORCH_FN(wrapper_CPU_le_out_Scalar_out));
m.impl("le_.Scalar", TORCH_FN(wrapper_CPU_le__Scalar));
m.impl("le.Tensor", TORCH_FN(wrapper_CPU_le_Tensor));
m.impl("le.Tensor_out", TORCH_FN(wrapper_CPU_le_out_Tensor_out));
m.impl("le_.Tensor", TORCH_FN(wrapper_CPU_le__Tensor));
m.impl("gt.Scalar", TORCH_FN(wrapper_CPU_gt_Scalar));
m.impl("gt.Scalar_out", TORCH_FN(wrapper_CPU_gt_out_Scalar_out));
m.impl("gt_.Scalar", TORCH_FN(wrapper_CPU_gt__Scalar));
m.impl("gt.Tensor", TORCH_FN(wrapper_CPU_gt_Tensor));
m.impl("gt.Tensor_out", TORCH_FN(wrapper_CPU_gt_out_Tensor_out));
m.impl("gt_.Tensor", TORCH_FN(wrapper_CPU_gt__Tensor));
m.impl("lt.Scalar", TORCH_FN(wrapper_CPU_lt_Scalar));
m.impl("lt.Scalar_out", TORCH_FN(wrapper_CPU_lt_out_Scalar_out));
m.impl("lt_.Scalar", TORCH_FN(wrapper_CPU_lt__Scalar));
m.impl("lt.Tensor", TORCH_FN(wrapper_CPU_lt_Tensor));
m.impl("lt.Tensor_out", TORCH_FN(wrapper_CPU_lt_out_Tensor_out));
m.impl("lt_.Tensor", TORCH_FN(wrapper_CPU_lt__Tensor));
m.impl("take",
TORCH_FN(wrapper_CPU__take));
m.impl("take.out",
TORCH_FN(wrapper_CPU_out_take_out));
m.impl("index_select",
TORCH_FN(wrapper_CPU__index_select));
m.impl("index_select.out",
TORCH_FN(wrapper_CPU_out_index_select_out));
m.impl("masked_select",
TORCH_FN(wrapper_CPU__masked_select));
m.impl("masked_select.out",
TORCH_FN(wrapper_CPU_out_masked_select_out));
m.impl("nonzero",
TORCH_FN(wrapper_CPU__nonzero));
m.impl("nonzero.out",
TORCH_FN(wrapper_CPU_out_nonzero_out));
m.impl("nonzero_static",
TORCH_FN(wrapper_CPU__nonzero_static));
m.impl("nonzero_static.out",
TORCH_FN(wrapper_CPU_out_nonzero_static_out));
m.impl("gather", TORCH_FN(wrapper_CPU_gather));
m.impl("gather.out", TORCH_FN(wrapper_CPU_gather_out_out));
m.impl("addcmul", TORCH_FN(wrapper_CPU_addcmul));
m.impl("addcmul.out", TORCH_FN(wrapper_CPU_addcmul_out_out));
m.impl("addcmul_", TORCH_FN(wrapper_CPU_addcmul_));
m.impl("addcdiv", TORCH_FN(wrapper_CPU_addcdiv));
m.impl("addcdiv.out", TORCH_FN(wrapper_CPU_addcdiv_out_out));
m.impl("addcdiv_", TORCH_FN(wrapper_CPU_addcdiv_));
m.impl("triangular_solve", TORCH_FN(wrapper_CPU_triangular_solve));
m.impl("triangular_solve.X", TORCH_FN(wrapper_CPU_triangular_solve_out_X));
m.impl("linalg_solve_triangular",
TORCH_FN(wrapper_CPU__linalg_solve_triangular));
m.impl("linalg_solve_triangular.out",
TORCH_FN(wrapper_CPU_out_linalg_solve_triangular_out));
m.impl("cholesky",
TORCH_FN(wrapper_CPU__cholesky));
m.impl("cholesky.out",
TORCH_FN(wrapper_CPU_out_cholesky_out));
m.impl("_cholesky_solve_helper",
TORCH_FN(wrapper_CPU___cholesky_solve_helper));
m.impl("cholesky_inverse",
TORCH_FN(wrapper_CPU__cholesky_inverse));
m.impl("cholesky_inverse.out",
TORCH_FN(wrapper_CPU_out_cholesky_inverse_out));
m.impl("geqrf",
TORCH_FN(wrapper_CPU__geqrf));
m.impl("geqrf.a",
TORCH_FN(wrapper_CPU_a_geqrf_out));
m.impl("ormqr",
TORCH_FN(wrapper_CPU__ormqr));
m.impl("ormqr.out",
TORCH_FN(wrapper_CPU_out_ormqr_out));
m.impl("lu_unpack", TORCH_FN(wrapper_CPU_lu_unpack));
m.impl("lu_unpack.out", TORCH_FN(wrapper_CPU_lu_unpack_out_out));
m.impl("multinomial",
TORCH_FN(wrapper_CPU__multinomial));
m.impl("multinomial.out",
TORCH_FN(wrapper_CPU_out_multinomial_out));
m.impl("lgamma", TORCH_FN(wrapper_CPU_lgamma));
m.impl("lgamma.out", TORCH_FN(wrapper_CPU_lgamma_out_out));
m.impl("lgamma_", TORCH_FN(wrapper_CPU_lgamma_));
m.impl("polygamma", TORCH_FN(wrapper_CPU_polygamma));
m.impl("polygamma.out", TORCH_FN(wrapper_CPU_polygamma_out_out));
m.impl("erfinv", TORCH_FN(wrapper_CPU_erfinv));
m.impl("erfinv.out", TORCH_FN(wrapper_CPU_erfinv_out_out));
m.impl("erfinv_", TORCH_FN(wrapper_CPU_erfinv_));
m.impl("i0", TORCH_FN(wrapper_CPU_i0));
m.impl("i0.out", TORCH_FN(wrapper_CPU_i0_out_out));
m.impl("i0_", TORCH_FN(wrapper_CPU_i0_));
m.impl("sign", TORCH_FN(wrapper_CPU_sign));
m.impl("sign.out", TORCH_FN(wrapper_CPU_sign_out_out));
m.impl("sign_", TORCH_FN(wrapper_CPU_sign_));
m.impl("signbit", TORCH_FN(wrapper_CPU_signbit));
m.impl("signbit.out", TORCH_FN(wrapper_CPU_signbit_out_out));
m.impl("atan2", TORCH_FN(wrapper_CPU_atan2));
m.impl("atan2.out", TORCH_FN(wrapper_CPU_atan2_out_out));
m.impl("atan2_", TORCH_FN(wrapper_CPU_atan2_));
m.impl("histc",
TORCH_FN(wrapper_CPU__histc));
m.impl("histc.out",
TORCH_FN(wrapper_CPU_out_histc_out));
m.impl("histogram.bins_tensor",
TORCH_FN(wrapper_CPU_bins_tensor_histogram));
m.impl("histogram.bins_tensor_out",
TORCH_FN(wrapper_CPU_bins_tensor_out_histogram_out));
m.impl("histogram.bin_ct",
TORCH_FN(wrapper_CPU_bin_ct_histogram));
m.impl("histogram.bin_ct_out",
TORCH_FN(wrapper_CPU_bin_ct_out_histogram_out));
m.impl("_histogramdd_bin_edges",
TORCH_FN(wrapper_CPU___histogramdd_bin_edges));
m.impl("_histogramdd_from_bin_cts",
TORCH_FN(wrapper_CPU___histogramdd_from_bin_cts));
m.impl("_histogramdd_from_bin_tensors",
TORCH_FN(wrapper_CPU___histogramdd_from_bin_tensors));
m.impl("fmod.Tensor", TORCH_FN(wrapper_CPU_fmod_Tensor));
m.impl("fmod.Tensor_out", TORCH_FN(wrapper_CPU_fmod_out_Tensor_out));
m.impl("fmod_.Tensor", TORCH_FN(wrapper_CPU_fmod__Tensor));
m.impl("hypot", TORCH_FN(wrapper_CPU_hypot));
m.impl("hypot.out", TORCH_FN(wrapper_CPU_hypot_out_out));
m.impl("hypot_", TORCH_FN(wrapper_CPU_hypot_));
m.impl("igamma", TORCH_FN(wrapper_CPU_igamma));
m.impl("igamma.out", TORCH_FN(wrapper_CPU_igamma_out_out));
m.impl("igamma_", TORCH_FN(wrapper_CPU_igamma_));
m.impl("igammac", TORCH_FN(wrapper_CPU_igammac));
m.impl("igammac.out", TORCH_FN(wrapper_CPU_igammac_out_out));
m.impl("igammac_", TORCH_FN(wrapper_CPU_igammac_));
m.impl("nextafter", TORCH_FN(wrapper_CPU_nextafter));
m.impl("nextafter.out", TORCH_FN(wrapper_CPU_nextafter_out_out));
m.impl("nextafter_", TORCH_FN(wrapper_CPU_nextafter_));
m.impl("remainder.Tensor", TORCH_FN(wrapper_CPU_remainder_Tensor));
m.impl("remainder.Tensor_out", TORCH_FN(wrapper_CPU_remainder_out_Tensor_out));
m.impl("remainder_.Tensor", TORCH_FN(wrapper_CPU_remainder__Tensor));
m.impl("remainder.Scalar_Tensor",
TORCH_FN(wrapper_CPU_Scalar_Tensor_remainder));
m.impl("min",
TORCH_FN(wrapper_CPU__min));
m.impl("min.unary_out",
TORCH_FN(wrapper_CPU_unary_out_min_out));
m.impl("fmin", TORCH_FN(wrapper_CPU_fmin));
m.impl("fmin.out", TORCH_FN(wrapper_CPU_fmin_out_out));
m.impl("max",
TORCH_FN(wrapper_CPU__max));
m.impl("max.unary_out",
TORCH_FN(wrapper_CPU_unary_out_max_out));
m.impl("fmax", TORCH_FN(wrapper_CPU_fmax));
m.impl("fmax.out", TORCH_FN(wrapper_CPU_fmax_out_out));
m.impl("maximum", TORCH_FN(wrapper_CPU_maximum));
m.impl("maximum.out", TORCH_FN(wrapper_CPU_maximum_out_out));
m.impl("minimum", TORCH_FN(wrapper_CPU_minimum));
m.impl("minimum.out", TORCH_FN(wrapper_CPU_minimum_out_out));
m.impl("sort.stable", TORCH_FN(wrapper_CPU_sort_stable));
m.impl("sort.values_stable", TORCH_FN(wrapper_CPU_sort_out_values_stable));
m.impl("argsort.stable",
TORCH_FN(wrapper_CPU_stable_argsort));
m.impl("topk", TORCH_FN(wrapper_CPU_topk));
m.impl("topk.values", TORCH_FN(wrapper_CPU_topk_out_values));
m.impl("all", TORCH_FN(wrapper_CPU_all));
m.impl("all.all_out", TORCH_FN(wrapper_CPU_all_out_all_out));
m.impl("any", TORCH_FN(wrapper_CPU_any));
m.impl("any.all_out", TORCH_FN(wrapper_CPU_any_out_all_out));
m.impl("renorm", TORCH_FN(wrapper_CPU_renorm));
m.impl("renorm.out", TORCH_FN(wrapper_CPU_renorm_out_out));
m.impl("renorm_", TORCH_FN(wrapper_CPU_renorm_));
m.impl("unfold",
TORCH_FN(wrapper_CPU__unfold));
m.impl("unfold_backward",
TORCH_FN(wrapper_CPU__unfold_backward));
m.impl("equal",
TORCH_FN(wrapper_CPU__equal));
m.impl("pow.Tensor_Tensor", TORCH_FN(wrapper_CPU_pow_Tensor_Tensor));
m.impl("pow.Tensor_Tensor_out", TORCH_FN(wrapper_CPU_pow_out_Tensor_Tensor_out));
m.impl("pow_.Tensor", TORCH_FN(wrapper_CPU_pow__Tensor));
m.impl("pow.Scalar", TORCH_FN(wrapper_CPU_pow_Scalar));
m.impl("pow.Scalar_out", TORCH_FN(wrapper_CPU_pow_out_Scalar_out));
m.impl("pow.Tensor_Scalar", TORCH_FN(wrapper_CPU_pow_Tensor_Scalar));
m.impl("pow.Tensor_Scalar_out", TORCH_FN(wrapper_CPU_pow_out_Tensor_Scalar_out));
m.impl("pow_.Scalar", TORCH_FN(wrapper_CPU_pow__Scalar));
m.impl("normal_",
TORCH_FN(wrapper_CPU__normal_));
m.impl("normal.Tensor_float",
TORCH_FN(wrapper_CPU_Tensor_float_normal));
m.impl("normal.Tensor_float_out",
TORCH_FN(wrapper_CPU_Tensor_float_out_normal_out));
m.impl("normal.float_Tensor",
TORCH_FN(wrapper_CPU_float_Tensor_normal));
m.impl("normal.float_Tensor_out",
TORCH_FN(wrapper_CPU_float_Tensor_out_normal_out));
m.impl("normal.Tensor_Tensor",
TORCH_FN(wrapper_CPU_Tensor_Tensor_normal));
m.impl("normal.Tensor_Tensor_out",
TORCH_FN(wrapper_CPU_Tensor_Tensor_out_normal_out));
m.impl("_amp_foreach_non_finite_check_and_unscale_",
TORCH_FN(wrapper_CPU___amp_foreach_non_finite_check_and_unscale_));
m.impl("_amp_update_scale_",
TORCH_FN(wrapper_CPU___amp_update_scale_));
m.impl("_foreach_add.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_add));
m.impl("_foreach_add_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_add_));
m.impl("_foreach_add.List",
TORCH_FN(wrapper_CPU_List__foreach_add));
m.impl("_foreach_add_.List",
TORCH_FN(wrapper_CPU_List__foreach_add_));
m.impl("_foreach_add.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_add));
m.impl("_foreach_add_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_add_));
m.impl("_foreach_add.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_add));
m.impl("_foreach_add_.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_add_));
m.impl("_foreach_sub.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_sub));
m.impl("_foreach_sub_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_sub_));
m.impl("_foreach_sub.List",
TORCH_FN(wrapper_CPU_List__foreach_sub));
m.impl("_foreach_sub_.List",
TORCH_FN(wrapper_CPU_List__foreach_sub_));
m.impl("_foreach_sub.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_sub));
m.impl("_foreach_sub_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_sub_));
m.impl("_foreach_mul.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_mul));
m.impl("_foreach_mul_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_mul_));
m.impl("_foreach_mul.List",
TORCH_FN(wrapper_CPU_List__foreach_mul));
m.impl("_foreach_mul_.List",
TORCH_FN(wrapper_CPU_List__foreach_mul_));
m.impl("_foreach_mul.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_mul));
m.impl("_foreach_mul_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_mul_));
m.impl("_foreach_mul.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_mul));
m.impl("_foreach_mul_.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_mul_));
m.impl("_foreach_div.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_div));
m.impl("_foreach_div_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_div_));
m.impl("_foreach_div.List",
TORCH_FN(wrapper_CPU_List__foreach_div));
m.impl("_foreach_div_.List",
TORCH_FN(wrapper_CPU_List__foreach_div_));
m.impl("_foreach_div.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_div));
m.impl("_foreach_div_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_div_));
m.impl("_foreach_div.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_div));
m.impl("_foreach_div_.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_div_));
m.impl("_foreach_clamp_max.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_clamp_max));
m.impl("_foreach_clamp_max_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_clamp_max_));
m.impl("_foreach_clamp_max.List",
TORCH_FN(wrapper_CPU_List__foreach_clamp_max));
m.impl("_foreach_clamp_max_.List",
TORCH_FN(wrapper_CPU_List__foreach_clamp_max_));
m.impl("_foreach_clamp_max.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_clamp_max));
m.impl("_foreach_clamp_max_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_clamp_max_));
m.impl("_foreach_clamp_min.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_clamp_min));
m.impl("_foreach_clamp_min_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_clamp_min_));
m.impl("_foreach_clamp_min.List",
TORCH_FN(wrapper_CPU_List__foreach_clamp_min));
m.impl("_foreach_clamp_min_.List",
TORCH_FN(wrapper_CPU_List__foreach_clamp_min_));
m.impl("_foreach_clamp_min.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_clamp_min));
m.impl("_foreach_clamp_min_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_clamp_min_));
m.impl("_foreach_maximum.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_maximum));
m.impl("_foreach_maximum_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_maximum_));
m.impl("_foreach_maximum.List",
TORCH_FN(wrapper_CPU_List__foreach_maximum));
m.impl("_foreach_maximum_.List",
TORCH_FN(wrapper_CPU_List__foreach_maximum_));
m.impl("_foreach_maximum.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_maximum));
m.impl("_foreach_maximum_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_maximum_));
m.impl("_foreach_minimum.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_minimum));
m.impl("_foreach_minimum_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_minimum_));
m.impl("_foreach_minimum.List",
TORCH_FN(wrapper_CPU_List__foreach_minimum));
m.impl("_foreach_minimum_.List",
TORCH_FN(wrapper_CPU_List__foreach_minimum_));
m.impl("_foreach_minimum.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_minimum));
m.impl("_foreach_minimum_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_minimum_));
m.impl("_foreach_addcdiv.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_addcdiv));
m.impl("_foreach_addcdiv_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_addcdiv_));
m.impl("_foreach_addcdiv.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_addcdiv));
m.impl("_foreach_addcdiv_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_addcdiv_));
m.impl("_foreach_addcdiv.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_addcdiv));
m.impl("_foreach_addcdiv_.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_addcdiv_));
m.impl("_foreach_addcmul.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_addcmul));
m.impl("_foreach_addcmul_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_addcmul_));
m.impl("_foreach_addcmul.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_addcmul));
m.impl("_foreach_addcmul_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_addcmul_));
m.impl("_foreach_addcmul.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_addcmul));
m.impl("_foreach_addcmul_.Tensor",
TORCH_FN(wrapper_CPU_Tensor__foreach_addcmul_));
m.impl("_foreach_abs",
TORCH_FN(wrapper_CPU___foreach_abs));
m.impl("_foreach_abs_",
TORCH_FN(wrapper_CPU___foreach_abs_));
m.impl("_foreach_acos",
TORCH_FN(wrapper_CPU___foreach_acos));
m.impl("_foreach_acos_",
TORCH_FN(wrapper_CPU___foreach_acos_));
m.impl("_foreach_asin",
TORCH_FN(wrapper_CPU___foreach_asin));
m.impl("_foreach_asin_",
TORCH_FN(wrapper_CPU___foreach_asin_));
m.impl("_foreach_atan",
TORCH_FN(wrapper_CPU___foreach_atan));
m.impl("_foreach_atan_",
TORCH_FN(wrapper_CPU___foreach_atan_));
m.impl("_foreach_ceil",
TORCH_FN(wrapper_CPU___foreach_ceil));
m.impl("_foreach_ceil_",
TORCH_FN(wrapper_CPU___foreach_ceil_));
m.impl("_foreach_cos",
TORCH_FN(wrapper_CPU___foreach_cos));
m.impl("_foreach_cos_",
TORCH_FN(wrapper_CPU___foreach_cos_));
m.impl("_foreach_cosh",
TORCH_FN(wrapper_CPU___foreach_cosh));
m.impl("_foreach_cosh_",
TORCH_FN(wrapper_CPU___foreach_cosh_));
m.impl("_foreach_erf",
TORCH_FN(wrapper_CPU___foreach_erf));
m.impl("_foreach_erf_",
TORCH_FN(wrapper_CPU___foreach_erf_));
m.impl("_foreach_erfc",
TORCH_FN(wrapper_CPU___foreach_erfc));
m.impl("_foreach_erfc_",
TORCH_FN(wrapper_CPU___foreach_erfc_));
m.impl("_foreach_exp",
TORCH_FN(wrapper_CPU___foreach_exp));
m.impl("_foreach_exp_",
TORCH_FN(wrapper_CPU___foreach_exp_));
m.impl("_foreach_expm1",
TORCH_FN(wrapper_CPU___foreach_expm1));
m.impl("_foreach_expm1_",
TORCH_FN(wrapper_CPU___foreach_expm1_));
m.impl("_foreach_floor",
TORCH_FN(wrapper_CPU___foreach_floor));
m.impl("_foreach_floor_",
TORCH_FN(wrapper_CPU___foreach_floor_));
m.impl("_foreach_frac",
TORCH_FN(wrapper_CPU___foreach_frac));
m.impl("_foreach_frac_",
TORCH_FN(wrapper_CPU___foreach_frac_));
m.impl("_foreach_lerp.List",
TORCH_FN(wrapper_CPU_List__foreach_lerp));
m.impl("_foreach_lerp_.List",
TORCH_FN(wrapper_CPU_List__foreach_lerp_));
m.impl("_foreach_lerp.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_lerp));
m.impl("_foreach_lerp_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_lerp_));
m.impl("_foreach_lgamma",
TORCH_FN(wrapper_CPU___foreach_lgamma));
m.impl("_foreach_lgamma_",
TORCH_FN(wrapper_CPU___foreach_lgamma_));
m.impl("_foreach_log",
TORCH_FN(wrapper_CPU___foreach_log));
m.impl("_foreach_log_",
TORCH_FN(wrapper_CPU___foreach_log_));
m.impl("_foreach_log10",
TORCH_FN(wrapper_CPU___foreach_log10));
m.impl("_foreach_log10_",
TORCH_FN(wrapper_CPU___foreach_log10_));
m.impl("_foreach_log1p",
TORCH_FN(wrapper_CPU___foreach_log1p));
m.impl("_foreach_log1p_",
TORCH_FN(wrapper_CPU___foreach_log1p_));
m.impl("_foreach_log2",
TORCH_FN(wrapper_CPU___foreach_log2));
m.impl("_foreach_log2_",
TORCH_FN(wrapper_CPU___foreach_log2_));
m.impl("_foreach_neg",
TORCH_FN(wrapper_CPU___foreach_neg));
m.impl("_foreach_neg_",
TORCH_FN(wrapper_CPU___foreach_neg_));
m.impl("_foreach_norm.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_norm));
m.impl("_foreach_pow.List",
TORCH_FN(wrapper_CPU_List__foreach_pow));
m.impl("_foreach_pow_.List",
TORCH_FN(wrapper_CPU_List__foreach_pow_));
m.impl("_foreach_pow.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_pow));
m.impl("_foreach_pow_.Scalar",
TORCH_FN(wrapper_CPU_Scalar__foreach_pow_));
m.impl("_foreach_pow.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_pow));
m.impl("_foreach_pow_.ScalarList",
TORCH_FN(wrapper_CPU_ScalarList__foreach_pow_));
m.impl("_foreach_pow.ScalarAndTensor",
TORCH_FN(wrapper_CPU_ScalarAndTensor__foreach_pow));
m.impl("_foreach_reciprocal",
TORCH_FN(wrapper_CPU___foreach_reciprocal));
m.impl("_foreach_reciprocal_",
TORCH_FN(wrapper_CPU___foreach_reciprocal_));
m.impl("_foreach_round",
TORCH_FN(wrapper_CPU___foreach_round));
m.impl("_foreach_round_",
TORCH_FN(wrapper_CPU___foreach_round_));
m.impl("_foreach_sigmoid",
TORCH_FN(wrapper_CPU___foreach_sigmoid));
m.impl("_foreach_sigmoid_",
TORCH_FN(wrapper_CPU___foreach_sigmoid_));
m.impl("_foreach_sign",
TORCH_FN(wrapper_CPU___foreach_sign));
m.impl("_foreach_sign_",
TORCH_FN(wrapper_CPU___foreach_sign_));
m.impl("_foreach_sin",
TORCH_FN(wrapper_CPU___foreach_sin));
m.impl("_foreach_sin_",
TORCH_FN(wrapper_CPU___foreach_sin_));
m.impl("_foreach_sinh",
TORCH_FN(wrapper_CPU___foreach_sinh));
m.impl("_foreach_sinh_",
TORCH_FN(wrapper_CPU___foreach_sinh_));
m.impl("_foreach_sqrt",
TORCH_FN(wrapper_CPU___foreach_sqrt));
m.impl("_foreach_sqrt_",
TORCH_FN(wrapper_CPU___foreach_sqrt_));
m.impl("_foreach_tan",
TORCH_FN(wrapper_CPU___foreach_tan));
m.impl("_foreach_tan_",
TORCH_FN(wrapper_CPU___foreach_tan_));
m.impl("_foreach_tanh",
TORCH_FN(wrapper_CPU___foreach_tanh));
m.impl("_foreach_tanh_",
TORCH_FN(wrapper_CPU___foreach_tanh_));
m.impl("_foreach_trunc",
TORCH_FN(wrapper_CPU___foreach_trunc));
m.impl("_foreach_trunc_",
TORCH_FN(wrapper_CPU___foreach_trunc_));
m.impl("_foreach_zero_",
TORCH_FN(wrapper_CPU___foreach_zero_));
m.impl("_foreach_copy_",
TORCH_FN(wrapper_CPU___foreach_copy_));
m.impl("bucketize.Tensor",
TORCH_FN(wrapper_CPU_Tensor_bucketize));
m.impl("bucketize.Tensor_out",
TORCH_FN(wrapper_CPU_Tensor_out_bucketize_out));
m.impl("bucketize.Scalar",
TORCH_FN(wrapper_CPU_Scalar_bucketize));
m.impl("searchsorted.Tensor",
TORCH_FN(wrapper_CPU_Tensor_searchsorted));
m.impl("searchsorted.Tensor_out",
TORCH_FN(wrapper_CPU_Tensor_out_searchsorted_out));
m.impl("searchsorted.Scalar",
TORCH_FN(wrapper_CPU_Scalar_searchsorted));
m.impl("searchsorted.Scalar_out",
TORCH_FN(wrapper_CPU_Scalar_out_searchsorted_out));
m.impl("_convert_indices_from_coo_to_csr", TORCH_FN(wrapper_CPU__convert_indices_from_coo_to_csr));
m.impl("_convert_indices_from_coo_to_csr.out", TORCH_FN(wrapper_CPU__convert_indices_from_coo_to_csr_out_out));
m.impl("_convert_indices_from_csr_to_coo", TORCH_FN(wrapper_CPU__convert_indices_from_csr_to_coo));
m.impl("_convert_indices_from_csr_to_coo.out", TORCH_FN(wrapper_CPU__convert_indices_from_csr_to_coo_out_out));
m.impl("mse_loss", TORCH_FN(wrapper_CPU_mse_loss));
m.impl("mse_loss.out", TORCH_FN(wrapper_CPU_mse_loss_out_out));
m.impl("mse_loss_backward",
TORCH_FN(wrapper_CPU__mse_loss_backward));
m.impl("mse_loss_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_mse_loss_backward_out));
m.impl("multi_margin_loss",
TORCH_FN(wrapper_CPU__multi_margin_loss));
m.impl("multi_margin_loss.out",
TORCH_FN(wrapper_CPU_out_multi_margin_loss_out));
m.impl("multi_margin_loss_backward",
TORCH_FN(wrapper_CPU__multi_margin_loss_backward));
m.impl("multi_margin_loss_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_multi_margin_loss_backward_out));
m.impl("multilabel_margin_loss_forward",
TORCH_FN(wrapper_CPU__multilabel_margin_loss_forward));
m.impl("multilabel_margin_loss_forward.output",
TORCH_FN(wrapper_CPU_output_multilabel_margin_loss_forward_out));
m.impl("multilabel_margin_loss_backward",
TORCH_FN(wrapper_CPU__multilabel_margin_loss_backward));
m.impl("multilabel_margin_loss_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_multilabel_margin_loss_backward_out));
m.impl("nll_loss_forward", TORCH_FN(wrapper_CPU_nll_loss_forward));
m.impl("nll_loss_forward.output", TORCH_FN(wrapper_CPU_nll_loss_forward_out_output));
m.impl("nll_loss_backward", TORCH_FN(wrapper_CPU_nll_loss_backward));
m.impl("nll_loss_backward.grad_input", TORCH_FN(wrapper_CPU_nll_loss_backward_out_grad_input));
m.impl("nll_loss2d_forward",
TORCH_FN(wrapper_CPU__nll_loss2d_forward));
m.impl("nll_loss2d_forward.output",
TORCH_FN(wrapper_CPU_output_nll_loss2d_forward_out));
m.impl("nll_loss2d_backward",
TORCH_FN(wrapper_CPU__nll_loss2d_backward));
m.impl("nll_loss2d_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_nll_loss2d_backward_out));
m.impl("smooth_l1_loss", TORCH_FN(wrapper_CPU_smooth_l1_loss));
m.impl("smooth_l1_loss.out", TORCH_FN(wrapper_CPU_smooth_l1_loss_out_out));
m.impl("smooth_l1_loss_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_smooth_l1_loss_backward_out));
m.impl("huber_loss",
TORCH_FN(wrapper_CPU__huber_loss));
m.impl("huber_loss.out",
TORCH_FN(wrapper_CPU_out_huber_loss_out));
m.impl("huber_loss_backward.out",
TORCH_FN(wrapper_CPU_out_huber_loss_backward_out));
m.impl("elu", TORCH_FN(wrapper_CPU_elu));
m.impl("elu.out", TORCH_FN(wrapper_CPU_elu_out_out));
m.impl("elu_", TORCH_FN(wrapper_CPU_elu_));
m.impl("elu_backward", TORCH_FN(wrapper_CPU_elu_backward));
m.impl("elu_backward.grad_input", TORCH_FN(wrapper_CPU_elu_backward_out_grad_input));
m.impl("glu", TORCH_FN(wrapper_CPU_glu));
m.impl("glu.out", TORCH_FN(wrapper_CPU_glu_out_out));
m.impl("glu_backward",
TORCH_FN(wrapper_CPU__glu_backward));
m.impl("glu_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_glu_backward_out));
m.impl("glu_jvp",
TORCH_FN(wrapper_CPU__glu_jvp));
m.impl("glu_backward_jvp",
TORCH_FN(wrapper_CPU__glu_backward_jvp));
m.impl("hardsigmoid", TORCH_FN(wrapper_CPU_hardsigmoid));
m.impl("hardsigmoid.out", TORCH_FN(wrapper_CPU_hardsigmoid_out_out));
m.impl("hardsigmoid_", TORCH_FN(wrapper_CPU_hardsigmoid_));
m.impl("hardsigmoid_backward", TORCH_FN(wrapper_CPU_hardsigmoid_backward));
m.impl("hardsigmoid_backward.grad_input", TORCH_FN(wrapper_CPU_hardsigmoid_backward_out_grad_input));
m.impl("hardtanh",
TORCH_FN(wrapper_CPU__hardtanh));
m.impl("hardtanh.out",
TORCH_FN(wrapper_CPU_out_hardtanh_out));
m.impl("hardtanh_",
TORCH_FN(wrapper_CPU__hardtanh_));
m.impl("hardtanh_backward",
TORCH_FN(wrapper_CPU__hardtanh_backward));
m.impl("hardtanh_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_hardtanh_backward_out));
m.impl("hardswish",
TORCH_FN(wrapper_CPU__hardswish));
m.impl("hardswish.out",
TORCH_FN(wrapper_CPU_out_hardswish_out));
m.impl("hardswish_",
TORCH_FN(wrapper_CPU__hardswish_));
m.impl("hardswish_backward",
TORCH_FN(wrapper_CPU__hardswish_backward));
m.impl("leaky_relu", TORCH_FN(wrapper_CPU_leaky_relu));
m.impl("leaky_relu.out", TORCH_FN(wrapper_CPU_leaky_relu_out_out));
m.impl("leaky_relu_", TORCH_FN(wrapper_CPU_leaky_relu_));
m.impl("leaky_relu_backward", TORCH_FN(wrapper_CPU_leaky_relu_backward));
m.impl("leaky_relu_backward.grad_input", TORCH_FN(wrapper_CPU_leaky_relu_backward_out_grad_input));
m.impl("log_sigmoid_forward",
TORCH_FN(wrapper_CPU__log_sigmoid_forward));
m.impl("log_sigmoid_forward.output",
TORCH_FN(wrapper_CPU_output_log_sigmoid_forward_out));
m.impl("log_sigmoid_backward",
TORCH_FN(wrapper_CPU__log_sigmoid_backward));
m.impl("log_sigmoid_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_log_sigmoid_backward_out));
m.impl("rrelu_with_noise",
TORCH_FN(wrapper_CPU__rrelu_with_noise));
m.impl("rrelu_with_noise.out",
TORCH_FN(wrapper_CPU_out_rrelu_with_noise_out));
m.impl("rrelu_with_noise_",
TORCH_FN(wrapper_CPU__rrelu_with_noise_));
m.impl("softplus", TORCH_FN(wrapper_CPU_softplus));
m.impl("softplus.out", TORCH_FN(wrapper_CPU_softplus_out_out));
m.impl("softplus_backward", TORCH_FN(wrapper_CPU_softplus_backward));
m.impl("softplus_backward.grad_input", TORCH_FN(wrapper_CPU_softplus_backward_out_grad_input));
m.impl("softshrink", TORCH_FN(wrapper_CPU_softshrink));
m.impl("softshrink.out", TORCH_FN(wrapper_CPU_softshrink_out_out));
m.impl("softshrink_backward", TORCH_FN(wrapper_CPU_softshrink_backward));
m.impl("softshrink_backward.grad_input", TORCH_FN(wrapper_CPU_softshrink_backward_out_grad_input));
m.impl("adaptive_avg_pool2d.out",
TORCH_FN(wrapper_CPU_out_adaptive_avg_pool2d_out));
m.impl("_adaptive_avg_pool2d",
TORCH_FN(wrapper_CPU___adaptive_avg_pool2d));
m.impl("_adaptive_avg_pool2d_backward",
TORCH_FN(wrapper_CPU___adaptive_avg_pool2d_backward));
m.impl("adaptive_avg_pool3d.out",
TORCH_FN(wrapper_CPU_out_adaptive_avg_pool3d_out));
m.impl("_adaptive_avg_pool3d",
TORCH_FN(wrapper_CPU___adaptive_avg_pool3d));
m.impl("adaptive_avg_pool3d_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_adaptive_avg_pool3d_backward_out));
m.impl("_adaptive_avg_pool3d_backward",
TORCH_FN(wrapper_CPU___adaptive_avg_pool3d_backward));
m.impl("adaptive_max_pool2d", TORCH_FN(wrapper_CPU_adaptive_max_pool2d));
m.impl("adaptive_max_pool2d.out", TORCH_FN(wrapper_CPU_adaptive_max_pool2d_out_out));
m.impl("adaptive_max_pool2d_backward", TORCH_FN(wrapper_CPU_adaptive_max_pool2d_backward));
m.impl("adaptive_max_pool2d_backward.grad_input", TORCH_FN(wrapper_CPU_adaptive_max_pool2d_backward_out_grad_input));
m.impl("adaptive_max_pool3d", TORCH_FN(wrapper_CPU_adaptive_max_pool3d));
m.impl("adaptive_max_pool3d.out", TORCH_FN(wrapper_CPU_adaptive_max_pool3d_out_out));
m.impl("adaptive_max_pool3d_backward", TORCH_FN(wrapper_CPU_adaptive_max_pool3d_backward));
m.impl("adaptive_max_pool3d_backward.grad_input", TORCH_FN(wrapper_CPU_adaptive_max_pool3d_backward_out_grad_input));
m.impl("avg_pool2d", TORCH_FN(wrapper_CPU_avg_pool2d));
m.impl("avg_pool2d.out", TORCH_FN(wrapper_CPU_avg_pool2d_out_out));
m.impl("avg_pool2d_backward", TORCH_FN(wrapper_CPU_avg_pool2d_backward));
m.impl("avg_pool2d_backward.grad_input", TORCH_FN(wrapper_CPU_avg_pool2d_backward_out_grad_input));
m.impl("avg_pool3d", TORCH_FN(wrapper_CPU_avg_pool3d));
m.impl("avg_pool3d.out", TORCH_FN(wrapper_CPU_avg_pool3d_out_out));
m.impl("avg_pool3d_backward", TORCH_FN(wrapper_CPU_avg_pool3d_backward));
m.impl("avg_pool3d_backward.grad_input", TORCH_FN(wrapper_CPU_avg_pool3d_backward_out_grad_input));
m.impl("fractional_max_pool2d", TORCH_FN(wrapper_CPU_fractional_max_pool2d));
m.impl("fractional_max_pool2d.output", TORCH_FN(wrapper_CPU_fractional_max_pool2d_out_output));
m.impl("fractional_max_pool2d_backward", TORCH_FN(wrapper_CPU_fractional_max_pool2d_backward));
m.impl("fractional_max_pool2d_backward.grad_input", TORCH_FN(wrapper_CPU_fractional_max_pool2d_backward_out_grad_input));
m.impl("fractional_max_pool3d", TORCH_FN(wrapper_CPU_fractional_max_pool3d));
m.impl("fractional_max_pool3d.output", TORCH_FN(wrapper_CPU_fractional_max_pool3d_out_output));
m.impl("fractional_max_pool3d_backward",
TORCH_FN(wrapper_CPU__fractional_max_pool3d_backward));
m.impl("fractional_max_pool3d_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_fractional_max_pool3d_backward_out));
m.impl("max_pool2d_with_indices", TORCH_FN(wrapper_CPU_max_pool2d_with_indices));
m.impl("max_pool2d_with_indices.out", TORCH_FN(wrapper_CPU_max_pool2d_with_indices_out_out));
m.impl("max_pool2d_with_indices_backward", TORCH_FN(wrapper_CPU_max_pool2d_with_indices_backward));
m.impl("max_pool2d_with_indices_backward.grad_input", TORCH_FN(wrapper_CPU_max_pool2d_with_indices_backward_out_grad_input));
m.impl("max_pool3d_with_indices",
TORCH_FN(wrapper_CPU__max_pool3d_with_indices));
m.impl("max_pool3d_with_indices.out",
TORCH_FN(wrapper_CPU_out_max_pool3d_with_indices_out));
m.impl("max_pool3d_with_indices_backward",
TORCH_FN(wrapper_CPU__max_pool3d_with_indices_backward));
m.impl("max_pool3d_with_indices_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_max_pool3d_with_indices_backward_out));
m.impl("max_unpool2d",
TORCH_FN(wrapper_CPU__max_unpool2d));
m.impl("max_unpool2d.out",
TORCH_FN(wrapper_CPU_out_max_unpool2d_out));
m.impl("max_unpool3d",
TORCH_FN(wrapper_CPU__max_unpool3d));
m.impl("max_unpool3d.out",
TORCH_FN(wrapper_CPU_out_max_unpool3d_out));
m.impl("reflection_pad1d", TORCH_FN(wrapper_CPU_reflection_pad1d));
m.impl("reflection_pad1d.out", TORCH_FN(wrapper_CPU_reflection_pad1d_out_out));
m.impl("reflection_pad1d_backward", TORCH_FN(wrapper_CPU_reflection_pad1d_backward));
m.impl("reflection_pad1d_backward.grad_input", TORCH_FN(wrapper_CPU_reflection_pad1d_backward_out_grad_input));
m.impl("reflection_pad2d",
TORCH_FN(wrapper_CPU__reflection_pad2d));
m.impl("reflection_pad2d.out",
TORCH_FN(wrapper_CPU_out_reflection_pad2d_out));
m.impl("reflection_pad2d_backward",
TORCH_FN(wrapper_CPU__reflection_pad2d_backward));
m.impl("reflection_pad2d_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_reflection_pad2d_backward_out));
m.impl("reflection_pad3d", TORCH_FN(wrapper_CPU_reflection_pad3d));
m.impl("reflection_pad3d.out", TORCH_FN(wrapper_CPU_reflection_pad3d_out_out));
m.impl("reflection_pad3d_backward", TORCH_FN(wrapper_CPU_reflection_pad3d_backward));
m.impl("reflection_pad3d_backward.grad_input", TORCH_FN(wrapper_CPU_reflection_pad3d_backward_out_grad_input));
m.impl("replication_pad1d", TORCH_FN(wrapper_CPU_replication_pad1d));
m.impl("replication_pad1d.out", TORCH_FN(wrapper_CPU_replication_pad1d_out_out));
m.impl("replication_pad1d_backward", TORCH_FN(wrapper_CPU_replication_pad1d_backward));
m.impl("replication_pad1d_backward.grad_input", TORCH_FN(wrapper_CPU_replication_pad1d_backward_out_grad_input));
m.impl("replication_pad2d", TORCH_FN(wrapper_CPU_replication_pad2d));
m.impl("replication_pad2d.out", TORCH_FN(wrapper_CPU_replication_pad2d_out_out));
m.impl("replication_pad2d_backward",
TORCH_FN(wrapper_CPU__replication_pad2d_backward));
m.impl("replication_pad2d_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_replication_pad2d_backward_out));
m.impl("replication_pad3d", TORCH_FN(wrapper_CPU_replication_pad3d));
m.impl("replication_pad3d.out", TORCH_FN(wrapper_CPU_replication_pad3d_out_out));
m.impl("replication_pad3d_backward",
TORCH_FN(wrapper_CPU__replication_pad3d_backward));
m.impl("replication_pad3d_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input_replication_pad3d_backward_out));
m.impl("upsample_linear1d", TORCH_FN(wrapper_CPU_upsample_linear1d));
m.impl("upsample_linear1d.out", TORCH_FN(wrapper_CPU_upsample_linear1d_out_out));
m.impl("upsample_linear1d_backward", TORCH_FN(wrapper_CPU_upsample_linear1d_backward));
m.impl("upsample_linear1d_backward.grad_input", TORCH_FN(wrapper_CPU_upsample_linear1d_backward_out_grad_input));
m.impl("upsample_bilinear2d", TORCH_FN(wrapper_CPU_upsample_bilinear2d));
m.impl("upsample_bilinear2d.out", TORCH_FN(wrapper_CPU_upsample_bilinear2d_out_out));
m.impl("upsample_bilinear2d_backward", TORCH_FN(wrapper_CPU_upsample_bilinear2d_backward));
m.impl("upsample_bilinear2d_backward.grad_input", TORCH_FN(wrapper_CPU_upsample_bilinear2d_backward_out_grad_input));
m.impl("_upsample_bilinear2d_aa", TORCH_FN(wrapper_CPU__upsample_bilinear2d_aa));
m.impl("_upsample_bilinear2d_aa.out", TORCH_FN(wrapper_CPU__upsample_bilinear2d_aa_out_out));
m.impl("_upsample_bilinear2d_aa_backward", TORCH_FN(wrapper_CPU__upsample_bilinear2d_aa_backward));
m.impl("_upsample_bilinear2d_aa_backward.grad_input", TORCH_FN(wrapper_CPU__upsample_bilinear2d_aa_backward_out_grad_input));
m.impl("upsample_bicubic2d", TORCH_FN(wrapper_CPU_upsample_bicubic2d));
m.impl("upsample_bicubic2d.out", TORCH_FN(wrapper_CPU_upsample_bicubic2d_out_out));
m.impl("upsample_bicubic2d_backward", TORCH_FN(wrapper_CPU_upsample_bicubic2d_backward));
m.impl("upsample_bicubic2d_backward.grad_input", TORCH_FN(wrapper_CPU_upsample_bicubic2d_backward_out_grad_input));
m.impl("_upsample_bicubic2d_aa", TORCH_FN(wrapper_CPU__upsample_bicubic2d_aa));
m.impl("_upsample_bicubic2d_aa.out", TORCH_FN(wrapper_CPU__upsample_bicubic2d_aa_out_out));
m.impl("_upsample_bicubic2d_aa_backward", TORCH_FN(wrapper_CPU__upsample_bicubic2d_aa_backward));
m.impl("_upsample_bicubic2d_aa_backward.grad_input", TORCH_FN(wrapper_CPU__upsample_bicubic2d_aa_backward_out_grad_input));
m.impl("upsample_trilinear3d", TORCH_FN(wrapper_CPU_upsample_trilinear3d));
m.impl("upsample_trilinear3d.out", TORCH_FN(wrapper_CPU_upsample_trilinear3d_out_out));
m.impl("upsample_trilinear3d_backward", TORCH_FN(wrapper_CPU_upsample_trilinear3d_backward));
m.impl("upsample_trilinear3d_backward.grad_input", TORCH_FN(wrapper_CPU_upsample_trilinear3d_backward_out_grad_input));
m.impl("upsample_nearest1d", TORCH_FN(wrapper_CPU_upsample_nearest1d));
m.impl("upsample_nearest1d.out", TORCH_FN(wrapper_CPU_upsample_nearest1d_out_out));
m.impl("_upsample_nearest_exact1d", TORCH_FN(wrapper_CPU__upsample_nearest_exact1d));
m.impl("_upsample_nearest_exact1d.out", TORCH_FN(wrapper_CPU__upsample_nearest_exact1d_out_out));
m.impl("upsample_nearest1d_backward", TORCH_FN(wrapper_CPU_upsample_nearest1d_backward));
m.impl("upsample_nearest1d_backward.grad_input", TORCH_FN(wrapper_CPU_upsample_nearest1d_backward_out_grad_input));
m.impl("_upsample_nearest_exact1d_backward", TORCH_FN(wrapper_CPU__upsample_nearest_exact1d_backward));
m.impl("_upsample_nearest_exact1d_backward.grad_input", TORCH_FN(wrapper_CPU__upsample_nearest_exact1d_backward_out_grad_input));
m.impl("upsample_nearest2d", TORCH_FN(wrapper_CPU_upsample_nearest2d));
m.impl("upsample_nearest2d.out", TORCH_FN(wrapper_CPU_upsample_nearest2d_out_out));
m.impl("_upsample_nearest_exact2d", TORCH_FN(wrapper_CPU__upsample_nearest_exact2d));
m.impl("_upsample_nearest_exact2d.out", TORCH_FN(wrapper_CPU__upsample_nearest_exact2d_out_out));
m.impl("upsample_nearest2d_backward", TORCH_FN(wrapper_CPU_upsample_nearest2d_backward));
m.impl("upsample_nearest2d_backward.grad_input", TORCH_FN(wrapper_CPU_upsample_nearest2d_backward_out_grad_input));
m.impl("_upsample_nearest_exact2d_backward", TORCH_FN(wrapper_CPU__upsample_nearest_exact2d_backward));
m.impl("_upsample_nearest_exact2d_backward.grad_input", TORCH_FN(wrapper_CPU__upsample_nearest_exact2d_backward_out_grad_input));
m.impl("upsample_nearest3d", TORCH_FN(wrapper_CPU_upsample_nearest3d));
m.impl("upsample_nearest3d.out", TORCH_FN(wrapper_CPU_upsample_nearest3d_out_out));
m.impl("_upsample_nearest_exact3d", TORCH_FN(wrapper_CPU__upsample_nearest_exact3d));
m.impl("_upsample_nearest_exact3d.out", TORCH_FN(wrapper_CPU__upsample_nearest_exact3d_out_out));
m.impl("upsample_nearest3d_backward", TORCH_FN(wrapper_CPU_upsample_nearest3d_backward));
m.impl("upsample_nearest3d_backward.grad_input", TORCH_FN(wrapper_CPU_upsample_nearest3d_backward_out_grad_input));
m.impl("_upsample_nearest_exact3d_backward", TORCH_FN(wrapper_CPU__upsample_nearest_exact3d_backward));
m.impl("_upsample_nearest_exact3d_backward.grad_input", TORCH_FN(wrapper_CPU__upsample_nearest_exact3d_backward_out_grad_input));
m.impl("sigmoid_backward", TORCH_FN(wrapper_CPU_sigmoid_backward));
m.impl("sigmoid_backward.grad_input", TORCH_FN(wrapper_CPU_sigmoid_backward_out_grad_input));
m.impl("logit_backward", TORCH_FN(wrapper_CPU_logit_backward));
m.impl("logit_backward.grad_input", TORCH_FN(wrapper_CPU_logit_backward_out_grad_input));
m.impl("tanh_backward", TORCH_FN(wrapper_CPU_tanh_backward));
m.impl("tanh_backward.grad_input", TORCH_FN(wrapper_CPU_tanh_backward_out_grad_input));
m.impl("slow_conv_transpose2d", TORCH_FN(wrapper_CPU_slow_conv_transpose2d));
m.impl("slow_conv_transpose2d.out", TORCH_FN(wrapper_CPU_slow_conv_transpose2d_out_out));
m.impl("slow_conv_transpose3d",
TORCH_FN(wrapper_CPU__slow_conv_transpose3d));
m.impl("slow_conv_transpose3d.out",
TORCH_FN(wrapper_CPU_out_slow_conv_transpose3d_out));
m.impl("_slow_conv2d_forward",
TORCH_FN(wrapper_CPU___slow_conv2d_forward));
m.impl("_slow_conv2d_forward.output",
TORCH_FN(wrapper_CPU_output__slow_conv2d_forward_out));
m.impl("_slow_conv2d_backward.grad_input",
TORCH_FN(wrapper_CPU_grad_input__slow_conv2d_backward_out));
m.impl("_slow_conv2d_backward.output_mask",
TORCH_FN(wrapper_CPU_output_mask__slow_conv2d_backward));
m.impl("slow_conv3d_forward",
TORCH_FN(wrapper_CPU__slow_conv3d_forward));
m.impl("slow_conv3d_forward.output",
TORCH_FN(wrapper_CPU_output_slow_conv3d_forward_out));
m.impl("slow_conv_dilated2d",
TORCH_FN(wrapper_CPU__slow_conv_dilated2d));
m.impl("slow_conv_dilated3d",
TORCH_FN(wrapper_CPU__slow_conv_dilated3d));
m.impl("col2im",
TORCH_FN(wrapper_CPU__col2im));
m.impl("col2im.out",
TORCH_FN(wrapper_CPU_out_col2im_out));
m.impl("im2col",
TORCH_FN(wrapper_CPU__im2col));
m.impl("im2col.out",
TORCH_FN(wrapper_CPU_out_im2col_out));
m.impl("isposinf", TORCH_FN(wrapper_CPU_isposinf));
m.impl("isposinf.out", TORCH_FN(wrapper_CPU_isposinf_out_out));
m.impl("isneginf", TORCH_FN(wrapper_CPU_isneginf));
m.impl("isneginf.out", TORCH_FN(wrapper_CPU_isneginf_out_out));
m.impl("special_entr", TORCH_FN(wrapper_CPU_special_entr));
m.impl("special_entr.out", TORCH_FN(wrapper_CPU_special_entr_out_out));
m.impl("special_ndtri", TORCH_FN(wrapper_CPU_special_ndtri));
m.impl("special_ndtri.out", TORCH_FN(wrapper_CPU_special_ndtri_out_out));
m.impl("special_log_ndtr", TORCH_FN(wrapper_CPU_special_log_ndtr));
m.impl("special_log_ndtr.out", TORCH_FN(wrapper_CPU_special_log_ndtr_out_out));
m.impl("special_erfcx", TORCH_FN(wrapper_CPU_special_erfcx));
m.impl("special_erfcx.out", TORCH_FN(wrapper_CPU_special_erfcx_out_out));
m.impl("special_xlog1py", TORCH_FN(wrapper_CPU_special_xlog1py));
m.impl("special_xlog1py.out", TORCH_FN(wrapper_CPU_special_xlog1py_out_out));
m.impl("special_zeta", TORCH_FN(wrapper_CPU_special_zeta));
m.impl("special_zeta.out", TORCH_FN(wrapper_CPU_special_zeta_out_out));
m.impl("special_i0e", TORCH_FN(wrapper_CPU_special_i0e));
m.impl("special_i0e.out", TORCH_FN(wrapper_CPU_special_i0e_out_out));
m.impl("special_i1", TORCH_FN(wrapper_CPU_special_i1));
m.impl("special_i1.out", TORCH_FN(wrapper_CPU_special_i1_out_out));
m.impl("special_i1e", TORCH_FN(wrapper_CPU_special_i1e));
m.impl("special_i1e.out", TORCH_FN(wrapper_CPU_special_i1e_out_out));
m.impl("linalg_cholesky_ex", TORCH_FN(wrapper_CPU_linalg_cholesky_ex));
m.impl("linalg_cholesky_ex.L", TORCH_FN(wrapper_CPU_linalg_cholesky_ex_out_L));
m.impl("linalg_cross", TORCH_FN(wrapper_CPU_linalg_cross));
m.impl("linalg_cross.out", TORCH_FN(wrapper_CPU_linalg_cross_out_out));
m.impl("linalg_lu_factor_ex", TORCH_FN(wrapper_CPU_linalg_lu_factor_ex));
m.impl("linalg_lu_factor_ex.out", TORCH_FN(wrapper_CPU_linalg_lu_factor_ex_out_out));
m.impl("linalg_lu", TORCH_FN(wrapper_CPU_linalg_lu));
m.impl("linalg_lu.out", TORCH_FN(wrapper_CPU_linalg_lu_out_out));
m.impl("linalg_lu_solve", TORCH_FN(wrapper_CPU_linalg_lu_solve));
m.impl("linalg_lu_solve.out", TORCH_FN(wrapper_CPU_linalg_lu_solve_out_out));
m.impl("_linalg_det", TORCH_FN(wrapper_CPU__linalg_det));
m.impl("_linalg_det.result", TORCH_FN(wrapper_CPU__linalg_det_out_result));
m.impl("linalg_ldl_factor_ex", TORCH_FN(wrapper_CPU_linalg_ldl_factor_ex));
m.impl("linalg_ldl_factor_ex.out", TORCH_FN(wrapper_CPU_linalg_ldl_factor_ex_out_out));
m.impl("linalg_ldl_solve", TORCH_FN(wrapper_CPU_linalg_ldl_solve));
m.impl("linalg_ldl_solve.out", TORCH_FN(wrapper_CPU_linalg_ldl_solve_out_out));
m.impl("linalg_lstsq.out",
TORCH_FN(wrapper_CPU_out_linalg_lstsq_out));
m.impl("linalg_matrix_exp",
TORCH_FN(wrapper_CPU__linalg_matrix_exp));
m.impl("_linalg_slogdet", TORCH_FN(wrapper_CPU__linalg_slogdet));
m.impl("_linalg_slogdet.sign", TORCH_FN(wrapper_CPU__linalg_slogdet_out_sign));
m.impl("linalg_eig",
TORCH_FN(wrapper_CPU__linalg_eig));
m.impl("linalg_eig.out",
TORCH_FN(wrapper_CPU_out_linalg_eig_out));
m.impl("_linalg_eigh", TORCH_FN(wrapper_CPU__linalg_eigh));
m.impl("_linalg_eigh.eigenvalues", TORCH_FN(wrapper_CPU__linalg_eigh_out_eigenvalues));
m.impl("linalg_householder_product",
TORCH_FN(wrapper_CPU__linalg_householder_product));
m.impl("linalg_householder_product.out",
TORCH_FN(wrapper_CPU_out_linalg_householder_product_out));
m.impl("linalg_inv_ex", TORCH_FN(wrapper_CPU_linalg_inv_ex));
m.impl("linalg_inv_ex.inverse", TORCH_FN(wrapper_CPU_linalg_inv_ex_out_inverse));
m.impl("linalg_vector_norm", TORCH_FN(wrapper_CPU_linalg_vector_norm));
m.impl("linalg_vector_norm.out", TORCH_FN(wrapper_CPU_linalg_vector_norm_out_out));
m.impl("_linalg_svd", TORCH_FN(wrapper_CPU__linalg_svd));
m.impl("_linalg_svd.U", TORCH_FN(wrapper_CPU__linalg_svd_out_U));
m.impl("_linalg_solve_ex", TORCH_FN(wrapper_CPU__linalg_solve_ex));
m.impl("_linalg_solve_ex.result", TORCH_FN(wrapper_CPU__linalg_solve_ex_out_result));
m.impl("linalg_qr", TORCH_FN(wrapper_CPU_linalg_qr));
m.impl("linalg_qr.out", TORCH_FN(wrapper_CPU_linalg_qr_out_out));
m.impl("_test_optional_intlist",
TORCH_FN(wrapper_CPU___test_optional_intlist));
m.impl("_test_optional_filled_intlist",
TORCH_FN(wrapper_CPU___test_optional_filled_intlist));
m.impl("_test_optional_floatlist",
TORCH_FN(wrapper_CPU___test_optional_floatlist));
m.impl("segment_reduce",
TORCH_FN(wrapper_CPU__segment_reduce));
m.impl("_segment_reduce_backward",
TORCH_FN(wrapper_CPU___segment_reduce_backward));
m.impl("_transformer_encoder_layer_fwd",
TORCH_FN(wrapper_CPU___transformer_encoder_layer_fwd));
m.impl("_native_multi_head_attention",
TORCH_FN(wrapper_CPU___native_multi_head_attention));
m.impl("_fused_sdp_choice",
TORCH_FN(wrapper_CPU___fused_sdp_choice));
m.impl("_scaled_dot_product_flash_attention_for_cpu",
TORCH_FN(wrapper_CPU___scaled_dot_product_flash_attention_for_cpu));
m.impl("_scaled_dot_product_flash_attention_for_cpu_backward",
TORCH_FN(wrapper_CPU___scaled_dot_product_flash_attention_for_cpu_backward));
m.impl("special_airy_ai", TORCH_FN(wrapper_CPU_special_airy_ai));
m.impl("special_airy_ai.out", TORCH_FN(wrapper_CPU_special_airy_ai_out_out));
m.impl("special_bessel_j0", TORCH_FN(wrapper_CPU_special_bessel_j0));
m.impl("special_bessel_j0.out", TORCH_FN(wrapper_CPU_special_bessel_j0_out_out));
m.impl("special_bessel_j1", TORCH_FN(wrapper_CPU_special_bessel_j1));
m.impl("special_bessel_j1.out", TORCH_FN(wrapper_CPU_special_bessel_j1_out_out));
m.impl("special_bessel_y0", TORCH_FN(wrapper_CPU_special_bessel_y0));
m.impl("special_bessel_y0.out", TORCH_FN(wrapper_CPU_special_bessel_y0_out_out));
m.impl("special_bessel_y1", TORCH_FN(wrapper_CPU_special_bessel_y1));
m.impl("special_bessel_y1.out", TORCH_FN(wrapper_CPU_special_bessel_y1_out_out));
m.impl("special_chebyshev_polynomial_t", TORCH_FN(wrapper_CPU_special_chebyshev_polynomial_t));
m.impl("special_chebyshev_polynomial_t.out", TORCH_FN(wrapper_CPU_special_chebyshev_polynomial_t_out_out));
m.impl("special_chebyshev_polynomial_u", TORCH_FN(wrapper_CPU_special_chebyshev_polynomial_u));
m.impl("special_chebyshev_polynomial_u.out", TORCH_FN(wrapper_CPU_special_chebyshev_polynomial_u_out_out));
m.impl("special_chebyshev_polynomial_v", TORCH_FN(wrapper_CPU_special_chebyshev_polynomial_v));
m.impl("special_chebyshev_polynomial_v.out", TORCH_FN(wrapper_CPU_special_chebyshev_polynomial_v_out_out));
m.impl("special_chebyshev_polynomial_w", TORCH_FN(wrapper_CPU_special_chebyshev_polynomial_w));
m.impl("special_chebyshev_polynomial_w.out", TORCH_FN(wrapper_CPU_special_chebyshev_polynomial_w_out_out));
m.impl("special_hermite_polynomial_h", TORCH_FN(wrapper_CPU_special_hermite_polynomial_h));
m.impl("special_hermite_polynomial_h.out", TORCH_FN(wrapper_CPU_special_hermite_polynomial_h_out_out));
m.impl("special_hermite_polynomial_he", TORCH_FN(wrapper_CPU_special_hermite_polynomial_he));
m.impl("special_hermite_polynomial_he.out", TORCH_FN(wrapper_CPU_special_hermite_polynomial_he_out_out));
m.impl("special_laguerre_polynomial_l", TORCH_FN(wrapper_CPU_special_laguerre_polynomial_l));
m.impl("special_laguerre_polynomial_l.out", TORCH_FN(wrapper_CPU_special_laguerre_polynomial_l_out_out));
m.impl("special_legendre_polynomial_p", TORCH_FN(wrapper_CPU_special_legendre_polynomial_p));
m.impl("special_legendre_polynomial_p.out", TORCH_FN(wrapper_CPU_special_legendre_polynomial_p_out_out));
m.impl("special_modified_bessel_i0", TORCH_FN(wrapper_CPU_special_modified_bessel_i0));
m.impl("special_modified_bessel_i0.out", TORCH_FN(wrapper_CPU_special_modified_bessel_i0_out_out));
m.impl("special_modified_bessel_i1", TORCH_FN(wrapper_CPU_special_modified_bessel_i1));
m.impl("special_modified_bessel_i1.out", TORCH_FN(wrapper_CPU_special_modified_bessel_i1_out_out));
m.impl("special_modified_bessel_k0", TORCH_FN(wrapper_CPU_special_modified_bessel_k0));
m.impl("special_modified_bessel_k0.out", TORCH_FN(wrapper_CPU_special_modified_bessel_k0_out_out));
m.impl("special_modified_bessel_k1", TORCH_FN(wrapper_CPU_special_modified_bessel_k1));
m.impl("special_modified_bessel_k1.out", TORCH_FN(wrapper_CPU_special_modified_bessel_k1_out_out));
m.impl("special_scaled_modified_bessel_k0", TORCH_FN(wrapper_CPU_special_scaled_modified_bessel_k0));
m.impl("special_scaled_modified_bessel_k0.out", TORCH_FN(wrapper_CPU_special_scaled_modified_bessel_k0_out_out));
m.impl("special_scaled_modified_bessel_k1", TORCH_FN(wrapper_CPU_special_scaled_modified_bessel_k1));
m.impl("special_scaled_modified_bessel_k1.out", TORCH_FN(wrapper_CPU_special_scaled_modified_bessel_k1_out_out));
m.impl("special_shifted_chebyshev_polynomial_t", TORCH_FN(wrapper_CPU_special_shifted_chebyshev_polynomial_t));
m.impl("special_shifted_chebyshev_polynomial_t.out", TORCH_FN(wrapper_CPU_special_shifted_chebyshev_polynomial_t_out_out));
m.impl("special_shifted_chebyshev_polynomial_u", TORCH_FN(wrapper_CPU_special_shifted_chebyshev_polynomial_u));
m.impl("special_shifted_chebyshev_polynomial_u.out", TORCH_FN(wrapper_CPU_special_shifted_chebyshev_polynomial_u_out_out));
m.impl("special_shifted_chebyshev_polynomial_v", TORCH_FN(wrapper_CPU_special_shifted_chebyshev_polynomial_v));
m.impl("special_shifted_chebyshev_polynomial_v.out", TORCH_FN(wrapper_CPU_special_shifted_chebyshev_polynomial_v_out_out));
m.impl("special_shifted_chebyshev_polynomial_w", TORCH_FN(wrapper_CPU_special_shifted_chebyshev_polynomial_w));
m.impl("special_shifted_chebyshev_polynomial_w.out", TORCH_FN(wrapper_CPU_special_shifted_chebyshev_polynomial_w_out_out));
m.impl("special_spherical_bessel_j0", TORCH_FN(wrapper_CPU_special_spherical_bessel_j0));
m.impl("special_spherical_bessel_j0.out", TORCH_FN(wrapper_CPU_special_spherical_bessel_j0_out_out));
m.impl("_foobar",
TORCH_FN(wrapper_CPU___foobar));
};
} // anonymous namespace
namespace cpu {
void _assert_async(const at::Tensor & self) {
return wrapper_CPU___assert_async(self);
}
void _assert_async(const at::Tensor & self, c10::string_view assert_msg) {
return wrapper_CPU_msg__assert_async(self, assert_msg);
}
at::Tensor _functional_assert_async(const at::Tensor & self, c10::string_view assert_msg, const at::Tensor & dep_token) {
return wrapper_CPU_msg__functional_assert_async(self, assert_msg, dep_token);
}
at::Tensor _make_dep_token(at::TensorOptions options, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___make_dep_token(c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt(), c10::impl::check_tensor_options_and_extract_memory_format(options, memory_format));
}
at::Tensor _make_dep_token(c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___make_dep_token(dtype, layout, device, pin_memory, memory_format);
}
::std::tuple<at::Tensor,at::Tensor> native_dropout(const at::Tensor & input, double p, c10::optional<bool> train) {
return wrapper_CPU__native_dropout(input, p, train);
}
at::Tensor native_dropout_backward(const at::Tensor & grad_output, const at::Tensor & mask, double scale) {
return wrapper_CPU__native_dropout_backward(grad_output, mask, scale);
}
at::Tensor & abs_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_out_abs_out(self, out);
}
at::Tensor & abs_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_out_abs_out(self, out);
}
at::Tensor angle(const at::Tensor & self) {
return wrapper_CPU__angle(self);
}
at::Tensor & angle_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_out_angle_out(self, out);
}
at::Tensor & angle_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_out_angle_out(self, out);
}
at::Tensor view_as_real(const at::Tensor & self) {
return wrapper_CPU__view_as_real(self);
}
at::Tensor view_as_complex(const at::Tensor & self) {
return wrapper_CPU__view_as_complex(self);
}
at::Tensor sgn(const at::Tensor & self) {
return wrapper_CPU_sgn(self);
}
at::Tensor & sgn_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_sgn_out_out(self, out);
}
at::Tensor & sgn_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_sgn_out_out(self, out);
}
at::Tensor & sgn_(at::Tensor & self) {
return wrapper_CPU_sgn_(self);
}
at::Tensor & conj_physical_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_out_conj_physical_out(self, out);
}
at::Tensor & conj_physical_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_out_conj_physical_out(self, out);
}
at::Tensor acos(const at::Tensor & self) {
return wrapper_CPU_acos(self);
}
at::Tensor & acos_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_acos_out_out(self, out);
}
at::Tensor & acos_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_acos_out_out(self, out);
}
at::Tensor & acos_(at::Tensor & self) {
return wrapper_CPU_acos_(self);
}
at::Tensor add(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_add_Tensor(self, other, alpha);
}
at::Tensor & add_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_add_out_out(self, other, alpha, out);
}
at::Tensor & add_outf(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_add_out_out(self, other, alpha, out);
}
at::Tensor & add_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_add__Tensor(self, other, alpha);
}
at::Tensor _add_relu(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_Tensor__add_relu(self, other, alpha);
}
at::Tensor & _add_relu_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_out__add_relu_out(self, other, alpha, out);
}
at::Tensor & _add_relu_outf(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_out__add_relu_out(self, other, alpha, out);
}
at::Tensor & _add_relu_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_Tensor__add_relu_(self, other, alpha);
}
at::Tensor _add_relu(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
return wrapper_CPU_Scalar__add_relu(self, other, alpha);
}
at::Tensor & _add_relu_(at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
return wrapper_CPU_Scalar__add_relu_(self, other, alpha);
}
at::Tensor addmv(const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_addmv(self, mat, vec, beta, alpha);
}
at::Tensor & addmv_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_addmv_out_out(self, mat, vec, beta, alpha, out);
}
at::Tensor & addmv_outf(const at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_addmv_out_out(self, mat, vec, beta, alpha, out);
}
at::Tensor & addmv_(at::Tensor & self, const at::Tensor & mat, const at::Tensor & vec, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_addmv_(self, mat, vec, beta, alpha);
}
at::Tensor addr(const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU__addr(self, vec1, vec2, beta, alpha);
}
at::Tensor & addr_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_out_addr_out(self, vec1, vec2, beta, alpha, out);
}
at::Tensor & addr_outf(const at::Tensor & self, const at::Tensor & vec1, const at::Tensor & vec2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_out_addr_out(self, vec1, vec2, beta, alpha, out);
}
at::Tensor _test_functorch_fallback(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU___test_functorch_fallback(self, other);
}
at::Tensor all(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_all_dim(self, dim, keepdim);
}
at::Tensor & all_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_all_out_out(self, dim, keepdim, out);
}
at::Tensor & all_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
return wrapper_CPU_all_out_out(self, dim, keepdim, out);
}
at::Tensor all(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
return wrapper_CPU_all_dims(self, dim, keepdim);
}
at::Tensor & all_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
return wrapper_CPU_all_out_dims_out(self, dim, keepdim, out);
}
at::Tensor & all_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CPU_all_out_dims_out(self, dim, keepdim, out);
}
at::Tensor any(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_any_dim(self, dim, keepdim);
}
at::Tensor & any_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_any_out_out(self, dim, keepdim, out);
}
at::Tensor & any_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
return wrapper_CPU_any_out_out(self, dim, keepdim, out);
}
at::Tensor any(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
return wrapper_CPU_any_dims(self, dim, keepdim);
}
at::Tensor & any_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim) {
return wrapper_CPU_any_out_dims_out(self, dim, keepdim, out);
}
at::Tensor & any_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CPU_any_out_dims_out(self, dim, keepdim, out);
}
at::Tensor & arange_out(at::Tensor & out, const at::Scalar & start, const at::Scalar & end, const at::Scalar & step) {
return wrapper_CPU_start_out_arange_out(start, end, step, out);
}
at::Tensor & arange_outf(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
return wrapper_CPU_start_out_arange_out(start, end, step, out);
}
at::Tensor argmax(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CPU_argmax(self, dim, keepdim);
}
at::Tensor & argmax_out(at::Tensor & out, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CPU_argmax_out_out(self, dim, keepdim, out);
}
at::Tensor & argmax_outf(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
return wrapper_CPU_argmax_out_out(self, dim, keepdim, out);
}
at::Tensor argmin(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CPU_argmin(self, dim, keepdim);
}
at::Tensor & argmin_out(at::Tensor & out, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CPU_argmin_out_out(self, dim, keepdim, out);
}
at::Tensor & argmin_outf(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
return wrapper_CPU_argmin_out_out(self, dim, keepdim, out);
}
at::Tensor acosh(const at::Tensor & self) {
return wrapper_CPU_acosh(self);
}
at::Tensor & acosh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_acosh_out_out(self, out);
}
at::Tensor & acosh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_acosh_out_out(self, out);
}
at::Tensor & acosh_(at::Tensor & self) {
return wrapper_CPU_acosh_(self);
}
at::Tensor asinh(const at::Tensor & self) {
return wrapper_CPU_asinh(self);
}
at::Tensor & asinh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_asinh_out_out(self, out);
}
at::Tensor & asinh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_asinh_out_out(self, out);
}
at::Tensor & asinh_(at::Tensor & self) {
return wrapper_CPU_asinh_(self);
}
at::Tensor atanh(const at::Tensor & self) {
return wrapper_CPU_atanh(self);
}
at::Tensor & atanh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_atanh_out_out(self, out);
}
at::Tensor & atanh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_atanh_out_out(self, out);
}
at::Tensor & atanh_(at::Tensor & self) {
return wrapper_CPU_atanh_(self);
}
at::Tensor as_strided(const at::Tensor & self, at::IntArrayRef size, at::IntArrayRef stride, c10::optional<int64_t> storage_offset) {
return wrapper_CPU__as_strided(self, c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride), storage_offset.has_value() ? c10::make_optional(c10::SymInt(*storage_offset)) : c10::nullopt);
}
at::Tensor as_strided_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<c10::SymInt> storage_offset) {
return wrapper_CPU__as_strided(self, size, stride, storage_offset);
}
at::Tensor asin(const at::Tensor & self) {
return wrapper_CPU_asin(self);
}
at::Tensor & asin_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_asin_out_out(self, out);
}
at::Tensor & asin_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_asin_out_out(self, out);
}
at::Tensor & asin_(at::Tensor & self) {
return wrapper_CPU_asin_(self);
}
at::Tensor atan(const at::Tensor & self) {
return wrapper_CPU_atan(self);
}
at::Tensor & atan_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_atan_out_out(self, out);
}
at::Tensor & atan_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_atan_out_out(self, out);
}
at::Tensor & atan_(at::Tensor & self) {
return wrapper_CPU_atan_(self);
}
at::Tensor baddbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_baddbmm(self, batch1, batch2, beta, alpha);
}
at::Tensor & baddbmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_baddbmm_out_out(self, batch1, batch2, beta, alpha, out);
}
at::Tensor & baddbmm_outf(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_baddbmm_out_out(self, batch1, batch2, beta, alpha, out);
}
at::Tensor & baddbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_baddbmm_(self, batch1, batch2, beta, alpha);
}
at::Tensor & bernoulli_out(at::Tensor & out, const at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CPU_out_bernoulli_out(self, generator, out);
}
at::Tensor & bernoulli_outf(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CPU_out_bernoulli_out(self, generator, out);
}
at::Tensor & bernoulli_(at::Tensor & self, const at::Tensor & p, c10::optional<at::Generator> generator) {
return wrapper_CPU_Tensor_bernoulli_(self, p, generator);
}
at::Tensor & bernoulli_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
return wrapper_CPU_float_bernoulli_(self, p, generator);
}
at::Tensor binary_cross_entropy(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CPU__binary_cross_entropy(self, target, weight, reduction);
}
at::Tensor & binary_cross_entropy_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CPU_out_binary_cross_entropy_out(self, target, weight, reduction, out);
}
at::Tensor & binary_cross_entropy_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
return wrapper_CPU_out_binary_cross_entropy_out(self, target, weight, reduction, out);
}
at::Tensor binary_cross_entropy_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CPU__binary_cross_entropy_backward(grad_output, self, target, weight, reduction);
}
at::Tensor & binary_cross_entropy_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CPU_grad_input_binary_cross_entropy_backward_out(grad_output, self, target, weight, reduction, grad_input);
}
at::Tensor & binary_cross_entropy_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_binary_cross_entropy_backward_out(grad_output, self, target, weight, reduction, grad_input);
}
at::Tensor bincount(const at::Tensor & self, const c10::optional<at::Tensor> & weights, int64_t minlength) {
return wrapper_CPU__bincount(self, weights, minlength);
}
at::Tensor bitwise_not(const at::Tensor & self) {
return wrapper_CPU_bitwise_not(self);
}
at::Tensor & bitwise_not_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_bitwise_not_out_out(self, out);
}
at::Tensor & bitwise_not_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_bitwise_not_out_out(self, out);
}
at::Tensor & bitwise_not_(at::Tensor & self) {
return wrapper_CPU_bitwise_not_(self);
}
at::Tensor copysign(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_copysign_Tensor(self, other);
}
at::Tensor & copysign_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_copysign_out_out(self, other, out);
}
at::Tensor & copysign_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_copysign_out_out(self, other, out);
}
at::Tensor & copysign_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_copysign__Tensor(self, other);
}
at::Tensor & logical_not_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_out_logical_not_out(self, out);
}
at::Tensor & logical_not_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_out_logical_not_out(self, out);
}
at::Tensor & logical_xor_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_out_logical_xor_out(self, other, out);
}
at::Tensor & logical_xor_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_out_logical_xor_out(self, other, out);
}
at::Tensor & logical_and_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_out_logical_and_out(self, other, out);
}
at::Tensor & logical_and_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_out_logical_and_out(self, other, out);
}
at::Tensor & logical_or_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_out_logical_or_out(self, other, out);
}
at::Tensor & logical_or_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_out_logical_or_out(self, other, out);
}
at::Tensor bmm(const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CPU_bmm(self, mat2);
}
at::Tensor & bmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CPU_bmm_out_out(self, mat2, out);
}
at::Tensor & bmm_outf(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
return wrapper_CPU_bmm_out_out(self, mat2, out);
}
at::Tensor cat(const at::ITensorListRef & tensors, int64_t dim) {
return wrapper_CPU_cat(tensors, dim);
}
at::Tensor & cat_out(at::Tensor & out, const at::ITensorListRef & tensors, int64_t dim) {
return wrapper_CPU_cat_out_out(tensors, dim, out);
}
at::Tensor & cat_outf(const at::ITensorListRef & tensors, int64_t dim, at::Tensor & out) {
return wrapper_CPU_cat_out_out(tensors, dim, out);
}
at::Tensor ceil(const at::Tensor & self) {
return wrapper_CPU_ceil(self);
}
at::Tensor & ceil_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_ceil_out_out(self, out);
}
at::Tensor & ceil_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_ceil_out_out(self, out);
}
at::Tensor & ceil_(at::Tensor & self) {
return wrapper_CPU_ceil_(self);
}
at::Tensor clamp(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
return wrapper_CPU_clamp(self, min, max);
}
at::Tensor & clamp_out(at::Tensor & out, const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
return wrapper_CPU_clamp_out_out(self, min, max, out);
}
at::Tensor & clamp_outf(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max, at::Tensor & out) {
return wrapper_CPU_clamp_out_out(self, min, max, out);
}
at::Tensor & clamp_(at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
return wrapper_CPU_clamp_(self, min, max);
}
at::Tensor clamp(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
return wrapper_CPU_clamp_Tensor(self, min, max);
}
at::Tensor & clamp_out(at::Tensor & out, const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
return wrapper_CPU_clamp_out_Tensor_out(self, min, max, out);
}
at::Tensor & clamp_outf(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max, at::Tensor & out) {
return wrapper_CPU_clamp_out_Tensor_out(self, min, max, out);
}
at::Tensor & clamp_(at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
return wrapper_CPU_clamp__Tensor(self, min, max);
}
at::Tensor clamp_max(const at::Tensor & self, const at::Scalar & max) {
return wrapper_CPU_clamp_max(self, max);
}
at::Tensor & clamp_max_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & max) {
return wrapper_CPU_clamp_max_out_out(self, max, out);
}
at::Tensor & clamp_max_outf(const at::Tensor & self, const at::Scalar & max, at::Tensor & out) {
return wrapper_CPU_clamp_max_out_out(self, max, out);
}
at::Tensor & clamp_max_(at::Tensor & self, const at::Scalar & max) {
return wrapper_CPU_clamp_max_(self, max);
}
at::Tensor clamp_max(const at::Tensor & self, const at::Tensor & max) {
return wrapper_CPU_clamp_max_Tensor(self, max);
}
at::Tensor & clamp_max_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & max) {
return wrapper_CPU_clamp_max_out_Tensor_out(self, max, out);
}
at::Tensor & clamp_max_outf(const at::Tensor & self, const at::Tensor & max, at::Tensor & out) {
return wrapper_CPU_clamp_max_out_Tensor_out(self, max, out);
}
at::Tensor & clamp_max_(at::Tensor & self, const at::Tensor & max) {
return wrapper_CPU_clamp_max__Tensor(self, max);
}
at::Tensor clamp_min(const at::Tensor & self, const at::Scalar & min) {
return wrapper_CPU_clamp_min(self, min);
}
at::Tensor & clamp_min_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & min) {
return wrapper_CPU_clamp_min_out_out(self, min, out);
}
at::Tensor & clamp_min_outf(const at::Tensor & self, const at::Scalar & min, at::Tensor & out) {
return wrapper_CPU_clamp_min_out_out(self, min, out);
}
at::Tensor & clamp_min_(at::Tensor & self, const at::Scalar & min) {
return wrapper_CPU_clamp_min_(self, min);
}
at::Tensor clamp_min(const at::Tensor & self, const at::Tensor & min) {
return wrapper_CPU_clamp_min_Tensor(self, min);
}
at::Tensor & clamp_min_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & min) {
return wrapper_CPU_clamp_min_out_Tensor_out(self, min, out);
}
at::Tensor & clamp_min_outf(const at::Tensor & self, const at::Tensor & min, at::Tensor & out) {
return wrapper_CPU_clamp_min_out_Tensor_out(self, min, out);
}
at::Tensor & clamp_min_(at::Tensor & self, const at::Tensor & min) {
return wrapper_CPU_clamp_min__Tensor(self, min);
}
at::Tensor & complex_out(at::Tensor & out, const at::Tensor & real, const at::Tensor & imag) {
return wrapper_CPU_out_complex_out(real, imag, out);
}
at::Tensor & complex_outf(const at::Tensor & real, const at::Tensor & imag, at::Tensor & out) {
return wrapper_CPU_out_complex_out(real, imag, out);
}
at::Tensor & polar_out(at::Tensor & out, const at::Tensor & abs, const at::Tensor & angle) {
return wrapper_CPU_out_polar_out(abs, angle, out);
}
at::Tensor & polar_outf(const at::Tensor & abs, const at::Tensor & angle, at::Tensor & out) {
return wrapper_CPU_out_polar_out(abs, angle, out);
}
at::Tensor cos(const at::Tensor & self) {
return wrapper_CPU_cos(self);
}
at::Tensor & cos_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_cos_out_out(self, out);
}
at::Tensor & cos_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_cos_out_out(self, out);
}
at::Tensor & cos_(at::Tensor & self) {
return wrapper_CPU_cos_(self);
}
at::Tensor cosh(const at::Tensor & self) {
return wrapper_CPU_cosh(self);
}
at::Tensor & cosh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_cosh_out_out(self, out);
}
at::Tensor & cosh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_cosh_out_out(self, out);
}
at::Tensor & cosh_(at::Tensor & self) {
return wrapper_CPU_cosh_(self);
}
at::Tensor count_nonzero(const at::Tensor & self, at::IntArrayRef dim) {
return wrapper_CPU_dim_IntList_count_nonzero(self, dim);
}
void _cummax_helper(const at::Tensor & self, at::Tensor & values, at::Tensor & indices, int64_t dim) {
return wrapper_CPU___cummax_helper(self, values, indices, dim);
}
void _cummin_helper(const at::Tensor & self, at::Tensor & values, at::Tensor & indices, int64_t dim) {
return wrapper_CPU___cummin_helper(self, values, indices, dim);
}
at::Tensor cumprod(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_cumprod(self, dim, dtype);
}
at::Tensor & cumprod_out(at::Tensor & out, const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_cumprod_out_out(self, dim, dtype, out);
}
at::Tensor & cumprod_outf(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CPU_cumprod_out_out(self, dim, dtype, out);
}
at::Tensor & cumprod_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_cumprod_(self, dim, dtype);
}
at::Tensor cumsum(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_cumsum(self, dim, dtype);
}
at::Tensor & cumsum_out(at::Tensor & out, const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_cumsum_out_out(self, dim, dtype, out);
}
at::Tensor & cumsum_outf(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CPU_cumsum_out_out(self, dim, dtype, out);
}
at::Tensor & cumsum_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_cumsum_(self, dim, dtype);
}
::std::tuple<at::Tensor,at::Tensor> _ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, int64_t blank, bool zero_infinity) {
return wrapper_CPU___ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}
::std::tuple<at::Tensor,at::Tensor> _ctc_loss(const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, int64_t blank, bool zero_infinity) {
return wrapper_CPU_Tensor__ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity);
}
at::Tensor _ctc_loss_backward(const at::Tensor & grad, const at::Tensor & log_probs, const at::Tensor & targets, at::IntArrayRef input_lengths, at::IntArrayRef target_lengths, const at::Tensor & neg_log_likelihood, const at::Tensor & log_alpha, int64_t blank, bool zero_infinity) {
return wrapper_CPU___ctc_loss_backward(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity);
}
at::Tensor _ctc_loss_backward(const at::Tensor & grad, const at::Tensor & log_probs, const at::Tensor & targets, const at::Tensor & input_lengths, const at::Tensor & target_lengths, const at::Tensor & neg_log_likelihood, const at::Tensor & log_alpha, int64_t blank, bool zero_infinity) {
return wrapper_CPU_Tensor__ctc_loss_backward(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity);
}
at::Tensor div(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_div_Tensor(self, other);
}
at::Tensor & div_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_div_out_out(self, other, out);
}
at::Tensor & div_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_div_out_out(self, other, out);
}
at::Tensor & div_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_div__Tensor(self, other);
}
at::Tensor div(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
return wrapper_CPU_div_Tensor_mode(self, other, rounding_mode);
}
at::Tensor & div_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
return wrapper_CPU_div_out_out_mode(self, other, rounding_mode, out);
}
at::Tensor & div_outf(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode, at::Tensor & out) {
return wrapper_CPU_div_out_out_mode(self, other, rounding_mode, out);
}
at::Tensor & div_(at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
return wrapper_CPU_div__Tensor_mode(self, other, rounding_mode);
}
at::Tensor dot(const at::Tensor & self, const at::Tensor & tensor) {
return wrapper_CPU__dot(self, tensor);
}
at::Tensor vdot(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU__vdot(self, other);
}
at::Tensor embedding_dense_backward(const at::Tensor & grad_output, const at::Tensor & indices, int64_t num_weights, int64_t padding_idx, bool scale_grad_by_freq) {
return wrapper_CPU__embedding_dense_backward(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq);
}
at::Tensor embedding_dense_backward_symint(const at::Tensor & grad_output, const at::Tensor & indices, c10::SymInt num_weights, c10::SymInt padding_idx, bool scale_grad_by_freq) {
return wrapper_CPU__embedding_dense_backward(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq);
}
at::Tensor & embedding_renorm_(at::Tensor & self, const at::Tensor & indices, double max_norm, double norm_type) {
return wrapper_CPU__embedding_renorm_(self, indices, max_norm, norm_type);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _embedding_bag_forward_only(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
return wrapper_CPU___embedding_bag_forward_only(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _embedding_bag(const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, bool scale_grad_by_freq, int64_t mode, bool sparse, const c10::optional<at::Tensor> & per_sample_weights, bool include_last_offset, int64_t padding_idx) {
return wrapper_CPU___embedding_bag(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx);
}
at::Tensor _embedding_bag_dense_backward(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, int64_t num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
return wrapper_CPU___embedding_bag_dense_backward(grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}
at::Tensor _embedding_bag_dense_backward_symint(const at::Tensor & grad, const at::Tensor & indices, const at::Tensor & offset2bag, const at::Tensor & bag_size, const at::Tensor & maximum_indices, c10::SymInt num_weights, bool scale_grad_by_freq, int64_t mode, const c10::optional<at::Tensor> & per_sample_weights, int64_t padding_idx) {
return wrapper_CPU___embedding_bag_dense_backward(grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx);
}
at::Tensor _embedding_bag_per_sample_weights_backward(const at::Tensor & grad, const at::Tensor & weight, const at::Tensor & indices, const at::Tensor & offsets, const at::Tensor & offset2bag, int64_t mode, int64_t padding_idx) {
return wrapper_CPU___embedding_bag_per_sample_weights_backward(grad, weight, indices, offsets, offset2bag, mode, padding_idx);
}
at::Tensor empty(at::IntArrayRef size, at::TensorOptions options, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU_memory_format_empty(c10::fromIntArrayRefSlow(size), c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt(), c10::impl::check_tensor_options_and_extract_memory_format(options, memory_format));
}
at::Tensor empty(at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU_memory_format_empty(c10::fromIntArrayRefSlow(size), dtype, layout, device, pin_memory, memory_format);
}
at::Tensor empty_symint(c10::SymIntArrayRef size, at::TensorOptions options, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU_memory_format_empty(size, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt(), c10::impl::check_tensor_options_and_extract_memory_format(options, memory_format));
}
at::Tensor empty_symint(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU_memory_format_empty(size, dtype, layout, device, pin_memory, memory_format);
}
at::Tensor _empty_affine_quantized(at::IntArrayRef size, at::TensorOptions options, double scale, int64_t zero_point, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___empty_affine_quantized(c10::fromIntArrayRefSlow(size), c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt(), scale, zero_point, c10::impl::check_tensor_options_and_extract_memory_format(options, memory_format));
}
at::Tensor _empty_affine_quantized(at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, double scale, int64_t zero_point, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___empty_affine_quantized(c10::fromIntArrayRefSlow(size), dtype, layout, device, pin_memory, scale, zero_point, memory_format);
}
at::Tensor _empty_affine_quantized_symint(c10::SymIntArrayRef size, at::TensorOptions options, double scale, int64_t zero_point, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___empty_affine_quantized(size, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt(), scale, zero_point, c10::impl::check_tensor_options_and_extract_memory_format(options, memory_format));
}
at::Tensor _empty_affine_quantized_symint(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, double scale, int64_t zero_point, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___empty_affine_quantized(size, dtype, layout, device, pin_memory, scale, zero_point, memory_format);
}
at::Tensor _empty_per_channel_affine_quantized(at::IntArrayRef size, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, at::TensorOptions options, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___empty_per_channel_affine_quantized(c10::fromIntArrayRefSlow(size), scales, zero_points, axis, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt(), c10::impl::check_tensor_options_and_extract_memory_format(options, memory_format));
}
at::Tensor _empty_per_channel_affine_quantized(at::IntArrayRef size, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___empty_per_channel_affine_quantized(c10::fromIntArrayRefSlow(size), scales, zero_points, axis, dtype, layout, device, pin_memory, memory_format);
}
at::Tensor _empty_per_channel_affine_quantized_symint(c10::SymIntArrayRef size, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, at::TensorOptions options, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___empty_per_channel_affine_quantized(size, scales, zero_points, axis, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt(), c10::impl::check_tensor_options_and_extract_memory_format(options, memory_format));
}
at::Tensor _empty_per_channel_affine_quantized_symint(c10::SymIntArrayRef size, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU___empty_per_channel_affine_quantized(size, scales, zero_points, axis, dtype, layout, device, pin_memory, memory_format);
}
const at::Tensor & resize_(const at::Tensor & self, at::IntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU__resize_(self, c10::fromIntArrayRefSlow(size), memory_format);
}
const at::Tensor & resize__symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
return wrapper_CPU__resize_(self, size, memory_format);
}
at::Tensor empty_strided(at::IntArrayRef size, at::IntArrayRef stride, at::TensorOptions options) {
return wrapper_CPU__empty_strided(c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride), c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor empty_strided(at::IntArrayRef size, at::IntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CPU__empty_strided(c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride), dtype, layout, device, pin_memory);
}
at::Tensor empty_strided_symint(c10::SymIntArrayRef size, c10::SymIntArrayRef stride, at::TensorOptions options) {
return wrapper_CPU__empty_strided(size, stride, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor empty_strided_symint(c10::SymIntArrayRef size, c10::SymIntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CPU__empty_strided(size, stride, dtype, layout, device, pin_memory);
}
at::Tensor erf(const at::Tensor & self) {
return wrapper_CPU_erf(self);
}
at::Tensor & erf_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_erf_out_out(self, out);
}
at::Tensor & erf_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_erf_out_out(self, out);
}
at::Tensor & erf_(at::Tensor & self) {
return wrapper_CPU_erf_(self);
}
at::Tensor erfc(const at::Tensor & self) {
return wrapper_CPU_erfc(self);
}
at::Tensor & erfc_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_erfc_out_out(self, out);
}
at::Tensor & erfc_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_erfc_out_out(self, out);
}
at::Tensor & erfc_(at::Tensor & self) {
return wrapper_CPU_erfc_(self);
}
at::Tensor exp(const at::Tensor & self) {
return wrapper_CPU_exp(self);
}
at::Tensor & exp_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_exp_out_out(self, out);
}
at::Tensor & exp_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_exp_out_out(self, out);
}
at::Tensor & exp_(at::Tensor & self) {
return wrapper_CPU_exp_(self);
}
at::Tensor exp2(const at::Tensor & self) {
return wrapper_CPU_exp2(self);
}
at::Tensor & exp2_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_exp2_out_out(self, out);
}
at::Tensor & exp2_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_exp2_out_out(self, out);
}
at::Tensor & exp2_(at::Tensor & self) {
return wrapper_CPU_exp2_(self);
}
at::Tensor expm1(const at::Tensor & self) {
return wrapper_CPU_expm1(self);
}
at::Tensor & expm1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_expm1_out_out(self, out);
}
at::Tensor & expm1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_expm1_out_out(self, out);
}
at::Tensor & expm1_(at::Tensor & self) {
return wrapper_CPU_expm1_(self);
}
at::Tensor & eye_out(at::Tensor & out, int64_t n) {
return wrapper_CPU_out_eye_out(n, out);
}
at::Tensor & eye_outf(int64_t n, at::Tensor & out) {
return wrapper_CPU_out_eye_out(n, out);
}
at::Tensor & eye_symint_out(at::Tensor & out, c10::SymInt n) {
return wrapper_CPU_out_eye_out(n, out);
}
at::Tensor & eye_symint_outf(c10::SymInt n, at::Tensor & out) {
return wrapper_CPU_out_eye_out(n, out);
}
at::Tensor & eye_out(at::Tensor & out, int64_t n, int64_t m) {
return wrapper_CPU_m_out_eye_out(n, m, out);
}
at::Tensor & eye_outf(int64_t n, int64_t m, at::Tensor & out) {
return wrapper_CPU_m_out_eye_out(n, m, out);
}
at::Tensor & eye_symint_out(at::Tensor & out, c10::SymInt n, c10::SymInt m) {
return wrapper_CPU_m_out_eye_out(n, m, out);
}
at::Tensor & eye_symint_outf(c10::SymInt n, c10::SymInt m, at::Tensor & out) {
return wrapper_CPU_m_out_eye_out(n, m, out);
}
at::Tensor & fill_(at::Tensor & self, const at::Scalar & value) {
return wrapper_CPU_Scalar_fill_(self, value);
}
at::Tensor & fill_(at::Tensor & self, const at::Tensor & value) {
return wrapper_CPU_Tensor_fill_(self, value);
}
at::Tensor floor(const at::Tensor & self) {
return wrapper_CPU_floor(self);
}
at::Tensor & floor_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_floor_out_out(self, out);
}
at::Tensor & floor_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_floor_out_out(self, out);
}
at::Tensor & floor_(at::Tensor & self) {
return wrapper_CPU_floor_(self);
}
at::Tensor floor_divide(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU__floor_divide(self, other);
}
at::Tensor & floor_divide_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_out_floor_divide_out(self, other, out);
}
at::Tensor & floor_divide_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_out_floor_divide_out(self, other, out);
}
at::Tensor & floor_divide_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_Tensor_floor_divide_(self, other);
}
at::Tensor frac(const at::Tensor & self) {
return wrapper_CPU_frac(self);
}
at::Tensor & frac_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_frac_out_out(self, out);
}
at::Tensor & frac_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_frac_out_out(self, out);
}
at::Tensor & frac_(at::Tensor & self) {
return wrapper_CPU_frac_(self);
}
at::Tensor from_file(c10::string_view filename, c10::optional<bool> shared, c10::optional<int64_t> size, at::TensorOptions options) {
return wrapper_CPU__from_file(filename, shared, size, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor from_file(c10::string_view filename, c10::optional<bool> shared, c10::optional<int64_t> size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CPU__from_file(filename, shared, size, dtype, layout, device, pin_memory);
}
at::Tensor gcd(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_gcd(self, other);
}
at::Tensor & gcd_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_gcd_out_out(self, other, out);
}
at::Tensor & gcd_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_gcd_out_out(self, other, out);
}
at::Tensor & gcd_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_gcd_(self, other);
}
at::Tensor lcm(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_lcm(self, other);
}
at::Tensor & lcm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_lcm_out_out(self, other, out);
}
at::Tensor & lcm_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_lcm_out_out(self, other, out);
}
at::Tensor & lcm_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_lcm_(self, other);
}
at::Tensor grid_sampler_2d(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
return wrapper_CPU__grid_sampler_2d(input, grid, interpolation_mode, padding_mode, align_corners);
}
::std::tuple<at::Tensor,at::Tensor> grid_sampler_2d_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
return wrapper_CPU__grid_sampler_2d_backward(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}
at::Tensor grid_sampler_3d(const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners) {
return wrapper_CPU__grid_sampler_3d(input, grid, interpolation_mode, padding_mode, align_corners);
}
::std::tuple<at::Tensor,at::Tensor> grid_sampler_3d_backward(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & grid, int64_t interpolation_mode, int64_t padding_mode, bool align_corners, ::std::array<bool,2> output_mask) {
return wrapper_CPU__grid_sampler_3d_backward(grad_output, input, grid, interpolation_mode, padding_mode, align_corners, output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_group_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, int64_t N, int64_t C, int64_t HxW, int64_t group, double eps) {
return wrapper_CPU__native_group_norm(input, weight, bias, N, C, HxW, group, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_group_norm_symint(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, double eps) {
return wrapper_CPU__native_group_norm(input, weight, bias, N, C, HxW, group, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_group_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, int64_t N, int64_t C, int64_t HxW, int64_t group, ::std::array<bool,3> output_mask) {
return wrapper_CPU__native_group_norm_backward(grad_out, input, mean, rstd, weight, N, C, HxW, group, output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_group_norm_backward_symint(const at::Tensor & grad_out, const at::Tensor & input, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, c10::SymInt N, c10::SymInt C, c10::SymInt HxW, int64_t group, ::std::array<bool,3> output_mask) {
return wrapper_CPU__native_group_norm_backward(grad_out, input, mean, rstd, weight, N, C, HxW, group, output_mask);
}
at::Tensor _fft_r2c(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided) {
return wrapper_CPU___fft_r2c(self, dim, normalization, onesided);
}
at::Tensor & _fft_r2c_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided) {
return wrapper_CPU_out__fft_r2c_out(self, dim, normalization, onesided, out);
}
at::Tensor & _fft_r2c_outf(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool onesided, at::Tensor & out) {
return wrapper_CPU_out__fft_r2c_out(self, dim, normalization, onesided, out);
}
at::Tensor _fft_c2r(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, int64_t last_dim_size) {
return wrapper_CPU___fft_c2r(self, dim, normalization, last_dim_size);
}
at::Tensor _fft_c2r_symint(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size) {
return wrapper_CPU___fft_c2r(self, dim, normalization, last_dim_size);
}
at::Tensor & _fft_c2r_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, int64_t last_dim_size) {
return wrapper_CPU_out__fft_c2r_out(self, dim, normalization, last_dim_size, out);
}
at::Tensor & _fft_c2r_outf(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, int64_t last_dim_size, at::Tensor & out) {
return wrapper_CPU_out__fft_c2r_out(self, dim, normalization, last_dim_size, out);
}
at::Tensor & _fft_c2r_symint_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size) {
return wrapper_CPU_out__fft_c2r_out(self, dim, normalization, last_dim_size, out);
}
at::Tensor & _fft_c2r_symint_outf(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, c10::SymInt last_dim_size, at::Tensor & out) {
return wrapper_CPU_out__fft_c2r_out(self, dim, normalization, last_dim_size, out);
}
at::Tensor _fft_c2c(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool forward) {
return wrapper_CPU___fft_c2c(self, c10::fromIntArrayRefSlow(dim), normalization, forward);
}
at::Tensor _fft_c2c_symint(const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward) {
return wrapper_CPU___fft_c2c(self, dim, normalization, forward);
}
at::Tensor & _fft_c2c_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool forward) {
return wrapper_CPU_out__fft_c2c_out(self, c10::fromIntArrayRefSlow(dim), normalization, forward, out);
}
at::Tensor & _fft_c2c_outf(const at::Tensor & self, at::IntArrayRef dim, int64_t normalization, bool forward, at::Tensor & out) {
return wrapper_CPU_out__fft_c2c_out(self, c10::fromIntArrayRefSlow(dim), normalization, forward, out);
}
at::Tensor & _fft_c2c_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward) {
return wrapper_CPU_out__fft_c2c_out(self, dim, normalization, forward, out);
}
at::Tensor & _fft_c2c_symint_outf(const at::Tensor & self, c10::SymIntArrayRef dim, int64_t normalization, bool forward, at::Tensor & out) {
return wrapper_CPU_out__fft_c2c_out(self, dim, normalization, forward, out);
}
void _validate_compressed_sparse_indices(bool is_crow, const at::Tensor & compressed_idx, const at::Tensor & plain_idx, int64_t cdim, int64_t dim, int64_t nnz) {
return wrapper_CPU___validate_compressed_sparse_indices(is_crow, compressed_idx, plain_idx, cdim, dim, nnz);
}
at::Tensor index(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices) {
return wrapper_CPU_index_Tensor(self, indices);
}
at::Tensor & index_out(at::Tensor & out, const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices) {
return wrapper_CPU_index_out_Tensor_out(self, indices, out);
}
at::Tensor & index_outf(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, at::Tensor & out) {
return wrapper_CPU_index_out_Tensor_out(self, indices, out);
}
at::Tensor index_copy(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
return wrapper_CPU_index_copy(self, dim, index, source);
}
at::Tensor & index_copy_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
return wrapper_CPU_index_copy_out_out(self, dim, index, source, out);
}
at::Tensor & index_copy_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, at::Tensor & out) {
return wrapper_CPU_index_copy_out_out(self, dim, index, source, out);
}
at::Tensor & index_copy_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
return wrapper_CPU_index_copy_(self, dim, index, source);
}
at::Tensor & _index_put_impl_(at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
return wrapper_CPU___index_put_impl_(self, indices, values, accumulate, unsafe);
}
at::Tensor isin(const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert) {
return wrapper_CPU_isin_Tensor_Tensor(elements, test_elements, assume_unique, invert);
}
at::Tensor & isin_out(at::Tensor & out, const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert) {
return wrapper_CPU_isin_out_Tensor_Tensor_out(elements, test_elements, assume_unique, invert, out);
}
at::Tensor & isin_outf(const at::Tensor & elements, const at::Tensor & test_elements, bool assume_unique, bool invert, at::Tensor & out) {
return wrapper_CPU_isin_out_Tensor_Tensor_out(elements, test_elements, assume_unique, invert, out);
}
at::Tensor isin(const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert) {
return wrapper_CPU_isin_Tensor_Scalar(elements, test_element, assume_unique, invert);
}
at::Tensor & isin_out(at::Tensor & out, const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert) {
return wrapper_CPU_isin_out_Tensor_Scalar_out(elements, test_element, assume_unique, invert, out);
}
at::Tensor & isin_outf(const at::Tensor & elements, const at::Scalar & test_element, bool assume_unique, bool invert, at::Tensor & out) {
return wrapper_CPU_isin_out_Tensor_Scalar_out(elements, test_element, assume_unique, invert, out);
}
at::Tensor isin(const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert) {
return wrapper_CPU_isin_Scalar_Tensor(element, test_elements, assume_unique, invert);
}
at::Tensor & isin_out(at::Tensor & out, const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert) {
return wrapper_CPU_isin_out_Scalar_Tensor_out(element, test_elements, assume_unique, invert, out);
}
at::Tensor & isin_outf(const at::Scalar & element, const at::Tensor & test_elements, bool assume_unique, bool invert, at::Tensor & out) {
return wrapper_CPU_isin_out_Scalar_Tensor_out(element, test_elements, assume_unique, invert, out);
}
at::Tensor isnan(const at::Tensor & self) {
return wrapper_CPU__isnan(self);
}
::std::tuple<at::Tensor &,at::Tensor &> kthvalue_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, int64_t k, int64_t dim, bool keepdim) {
return wrapper_CPU_values_kthvalue_out(self, k, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> kthvalue_outf(const at::Tensor & self, int64_t k, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
return wrapper_CPU_values_kthvalue_out(self, k, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_layer_norm(const at::Tensor & input, at::IntArrayRef normalized_shape, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps) {
return wrapper_CPU__native_layer_norm(input, c10::fromIntArrayRefSlow(normalized_shape), weight, bias, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_layer_norm_symint(const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, double eps) {
return wrapper_CPU__native_layer_norm(input, normalized_shape, weight, bias, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_layer_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, at::IntArrayRef normalized_shape, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, ::std::array<bool,3> output_mask) {
return wrapper_CPU__native_layer_norm_backward(grad_out, input, c10::fromIntArrayRefSlow(normalized_shape), mean, rstd, weight, bias, output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_layer_norm_backward_symint(const at::Tensor & grad_out, const at::Tensor & input, c10::SymIntArrayRef normalized_shape, const at::Tensor & mean, const at::Tensor & rstd, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, ::std::array<bool,3> output_mask) {
return wrapper_CPU__native_layer_norm_backward(grad_out, input, normalized_shape, mean, rstd, weight, bias, output_mask);
}
at::Tensor & nan_to_num_out(at::Tensor & out, const at::Tensor & self, c10::optional<double> nan, c10::optional<double> posinf, c10::optional<double> neginf) {
return wrapper_CPU_out_nan_to_num_out(self, nan, posinf, neginf, out);
}
at::Tensor & nan_to_num_outf(const at::Tensor & self, c10::optional<double> nan, c10::optional<double> posinf, c10::optional<double> neginf, at::Tensor & out) {
return wrapper_CPU_out_nan_to_num_out(self, nan, posinf, neginf, out);
}
at::Tensor & linspace_out(at::Tensor & out, const at::Scalar & start, const at::Scalar & end, int64_t steps) {
return wrapper_CPU_out_linspace_out(start, end, steps, out);
}
at::Tensor & linspace_outf(const at::Scalar & start, const at::Scalar & end, int64_t steps, at::Tensor & out) {
return wrapper_CPU_out_linspace_out(start, end, steps, out);
}
at::Tensor log(const at::Tensor & self) {
return wrapper_CPU_log(self);
}
at::Tensor & log_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_log_out_out(self, out);
}
at::Tensor & log_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_log_out_out(self, out);
}
at::Tensor & log_(at::Tensor & self) {
return wrapper_CPU_log_(self);
}
at::Tensor log10(const at::Tensor & self) {
return wrapper_CPU_log10(self);
}
at::Tensor & log10_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_log10_out_out(self, out);
}
at::Tensor & log10_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_log10_out_out(self, out);
}
at::Tensor & log10_(at::Tensor & self) {
return wrapper_CPU_log10_(self);
}
at::Tensor log1p(const at::Tensor & self) {
return wrapper_CPU_log1p(self);
}
at::Tensor & log1p_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_log1p_out_out(self, out);
}
at::Tensor & log1p_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_log1p_out_out(self, out);
}
at::Tensor & log1p_(at::Tensor & self) {
return wrapper_CPU_log1p_(self);
}
at::Tensor log2(const at::Tensor & self) {
return wrapper_CPU_log2(self);
}
at::Tensor & log2_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_log2_out_out(self, out);
}
at::Tensor & log2_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_log2_out_out(self, out);
}
at::Tensor & log2_(at::Tensor & self) {
return wrapper_CPU_log2_(self);
}
at::Tensor logaddexp(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_logaddexp(self, other);
}
at::Tensor & logaddexp_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_logaddexp_out_out(self, other, out);
}
at::Tensor & logaddexp_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_logaddexp_out_out(self, other, out);
}
at::Tensor logaddexp2(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_logaddexp2(self, other);
}
at::Tensor & logaddexp2_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_logaddexp2_out_out(self, other, out);
}
at::Tensor & logaddexp2_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_logaddexp2_out_out(self, other, out);
}
at::Tensor xlogy(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_xlogy_Tensor(self, other);
}
at::Tensor & xlogy_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_xlogy_out_OutTensor(self, other, out);
}
at::Tensor & xlogy_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_xlogy_out_OutTensor(self, other, out);
}
at::Tensor & xlogy_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_xlogy__Tensor(self, other);
}
at::Tensor & logspace_out(at::Tensor & out, const at::Scalar & start, const at::Scalar & end, int64_t steps, double base) {
return wrapper_CPU_out_logspace_out(start, end, steps, base, out);
}
at::Tensor & logspace_outf(const at::Scalar & start, const at::Scalar & end, int64_t steps, double base, at::Tensor & out) {
return wrapper_CPU_out_logspace_out(start, end, steps, base, out);
}
at::Tensor _log_softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
return wrapper_CPU__log_softmax(self, dim, half_to_float);
}
at::Tensor & _log_softmax_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool half_to_float) {
return wrapper_CPU__log_softmax_out_out(self, dim, half_to_float, out);
}
at::Tensor & _log_softmax_outf(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
return wrapper_CPU__log_softmax_out_out(self, dim, half_to_float, out);
}
at::Tensor _log_softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
return wrapper_CPU__log_softmax_backward_data(grad_output, output, dim, input_dtype);
}
at::Tensor & _log_softmax_backward_data_out(at::Tensor & out, const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
return wrapper_CPU__log_softmax_backward_data_out_out(grad_output, output, dim, input_dtype, out);
}
at::Tensor & _log_softmax_backward_data_outf(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & out) {
return wrapper_CPU__log_softmax_backward_data_out_out(grad_output, output, dim, input_dtype, out);
}
at::Tensor _logcumsumexp(const at::Tensor & self, int64_t dim) {
return wrapper_CPU___logcumsumexp(self, dim);
}
at::Tensor & _logcumsumexp_out(at::Tensor & out, const at::Tensor & self, int64_t dim) {
return wrapper_CPU_out__logcumsumexp_out(self, dim, out);
}
at::Tensor & _logcumsumexp_outf(const at::Tensor & self, int64_t dim, at::Tensor & out) {
return wrapper_CPU_out__logcumsumexp_out(self, dim, out);
}
::std::tuple<at::Tensor,at::Tensor> _aminmax(const at::Tensor & self) {
return wrapper_CPU___aminmax(self);
}
::std::tuple<at::Tensor,at::Tensor> _aminmax(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_dim__aminmax(self, dim, keepdim);
}
::std::tuple<at::Tensor,at::Tensor> aminmax(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CPU_aminmax(self, dim, keepdim);
}
::std::tuple<at::Tensor &,at::Tensor &> aminmax_out(at::Tensor & min, at::Tensor & max, const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
return wrapper_CPU_aminmax_out_out(self, dim, keepdim, min, max);
}
::std::tuple<at::Tensor &,at::Tensor &> aminmax_outf(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & min, at::Tensor & max) {
return wrapper_CPU_aminmax_out_out(self, dim, keepdim, min, max);
}
at::Tensor _compute_linear_combination(const at::Tensor & input, const at::Tensor & coefficients) {
return wrapper_CPU___compute_linear_combination(input, coefficients);
}
at::Tensor & _compute_linear_combination_out(at::Tensor & out, const at::Tensor & input, const at::Tensor & coefficients) {
return wrapper_CPU_out__compute_linear_combination_out(input, coefficients, out);
}
at::Tensor & _compute_linear_combination_outf(const at::Tensor & input, const at::Tensor & coefficients, at::Tensor & out) {
return wrapper_CPU_out__compute_linear_combination_out(input, coefficients, out);
}
::std::tuple<at::Tensor,at::Tensor> max(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_max_dim(self, dim, keepdim);
}
::std::tuple<at::Tensor &,at::Tensor &> max_out(at::Tensor & max, at::Tensor & max_values, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_max_out_dim_max(self, dim, keepdim, max, max_values);
}
::std::tuple<at::Tensor &,at::Tensor &> max_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
return wrapper_CPU_max_out_dim_max(self, dim, keepdim, max, max_values);
}
at::Tensor amax(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
return wrapper_CPU_amax(self, dim, keepdim);
}
at::Tensor & amax_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
return wrapper_CPU_amax_out_out(self, dim, keepdim, out);
}
at::Tensor & amax_outf(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CPU_amax_out_out(self, dim, keepdim, out);
}
at::Tensor mean(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_mean_dim(self, dim, keepdim, dtype);
}
at::Tensor & mean_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_mean_out_out(self, dim, keepdim, dtype, out);
}
at::Tensor & mean_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CPU_mean_out_out(self, dim, keepdim, dtype, out);
}
at::Tensor median(const at::Tensor & self) {
return wrapper_CPU__median(self);
}
::std::tuple<at::Tensor &,at::Tensor &> median_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_dim_values_median_out(self, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> median_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
return wrapper_CPU_dim_values_median_out(self, dim, keepdim, values, indices);
}
at::Tensor nanmedian(const at::Tensor & self) {
return wrapper_CPU__nanmedian(self);
}
::std::tuple<at::Tensor &,at::Tensor &> nanmedian_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_dim_values_nanmedian_out(self, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> nanmedian_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
return wrapper_CPU_dim_values_nanmedian_out(self, dim, keepdim, values, indices);
}
::std::tuple<at::Tensor,at::Tensor> min(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_min_dim(self, dim, keepdim);
}
::std::tuple<at::Tensor &,at::Tensor &> min_out(at::Tensor & min, at::Tensor & min_indices, const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU_min_out_dim_min(self, dim, keepdim, min, min_indices);
}
::std::tuple<at::Tensor &,at::Tensor &> min_outf(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & min, at::Tensor & min_indices) {
return wrapper_CPU_min_out_dim_min(self, dim, keepdim, min, min_indices);
}
at::Tensor amin(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
return wrapper_CPU_amin(self, dim, keepdim);
}
at::Tensor & amin_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
return wrapper_CPU_amin_out_out(self, dim, keepdim, out);
}
at::Tensor & amin_outf(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CPU_amin_out_out(self, dim, keepdim, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> mkldnn_rnn_layer(const at::Tensor & input, const at::Tensor & weight0, const at::Tensor & weight1, const at::Tensor & weight2, const at::Tensor & weight3, const at::Tensor & hx_, const at::Tensor & cx_, bool reverse, at::IntArrayRef batch_sizes, int64_t mode, int64_t hidden_size, int64_t num_layers, bool has_biases, bool bidirectional, bool batch_first, bool train) {
return wrapper_CPU__mkldnn_rnn_layer(input, weight0, weight1, weight2, weight3, hx_, cx_, reverse, batch_sizes, mode, hidden_size, num_layers, has_biases, bidirectional, batch_first, train);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor> mkldnn_rnn_layer_backward(const at::Tensor & input, const at::Tensor & weight1, const at::Tensor & weight2, const at::Tensor & weight3, const at::Tensor & weight4, const at::Tensor & hx_, const at::Tensor & cx_tmp, const at::Tensor & output, const at::Tensor & hy_, const at::Tensor & cy_, const c10::optional<at::Tensor> & grad_output, const c10::optional<at::Tensor> & grad_hy, const c10::optional<at::Tensor> & grad_cy, bool reverse, int64_t mode, int64_t hidden_size, int64_t num_layers, bool has_biases, bool train, bool bidirectional, at::IntArrayRef batch_sizes, bool batch_first, const at::Tensor & workspace) {
return wrapper_CPU__mkldnn_rnn_layer_backward(input, weight1, weight2, weight3, weight4, hx_, cx_tmp, output, hy_, cy_, grad_output, grad_hy, grad_cy, reverse, mode, hidden_size, num_layers, has_biases, train, bidirectional, batch_sizes, batch_first, workspace);
}
at::Tensor mm(const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CPU_mm(self, mat2);
}
at::Tensor & mm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat2) {
return wrapper_CPU_mm_out_out(self, mat2, out);
}
at::Tensor & mm_outf(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
return wrapper_CPU_mm_out_out(self, mat2, out);
}
::std::tuple<at::Tensor,at::Tensor> mode(const at::Tensor & self, int64_t dim, bool keepdim) {
return wrapper_CPU__mode(self, dim, keepdim);
}
at::Tensor mul(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_mul_Tensor(self, other);
}
at::Tensor & mul_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_mul_out_out(self, other, out);
}
at::Tensor & mul_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_mul_out_out(self, other, out);
}
at::Tensor & mul_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_mul__Tensor(self, other);
}
at::Tensor & mvlgamma_out(at::Tensor & out, const at::Tensor & self, int64_t p) {
return wrapper_CPU_out_mvlgamma_out(self, p, out);
}
at::Tensor & mvlgamma_outf(const at::Tensor & self, int64_t p, at::Tensor & out) {
return wrapper_CPU_out_mvlgamma_out(self, p, out);
}
at::Tensor narrow_copy(const at::Tensor & self, int64_t dim, int64_t start, int64_t length) {
return wrapper_CPU__narrow_copy(self, dim, start, length);
}
at::Tensor narrow_copy_symint(const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length) {
return wrapper_CPU__narrow_copy(self, dim, start, length);
}
at::Tensor & narrow_copy_out(at::Tensor & out, const at::Tensor & self, int64_t dim, int64_t start, int64_t length) {
return wrapper_CPU_out_narrow_copy_out(self, dim, start, length, out);
}
at::Tensor & narrow_copy_outf(const at::Tensor & self, int64_t dim, int64_t start, int64_t length, at::Tensor & out) {
return wrapper_CPU_out_narrow_copy_out(self, dim, start, length, out);
}
at::Tensor & narrow_copy_symint_out(at::Tensor & out, const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length) {
return wrapper_CPU_out_narrow_copy_out(self, dim, start, length, out);
}
at::Tensor & narrow_copy_symint_outf(const at::Tensor & self, int64_t dim, c10::SymInt start, c10::SymInt length, at::Tensor & out) {
return wrapper_CPU_out_narrow_copy_out(self, dim, start, length, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_batch_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps) {
return wrapper_CPU__native_batch_norm(input, weight, bias, running_mean, running_var, training, momentum, eps);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> native_batch_norm_out(at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps) {
return wrapper_CPU_out_native_batch_norm_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> native_batch_norm_outf(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
return wrapper_CPU_out_native_batch_norm_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _native_batch_norm_legit_out(at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps) {
return wrapper_CPU_out__native_batch_norm_legit_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _native_batch_norm_legit_outf(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
return wrapper_CPU_out__native_batch_norm_legit_out(input, weight, bias, running_mean, running_var, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _native_batch_norm_legit(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, at::Tensor & running_mean, at::Tensor & running_var, bool training, double momentum, double eps) {
return wrapper_CPU___native_batch_norm_legit(input, weight, bias, running_mean, running_var, training, momentum, eps);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _native_batch_norm_legit(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps) {
return wrapper_CPU_no_stats__native_batch_norm_legit(input, weight, bias, training, momentum, eps);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _native_batch_norm_legit_out(at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps) {
return wrapper_CPU_no_stats_out__native_batch_norm_legit_out(input, weight, bias, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _native_batch_norm_legit_outf(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
return wrapper_CPU_no_stats_out__native_batch_norm_legit_out(input, weight, bias, training, momentum, eps, out, save_mean, save_invstd);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> native_batch_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_invstd, bool train, double eps, ::std::array<bool,3> output_mask) {
return wrapper_CPU__native_batch_norm_backward(grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask);
}
::std::tuple<at::Tensor,at::Tensor> batch_norm_update_stats(const at::Tensor & input, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, double momentum) {
return wrapper_CPU__batch_norm_update_stats(input, running_mean, running_var, momentum);
}
at::Tensor _cdist_forward(const at::Tensor & x1, const at::Tensor & x2, double p, c10::optional<int64_t> compute_mode) {
return wrapper_CPU___cdist_forward(x1, x2, p, compute_mode);
}
at::Tensor _cdist_backward(const at::Tensor & grad, const at::Tensor & x1, const at::Tensor & x2, double p, const at::Tensor & cdist) {
return wrapper_CPU___cdist_backward(grad, x1, x2, p, cdist);
}
at::Tensor _pdist_forward(const at::Tensor & self, double p) {
return wrapper_CPU___pdist_forward(self, p);
}
at::Tensor _pdist_backward(const at::Tensor & grad, const at::Tensor & self, double p, const at::Tensor & pdist) {
return wrapper_CPU___pdist_backward(grad, self, p, pdist);
}
at::Tensor pixel_shuffle(const at::Tensor & self, int64_t upscale_factor) {
return wrapper_CPU__pixel_shuffle(self, upscale_factor);
}
at::Tensor pixel_unshuffle(const at::Tensor & self, int64_t downscale_factor) {
return wrapper_CPU__pixel_unshuffle(self, downscale_factor);
}
at::Tensor channel_shuffle(const at::Tensor & self, int64_t groups) {
return wrapper_CPU__channel_shuffle(self, groups);
}
at::Tensor channel_shuffle_symint(const at::Tensor & self, c10::SymInt groups) {
return wrapper_CPU__channel_shuffle(self, groups);
}
at::Tensor native_channel_shuffle(const at::Tensor & self, int64_t groups) {
return wrapper_CPU__native_channel_shuffle(self, groups);
}
at::Tensor native_channel_shuffle_symint(const at::Tensor & self, c10::SymInt groups) {
return wrapper_CPU__native_channel_shuffle(self, groups);
}
at::Tensor & randperm_out(at::Tensor & out, int64_t n, c10::optional<at::Generator> generator) {
return wrapper_CPU_generator_out_randperm_out(n, generator, out);
}
at::Tensor & randperm_outf(int64_t n, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CPU_generator_out_randperm_out(n, generator, out);
}
at::Tensor & randperm_symint_out(at::Tensor & out, c10::SymInt n, c10::optional<at::Generator> generator) {
return wrapper_CPU_generator_out_randperm_out(n, generator, out);
}
at::Tensor & randperm_symint_outf(c10::SymInt n, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CPU_generator_out_randperm_out(n, generator, out);
}
at::Tensor & range_out(at::Tensor & out, const at::Scalar & start, const at::Scalar & end, const at::Scalar & step) {
return wrapper_CPU_out_range_out(start, end, step, out);
}
at::Tensor & range_outf(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
return wrapper_CPU_out_range_out(start, end, step, out);
}
at::Tensor reciprocal(const at::Tensor & self) {
return wrapper_CPU_reciprocal(self);
}
at::Tensor & reciprocal_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_reciprocal_out_out(self, out);
}
at::Tensor & reciprocal_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_reciprocal_out_out(self, out);
}
at::Tensor & reciprocal_(at::Tensor & self) {
return wrapper_CPU_reciprocal_(self);
}
at::Tensor neg(const at::Tensor & self) {
return wrapper_CPU_neg(self);
}
at::Tensor & neg_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_neg_out_out(self, out);
}
at::Tensor & neg_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_neg_out_out(self, out);
}
at::Tensor & neg_(at::Tensor & self) {
return wrapper_CPU_neg_(self);
}
at::Tensor repeat_interleave(const at::Tensor & repeats, c10::optional<int64_t> output_size) {
return wrapper_CPU_Tensor_repeat_interleave(repeats, output_size.has_value() ? c10::make_optional(c10::SymInt(*output_size)) : c10::nullopt);
}
at::Tensor repeat_interleave_symint(const at::Tensor & repeats, c10::optional<c10::SymInt> output_size) {
return wrapper_CPU_Tensor_repeat_interleave(repeats, output_size);
}
at::Tensor _reshape_alias(const at::Tensor & self, at::IntArrayRef size, at::IntArrayRef stride) {
return wrapper_CPU___reshape_alias(self, c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride));
}
at::Tensor _reshape_alias_symint(const at::Tensor & self, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
return wrapper_CPU___reshape_alias(self, size, stride);
}
at::Tensor round(const at::Tensor & self) {
return wrapper_CPU_round(self);
}
at::Tensor & round_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_round_out_out(self, out);
}
at::Tensor & round_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_round_out_out(self, out);
}
at::Tensor & round_(at::Tensor & self) {
return wrapper_CPU_round_(self);
}
at::Tensor round(const at::Tensor & self, int64_t decimals) {
return wrapper_CPU_round_decimals(self, decimals);
}
at::Tensor & round_out(at::Tensor & out, const at::Tensor & self, int64_t decimals) {
return wrapper_CPU_round_out_decimals_out(self, decimals, out);
}
at::Tensor & round_outf(const at::Tensor & self, int64_t decimals, at::Tensor & out) {
return wrapper_CPU_round_out_decimals_out(self, decimals, out);
}
at::Tensor & round_(at::Tensor & self, int64_t decimals) {
return wrapper_CPU_round__decimals(self, decimals);
}
at::Tensor relu(const at::Tensor & self) {
return wrapper_CPU__relu(self);
}
at::Tensor & relu_(at::Tensor & self) {
return wrapper_CPU__relu_(self);
}
at::Tensor _prelu_kernel(const at::Tensor & self, const at::Tensor & weight) {
return wrapper_CPU___prelu_kernel(self, weight);
}
::std::tuple<at::Tensor,at::Tensor> _prelu_kernel_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight) {
return wrapper_CPU___prelu_kernel_backward(grad_output, self, weight);
}
at::Tensor gelu(const at::Tensor & self, c10::string_view approximate) {
return wrapper_CPU_gelu(self, approximate);
}
at::Tensor & gelu_out(at::Tensor & out, const at::Tensor & self, c10::string_view approximate) {
return wrapper_CPU_gelu_out_out(self, approximate, out);
}
at::Tensor & gelu_outf(const at::Tensor & self, c10::string_view approximate, at::Tensor & out) {
return wrapper_CPU_gelu_out_out(self, approximate, out);
}
at::Tensor & gelu_(at::Tensor & self, c10::string_view approximate) {
return wrapper_CPU_gelu_(self, approximate);
}
at::Tensor gelu_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
return wrapper_CPU_gelu_backward(grad_output, self, approximate);
}
at::Tensor & gelu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
return wrapper_CPU_gelu_backward_out_grad_input(grad_output, self, approximate, grad_input);
}
at::Tensor & gelu_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate, at::Tensor & grad_input) {
return wrapper_CPU_gelu_backward_out_grad_input(grad_output, self, approximate, grad_input);
}
at::Tensor hardshrink(const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CPU_hardshrink(self, lambd);
}
at::Tensor & hardshrink_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CPU_hardshrink_out_out(self, lambd, out);
}
at::Tensor & hardshrink_outf(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
return wrapper_CPU_hardshrink_out_out(self, lambd, out);
}
at::Tensor hardshrink_backward(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CPU_hardshrink_backward(grad_out, self, lambd);
}
at::Tensor & hardshrink_backward_out(at::Tensor & grad_input, const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CPU_hardshrink_backward_out_grad_input(grad_out, self, lambd, grad_input);
}
at::Tensor & hardshrink_backward_outf(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
return wrapper_CPU_hardshrink_backward_out_grad_input(grad_out, self, lambd, grad_input);
}
at::Tensor rsqrt(const at::Tensor & self) {
return wrapper_CPU_rsqrt(self);
}
at::Tensor & rsqrt_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_rsqrt_out_out(self, out);
}
at::Tensor & rsqrt_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_rsqrt_out_out(self, out);
}
at::Tensor & rsqrt_(at::Tensor & self) {
return wrapper_CPU_rsqrt_(self);
}
at::Tensor silu(const at::Tensor & self) {
return wrapper_CPU_silu(self);
}
at::Tensor & silu_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_silu_out_out(self, out);
}
at::Tensor & silu_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_silu_out_out(self, out);
}
at::Tensor & silu_(at::Tensor & self) {
return wrapper_CPU_silu_(self);
}
at::Tensor silu_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CPU_silu_backward(grad_output, self);
}
at::Tensor & silu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CPU_silu_backward_out_grad_input(grad_output, self, grad_input);
}
at::Tensor & silu_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
return wrapper_CPU_silu_backward_out_grad_input(grad_output, self, grad_input);
}
at::Tensor mish(const at::Tensor & self) {
return wrapper_CPU_mish(self);
}
at::Tensor & mish_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_mish_out_out(self, out);
}
at::Tensor & mish_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_mish_out_out(self, out);
}
at::Tensor & mish_(at::Tensor & self) {
return wrapper_CPU_mish_(self);
}
at::Tensor mish_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CPU__mish_backward(grad_output, self);
}
at::Tensor sigmoid(const at::Tensor & self) {
return wrapper_CPU_sigmoid(self);
}
at::Tensor & sigmoid_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_sigmoid_out_out(self, out);
}
at::Tensor & sigmoid_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_sigmoid_out_out(self, out);
}
at::Tensor & sigmoid_(at::Tensor & self) {
return wrapper_CPU_sigmoid_(self);
}
at::Tensor logit(const at::Tensor & self, c10::optional<double> eps) {
return wrapper_CPU__logit(self, eps);
}
at::Tensor & logit_out(at::Tensor & out, const at::Tensor & self, c10::optional<double> eps) {
return wrapper_CPU_out_logit_out(self, eps, out);
}
at::Tensor & logit_outf(const at::Tensor & self, c10::optional<double> eps, at::Tensor & out) {
return wrapper_CPU_out_logit_out(self, eps, out);
}
at::Tensor & logit_(at::Tensor & self, c10::optional<double> eps) {
return wrapper_CPU__logit_(self, eps);
}
at::Tensor sin(const at::Tensor & self) {
return wrapper_CPU_sin(self);
}
at::Tensor & sin_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_sin_out_out(self, out);
}
at::Tensor & sin_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_sin_out_out(self, out);
}
at::Tensor & sin_(at::Tensor & self) {
return wrapper_CPU_sin_(self);
}
at::Tensor sinc(const at::Tensor & self) {
return wrapper_CPU_sinc(self);
}
at::Tensor & sinc_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_sinc_out_out(self, out);
}
at::Tensor & sinc_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_sinc_out_out(self, out);
}
at::Tensor & sinc_(at::Tensor & self) {
return wrapper_CPU_sinc_(self);
}
at::Tensor sinh(const at::Tensor & self) {
return wrapper_CPU_sinh(self);
}
at::Tensor & sinh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_sinh_out_out(self, out);
}
at::Tensor & sinh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_sinh_out_out(self, out);
}
at::Tensor & sinh_(at::Tensor & self) {
return wrapper_CPU_sinh_(self);
}
at::Tensor _softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
return wrapper_CPU__softmax(self, dim, half_to_float);
}
at::Tensor & _softmax_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool half_to_float) {
return wrapper_CPU__softmax_out_out(self, dim, half_to_float, out);
}
at::Tensor & _softmax_outf(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
return wrapper_CPU__softmax_out_out(self, dim, half_to_float, out);
}
at::Tensor _softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
return wrapper_CPU__softmax_backward_data(grad_output, output, dim, input_dtype);
}
at::Tensor & _softmax_backward_data_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
return wrapper_CPU__softmax_backward_data_out_out(grad_output, output, dim, input_dtype, grad_input);
}
at::Tensor & _softmax_backward_data_outf(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & grad_input) {
return wrapper_CPU__softmax_backward_data_out_out(grad_output, output, dim, input_dtype, grad_input);
}
at::Tensor & sspaddmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_out_sspaddmm_out(self, mat1, mat2, beta, alpha, out);
}
at::Tensor & sspaddmm_outf(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_out_sspaddmm_out(self, mat1, mat2, beta, alpha, out);
}
at::Tensor _stack(at::TensorList tensors, int64_t dim) {
return wrapper_CPU___stack(tensors, dim);
}
at::Tensor & _stack_out(at::Tensor & out, at::TensorList tensors, int64_t dim) {
return wrapper_CPU_out__stack_out(tensors, dim, out);
}
at::Tensor & _stack_outf(at::TensorList tensors, int64_t dim, at::Tensor & out) {
return wrapper_CPU_out__stack_out(tensors, dim, out);
}
at::Tensor sum(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_sum_dim_IntList(self, dim, keepdim, dtype);
}
at::Tensor & sum_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_sum_out_IntList_out(self, dim, keepdim, dtype, out);
}
at::Tensor & sum_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CPU_sum_out_IntList_out(self, dim, keepdim, dtype, out);
}
at::Tensor nansum(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU__nansum(self, dim, keepdim, dtype);
}
at::Tensor & nansum_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_out_nansum_out(self, dim, keepdim, dtype, out);
}
at::Tensor & nansum_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CPU_out_nansum_out(self, dim, keepdim, dtype, out);
}
at::Tensor sqrt(const at::Tensor & self) {
return wrapper_CPU_sqrt(self);
}
at::Tensor & sqrt_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_sqrt_out_out(self, out);
}
at::Tensor & sqrt_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_sqrt_out_out(self, out);
}
at::Tensor & sqrt_(at::Tensor & self) {
return wrapper_CPU_sqrt_(self);
}
at::Tensor std(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CPU_correction_std(self, dim, correction, keepdim);
}
at::Tensor & std_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CPU_correction_out_std_out(self, dim, correction, keepdim, out);
}
at::Tensor & std_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out) {
return wrapper_CPU_correction_out_std_out(self, dim, correction, keepdim, out);
}
::std::tuple<at::Tensor,at::Tensor> std_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CPU_correction_std_mean(self, dim, correction, keepdim);
}
at::Tensor prod(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU__prod(self, dtype);
}
at::Tensor prod(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_prod_dim_int(self, dim, keepdim, dtype);
}
at::Tensor & prod_out(at::Tensor & out, const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_prod_out_int_out(self, dim, keepdim, dtype, out);
}
at::Tensor & prod_outf(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CPU_prod_out_int_out(self, dim, keepdim, dtype, out);
}
at::Tensor tan(const at::Tensor & self) {
return wrapper_CPU_tan(self);
}
at::Tensor & tan_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_tan_out_out(self, out);
}
at::Tensor & tan_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_tan_out_out(self, out);
}
at::Tensor & tan_(at::Tensor & self) {
return wrapper_CPU_tan_(self);
}
at::Tensor tanh(const at::Tensor & self) {
return wrapper_CPU_tanh(self);
}
at::Tensor & tanh_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_tanh_out_out(self, out);
}
at::Tensor & tanh_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_tanh_out_out(self, out);
}
at::Tensor & tanh_(at::Tensor & self) {
return wrapper_CPU_tanh_(self);
}
at::Tensor threshold(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
return wrapper_CPU_threshold(self, threshold, value);
}
at::Tensor & threshold_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
return wrapper_CPU_threshold_out_out(self, threshold, value, out);
}
at::Tensor & threshold_outf(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value, at::Tensor & out) {
return wrapper_CPU_threshold_out_out(self, threshold, value, out);
}
at::Tensor & threshold_(at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
return wrapper_CPU_threshold_(self, threshold, value);
}
at::Tensor threshold_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
return wrapper_CPU_threshold_backward(grad_output, self, threshold);
}
at::Tensor & threshold_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
return wrapper_CPU_threshold_backward_out_grad_input(grad_output, self, threshold, grad_input);
}
at::Tensor & threshold_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold, at::Tensor & grad_input) {
return wrapper_CPU_threshold_backward_out_grad_input(grad_output, self, threshold, grad_input);
}
at::Tensor flip(const at::Tensor & self, at::IntArrayRef dims) {
return wrapper_CPU__flip(self, dims);
}
at::Tensor roll(const at::Tensor & self, at::IntArrayRef shifts, at::IntArrayRef dims) {
return wrapper_CPU__roll(self, c10::fromIntArrayRefSlow(shifts), dims);
}
at::Tensor roll_symint(const at::Tensor & self, c10::SymIntArrayRef shifts, at::IntArrayRef dims) {
return wrapper_CPU__roll(self, shifts, dims);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _transform_bias_rescale_qkv(const at::Tensor & qkv, const at::Tensor & qkv_bias, int64_t num_heads) {
return wrapper_CPU___transform_bias_rescale_qkv(qkv, qkv_bias, num_heads);
}
at::Tensor _nested_tensor_from_mask(const at::Tensor & t, const at::Tensor & mask, bool mask_check) {
return wrapper_CPU___nested_tensor_from_mask(t, mask, mask_check);
}
bool _nested_tensor_from_mask_left_aligned(const at::Tensor & t, const at::Tensor & mask) {
return wrapper_CPU___nested_tensor_from_mask_left_aligned(t, mask);
}
at::Tensor _nested_from_padded(const at::Tensor & padded, const at::Tensor & cpu_nested_shape_example, bool fuse_transform_0213) {
return wrapper_CPU___nested_from_padded(padded, cpu_nested_shape_example, fuse_transform_0213);
}
at::Tensor _nested_view_from_buffer(const at::Tensor & self, const at::Tensor & nested_size, const at::Tensor & nested_strides, const at::Tensor & offsets) {
return wrapper_CPU___nested_view_from_buffer(self, nested_size, nested_strides, offsets);
}
at::Tensor trunc(const at::Tensor & self) {
return wrapper_CPU_trunc(self);
}
at::Tensor & trunc_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_trunc_out_out(self, out);
}
at::Tensor & trunc_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_trunc_out_out(self, out);
}
at::Tensor & trunc_(at::Tensor & self) {
return wrapper_CPU_trunc_(self);
}
::std::tuple<at::Tensor,at::Tensor> _unique(const at::Tensor & self, bool sorted, bool return_inverse) {
return wrapper_CPU___unique(self, sorted, return_inverse);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> unique_dim(const at::Tensor & self, int64_t dim, bool sorted, bool return_inverse, bool return_counts) {
return wrapper_CPU__unique_dim(self, dim, sorted, return_inverse, return_counts);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> unique_consecutive(const at::Tensor & self, bool return_inverse, bool return_counts, c10::optional<int64_t> dim) {
return wrapper_CPU__unique_consecutive(self, return_inverse, return_counts, dim);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> unique_dim_consecutive(const at::Tensor & self, int64_t dim, bool return_inverse, bool return_counts) {
return wrapper_CPU__unique_dim_consecutive(self, dim, return_inverse, return_counts);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _unique2(const at::Tensor & self, bool sorted, bool return_inverse, bool return_counts) {
return wrapper_CPU___unique2(self, sorted, return_inverse, return_counts);
}
at::Tensor var(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CPU_correction_var(self, dim, correction, keepdim);
}
at::Tensor & var_out(at::Tensor & out, const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CPU_correction_out_var_out(self, dim, correction, keepdim, out);
}
at::Tensor & var_outf(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim, at::Tensor & out) {
return wrapper_CPU_correction_out_var_out(self, dim, correction, keepdim, out);
}
::std::tuple<at::Tensor,at::Tensor> var_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, const c10::optional<at::Scalar> & correction, bool keepdim) {
return wrapper_CPU_correction_var_mean(self, dim, correction, keepdim);
}
at::Tensor where(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_self_where(condition, self, other);
}
at::Tensor & where_out(at::Tensor & out, const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_self_out_where_out(condition, self, other, out);
}
at::Tensor & where_outf(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_self_out_where_out(condition, self, other, out);
}
::std::tuple<at::Tensor,at::Tensor> _weight_norm_interface(const at::Tensor & v, const at::Tensor & g, int64_t dim) {
return wrapper_CPU___weight_norm_interface(v, g, dim);
}
::std::tuple<at::Tensor,at::Tensor> _weight_norm_interface_backward(const at::Tensor & grad_w, const at::Tensor & saved_v, const at::Tensor & saved_g, const at::Tensor & saved_norms, int64_t dim) {
return wrapper_CPU___weight_norm_interface_backward(grad_w, saved_v, saved_g, saved_norms, dim);
}
at::Tensor _efficientzerotensor(at::IntArrayRef size, at::TensorOptions options) {
return wrapper_CPU___efficientzerotensor(c10::fromIntArrayRefSlow(size), c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor _efficientzerotensor(at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CPU___efficientzerotensor(c10::fromIntArrayRefSlow(size), dtype, layout, device, pin_memory);
}
at::Tensor _efficientzerotensor_symint(c10::SymIntArrayRef size, at::TensorOptions options) {
return wrapper_CPU___efficientzerotensor(size, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor _efficientzerotensor_symint(c10::SymIntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CPU___efficientzerotensor(size, dtype, layout, device, pin_memory);
}
at::Tensor _standard_gamma_grad(const at::Tensor & self, const at::Tensor & output) {
return wrapper_CPU___standard_gamma_grad(self, output);
}
at::Tensor _standard_gamma(const at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CPU___standard_gamma(self, generator);
}
at::Tensor _dirichlet_grad(const at::Tensor & x, const at::Tensor & alpha, const at::Tensor & total) {
return wrapper_CPU___dirichlet_grad(x, alpha, total);
}
at::Tensor _sample_dirichlet(const at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CPU___sample_dirichlet(self, generator);
}
at::Tensor poisson(const at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CPU__poisson(self, generator);
}
at::Tensor binomial(const at::Tensor & count, const at::Tensor & prob, c10::optional<at::Generator> generator) {
return wrapper_CPU__binomial(count, prob, generator);
}
at::Tensor _spdiags(const at::Tensor & diagonals, const at::Tensor & offsets, at::IntArrayRef shape, c10::optional<at::Layout> layout) {
return wrapper_CPU___spdiags(diagonals, offsets, shape, layout);
}
at::Tensor norm(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype) {
return wrapper_CPU_norm_ScalarOpt_dim_dtype(self, p, dim, keepdim, dtype);
}
at::Tensor & norm_out(at::Tensor & out, const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype) {
return wrapper_CPU_norm_out_dtype_out(self, p, dim, keepdim, dtype, out);
}
at::Tensor & norm_outf(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype, at::Tensor & out) {
return wrapper_CPU_norm_out_dtype_out(self, p, dim, keepdim, dtype, out);
}
at::Tensor norm(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim) {
return wrapper_CPU_norm_ScalarOpt_dim(self, p, dim, keepdim);
}
at::Tensor & norm_out(at::Tensor & out, const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim) {
return wrapper_CPU_norm_out_out(self, p, dim, keepdim, out);
}
at::Tensor & norm_outf(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
return wrapper_CPU_norm_out_out(self, p, dim, keepdim, out);
}
::std::tuple<at::Tensor &,at::Tensor &> frexp_out(at::Tensor & mantissa, at::Tensor & exponent, const at::Tensor & self) {
return wrapper_CPU_Tensor_out_frexp_out(self, mantissa, exponent);
}
::std::tuple<at::Tensor &,at::Tensor &> frexp_outf(const at::Tensor & self, at::Tensor & mantissa, at::Tensor & exponent) {
return wrapper_CPU_Tensor_out_frexp_out(self, mantissa, exponent);
}
at::Tensor & zero_(at::Tensor & self) {
return wrapper_CPU__zero_(self);
}
at::Tensor sub(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_sub_Tensor(self, other, alpha);
}
at::Tensor & sub_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_sub_out_out(self, other, alpha, out);
}
at::Tensor & sub_outf(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_sub_out_out(self, other, alpha, out);
}
at::Tensor & sub_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_sub__Tensor(self, other, alpha);
}
at::Tensor rsub(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_Tensor_rsub(self, other, alpha);
}
at::Tensor heaviside(const at::Tensor & self, const at::Tensor & values) {
return wrapper_CPU_heaviside(self, values);
}
at::Tensor & heaviside_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & values) {
return wrapper_CPU_heaviside_out_out(self, values, out);
}
at::Tensor & heaviside_outf(const at::Tensor & self, const at::Tensor & values, at::Tensor & out) {
return wrapper_CPU_heaviside_out_out(self, values, out);
}
at::Tensor & heaviside_(at::Tensor & self, const at::Tensor & values) {
return wrapper_CPU_heaviside_(self, values);
}
at::Tensor addmm(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_addmm(self, mat1, mat2, beta, alpha);
}
at::Tensor & addmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_addmm_out_out(self, mat1, mat2, beta, alpha, out);
}
at::Tensor & addmm_outf(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_addmm_out_out(self, mat1, mat2, beta, alpha, out);
}
at::Tensor & addmm_(at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_addmm_(self, mat1, mat2, beta, alpha);
}
at::Tensor _addmm_activation(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu) {
return wrapper_CPU__addmm_activation(self, mat1, mat2, beta, alpha, use_gelu);
}
at::Tensor & _addmm_activation_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu) {
return wrapper_CPU__addmm_activation_out_out(self, mat1, mat2, beta, alpha, use_gelu, out);
}
at::Tensor & _addmm_activation_outf(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, bool use_gelu, at::Tensor & out) {
return wrapper_CPU__addmm_activation_out_out(self, mat1, mat2, beta, alpha, use_gelu, out);
}
int64_t sparse_dim(const at::Tensor & self) {
return wrapper_CPU__sparse_dim(self);
}
int64_t dense_dim(const at::Tensor & self) {
return wrapper_CPU__dense_dim(self);
}
at::Tensor _to_sparse(const at::Tensor & self, int64_t sparse_dim) {
return wrapper_CPU_sparse_dim__to_sparse(self, sparse_dim);
}
at::Tensor _to_sparse(const at::Tensor & self, c10::optional<at::Layout> layout, at::OptionalIntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
return wrapper_CPU___to_sparse(self, layout, blocksize, dense_dim);
}
at::Tensor _to_sparse_csr(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
return wrapper_CPU___to_sparse_csr(self, dense_dim);
}
at::Tensor _to_sparse_csc(const at::Tensor & self, c10::optional<int64_t> dense_dim) {
return wrapper_CPU___to_sparse_csc(self, dense_dim);
}
at::Tensor _to_sparse_bsr(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
return wrapper_CPU___to_sparse_bsr(self, blocksize, dense_dim);
}
at::Tensor _to_sparse_bsc(const at::Tensor & self, at::IntArrayRef blocksize, c10::optional<int64_t> dense_dim) {
return wrapper_CPU___to_sparse_bsc(self, blocksize, dense_dim);
}
at::Tensor to_mkldnn(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU__to_mkldnn(self, dtype);
}
at::Tensor quantize_per_tensor_dynamic(const at::Tensor & self, at::ScalarType dtype, bool reduce_range) {
return wrapper_CPU__quantize_per_tensor_dynamic(self, dtype, reduce_range);
}
at::Tensor quantize_per_tensor(const at::Tensor & self, double scale, int64_t zero_point, at::ScalarType dtype) {
return wrapper_CPU__quantize_per_tensor(self, scale, zero_point, dtype);
}
at::Tensor quantize_per_tensor(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, at::ScalarType dtype) {
return wrapper_CPU_tensor_qparams_quantize_per_tensor(self, scale, zero_point, dtype);
}
::std::vector<at::Tensor> quantize_per_tensor(at::TensorList tensors, const at::Tensor & scales, const at::Tensor & zero_points, at::ScalarType dtype) {
return wrapper_CPU_tensors_quantize_per_tensor(tensors, scales, zero_points, dtype);
}
at::Tensor quantize_per_channel(const at::Tensor & self, const at::Tensor & scales, const at::Tensor & zero_points, int64_t axis, at::ScalarType dtype) {
return wrapper_CPU__quantize_per_channel(self, scales, zero_points, axis, dtype);
}
at::Tensor dequantize(const at::Tensor & self) {
return wrapper_CPU_self_dequantize(self);
}
at::Tensor _make_per_tensor_quantized_tensor(const at::Tensor & self, double scale, int64_t zero_point) {
return wrapper_CPU___make_per_tensor_quantized_tensor(self, scale, zero_point);
}
at::Tensor _make_per_channel_quantized_tensor(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis) {
return wrapper_CPU___make_per_channel_quantized_tensor(self, scale, zero_point, axis);
}
::std::tuple<at::Tensor,at::Tensor> fake_quantize_per_tensor_affine_cachemask(const at::Tensor & self, double scale, int64_t zero_point, int64_t quant_min, int64_t quant_max) {
return wrapper_CPU__fake_quantize_per_tensor_affine_cachemask(self, scale, zero_point, quant_min, quant_max);
}
::std::tuple<at::Tensor,at::Tensor> _fake_quantize_per_tensor_affine_cachemask_tensor_qparams(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, const at::Tensor & fake_quant_enabled, int64_t quant_min, int64_t quant_max) {
return wrapper_CPU___fake_quantize_per_tensor_affine_cachemask_tensor_qparams(self, scale, zero_point, fake_quant_enabled, quant_min, quant_max);
}
at::Tensor _fake_quantize_learnable_per_tensor_affine(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t quant_min, int64_t quant_max, double grad_factor) {
return wrapper_CPU___fake_quantize_learnable_per_tensor_affine(self, scale, zero_point, quant_min, quant_max, grad_factor);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _fake_quantize_learnable_per_tensor_affine_backward(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t quant_min, int64_t quant_max, double grad_factor) {
return wrapper_CPU___fake_quantize_learnable_per_tensor_affine_backward(grad, self, scale, zero_point, quant_min, quant_max, grad_factor);
}
::std::tuple<at::Tensor,at::Tensor> fake_quantize_per_channel_affine_cachemask(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max) {
return wrapper_CPU__fake_quantize_per_channel_affine_cachemask(self, scale, zero_point, axis, quant_min, quant_max);
}
at::Tensor _fake_quantize_learnable_per_channel_affine(const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, double grad_factor) {
return wrapper_CPU___fake_quantize_learnable_per_channel_affine(self, scale, zero_point, axis, quant_min, quant_max, grad_factor);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _fake_quantize_learnable_per_channel_affine_backward(const at::Tensor & grad, const at::Tensor & self, const at::Tensor & scale, const at::Tensor & zero_point, int64_t axis, int64_t quant_min, int64_t quant_max, double grad_factor) {
return wrapper_CPU___fake_quantize_learnable_per_channel_affine_backward(grad, self, scale, zero_point, axis, quant_min, quant_max, grad_factor);
}
::std::tuple<at::Tensor,at::Tensor> _fused_moving_avg_obs_fq_helper(const at::Tensor & self, const at::Tensor & observer_on, const at::Tensor & fake_quant_on, at::Tensor & running_min, at::Tensor & running_max, at::Tensor & scale, at::Tensor & zero_point, double averaging_const, int64_t quant_min, int64_t quant_max, int64_t ch_axis, bool per_row_fake_quant, bool symmetric_quant) {
return wrapper_CPU___fused_moving_avg_obs_fq_helper(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
}
at::Scalar _local_scalar_dense(const at::Tensor & self) {
return wrapper_CPU___local_scalar_dense(self);
}
at::Tensor & set_(at::Tensor & self, at::Storage source) {
return wrapper_CPU_source_Storage_set_(self, source);
}
at::Tensor & set_(at::Tensor & self, at::Storage source, int64_t storage_offset, at::IntArrayRef size, at::IntArrayRef stride) {
return wrapper_CPU_source_Storage_storage_offset_set_(self, source, storage_offset, c10::fromIntArrayRefSlow(size), c10::fromIntArrayRefSlow(stride));
}
at::Tensor & set__symint(at::Tensor & self, at::Storage source, c10::SymInt storage_offset, c10::SymIntArrayRef size, c10::SymIntArrayRef stride) {
return wrapper_CPU_source_Storage_storage_offset_set_(self, source, storage_offset, size, stride);
}
at::Tensor & set_(at::Tensor & self, const at::Tensor & source) {
return wrapper_CPU_source_Tensor_set_(self, source);
}
at::Tensor & set_(at::Tensor & self) {
return wrapper_CPU__set_(self);
}
bool is_set_to(const at::Tensor & self, const at::Tensor & tensor) {
return wrapper_CPU__is_set_to(self, tensor);
}
at::Tensor & masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
return wrapper_CPU_Scalar_masked_fill_(self, mask, value);
}
at::Tensor & masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
return wrapper_CPU_Tensor_masked_fill_(self, mask, value);
}
at::Tensor & masked_scatter_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & source) {
return wrapper_CPU__masked_scatter_(self, mask, source);
}
at::Tensor _masked_softmax(const at::Tensor & self, const at::Tensor & mask, c10::optional<int64_t> dim, c10::optional<int64_t> mask_type) {
return wrapper_CPU___masked_softmax(self, mask, dim, mask_type);
}
at::Tensor _masked_softmax_backward(const at::Tensor & grad_output, const at::Tensor & output, const at::Tensor & mask, c10::optional<int64_t> dim) {
return wrapper_CPU___masked_softmax_backward(grad_output, output, mask, dim);
}
at::Tensor view(const at::Tensor & self, at::IntArrayRef size) {
return wrapper_CPU__view(self, c10::fromIntArrayRefSlow(size));
}
at::Tensor view_symint(const at::Tensor & self, c10::SymIntArrayRef size) {
return wrapper_CPU__view(self, size);
}
at::Tensor & put_(at::Tensor & self, const at::Tensor & index, const at::Tensor & source, bool accumulate) {
return wrapper_CPU__put_(self, index, source, accumulate);
}
at::Tensor index_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
return wrapper_CPU_index_add(self, dim, index, source, alpha);
}
at::Tensor & index_add_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
return wrapper_CPU_index_add_out_out(self, dim, index, source, alpha, out);
}
at::Tensor & index_add_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_index_add_out_out(self, dim, index, source, alpha, out);
}
at::Tensor & index_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
return wrapper_CPU_index_add_(self, dim, index, source, alpha);
}
at::Tensor index_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
return wrapper_CPU_index_reduce(self, dim, index, source, reduce, include_self);
}
at::Tensor & index_reduce_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
return wrapper_CPU_index_reduce_out_out(self, dim, index, source, reduce, include_self, out);
}
at::Tensor & index_reduce_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self, at::Tensor & out) {
return wrapper_CPU_index_reduce_out_out(self, dim, index, source, reduce, include_self, out);
}
at::Tensor & index_reduce_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, c10::string_view reduce, bool include_self) {
return wrapper_CPU_index_reduce_(self, dim, index, source, reduce, include_self);
}
at::Tensor & index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
return wrapper_CPU_int_Scalar_index_fill_(self, dim, index, value);
}
at::Tensor & index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & value) {
return wrapper_CPU_int_Tensor_index_fill_(self, dim, index, value);
}
at::Tensor scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CPU_scatter_src(self, dim, index, src);
}
at::Tensor & scatter_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CPU_scatter_out_src_out(self, dim, index, src, out);
}
at::Tensor & scatter_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
return wrapper_CPU_scatter_out_src_out(self, dim, index, src, out);
}
at::Tensor & scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CPU_scatter__src(self, dim, index, src);
}
at::Tensor scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
return wrapper_CPU_scatter_value(self, dim, index, value);
}
at::Tensor & scatter_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
return wrapper_CPU_scatter_out_value_out(self, dim, index, value, out);
}
at::Tensor & scatter_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, at::Tensor & out) {
return wrapper_CPU_scatter_out_value_out(self, dim, index, value, out);
}
at::Tensor & scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
return wrapper_CPU_scatter__value(self, dim, index, value);
}
at::Tensor scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
return wrapper_CPU_scatter_reduce(self, dim, index, src, reduce);
}
at::Tensor & scatter_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
return wrapper_CPU_scatter_out_reduce_out(self, dim, index, src, reduce, out);
}
at::Tensor & scatter_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, at::Tensor & out) {
return wrapper_CPU_scatter_out_reduce_out(self, dim, index, src, reduce, out);
}
at::Tensor & scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
return wrapper_CPU_scatter__reduce(self, dim, index, src, reduce);
}
at::Tensor scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
return wrapper_CPU_scatter_value_reduce(self, dim, index, value, reduce);
}
at::Tensor & scatter_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
return wrapper_CPU_scatter_out_value_reduce_out(self, dim, index, value, reduce, out);
}
at::Tensor & scatter_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce, at::Tensor & out) {
return wrapper_CPU_scatter_out_value_reduce_out(self, dim, index, value, reduce, out);
}
at::Tensor & scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
return wrapper_CPU_scatter__value_reduce(self, dim, index, value, reduce);
}
at::Tensor scatter_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CPU_scatter_add(self, dim, index, src);
}
at::Tensor & scatter_add_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CPU_scatter_add_out_out(self, dim, index, src, out);
}
at::Tensor & scatter_add_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
return wrapper_CPU_scatter_add_out_out(self, dim, index, src, out);
}
at::Tensor & scatter_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
return wrapper_CPU_scatter_add_(self, dim, index, src);
}
at::Tensor scatter_reduce(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
return wrapper_CPU_scatter_reduce_two(self, dim, index, src, reduce, include_self);
}
at::Tensor & scatter_reduce_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
return wrapper_CPU_scatter_reduce_out_two_out(self, dim, index, src, reduce, include_self, out);
}
at::Tensor & scatter_reduce_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self, at::Tensor & out) {
return wrapper_CPU_scatter_reduce_out_two_out(self, dim, index, src, reduce, include_self, out);
}
at::Tensor & scatter_reduce_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, bool include_self) {
return wrapper_CPU_scatter_reduce__two(self, dim, index, src, reduce, include_self);
}
at::Tensor eq(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_eq_Scalar(self, other);
}
at::Tensor & eq_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_eq_out_Scalar_out(self, other, out);
}
at::Tensor & eq_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CPU_eq_out_Scalar_out(self, other, out);
}
at::Tensor & eq_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_eq__Scalar(self, other);
}
at::Tensor eq(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_eq_Tensor(self, other);
}
at::Tensor & eq_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_eq_out_Tensor_out(self, other, out);
}
at::Tensor & eq_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_eq_out_Tensor_out(self, other, out);
}
at::Tensor & eq_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_eq__Tensor(self, other);
}
at::Tensor bitwise_and(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_and_Tensor(self, other);
}
at::Tensor & bitwise_and_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_and_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_and_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_bitwise_and_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_and_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_and__Tensor(self, other);
}
at::Tensor bitwise_or(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_or_Tensor(self, other);
}
at::Tensor & bitwise_or_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_or_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_or_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_bitwise_or_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_or_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_or__Tensor(self, other);
}
at::Tensor bitwise_xor(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_xor_Tensor(self, other);
}
at::Tensor & bitwise_xor_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_xor_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_xor_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_bitwise_xor_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_xor_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_xor__Tensor(self, other);
}
at::Tensor __lshift__(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_Scalar___lshift__(self, other);
}
at::Tensor & __ilshift__(at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_Scalar___ilshift__(self, other);
}
at::Tensor __lshift__(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_Tensor___lshift__(self, other);
}
at::Tensor & __ilshift__(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_Tensor___ilshift__(self, other);
}
at::Tensor bitwise_left_shift(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_left_shift_Tensor(self, other);
}
at::Tensor & bitwise_left_shift_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_left_shift_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_left_shift_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_bitwise_left_shift_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_left_shift_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_left_shift__Tensor(self, other);
}
at::Tensor __rshift__(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_Scalar___rshift__(self, other);
}
at::Tensor & __irshift__(at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_Scalar___irshift__(self, other);
}
at::Tensor __rshift__(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_Tensor___rshift__(self, other);
}
at::Tensor & __irshift__(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_Tensor___irshift__(self, other);
}
at::Tensor bitwise_right_shift(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_right_shift_Tensor(self, other);
}
at::Tensor & bitwise_right_shift_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_right_shift_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_right_shift_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_bitwise_right_shift_out_Tensor_out(self, other, out);
}
at::Tensor & bitwise_right_shift_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_bitwise_right_shift__Tensor(self, other);
}
at::Tensor tril(const at::Tensor & self, int64_t diagonal) {
return wrapper_CPU_tril(self, diagonal);
}
at::Tensor & tril_out(at::Tensor & out, const at::Tensor & self, int64_t diagonal) {
return wrapper_CPU_tril_out_out(self, diagonal, out);
}
at::Tensor & tril_outf(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
return wrapper_CPU_tril_out_out(self, diagonal, out);
}
at::Tensor & tril_(at::Tensor & self, int64_t diagonal) {
return wrapper_CPU_tril_(self, diagonal);
}
at::Tensor triu(const at::Tensor & self, int64_t diagonal) {
return wrapper_CPU_triu(self, diagonal);
}
at::Tensor & triu_out(at::Tensor & out, const at::Tensor & self, int64_t diagonal) {
return wrapper_CPU_triu_out_out(self, diagonal, out);
}
at::Tensor & triu_outf(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
return wrapper_CPU_triu_out_out(self, diagonal, out);
}
at::Tensor & triu_(at::Tensor & self, int64_t diagonal) {
return wrapper_CPU_triu_(self, diagonal);
}
at::Tensor digamma(const at::Tensor & self) {
return wrapper_CPU_digamma(self);
}
at::Tensor & digamma_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_digamma_out_out(self, out);
}
at::Tensor & digamma_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_digamma_out_out(self, out);
}
at::Tensor & digamma_(at::Tensor & self) {
return wrapper_CPU_digamma_(self);
}
at::Tensor lerp(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
return wrapper_CPU_lerp_Scalar(self, end, weight);
}
at::Tensor & lerp_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
return wrapper_CPU_lerp_out_Scalar_out(self, end, weight, out);
}
at::Tensor & lerp_outf(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight, at::Tensor & out) {
return wrapper_CPU_lerp_out_Scalar_out(self, end, weight, out);
}
at::Tensor & lerp_(at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
return wrapper_CPU_lerp__Scalar(self, end, weight);
}
at::Tensor lerp(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
return wrapper_CPU_lerp_Tensor(self, end, weight);
}
at::Tensor & lerp_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
return wrapper_CPU_lerp_out_Tensor_out(self, end, weight, out);
}
at::Tensor & lerp_outf(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight, at::Tensor & out) {
return wrapper_CPU_lerp_out_Tensor_out(self, end, weight, out);
}
at::Tensor & lerp_(at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
return wrapper_CPU_lerp__Tensor(self, end, weight);
}
at::Tensor addbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU__addbmm(self, batch1, batch2, beta, alpha);
}
at::Tensor & addbmm_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU_out_addbmm_out(self, batch1, batch2, beta, alpha, out);
}
at::Tensor & addbmm_outf(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
return wrapper_CPU_out_addbmm_out(self, batch1, batch2, beta, alpha, out);
}
at::Tensor & addbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
return wrapper_CPU__addbmm_(self, batch1, batch2, beta, alpha);
}
at::Tensor & random_(at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator) {
return wrapper_CPU_from_random_(self, from, to, generator);
}
at::Tensor & random_(at::Tensor & self, int64_t to, c10::optional<at::Generator> generator) {
return wrapper_CPU_to_random_(self, to, generator);
}
at::Tensor & random_(at::Tensor & self, c10::optional<at::Generator> generator) {
return wrapper_CPU__random_(self, generator);
}
at::Tensor & uniform_(at::Tensor & self, double from, double to, c10::optional<at::Generator> generator) {
return wrapper_CPU__uniform_(self, from, to, generator);
}
at::Tensor & cauchy_(at::Tensor & self, double median, double sigma, c10::optional<at::Generator> generator) {
return wrapper_CPU__cauchy_(self, median, sigma, generator);
}
at::Tensor & log_normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
return wrapper_CPU__log_normal_(self, mean, std, generator);
}
at::Tensor & exponential_(at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
return wrapper_CPU__exponential_(self, lambd, generator);
}
at::Tensor & geometric_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
return wrapper_CPU__geometric_(self, p, generator);
}
at::Tensor tril_indices(int64_t row, int64_t col, int64_t offset, at::TensorOptions options) {
return wrapper_CPU__tril_indices(row, col, offset, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor tril_indices(int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CPU__tril_indices(row, col, offset, dtype, layout, device, pin_memory);
}
at::Tensor triu_indices(int64_t row, int64_t col, int64_t offset, at::TensorOptions options) {
return wrapper_CPU__triu_indices(row, col, offset, c10::optTypeMetaToScalarType(options.dtype_opt()), options.layout_opt(), options.device_opt(), options.pinned_memory_opt());
}
at::Tensor triu_indices(int64_t row, int64_t col, int64_t offset, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
return wrapper_CPU__triu_indices(row, col, offset, dtype, layout, device, pin_memory);
}
at::Tensor trace(const at::Tensor & self) {
return wrapper_CPU__trace(self);
}
at::Tensor ne(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_ne_Scalar(self, other);
}
at::Tensor & ne_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_ne_out_Scalar_out(self, other, out);
}
at::Tensor & ne_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CPU_ne_out_Scalar_out(self, other, out);
}
at::Tensor & ne_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_ne__Scalar(self, other);
}
at::Tensor ne(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_ne_Tensor(self, other);
}
at::Tensor & ne_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_ne_out_Tensor_out(self, other, out);
}
at::Tensor & ne_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_ne_out_Tensor_out(self, other, out);
}
at::Tensor & ne_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_ne__Tensor(self, other);
}
at::Tensor ge(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_ge_Scalar(self, other);
}
at::Tensor & ge_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_ge_out_Scalar_out(self, other, out);
}
at::Tensor & ge_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CPU_ge_out_Scalar_out(self, other, out);
}
at::Tensor & ge_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_ge__Scalar(self, other);
}
at::Tensor ge(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_ge_Tensor(self, other);
}
at::Tensor & ge_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_ge_out_Tensor_out(self, other, out);
}
at::Tensor & ge_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_ge_out_Tensor_out(self, other, out);
}
at::Tensor & ge_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_ge__Tensor(self, other);
}
at::Tensor le(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_le_Scalar(self, other);
}
at::Tensor & le_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_le_out_Scalar_out(self, other, out);
}
at::Tensor & le_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CPU_le_out_Scalar_out(self, other, out);
}
at::Tensor & le_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_le__Scalar(self, other);
}
at::Tensor le(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_le_Tensor(self, other);
}
at::Tensor & le_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_le_out_Tensor_out(self, other, out);
}
at::Tensor & le_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_le_out_Tensor_out(self, other, out);
}
at::Tensor & le_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_le__Tensor(self, other);
}
at::Tensor gt(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_gt_Scalar(self, other);
}
at::Tensor & gt_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_gt_out_Scalar_out(self, other, out);
}
at::Tensor & gt_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CPU_gt_out_Scalar_out(self, other, out);
}
at::Tensor & gt_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_gt__Scalar(self, other);
}
at::Tensor gt(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_gt_Tensor(self, other);
}
at::Tensor & gt_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_gt_out_Tensor_out(self, other, out);
}
at::Tensor & gt_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_gt_out_Tensor_out(self, other, out);
}
at::Tensor & gt_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_gt__Tensor(self, other);
}
at::Tensor lt(const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_lt_Scalar(self, other);
}
at::Tensor & lt_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_lt_out_Scalar_out(self, other, out);
}
at::Tensor & lt_outf(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
return wrapper_CPU_lt_out_Scalar_out(self, other, out);
}
at::Tensor & lt_(at::Tensor & self, const at::Scalar & other) {
return wrapper_CPU_lt__Scalar(self, other);
}
at::Tensor lt(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_lt_Tensor(self, other);
}
at::Tensor & lt_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_lt_out_Tensor_out(self, other, out);
}
at::Tensor & lt_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_lt_out_Tensor_out(self, other, out);
}
at::Tensor & lt_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_lt__Tensor(self, other);
}
at::Tensor take(const at::Tensor & self, const at::Tensor & index) {
return wrapper_CPU__take(self, index);
}
at::Tensor & take_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & index) {
return wrapper_CPU_out_take_out(self, index, out);
}
at::Tensor & take_outf(const at::Tensor & self, const at::Tensor & index, at::Tensor & out) {
return wrapper_CPU_out_take_out(self, index, out);
}
at::Tensor index_select(const at::Tensor & self, int64_t dim, const at::Tensor & index) {
return wrapper_CPU__index_select(self, dim, index);
}
at::Tensor & index_select_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index) {
return wrapper_CPU_out_index_select_out(self, dim, index, out);
}
at::Tensor & index_select_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, at::Tensor & out) {
return wrapper_CPU_out_index_select_out(self, dim, index, out);
}
at::Tensor masked_select(const at::Tensor & self, const at::Tensor & mask) {
return wrapper_CPU__masked_select(self, mask);
}
at::Tensor & masked_select_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & mask) {
return wrapper_CPU_out_masked_select_out(self, mask, out);
}
at::Tensor & masked_select_outf(const at::Tensor & self, const at::Tensor & mask, at::Tensor & out) {
return wrapper_CPU_out_masked_select_out(self, mask, out);
}
at::Tensor nonzero(const at::Tensor & self) {
return wrapper_CPU__nonzero(self);
}
at::Tensor & nonzero_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_out_nonzero_out(self, out);
}
at::Tensor & nonzero_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_out_nonzero_out(self, out);
}
at::Tensor nonzero_static(const at::Tensor & self, int64_t size, int64_t fill_value) {
return wrapper_CPU__nonzero_static(self, size, fill_value);
}
at::Tensor & nonzero_static_out(at::Tensor & out, const at::Tensor & self, int64_t size, int64_t fill_value) {
return wrapper_CPU_out_nonzero_static_out(self, size, fill_value, out);
}
at::Tensor & nonzero_static_outf(const at::Tensor & self, int64_t size, int64_t fill_value, at::Tensor & out) {
return wrapper_CPU_out_nonzero_static_out(self, size, fill_value, out);
}
at::Tensor gather(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad) {
return wrapper_CPU_gather(self, dim, index, sparse_grad);
}
at::Tensor & gather_out(at::Tensor & out, const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad) {
return wrapper_CPU_gather_out_out(self, dim, index, sparse_grad, out);
}
at::Tensor & gather_outf(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad, at::Tensor & out) {
return wrapper_CPU_gather_out_out(self, dim, index, sparse_grad, out);
}
at::Tensor addcmul(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CPU_addcmul(self, tensor1, tensor2, value);
}
at::Tensor & addcmul_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CPU_addcmul_out_out(self, tensor1, tensor2, value, out);
}
at::Tensor & addcmul_outf(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
return wrapper_CPU_addcmul_out_out(self, tensor1, tensor2, value, out);
}
at::Tensor & addcmul_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CPU_addcmul_(self, tensor1, tensor2, value);
}
at::Tensor addcdiv(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CPU_addcdiv(self, tensor1, tensor2, value);
}
at::Tensor & addcdiv_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CPU_addcdiv_out_out(self, tensor1, tensor2, value, out);
}
at::Tensor & addcdiv_outf(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
return wrapper_CPU_addcdiv_out_out(self, tensor1, tensor2, value, out);
}
at::Tensor & addcdiv_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
return wrapper_CPU_addcdiv_(self, tensor1, tensor2, value);
}
::std::tuple<at::Tensor,at::Tensor> triangular_solve(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular) {
return wrapper_CPU_triangular_solve(self, A, upper, transpose, unitriangular);
}
::std::tuple<at::Tensor &,at::Tensor &> triangular_solve_out(at::Tensor & X, at::Tensor & M, const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular) {
return wrapper_CPU_triangular_solve_out_X(self, A, upper, transpose, unitriangular, X, M);
}
::std::tuple<at::Tensor &,at::Tensor &> triangular_solve_outf(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular, at::Tensor & X, at::Tensor & M) {
return wrapper_CPU_triangular_solve_out_X(self, A, upper, transpose, unitriangular, X, M);
}
at::Tensor linalg_solve_triangular(const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular) {
return wrapper_CPU__linalg_solve_triangular(self, B, upper, left, unitriangular);
}
at::Tensor & linalg_solve_triangular_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular) {
return wrapper_CPU_out_linalg_solve_triangular_out(self, B, upper, left, unitriangular, out);
}
at::Tensor & linalg_solve_triangular_outf(const at::Tensor & self, const at::Tensor & B, bool upper, bool left, bool unitriangular, at::Tensor & out) {
return wrapper_CPU_out_linalg_solve_triangular_out(self, B, upper, left, unitriangular, out);
}
at::Tensor cholesky(const at::Tensor & self, bool upper) {
return wrapper_CPU__cholesky(self, upper);
}
at::Tensor & cholesky_out(at::Tensor & out, const at::Tensor & self, bool upper) {
return wrapper_CPU_out_cholesky_out(self, upper, out);
}
at::Tensor & cholesky_outf(const at::Tensor & self, bool upper, at::Tensor & out) {
return wrapper_CPU_out_cholesky_out(self, upper, out);
}
at::Tensor _cholesky_solve_helper(const at::Tensor & self, const at::Tensor & A, bool upper) {
return wrapper_CPU___cholesky_solve_helper(self, A, upper);
}
at::Tensor cholesky_inverse(const at::Tensor & self, bool upper) {
return wrapper_CPU__cholesky_inverse(self, upper);
}
at::Tensor & cholesky_inverse_out(at::Tensor & out, const at::Tensor & self, bool upper) {
return wrapper_CPU_out_cholesky_inverse_out(self, upper, out);
}
at::Tensor & cholesky_inverse_outf(const at::Tensor & self, bool upper, at::Tensor & out) {
return wrapper_CPU_out_cholesky_inverse_out(self, upper, out);
}
::std::tuple<at::Tensor,at::Tensor> geqrf(const at::Tensor & self) {
return wrapper_CPU__geqrf(self);
}
::std::tuple<at::Tensor &,at::Tensor &> geqrf_out(at::Tensor & a, at::Tensor & tau, const at::Tensor & self) {
return wrapper_CPU_a_geqrf_out(self, a, tau);
}
::std::tuple<at::Tensor &,at::Tensor &> geqrf_outf(const at::Tensor & self, at::Tensor & a, at::Tensor & tau) {
return wrapper_CPU_a_geqrf_out(self, a, tau);
}
at::Tensor ormqr(const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose) {
return wrapper_CPU__ormqr(self, input2, input3, left, transpose);
}
at::Tensor & ormqr_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose) {
return wrapper_CPU_out_ormqr_out(self, input2, input3, left, transpose, out);
}
at::Tensor & ormqr_outf(const at::Tensor & self, const at::Tensor & input2, const at::Tensor & input3, bool left, bool transpose, at::Tensor & out) {
return wrapper_CPU_out_ormqr_out(self, input2, input3, left, transpose, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> lu_unpack(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots) {
return wrapper_CPU_lu_unpack(LU_data, LU_pivots, unpack_data, unpack_pivots);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> lu_unpack_out(at::Tensor & P, at::Tensor & L, at::Tensor & U, const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots) {
return wrapper_CPU_lu_unpack_out_out(LU_data, LU_pivots, unpack_data, unpack_pivots, P, L, U);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> lu_unpack_outf(const at::Tensor & LU_data, const at::Tensor & LU_pivots, bool unpack_data, bool unpack_pivots, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
return wrapper_CPU_lu_unpack_out_out(LU_data, LU_pivots, unpack_data, unpack_pivots, P, L, U);
}
at::Tensor multinomial(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator) {
return wrapper_CPU__multinomial(self, num_samples, replacement, generator);
}
at::Tensor & multinomial_out(at::Tensor & out, const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator) {
return wrapper_CPU_out_multinomial_out(self, num_samples, replacement, generator, out);
}
at::Tensor & multinomial_outf(const at::Tensor & self, int64_t num_samples, bool replacement, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CPU_out_multinomial_out(self, num_samples, replacement, generator, out);
}
at::Tensor lgamma(const at::Tensor & self) {
return wrapper_CPU_lgamma(self);
}
at::Tensor & lgamma_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_lgamma_out_out(self, out);
}
at::Tensor & lgamma_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_lgamma_out_out(self, out);
}
at::Tensor & lgamma_(at::Tensor & self) {
return wrapper_CPU_lgamma_(self);
}
at::Tensor polygamma(int64_t n, const at::Tensor & self) {
return wrapper_CPU_polygamma(n, self);
}
at::Tensor & polygamma_out(at::Tensor & out, int64_t n, const at::Tensor & self) {
return wrapper_CPU_polygamma_out_out(n, self, out);
}
at::Tensor & polygamma_outf(int64_t n, const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_polygamma_out_out(n, self, out);
}
at::Tensor erfinv(const at::Tensor & self) {
return wrapper_CPU_erfinv(self);
}
at::Tensor & erfinv_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_erfinv_out_out(self, out);
}
at::Tensor & erfinv_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_erfinv_out_out(self, out);
}
at::Tensor & erfinv_(at::Tensor & self) {
return wrapper_CPU_erfinv_(self);
}
at::Tensor i0(const at::Tensor & self) {
return wrapper_CPU_i0(self);
}
at::Tensor & i0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_i0_out_out(self, out);
}
at::Tensor & i0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_i0_out_out(self, out);
}
at::Tensor & i0_(at::Tensor & self) {
return wrapper_CPU_i0_(self);
}
at::Tensor sign(const at::Tensor & self) {
return wrapper_CPU_sign(self);
}
at::Tensor & sign_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_sign_out_out(self, out);
}
at::Tensor & sign_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_sign_out_out(self, out);
}
at::Tensor & sign_(at::Tensor & self) {
return wrapper_CPU_sign_(self);
}
at::Tensor signbit(const at::Tensor & self) {
return wrapper_CPU_signbit(self);
}
at::Tensor & signbit_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_signbit_out_out(self, out);
}
at::Tensor & signbit_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_signbit_out_out(self, out);
}
at::Tensor atan2(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_atan2(self, other);
}
at::Tensor & atan2_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_atan2_out_out(self, other, out);
}
at::Tensor & atan2_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_atan2_out_out(self, other, out);
}
at::Tensor & atan2_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_atan2_(self, other);
}
at::Tensor histc(const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max) {
return wrapper_CPU__histc(self, bins, min, max);
}
at::Tensor & histc_out(at::Tensor & out, const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max) {
return wrapper_CPU_out_histc_out(self, bins, min, max, out);
}
at::Tensor & histc_outf(const at::Tensor & self, int64_t bins, const at::Scalar & min, const at::Scalar & max, at::Tensor & out) {
return wrapper_CPU_out_histc_out(self, bins, min, max, out);
}
::std::tuple<at::Tensor,at::Tensor> histogram(const at::Tensor & self, const at::Tensor & bins, const c10::optional<at::Tensor> & weight, bool density) {
return wrapper_CPU_bins_tensor_histogram(self, bins, weight, density);
}
::std::tuple<at::Tensor &,at::Tensor &> histogram_out(at::Tensor & hist, at::Tensor & bin_edges, const at::Tensor & self, const at::Tensor & bins, const c10::optional<at::Tensor> & weight, bool density) {
return wrapper_CPU_bins_tensor_out_histogram_out(self, bins, weight, density, hist, bin_edges);
}
::std::tuple<at::Tensor &,at::Tensor &> histogram_outf(const at::Tensor & self, const at::Tensor & bins, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & hist, at::Tensor & bin_edges) {
return wrapper_CPU_bins_tensor_out_histogram_out(self, bins, weight, density, hist, bin_edges);
}
::std::tuple<at::Tensor,at::Tensor> histogram(const at::Tensor & self, int64_t bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
return wrapper_CPU_bin_ct_histogram(self, bins, range, weight, density);
}
::std::tuple<at::Tensor &,at::Tensor &> histogram_out(at::Tensor & hist, at::Tensor & bin_edges, const at::Tensor & self, int64_t bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
return wrapper_CPU_bin_ct_out_histogram_out(self, bins, range, weight, density, hist, bin_edges);
}
::std::tuple<at::Tensor &,at::Tensor &> histogram_outf(const at::Tensor & self, int64_t bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density, at::Tensor & hist, at::Tensor & bin_edges) {
return wrapper_CPU_bin_ct_out_histogram_out(self, bins, range, weight, density, hist, bin_edges);
}
::std::vector<at::Tensor> _histogramdd_bin_edges(const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
return wrapper_CPU___histogramdd_bin_edges(self, bins, range, weight, density);
}
at::Tensor _histogramdd_from_bin_cts(const at::Tensor & self, at::IntArrayRef bins, c10::optional<at::ArrayRef<double>> range, const c10::optional<at::Tensor> & weight, bool density) {
return wrapper_CPU___histogramdd_from_bin_cts(self, bins, range, weight, density);
}
at::Tensor _histogramdd_from_bin_tensors(const at::Tensor & self, at::TensorList bins, const c10::optional<at::Tensor> & weight, bool density) {
return wrapper_CPU___histogramdd_from_bin_tensors(self, bins, weight, density);
}
at::Tensor fmod(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_fmod_Tensor(self, other);
}
at::Tensor & fmod_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_fmod_out_Tensor_out(self, other, out);
}
at::Tensor & fmod_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_fmod_out_Tensor_out(self, other, out);
}
at::Tensor & fmod_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_fmod__Tensor(self, other);
}
at::Tensor hypot(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_hypot(self, other);
}
at::Tensor & hypot_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_hypot_out_out(self, other, out);
}
at::Tensor & hypot_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_hypot_out_out(self, other, out);
}
at::Tensor & hypot_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_hypot_(self, other);
}
at::Tensor igamma(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_igamma(self, other);
}
at::Tensor & igamma_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_igamma_out_out(self, other, out);
}
at::Tensor & igamma_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_igamma_out_out(self, other, out);
}
at::Tensor & igamma_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_igamma_(self, other);
}
at::Tensor igammac(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_igammac(self, other);
}
at::Tensor & igammac_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_igammac_out_out(self, other, out);
}
at::Tensor & igammac_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_igammac_out_out(self, other, out);
}
at::Tensor & igammac_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_igammac_(self, other);
}
at::Tensor nextafter(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_nextafter(self, other);
}
at::Tensor & nextafter_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_nextafter_out_out(self, other, out);
}
at::Tensor & nextafter_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_nextafter_out_out(self, other, out);
}
at::Tensor & nextafter_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_nextafter_(self, other);
}
at::Tensor remainder(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_remainder_Tensor(self, other);
}
at::Tensor & remainder_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_remainder_out_Tensor_out(self, other, out);
}
at::Tensor & remainder_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_remainder_out_Tensor_out(self, other, out);
}
at::Tensor & remainder_(at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_remainder__Tensor(self, other);
}
at::Tensor remainder(const at::Scalar & self, const at::Tensor & other) {
return wrapper_CPU_Scalar_Tensor_remainder(self, other);
}
at::Tensor min(const at::Tensor & self) {
return wrapper_CPU__min(self);
}
at::Tensor & min_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_unary_out_min_out(self, out);
}
at::Tensor & min_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_unary_out_min_out(self, out);
}
at::Tensor fmin(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_fmin(self, other);
}
at::Tensor & fmin_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_fmin_out_out(self, other, out);
}
at::Tensor & fmin_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_fmin_out_out(self, other, out);
}
at::Tensor max(const at::Tensor & self) {
return wrapper_CPU__max(self);
}
at::Tensor & max_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_unary_out_max_out(self, out);
}
at::Tensor & max_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_unary_out_max_out(self, out);
}
at::Tensor fmax(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_fmax(self, other);
}
at::Tensor & fmax_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_fmax_out_out(self, other, out);
}
at::Tensor & fmax_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_fmax_out_out(self, other, out);
}
at::Tensor maximum(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_maximum(self, other);
}
at::Tensor & maximum_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_maximum_out_out(self, other, out);
}
at::Tensor & maximum_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_maximum_out_out(self, other, out);
}
at::Tensor minimum(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_minimum(self, other);
}
at::Tensor & minimum_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_minimum_out_out(self, other, out);
}
at::Tensor & minimum_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_minimum_out_out(self, other, out);
}
::std::tuple<at::Tensor,at::Tensor> sort(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending) {
return wrapper_CPU_sort_stable(self, stable, dim, descending);
}
::std::tuple<at::Tensor &,at::Tensor &> sort_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending) {
return wrapper_CPU_sort_out_values_stable(self, stable, dim, descending, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> sort_outf(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending, at::Tensor & values, at::Tensor & indices) {
return wrapper_CPU_sort_out_values_stable(self, stable, dim, descending, values, indices);
}
at::Tensor argsort(const at::Tensor & self, bool stable, int64_t dim, bool descending) {
return wrapper_CPU_stable_argsort(self, stable, dim, descending);
}
::std::tuple<at::Tensor,at::Tensor> topk(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) {
return wrapper_CPU_topk(self, k, dim, largest, sorted);
}
::std::tuple<at::Tensor,at::Tensor> topk_symint(const at::Tensor & self, c10::SymInt k, int64_t dim, bool largest, bool sorted) {
return wrapper_CPU_topk(self, k.guard_int(__FILE__, __LINE__), dim, largest, sorted);
}
::std::tuple<at::Tensor &,at::Tensor &> topk_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) {
return wrapper_CPU_topk_out_values(self, k, dim, largest, sorted, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> topk_outf(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted, at::Tensor & values, at::Tensor & indices) {
return wrapper_CPU_topk_out_values(self, k, dim, largest, sorted, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> topk_symint_out(at::Tensor & values, at::Tensor & indices, const at::Tensor & self, c10::SymInt k, int64_t dim, bool largest, bool sorted) {
return wrapper_CPU_topk_out_values(self, k.guard_int(__FILE__, __LINE__), dim, largest, sorted, values, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> topk_symint_outf(const at::Tensor & self, c10::SymInt k, int64_t dim, bool largest, bool sorted, at::Tensor & values, at::Tensor & indices) {
return wrapper_CPU_topk_out_values(self, k.guard_int(__FILE__, __LINE__), dim, largest, sorted, values, indices);
}
at::Tensor all(const at::Tensor & self) {
return wrapper_CPU_all(self);
}
at::Tensor & all_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_all_out_all_out(self, out);
}
at::Tensor & all_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_all_out_all_out(self, out);
}
at::Tensor any(const at::Tensor & self) {
return wrapper_CPU_any(self);
}
at::Tensor & any_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_any_out_all_out(self, out);
}
at::Tensor & any_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_any_out_all_out(self, out);
}
at::Tensor renorm(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
return wrapper_CPU_renorm(self, p, dim, maxnorm);
}
at::Tensor & renorm_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
return wrapper_CPU_renorm_out_out(self, p, dim, maxnorm, out);
}
at::Tensor & renorm_outf(const at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm, at::Tensor & out) {
return wrapper_CPU_renorm_out_out(self, p, dim, maxnorm, out);
}
at::Tensor & renorm_(at::Tensor & self, const at::Scalar & p, int64_t dim, const at::Scalar & maxnorm) {
return wrapper_CPU_renorm_(self, p, dim, maxnorm);
}
at::Tensor unfold(const at::Tensor & self, int64_t dimension, int64_t size, int64_t step) {
return wrapper_CPU__unfold(self, dimension, size, step);
}
at::Tensor unfold_backward(const at::Tensor & grad_in, at::IntArrayRef input_sizes, int64_t dim, int64_t size, int64_t step) {
return wrapper_CPU__unfold_backward(grad_in, c10::fromIntArrayRefSlow(input_sizes), dim, size, step);
}
at::Tensor unfold_backward_symint(const at::Tensor & grad_in, c10::SymIntArrayRef input_sizes, int64_t dim, int64_t size, int64_t step) {
return wrapper_CPU__unfold_backward(grad_in, input_sizes, dim, size, step);
}
bool equal(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU__equal(self, other);
}
at::Tensor pow(const at::Tensor & self, const at::Tensor & exponent) {
return wrapper_CPU_pow_Tensor_Tensor(self, exponent);
}
at::Tensor & pow_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & exponent) {
return wrapper_CPU_pow_out_Tensor_Tensor_out(self, exponent, out);
}
at::Tensor & pow_outf(const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
return wrapper_CPU_pow_out_Tensor_Tensor_out(self, exponent, out);
}
at::Tensor & pow_(at::Tensor & self, const at::Tensor & exponent) {
return wrapper_CPU_pow__Tensor(self, exponent);
}
at::Tensor pow(const at::Scalar & self, const at::Tensor & exponent) {
return wrapper_CPU_pow_Scalar(self, exponent);
}
at::Tensor & pow_out(at::Tensor & out, const at::Scalar & self, const at::Tensor & exponent) {
return wrapper_CPU_pow_out_Scalar_out(self, exponent, out);
}
at::Tensor & pow_outf(const at::Scalar & self, const at::Tensor & exponent, at::Tensor & out) {
return wrapper_CPU_pow_out_Scalar_out(self, exponent, out);
}
at::Tensor pow(const at::Tensor & self, const at::Scalar & exponent) {
return wrapper_CPU_pow_Tensor_Scalar(self, exponent);
}
at::Tensor & pow_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & exponent) {
return wrapper_CPU_pow_out_Tensor_Scalar_out(self, exponent, out);
}
at::Tensor & pow_outf(const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
return wrapper_CPU_pow_out_Tensor_Scalar_out(self, exponent, out);
}
at::Tensor & pow_(at::Tensor & self, const at::Scalar & exponent) {
return wrapper_CPU_pow__Scalar(self, exponent);
}
at::Tensor & normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
return wrapper_CPU__normal_(self, mean, std, generator);
}
at::Tensor normal(const at::Tensor & mean, double std, c10::optional<at::Generator> generator) {
return wrapper_CPU_Tensor_float_normal(mean, std, generator);
}
at::Tensor & normal_out(at::Tensor & out, const at::Tensor & mean, double std, c10::optional<at::Generator> generator) {
return wrapper_CPU_Tensor_float_out_normal_out(mean, std, generator, out);
}
at::Tensor & normal_outf(const at::Tensor & mean, double std, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CPU_Tensor_float_out_normal_out(mean, std, generator, out);
}
at::Tensor normal(double mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
return wrapper_CPU_float_Tensor_normal(mean, std, generator);
}
at::Tensor & normal_out(at::Tensor & out, double mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
return wrapper_CPU_float_Tensor_out_normal_out(mean, std, generator, out);
}
at::Tensor & normal_outf(double mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CPU_float_Tensor_out_normal_out(mean, std, generator, out);
}
at::Tensor normal(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
return wrapper_CPU_Tensor_Tensor_normal(mean, std, generator);
}
at::Tensor & normal_out(at::Tensor & out, const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
return wrapper_CPU_Tensor_Tensor_out_normal_out(mean, std, generator, out);
}
at::Tensor & normal_outf(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CPU_Tensor_Tensor_out_normal_out(mean, std, generator, out);
}
void _amp_foreach_non_finite_check_and_unscale_(at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale) {
return wrapper_CPU___amp_foreach_non_finite_check_and_unscale_(self, found_inf, inv_scale);
}
at::Tensor & _amp_update_scale_(at::Tensor & self, at::Tensor & growth_tracker, const at::Tensor & found_inf, double scale_growth_factor, double scale_backoff_factor, int64_t growth_interval) {
return wrapper_CPU___amp_update_scale_(self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
}
::std::vector<at::Tensor> _foreach_add(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_add(self, scalar);
}
void _foreach_add_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_add_(self, scalar);
}
::std::vector<at::Tensor> _foreach_add(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
return wrapper_CPU_List__foreach_add(self, other, alpha);
}
void _foreach_add_(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
return wrapper_CPU_List__foreach_add_(self, other, alpha);
}
::std::vector<at::Tensor> _foreach_add(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_add(self, scalars);
}
void _foreach_add_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_add_(self, scalars);
}
::std::vector<at::Tensor> _foreach_add(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_Tensor__foreach_add(self, other, alpha);
}
void _foreach_add_(at::TensorList self, const at::Tensor & other, const at::Scalar & alpha) {
return wrapper_CPU_Tensor__foreach_add_(self, other, alpha);
}
::std::vector<at::Tensor> _foreach_sub(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_sub(self, scalar);
}
void _foreach_sub_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_sub_(self, scalar);
}
::std::vector<at::Tensor> _foreach_sub(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
return wrapper_CPU_List__foreach_sub(self, other, alpha);
}
void _foreach_sub_(at::TensorList self, at::TensorList other, const at::Scalar & alpha) {
return wrapper_CPU_List__foreach_sub_(self, other, alpha);
}
::std::vector<at::Tensor> _foreach_sub(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_sub(self, scalars);
}
void _foreach_sub_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_sub_(self, scalars);
}
::std::vector<at::Tensor> _foreach_mul(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_mul(self, scalar);
}
void _foreach_mul_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_mul_(self, scalar);
}
::std::vector<at::Tensor> _foreach_mul(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_mul(self, other);
}
void _foreach_mul_(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_mul_(self, other);
}
::std::vector<at::Tensor> _foreach_mul(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_mul(self, scalars);
}
void _foreach_mul_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_mul_(self, scalars);
}
::std::vector<at::Tensor> _foreach_mul(at::TensorList self, const at::Tensor & other) {
return wrapper_CPU_Tensor__foreach_mul(self, other);
}
void _foreach_mul_(at::TensorList self, const at::Tensor & other) {
return wrapper_CPU_Tensor__foreach_mul_(self, other);
}
::std::vector<at::Tensor> _foreach_div(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_div(self, scalar);
}
void _foreach_div_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_div_(self, scalar);
}
::std::vector<at::Tensor> _foreach_div(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_div(self, other);
}
void _foreach_div_(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_div_(self, other);
}
::std::vector<at::Tensor> _foreach_div(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_div(self, scalars);
}
void _foreach_div_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_div_(self, scalars);
}
::std::vector<at::Tensor> _foreach_div(at::TensorList self, const at::Tensor & other) {
return wrapper_CPU_Tensor__foreach_div(self, other);
}
void _foreach_div_(at::TensorList self, const at::Tensor & other) {
return wrapper_CPU_Tensor__foreach_div_(self, other);
}
::std::vector<at::Tensor> _foreach_clamp_max(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_clamp_max(self, scalar);
}
void _foreach_clamp_max_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_clamp_max_(self, scalar);
}
::std::vector<at::Tensor> _foreach_clamp_max(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_clamp_max(self, other);
}
void _foreach_clamp_max_(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_clamp_max_(self, other);
}
::std::vector<at::Tensor> _foreach_clamp_max(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_clamp_max(self, scalars);
}
void _foreach_clamp_max_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_clamp_max_(self, scalars);
}
::std::vector<at::Tensor> _foreach_clamp_min(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_clamp_min(self, scalar);
}
void _foreach_clamp_min_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_clamp_min_(self, scalar);
}
::std::vector<at::Tensor> _foreach_clamp_min(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_clamp_min(self, other);
}
void _foreach_clamp_min_(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_clamp_min_(self, other);
}
::std::vector<at::Tensor> _foreach_clamp_min(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_clamp_min(self, scalars);
}
void _foreach_clamp_min_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_clamp_min_(self, scalars);
}
::std::vector<at::Tensor> _foreach_maximum(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_maximum(self, scalar);
}
void _foreach_maximum_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_maximum_(self, scalar);
}
::std::vector<at::Tensor> _foreach_maximum(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_maximum(self, other);
}
void _foreach_maximum_(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_maximum_(self, other);
}
::std::vector<at::Tensor> _foreach_maximum(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_maximum(self, scalars);
}
void _foreach_maximum_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_maximum_(self, scalars);
}
::std::vector<at::Tensor> _foreach_minimum(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_minimum(self, scalar);
}
void _foreach_minimum_(at::TensorList self, const at::Scalar & scalar) {
return wrapper_CPU_Scalar__foreach_minimum_(self, scalar);
}
::std::vector<at::Tensor> _foreach_minimum(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_minimum(self, other);
}
void _foreach_minimum_(at::TensorList self, at::TensorList other) {
return wrapper_CPU_List__foreach_minimum_(self, other);
}
::std::vector<at::Tensor> _foreach_minimum(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_minimum(self, scalars);
}
void _foreach_minimum_(at::TensorList self, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_minimum_(self, scalars);
}
::std::vector<at::Tensor> _foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
return wrapper_CPU_Scalar__foreach_addcdiv(self, tensor1, tensor2, value);
}
void _foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
return wrapper_CPU_Scalar__foreach_addcdiv_(self, tensor1, tensor2, value);
}
::std::vector<at::Tensor> _foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_addcdiv(self, tensor1, tensor2, scalars);
}
void _foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_addcdiv_(self, tensor1, tensor2, scalars);
}
::std::vector<at::Tensor> _foreach_addcdiv(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
return wrapper_CPU_Tensor__foreach_addcdiv(self, tensor1, tensor2, scalars);
}
void _foreach_addcdiv_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
return wrapper_CPU_Tensor__foreach_addcdiv_(self, tensor1, tensor2, scalars);
}
::std::vector<at::Tensor> _foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
return wrapper_CPU_Scalar__foreach_addcmul(self, tensor1, tensor2, value);
}
void _foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Scalar & value) {
return wrapper_CPU_Scalar__foreach_addcmul_(self, tensor1, tensor2, value);
}
::std::vector<at::Tensor> _foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_addcmul(self, tensor1, tensor2, scalars);
}
void _foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, at::ArrayRef<at::Scalar> scalars) {
return wrapper_CPU_ScalarList__foreach_addcmul_(self, tensor1, tensor2, scalars);
}
::std::vector<at::Tensor> _foreach_addcmul(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
return wrapper_CPU_Tensor__foreach_addcmul(self, tensor1, tensor2, scalars);
}
void _foreach_addcmul_(at::TensorList self, at::TensorList tensor1, at::TensorList tensor2, const at::Tensor & scalars) {
return wrapper_CPU_Tensor__foreach_addcmul_(self, tensor1, tensor2, scalars);
}
::std::vector<at::Tensor> _foreach_abs(at::TensorList self) {
return wrapper_CPU___foreach_abs(self);
}
void _foreach_abs_(at::TensorList self) {
return wrapper_CPU___foreach_abs_(self);
}
::std::vector<at::Tensor> _foreach_acos(at::TensorList self) {
return wrapper_CPU___foreach_acos(self);
}
void _foreach_acos_(at::TensorList self) {
return wrapper_CPU___foreach_acos_(self);
}
::std::vector<at::Tensor> _foreach_asin(at::TensorList self) {
return wrapper_CPU___foreach_asin(self);
}
void _foreach_asin_(at::TensorList self) {
return wrapper_CPU___foreach_asin_(self);
}
::std::vector<at::Tensor> _foreach_atan(at::TensorList self) {
return wrapper_CPU___foreach_atan(self);
}
void _foreach_atan_(at::TensorList self) {
return wrapper_CPU___foreach_atan_(self);
}
::std::vector<at::Tensor> _foreach_ceil(at::TensorList self) {
return wrapper_CPU___foreach_ceil(self);
}
void _foreach_ceil_(at::TensorList self) {
return wrapper_CPU___foreach_ceil_(self);
}
::std::vector<at::Tensor> _foreach_cos(at::TensorList self) {
return wrapper_CPU___foreach_cos(self);
}
void _foreach_cos_(at::TensorList self) {
return wrapper_CPU___foreach_cos_(self);
}
::std::vector<at::Tensor> _foreach_cosh(at::TensorList self) {
return wrapper_CPU___foreach_cosh(self);
}
void _foreach_cosh_(at::TensorList self) {
return wrapper_CPU___foreach_cosh_(self);
}
::std::vector<at::Tensor> _foreach_erf(at::TensorList self) {
return wrapper_CPU___foreach_erf(self);
}
void _foreach_erf_(at::TensorList self) {
return wrapper_CPU___foreach_erf_(self);
}
::std::vector<at::Tensor> _foreach_erfc(at::TensorList self) {
return wrapper_CPU___foreach_erfc(self);
}
void _foreach_erfc_(at::TensorList self) {
return wrapper_CPU___foreach_erfc_(self);
}
::std::vector<at::Tensor> _foreach_exp(at::TensorList self) {
return wrapper_CPU___foreach_exp(self);
}
void _foreach_exp_(at::TensorList self) {
return wrapper_CPU___foreach_exp_(self);
}
::std::vector<at::Tensor> _foreach_expm1(at::TensorList self) {
return wrapper_CPU___foreach_expm1(self);
}
void _foreach_expm1_(at::TensorList self) {
return wrapper_CPU___foreach_expm1_(self);
}
::std::vector<at::Tensor> _foreach_floor(at::TensorList self) {
return wrapper_CPU___foreach_floor(self);
}
void _foreach_floor_(at::TensorList self) {
return wrapper_CPU___foreach_floor_(self);
}
::std::vector<at::Tensor> _foreach_frac(at::TensorList self) {
return wrapper_CPU___foreach_frac(self);
}
void _foreach_frac_(at::TensorList self) {
return wrapper_CPU___foreach_frac_(self);
}
::std::vector<at::Tensor> _foreach_lerp(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
return wrapper_CPU_List__foreach_lerp(self, tensors1, weights);
}
void _foreach_lerp_(at::TensorList self, at::TensorList tensors1, at::TensorList weights) {
return wrapper_CPU_List__foreach_lerp_(self, tensors1, weights);
}
::std::vector<at::Tensor> _foreach_lerp(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
return wrapper_CPU_Scalar__foreach_lerp(self, tensors1, weight);
}
void _foreach_lerp_(at::TensorList self, at::TensorList tensors1, const at::Scalar & weight) {
return wrapper_CPU_Scalar__foreach_lerp_(self, tensors1, weight);
}
::std::vector<at::Tensor> _foreach_lgamma(at::TensorList self) {
return wrapper_CPU___foreach_lgamma(self);
}
void _foreach_lgamma_(at::TensorList self) {
return wrapper_CPU___foreach_lgamma_(self);
}
::std::vector<at::Tensor> _foreach_log(at::TensorList self) {
return wrapper_CPU___foreach_log(self);
}
void _foreach_log_(at::TensorList self) {
return wrapper_CPU___foreach_log_(self);
}
::std::vector<at::Tensor> _foreach_log10(at::TensorList self) {
return wrapper_CPU___foreach_log10(self);
}
void _foreach_log10_(at::TensorList self) {
return wrapper_CPU___foreach_log10_(self);
}
::std::vector<at::Tensor> _foreach_log1p(at::TensorList self) {
return wrapper_CPU___foreach_log1p(self);
}
void _foreach_log1p_(at::TensorList self) {
return wrapper_CPU___foreach_log1p_(self);
}
::std::vector<at::Tensor> _foreach_log2(at::TensorList self) {
return wrapper_CPU___foreach_log2(self);
}
void _foreach_log2_(at::TensorList self) {
return wrapper_CPU___foreach_log2_(self);
}
::std::vector<at::Tensor> _foreach_neg(at::TensorList self) {
return wrapper_CPU___foreach_neg(self);
}
void _foreach_neg_(at::TensorList self) {
return wrapper_CPU___foreach_neg_(self);
}
::std::vector<at::Tensor> _foreach_norm(at::TensorList self, const at::Scalar & ord) {
return wrapper_CPU_Scalar__foreach_norm(self, ord);
}
::std::vector<at::Tensor> _foreach_pow(at::TensorList self, at::TensorList exponent) {
return wrapper_CPU_List__foreach_pow(self, exponent);
}
void _foreach_pow_(at::TensorList self, at::TensorList exponent) {
return wrapper_CPU_List__foreach_pow_(self, exponent);
}
::std::vector<at::Tensor> _foreach_pow(at::TensorList self, const at::Scalar & exponent) {
return wrapper_CPU_Scalar__foreach_pow(self, exponent);
}
void _foreach_pow_(at::TensorList self, const at::Scalar & exponent) {
return wrapper_CPU_Scalar__foreach_pow_(self, exponent);
}
::std::vector<at::Tensor> _foreach_pow(at::TensorList self, at::ArrayRef<at::Scalar> exponent) {
return wrapper_CPU_ScalarList__foreach_pow(self, exponent);
}
void _foreach_pow_(at::TensorList self, at::ArrayRef<at::Scalar> exponent) {
return wrapper_CPU_ScalarList__foreach_pow_(self, exponent);
}
::std::vector<at::Tensor> _foreach_pow(const at::Scalar & self, at::TensorList exponent) {
return wrapper_CPU_ScalarAndTensor__foreach_pow(self, exponent);
}
::std::vector<at::Tensor> _foreach_reciprocal(at::TensorList self) {
return wrapper_CPU___foreach_reciprocal(self);
}
void _foreach_reciprocal_(at::TensorList self) {
return wrapper_CPU___foreach_reciprocal_(self);
}
::std::vector<at::Tensor> _foreach_round(at::TensorList self) {
return wrapper_CPU___foreach_round(self);
}
void _foreach_round_(at::TensorList self) {
return wrapper_CPU___foreach_round_(self);
}
::std::vector<at::Tensor> _foreach_sigmoid(at::TensorList self) {
return wrapper_CPU___foreach_sigmoid(self);
}
void _foreach_sigmoid_(at::TensorList self) {
return wrapper_CPU___foreach_sigmoid_(self);
}
::std::vector<at::Tensor> _foreach_sign(at::TensorList self) {
return wrapper_CPU___foreach_sign(self);
}
void _foreach_sign_(at::TensorList self) {
return wrapper_CPU___foreach_sign_(self);
}
::std::vector<at::Tensor> _foreach_sin(at::TensorList self) {
return wrapper_CPU___foreach_sin(self);
}
void _foreach_sin_(at::TensorList self) {
return wrapper_CPU___foreach_sin_(self);
}
::std::vector<at::Tensor> _foreach_sinh(at::TensorList self) {
return wrapper_CPU___foreach_sinh(self);
}
void _foreach_sinh_(at::TensorList self) {
return wrapper_CPU___foreach_sinh_(self);
}
::std::vector<at::Tensor> _foreach_sqrt(at::TensorList self) {
return wrapper_CPU___foreach_sqrt(self);
}
void _foreach_sqrt_(at::TensorList self) {
return wrapper_CPU___foreach_sqrt_(self);
}
::std::vector<at::Tensor> _foreach_tan(at::TensorList self) {
return wrapper_CPU___foreach_tan(self);
}
void _foreach_tan_(at::TensorList self) {
return wrapper_CPU___foreach_tan_(self);
}
::std::vector<at::Tensor> _foreach_tanh(at::TensorList self) {
return wrapper_CPU___foreach_tanh(self);
}
void _foreach_tanh_(at::TensorList self) {
return wrapper_CPU___foreach_tanh_(self);
}
::std::vector<at::Tensor> _foreach_trunc(at::TensorList self) {
return wrapper_CPU___foreach_trunc(self);
}
void _foreach_trunc_(at::TensorList self) {
return wrapper_CPU___foreach_trunc_(self);
}
void _foreach_zero_(at::TensorList self) {
return wrapper_CPU___foreach_zero_(self);
}
void _foreach_copy_(at::TensorList self, at::TensorList src, bool non_blocking) {
return wrapper_CPU___foreach_copy_(self, src, non_blocking);
}
at::Tensor bucketize(const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right) {
return wrapper_CPU_Tensor_bucketize(self, boundaries, out_int32, right);
}
at::Tensor & bucketize_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right) {
return wrapper_CPU_Tensor_out_bucketize_out(self, boundaries, out_int32, right, out);
}
at::Tensor & bucketize_outf(const at::Tensor & self, const at::Tensor & boundaries, bool out_int32, bool right, at::Tensor & out) {
return wrapper_CPU_Tensor_out_bucketize_out(self, boundaries, out_int32, right, out);
}
at::Tensor bucketize(const at::Scalar & self, const at::Tensor & boundaries, bool out_int32, bool right) {
return wrapper_CPU_Scalar_bucketize(self, boundaries, out_int32, right);
}
at::Tensor searchsorted(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
return wrapper_CPU_Tensor_searchsorted(sorted_sequence, self, out_int32, right, side, sorter);
}
at::Tensor & searchsorted_out(at::Tensor & out, const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
return wrapper_CPU_Tensor_out_searchsorted_out(sorted_sequence, self, out_int32, right, side, sorter, out);
}
at::Tensor & searchsorted_outf(const at::Tensor & sorted_sequence, const at::Tensor & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
return wrapper_CPU_Tensor_out_searchsorted_out(sorted_sequence, self, out_int32, right, side, sorter, out);
}
at::Tensor searchsorted(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
return wrapper_CPU_Scalar_searchsorted(sorted_sequence, self, out_int32, right, side, sorter);
}
at::Tensor & searchsorted_out(at::Tensor & out, const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter) {
return wrapper_CPU_Scalar_out_searchsorted_out(sorted_sequence, self, out_int32, right, side, sorter, out);
}
at::Tensor & searchsorted_outf(const at::Tensor & sorted_sequence, const at::Scalar & self, bool out_int32, bool right, c10::optional<c10::string_view> side, const c10::optional<at::Tensor> & sorter, at::Tensor & out) {
return wrapper_CPU_Scalar_out_searchsorted_out(sorted_sequence, self, out_int32, right, side, sorter, out);
}
at::Tensor _convert_indices_from_coo_to_csr(const at::Tensor & self, int64_t size, bool out_int32) {
return wrapper_CPU__convert_indices_from_coo_to_csr(self, size, out_int32);
}
at::Tensor & _convert_indices_from_coo_to_csr_out(at::Tensor & out, const at::Tensor & self, int64_t size, bool out_int32) {
return wrapper_CPU__convert_indices_from_coo_to_csr_out_out(self, size, out_int32, out);
}
at::Tensor & _convert_indices_from_coo_to_csr_outf(const at::Tensor & self, int64_t size, bool out_int32, at::Tensor & out) {
return wrapper_CPU__convert_indices_from_coo_to_csr_out_out(self, size, out_int32, out);
}
at::Tensor _convert_indices_from_csr_to_coo(const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose) {
return wrapper_CPU__convert_indices_from_csr_to_coo(crow_indices, col_indices, out_int32, transpose);
}
at::Tensor & _convert_indices_from_csr_to_coo_out(at::Tensor & out, const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose) {
return wrapper_CPU__convert_indices_from_csr_to_coo_out_out(crow_indices, col_indices, out_int32, transpose, out);
}
at::Tensor & _convert_indices_from_csr_to_coo_outf(const at::Tensor & crow_indices, const at::Tensor & col_indices, bool out_int32, bool transpose, at::Tensor & out) {
return wrapper_CPU__convert_indices_from_csr_to_coo_out_out(crow_indices, col_indices, out_int32, transpose, out);
}
at::Tensor mse_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CPU_mse_loss(self, target, reduction);
}
at::Tensor & mse_loss_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CPU_mse_loss_out_out(self, target, reduction, out);
}
at::Tensor & mse_loss_outf(const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & out) {
return wrapper_CPU_mse_loss_out_out(self, target, reduction, out);
}
at::Tensor mse_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CPU__mse_loss_backward(grad_output, self, target, reduction);
}
at::Tensor & mse_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CPU_grad_input_mse_loss_backward_out(grad_output, self, target, reduction, grad_input);
}
at::Tensor & mse_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_mse_loss_backward_out(grad_output, self, target, reduction, grad_input);
}
at::Tensor multi_margin_loss(const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CPU__multi_margin_loss(self, target, p, margin, weight, reduction);
}
at::Tensor & multi_margin_loss_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CPU_out_multi_margin_loss_out(self, target, p, margin, weight, reduction, out);
}
at::Tensor & multi_margin_loss_outf(const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
return wrapper_CPU_out_multi_margin_loss_out(self, target, p, margin, weight, reduction, out);
}
at::Tensor multi_margin_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CPU__multi_margin_loss_backward(grad_output, self, target, p, margin, weight, reduction);
}
at::Tensor & multi_margin_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction) {
return wrapper_CPU_grad_input_multi_margin_loss_backward_out(grad_output, self, target, p, margin, weight, reduction, grad_input);
}
at::Tensor & multi_margin_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const at::Scalar & p, const at::Scalar & margin, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_multi_margin_loss_backward_out(grad_output, self, target, p, margin, weight, reduction, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> multilabel_margin_loss_forward(const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CPU__multilabel_margin_loss_forward(self, target, reduction);
}
::std::tuple<at::Tensor &,at::Tensor &> multilabel_margin_loss_forward_out(at::Tensor & output, at::Tensor & is_target, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
return wrapper_CPU_output_multilabel_margin_loss_forward_out(self, target, reduction, output, is_target);
}
::std::tuple<at::Tensor &,at::Tensor &> multilabel_margin_loss_forward_outf(const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & output, at::Tensor & is_target) {
return wrapper_CPU_output_multilabel_margin_loss_forward_out(self, target, reduction, output, is_target);
}
at::Tensor multilabel_margin_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target) {
return wrapper_CPU__multilabel_margin_loss_backward(grad_output, self, target, reduction, is_target);
}
at::Tensor & multilabel_margin_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target) {
return wrapper_CPU_grad_input_multilabel_margin_loss_backward_out(grad_output, self, target, reduction, is_target, grad_input);
}
at::Tensor & multilabel_margin_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, const at::Tensor & is_target, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_multilabel_margin_loss_backward_out(grad_output, self, target, reduction, is_target, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> nll_loss_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
return wrapper_CPU_nll_loss_forward(self, target, weight, reduction, ignore_index);
}
::std::tuple<at::Tensor,at::Tensor> nll_loss_forward_symint(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
return wrapper_CPU_nll_loss_forward(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__));
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss_forward_out(at::Tensor & output, at::Tensor & total_weight, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
return wrapper_CPU_nll_loss_forward_out_output(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss_forward_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, at::Tensor & output, at::Tensor & total_weight) {
return wrapper_CPU_nll_loss_forward_out_output(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss_forward_symint_out(at::Tensor & output, at::Tensor & total_weight, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
return wrapper_CPU_nll_loss_forward_out_output(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss_forward_symint_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, at::Tensor & output, at::Tensor & total_weight) {
return wrapper_CPU_nll_loss_forward_out_output(self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), output, total_weight);
}
at::Tensor nll_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
return wrapper_CPU_nll_loss_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
}
at::Tensor nll_loss_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
return wrapper_CPU_nll_loss_backward(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight);
}
at::Tensor & nll_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
return wrapper_CPU_nll_loss_backward_out_grad_input(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
return wrapper_CPU_nll_loss_backward_out_grad_input(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
return wrapper_CPU_nll_loss_backward_out_grad_input(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight, grad_input);
}
at::Tensor & nll_loss_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
return wrapper_CPU_nll_loss_backward_out_grad_input(grad_output, self, target, weight, reduction, ignore_index.guard_int(__FILE__, __LINE__), total_weight, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> nll_loss2d_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
return wrapper_CPU__nll_loss2d_forward(self, target, weight, reduction, ignore_index);
}
::std::tuple<at::Tensor,at::Tensor> nll_loss2d_forward_symint(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
return wrapper_CPU__nll_loss2d_forward(self, target, weight, reduction, ignore_index);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss2d_forward_out(at::Tensor & output, at::Tensor & total_weight, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
return wrapper_CPU_output_nll_loss2d_forward_out(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss2d_forward_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, at::Tensor & output, at::Tensor & total_weight) {
return wrapper_CPU_output_nll_loss2d_forward_out(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss2d_forward_symint_out(at::Tensor & output, at::Tensor & total_weight, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index) {
return wrapper_CPU_output_nll_loss2d_forward_out(self, target, weight, reduction, ignore_index, output, total_weight);
}
::std::tuple<at::Tensor &,at::Tensor &> nll_loss2d_forward_symint_outf(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, at::Tensor & output, at::Tensor & total_weight) {
return wrapper_CPU_output_nll_loss2d_forward_out(self, target, weight, reduction, ignore_index, output, total_weight);
}
at::Tensor nll_loss2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
return wrapper_CPU__nll_loss2d_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
}
at::Tensor nll_loss2d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
return wrapper_CPU__nll_loss2d_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
}
at::Tensor & nll_loss2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
return wrapper_CPU_grad_input_nll_loss2d_backward_out(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_nll_loss2d_backward_out(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight) {
return wrapper_CPU_grad_input_nll_loss2d_backward_out(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor & nll_loss2d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, c10::SymInt ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_nll_loss2d_backward_out(grad_output, self, target, weight, reduction, ignore_index, total_weight, grad_input);
}
at::Tensor smooth_l1_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
return wrapper_CPU_smooth_l1_loss(self, target, reduction, beta);
}
at::Tensor & smooth_l1_loss_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
return wrapper_CPU_smooth_l1_loss_out_out(self, target, reduction, beta, out);
}
at::Tensor & smooth_l1_loss_outf(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & out) {
return wrapper_CPU_smooth_l1_loss_out_out(self, target, reduction, beta, out);
}
at::Tensor & smooth_l1_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
return wrapper_CPU_grad_input_smooth_l1_loss_backward_out(grad_output, self, target, reduction, beta, grad_input);
}
at::Tensor & smooth_l1_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_smooth_l1_loss_backward_out(grad_output, self, target, reduction, beta, grad_input);
}
at::Tensor huber_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta) {
return wrapper_CPU__huber_loss(self, target, reduction, delta);
}
at::Tensor & huber_loss_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta) {
return wrapper_CPU_out_huber_loss_out(self, target, reduction, delta, out);
}
at::Tensor & huber_loss_outf(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta, at::Tensor & out) {
return wrapper_CPU_out_huber_loss_out(self, target, reduction, delta, out);
}
at::Tensor & huber_loss_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta) {
return wrapper_CPU_out_huber_loss_backward_out(grad_output, self, target, reduction, delta, grad_input);
}
at::Tensor & huber_loss_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double delta, at::Tensor & grad_input) {
return wrapper_CPU_out_huber_loss_backward_out(grad_output, self, target, reduction, delta, grad_input);
}
at::Tensor elu(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
return wrapper_CPU_elu(self, alpha, scale, input_scale);
}
at::Tensor & elu_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
return wrapper_CPU_elu_out_out(self, alpha, scale, input_scale, out);
}
at::Tensor & elu_outf(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, at::Tensor & out) {
return wrapper_CPU_elu_out_out(self, alpha, scale, input_scale, out);
}
at::Tensor & elu_(at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
return wrapper_CPU_elu_(self, alpha, scale, input_scale);
}
at::Tensor elu_backward(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
return wrapper_CPU_elu_backward(grad_output, alpha, scale, input_scale, is_result, self_or_result);
}
at::Tensor & elu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
return wrapper_CPU_elu_backward_out_grad_input(grad_output, alpha, scale, input_scale, is_result, self_or_result, grad_input);
}
at::Tensor & elu_backward_outf(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result, at::Tensor & grad_input) {
return wrapper_CPU_elu_backward_out_grad_input(grad_output, alpha, scale, input_scale, is_result, self_or_result, grad_input);
}
at::Tensor glu(const at::Tensor & self, int64_t dim) {
return wrapper_CPU_glu(self, dim);
}
at::Tensor & glu_out(at::Tensor & out, const at::Tensor & self, int64_t dim) {
return wrapper_CPU_glu_out_out(self, dim, out);
}
at::Tensor & glu_outf(const at::Tensor & self, int64_t dim, at::Tensor & out) {
return wrapper_CPU_glu_out_out(self, dim, out);
}
at::Tensor glu_backward(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim) {
return wrapper_CPU__glu_backward(grad_output, self, dim);
}
at::Tensor & glu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, int64_t dim) {
return wrapper_CPU_grad_input_glu_backward_out(grad_output, self, dim, grad_input);
}
at::Tensor & glu_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, int64_t dim, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_glu_backward_out(grad_output, self, dim, grad_input);
}
at::Tensor glu_jvp(const at::Tensor & glu, const at::Tensor & x, const at::Tensor & dx, int64_t dim) {
return wrapper_CPU__glu_jvp(glu, x, dx, dim);
}
at::Tensor glu_backward_jvp(const at::Tensor & grad_x, const at::Tensor & grad_glu, const at::Tensor & x, const at::Tensor & dgrad_glu, const at::Tensor & dx, int64_t dim) {
return wrapper_CPU__glu_backward_jvp(grad_x, grad_glu, x, dgrad_glu, dx, dim);
}
at::Tensor hardsigmoid(const at::Tensor & self) {
return wrapper_CPU_hardsigmoid(self);
}
at::Tensor & hardsigmoid_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_hardsigmoid_out_out(self, out);
}
at::Tensor & hardsigmoid_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_hardsigmoid_out_out(self, out);
}
at::Tensor & hardsigmoid_(at::Tensor & self) {
return wrapper_CPU_hardsigmoid_(self);
}
at::Tensor hardsigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CPU_hardsigmoid_backward(grad_output, self);
}
at::Tensor & hardsigmoid_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CPU_hardsigmoid_backward_out_grad_input(grad_output, self, grad_input);
}
at::Tensor & hardsigmoid_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
return wrapper_CPU_hardsigmoid_backward_out_grad_input(grad_output, self, grad_input);
}
at::Tensor hardtanh(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CPU__hardtanh(self, min_val, max_val);
}
at::Tensor & hardtanh_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CPU_out_hardtanh_out(self, min_val, max_val, out);
}
at::Tensor & hardtanh_outf(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & out) {
return wrapper_CPU_out_hardtanh_out(self, min_val, max_val, out);
}
at::Tensor & hardtanh_(at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CPU__hardtanh_(self, min_val, max_val);
}
at::Tensor hardtanh_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CPU__hardtanh_backward(grad_output, self, min_val, max_val);
}
at::Tensor & hardtanh_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
return wrapper_CPU_grad_input_hardtanh_backward_out(grad_output, self, min_val, max_val, grad_input);
}
at::Tensor & hardtanh_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_hardtanh_backward_out(grad_output, self, min_val, max_val, grad_input);
}
at::Tensor hardswish(const at::Tensor & self) {
return wrapper_CPU__hardswish(self);
}
at::Tensor & hardswish_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_out_hardswish_out(self, out);
}
at::Tensor & hardswish_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_out_hardswish_out(self, out);
}
at::Tensor & hardswish_(at::Tensor & self) {
return wrapper_CPU__hardswish_(self);
}
at::Tensor hardswish_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CPU__hardswish_backward(grad_output, self);
}
at::Tensor leaky_relu(const at::Tensor & self, const at::Scalar & negative_slope) {
return wrapper_CPU_leaky_relu(self, negative_slope);
}
at::Tensor & leaky_relu_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & negative_slope) {
return wrapper_CPU_leaky_relu_out_out(self, negative_slope, out);
}
at::Tensor & leaky_relu_outf(const at::Tensor & self, const at::Scalar & negative_slope, at::Tensor & out) {
return wrapper_CPU_leaky_relu_out_out(self, negative_slope, out);
}
at::Tensor & leaky_relu_(at::Tensor & self, const at::Scalar & negative_slope) {
return wrapper_CPU_leaky_relu_(self, negative_slope);
}
at::Tensor leaky_relu_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
return wrapper_CPU_leaky_relu_backward(grad_output, self, negative_slope, self_is_result);
}
at::Tensor & leaky_relu_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
return wrapper_CPU_leaky_relu_backward_out_grad_input(grad_output, self, negative_slope, self_is_result, grad_input);
}
at::Tensor & leaky_relu_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result, at::Tensor & grad_input) {
return wrapper_CPU_leaky_relu_backward_out_grad_input(grad_output, self, negative_slope, self_is_result, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> log_sigmoid_forward(const at::Tensor & self) {
return wrapper_CPU__log_sigmoid_forward(self);
}
::std::tuple<at::Tensor &,at::Tensor &> log_sigmoid_forward_out(at::Tensor & output, at::Tensor & buffer, const at::Tensor & self) {
return wrapper_CPU_output_log_sigmoid_forward_out(self, output, buffer);
}
::std::tuple<at::Tensor &,at::Tensor &> log_sigmoid_forward_outf(const at::Tensor & self, at::Tensor & output, at::Tensor & buffer) {
return wrapper_CPU_output_log_sigmoid_forward_out(self, output, buffer);
}
at::Tensor log_sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer) {
return wrapper_CPU__log_sigmoid_backward(grad_output, self, buffer);
}
at::Tensor & log_sigmoid_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer) {
return wrapper_CPU_grad_input_log_sigmoid_backward_out(grad_output, self, buffer, grad_input);
}
at::Tensor & log_sigmoid_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_log_sigmoid_backward_out(grad_output, self, buffer, grad_input);
}
at::Tensor rrelu_with_noise(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
return wrapper_CPU__rrelu_with_noise(self, noise, lower, upper, training, generator);
}
at::Tensor & rrelu_with_noise_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
return wrapper_CPU_out_rrelu_with_noise_out(self, noise, lower, upper, training, generator, out);
}
at::Tensor & rrelu_with_noise_outf(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator, at::Tensor & out) {
return wrapper_CPU_out_rrelu_with_noise_out(self, noise, lower, upper, training, generator, out);
}
at::Tensor & rrelu_with_noise_(at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
return wrapper_CPU__rrelu_with_noise_(self, noise, lower, upper, training, generator);
}
at::Tensor softplus(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
return wrapper_CPU_softplus(self, beta, threshold);
}
at::Tensor & softplus_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
return wrapper_CPU_softplus_out_out(self, beta, threshold, out);
}
at::Tensor & softplus_outf(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & out) {
return wrapper_CPU_softplus_out_out(self, beta, threshold, out);
}
at::Tensor softplus_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
return wrapper_CPU_softplus_backward(grad_output, self, beta, threshold);
}
at::Tensor & softplus_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
return wrapper_CPU_softplus_backward_out_grad_input(grad_output, self, beta, threshold, grad_input);
}
at::Tensor & softplus_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & grad_input) {
return wrapper_CPU_softplus_backward_out_grad_input(grad_output, self, beta, threshold, grad_input);
}
at::Tensor softshrink(const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CPU_softshrink(self, lambd);
}
at::Tensor & softshrink_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CPU_softshrink_out_out(self, lambd, out);
}
at::Tensor & softshrink_outf(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
return wrapper_CPU_softshrink_out_out(self, lambd, out);
}
at::Tensor softshrink_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CPU_softshrink_backward(grad_output, self, lambd);
}
at::Tensor & softshrink_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd) {
return wrapper_CPU_softshrink_backward_out_grad_input(grad_output, self, lambd, grad_input);
}
at::Tensor & softshrink_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
return wrapper_CPU_softshrink_backward_out_grad_input(grad_output, self, lambd, grad_input);
}
at::Tensor & adaptive_avg_pool2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CPU_out_adaptive_avg_pool2d_out(self, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & adaptive_avg_pool2d_outf(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out) {
return wrapper_CPU_out_adaptive_avg_pool2d_out(self, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & adaptive_avg_pool2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size) {
return wrapper_CPU_out_adaptive_avg_pool2d_out(self, output_size, out);
}
at::Tensor & adaptive_avg_pool2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
return wrapper_CPU_out_adaptive_avg_pool2d_out(self, output_size, out);
}
at::Tensor _adaptive_avg_pool2d(const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CPU___adaptive_avg_pool2d(self, c10::fromIntArrayRefSlow(output_size));
}
at::Tensor _adaptive_avg_pool2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size) {
return wrapper_CPU___adaptive_avg_pool2d(self, output_size);
}
at::Tensor _adaptive_avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CPU___adaptive_avg_pool2d_backward(grad_output, self);
}
at::Tensor & adaptive_avg_pool3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CPU_out_adaptive_avg_pool3d_out(self, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & adaptive_avg_pool3d_outf(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out) {
return wrapper_CPU_out_adaptive_avg_pool3d_out(self, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & adaptive_avg_pool3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size) {
return wrapper_CPU_out_adaptive_avg_pool3d_out(self, output_size, out);
}
at::Tensor & adaptive_avg_pool3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, at::Tensor & out) {
return wrapper_CPU_out_adaptive_avg_pool3d_out(self, output_size, out);
}
at::Tensor _adaptive_avg_pool3d(const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CPU___adaptive_avg_pool3d(self, c10::fromIntArrayRefSlow(output_size));
}
at::Tensor _adaptive_avg_pool3d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size) {
return wrapper_CPU___adaptive_avg_pool3d(self, output_size);
}
at::Tensor & adaptive_avg_pool3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CPU_grad_input_adaptive_avg_pool3d_backward_out(grad_output, self, grad_input);
}
at::Tensor & adaptive_avg_pool3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_adaptive_avg_pool3d_backward_out(grad_output, self, grad_input);
}
at::Tensor _adaptive_avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
return wrapper_CPU___adaptive_avg_pool3d_backward(grad_output, self);
}
::std::tuple<at::Tensor,at::Tensor> adaptive_max_pool2d(const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CPU_adaptive_max_pool2d(self, output_size);
}
::std::tuple<at::Tensor &,at::Tensor &> adaptive_max_pool2d_out(at::Tensor & out, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CPU_adaptive_max_pool2d_out_out(self, output_size, out, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> adaptive_max_pool2d_outf(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out, at::Tensor & indices) {
return wrapper_CPU_adaptive_max_pool2d_out_out(self, output_size, out, indices);
}
at::Tensor adaptive_max_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
return wrapper_CPU_adaptive_max_pool2d_backward(grad_output, self, indices);
}
at::Tensor & adaptive_max_pool2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
return wrapper_CPU_adaptive_max_pool2d_backward_out_grad_input(grad_output, self, indices, grad_input);
}
at::Tensor & adaptive_max_pool2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CPU_adaptive_max_pool2d_backward_out_grad_input(grad_output, self, indices, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> adaptive_max_pool3d(const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CPU_adaptive_max_pool3d(self, output_size);
}
::std::tuple<at::Tensor &,at::Tensor &> adaptive_max_pool3d_out(at::Tensor & out, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef output_size) {
return wrapper_CPU_adaptive_max_pool3d_out_out(self, output_size, out, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> adaptive_max_pool3d_outf(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out, at::Tensor & indices) {
return wrapper_CPU_adaptive_max_pool3d_out_out(self, output_size, out, indices);
}
at::Tensor adaptive_max_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
return wrapper_CPU_adaptive_max_pool3d_backward(grad_output, self, indices);
}
at::Tensor & adaptive_max_pool3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
return wrapper_CPU_adaptive_max_pool3d_backward_out_grad_input(grad_output, self, indices, grad_input);
}
at::Tensor & adaptive_max_pool3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CPU_adaptive_max_pool3d_backward_out_grad_input(grad_output, self, indices, grad_input);
}
at::Tensor avg_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CPU_avg_pool2d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
at::Tensor & avg_pool2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CPU_avg_pool2d_out_out(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}
at::Tensor & avg_pool2d_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
return wrapper_CPU_avg_pool2d_out_out(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}
at::Tensor avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CPU_avg_pool2d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
at::Tensor & avg_pool2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CPU_avg_pool2d_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}
at::Tensor & avg_pool2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
return wrapper_CPU_avg_pool2d_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}
at::Tensor avg_pool3d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CPU_avg_pool3d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
at::Tensor & avg_pool3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CPU_avg_pool3d_out_out(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}
at::Tensor & avg_pool3d_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
return wrapper_CPU_avg_pool3d_out_out(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, out);
}
at::Tensor avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CPU_avg_pool3d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}
at::Tensor & avg_pool3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
return wrapper_CPU_avg_pool3d_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}
at::Tensor & avg_pool3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
return wrapper_CPU_avg_pool3d_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> fractional_max_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
return wrapper_CPU_fractional_max_pool2d(self, kernel_size, output_size, random_samples);
}
::std::tuple<at::Tensor &,at::Tensor &> fractional_max_pool2d_out(at::Tensor & output, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
return wrapper_CPU_fractional_max_pool2d_out_output(self, kernel_size, output_size, random_samples, output, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> fractional_max_pool2d_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples, at::Tensor & output, at::Tensor & indices) {
return wrapper_CPU_fractional_max_pool2d_out_output(self, kernel_size, output_size, random_samples, output, indices);
}
at::Tensor fractional_max_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
return wrapper_CPU_fractional_max_pool2d_backward(grad_output, self, kernel_size, output_size, indices);
}
at::Tensor & fractional_max_pool2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
return wrapper_CPU_fractional_max_pool2d_backward_out_grad_input(grad_output, self, kernel_size, output_size, indices, grad_input);
}
at::Tensor & fractional_max_pool2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CPU_fractional_max_pool2d_backward_out_grad_input(grad_output, self, kernel_size, output_size, indices, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> fractional_max_pool3d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
return wrapper_CPU_fractional_max_pool3d(self, kernel_size, output_size, random_samples);
}
::std::tuple<at::Tensor &,at::Tensor &> fractional_max_pool3d_out(at::Tensor & output, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples) {
return wrapper_CPU_fractional_max_pool3d_out_output(self, kernel_size, output_size, random_samples, output, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> fractional_max_pool3d_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & random_samples, at::Tensor & output, at::Tensor & indices) {
return wrapper_CPU_fractional_max_pool3d_out_output(self, kernel_size, output_size, random_samples, output, indices);
}
at::Tensor fractional_max_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
return wrapper_CPU__fractional_max_pool3d_backward(grad_output, self, kernel_size, output_size, indices);
}
at::Tensor & fractional_max_pool3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices) {
return wrapper_CPU_grad_input_fractional_max_pool3d_backward_out(grad_output, self, kernel_size, output_size, indices, grad_input);
}
at::Tensor & fractional_max_pool3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef output_size, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_fractional_max_pool3d_backward_out(grad_output, self, kernel_size, output_size, indices, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> max_pool2d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
return wrapper_CPU_max_pool2d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
}
::std::tuple<at::Tensor &,at::Tensor &> max_pool2d_with_indices_out(at::Tensor & out, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
return wrapper_CPU_max_pool2d_with_indices_out_out(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> max_pool2d_with_indices_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
return wrapper_CPU_max_pool2d_with_indices_out_out(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
at::Tensor max_pool2d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
return wrapper_CPU_max_pool2d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}
at::Tensor & max_pool2d_with_indices_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
return wrapper_CPU_max_pool2d_with_indices_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
at::Tensor & max_pool2d_with_indices_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CPU_max_pool2d_with_indices_backward_out_grad_input(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
::std::tuple<at::Tensor,at::Tensor> max_pool3d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
return wrapper_CPU__max_pool3d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
}
::std::tuple<at::Tensor &,at::Tensor &> max_pool3d_with_indices_out(at::Tensor & out, at::Tensor & indices, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
return wrapper_CPU_out_max_pool3d_with_indices_out(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
::std::tuple<at::Tensor &,at::Tensor &> max_pool3d_with_indices_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
return wrapper_CPU_out_max_pool3d_with_indices_out(self, kernel_size, stride, padding, dilation, ceil_mode, out, indices);
}
at::Tensor max_pool3d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
return wrapper_CPU__max_pool3d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}
at::Tensor & max_pool3d_with_indices_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
return wrapper_CPU_grad_input_max_pool3d_with_indices_backward_out(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
at::Tensor & max_pool3d_with_indices_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_max_pool3d_with_indices_backward_out(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices, grad_input);
}
at::Tensor max_unpool2d(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size) {
return wrapper_CPU__max_unpool2d(self, indices, c10::fromIntArrayRefSlow(output_size));
}
at::Tensor max_unpool2d_symint(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size) {
return wrapper_CPU__max_unpool2d(self, indices, output_size);
}
at::Tensor & max_unpool2d_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size) {
return wrapper_CPU_out_max_unpool2d_out(self, indices, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & max_unpool2d_outf(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::Tensor & out) {
return wrapper_CPU_out_max_unpool2d_out(self, indices, c10::fromIntArrayRefSlow(output_size), out);
}
at::Tensor & max_unpool2d_symint_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size) {
return wrapper_CPU_out_max_unpool2d_out(self, indices, output_size, out);
}
at::Tensor & max_unpool2d_symint_outf(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::Tensor & out) {
return wrapper_CPU_out_max_unpool2d_out(self, indices, output_size, out);
}
at::Tensor max_unpool3d(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CPU__max_unpool3d(self, indices, c10::fromIntArrayRefSlow(output_size), stride, padding);
}
at::Tensor max_unpool3d_symint(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CPU__max_unpool3d(self, indices, output_size, stride, padding);
}
at::Tensor & max_unpool3d_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CPU_out_max_unpool3d_out(self, indices, c10::fromIntArrayRefSlow(output_size), stride, padding, out);
}
at::Tensor & max_unpool3d_outf(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_out_max_unpool3d_out(self, indices, c10::fromIntArrayRefSlow(output_size), stride, padding, out);
}
at::Tensor & max_unpool3d_symint_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CPU_out_max_unpool3d_out(self, indices, output_size, stride, padding, out);
}
at::Tensor & max_unpool3d_symint_outf(const at::Tensor & self, const at::Tensor & indices, c10::SymIntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_out_max_unpool3d_out(self, indices, output_size, stride, padding, out);
}
at::Tensor reflection_pad1d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_reflection_pad1d(self, padding);
}
at::Tensor reflection_pad1d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_reflection_pad1d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & reflection_pad1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_reflection_pad1d_out_out(self, padding, out);
}
at::Tensor & reflection_pad1d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_reflection_pad1d_out_out(self, padding, out);
}
at::Tensor & reflection_pad1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_reflection_pad1d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & reflection_pad1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_reflection_pad1d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor reflection_pad1d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_reflection_pad1d_backward(grad_output, self, padding);
}
at::Tensor reflection_pad1d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_reflection_pad1d_backward(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & reflection_pad1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_reflection_pad1d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad1d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_reflection_pad1d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_reflection_pad1d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor & reflection_pad1d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_reflection_pad1d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor reflection_pad2d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU__reflection_pad2d(self, c10::fromIntArrayRefSlow(padding));
}
at::Tensor reflection_pad2d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU__reflection_pad2d(self, padding);
}
at::Tensor & reflection_pad2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_out_reflection_pad2d_out(self, c10::fromIntArrayRefSlow(padding), out);
}
at::Tensor & reflection_pad2d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_out_reflection_pad2d_out(self, c10::fromIntArrayRefSlow(padding), out);
}
at::Tensor & reflection_pad2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_out_reflection_pad2d_out(self, padding, out);
}
at::Tensor & reflection_pad2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_out_reflection_pad2d_out(self, padding, out);
}
at::Tensor reflection_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU__reflection_pad2d_backward(grad_output, self, c10::fromIntArrayRefSlow(padding));
}
at::Tensor reflection_pad2d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU__reflection_pad2d_backward(grad_output, self, padding);
}
at::Tensor & reflection_pad2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_grad_input_reflection_pad2d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & reflection_pad2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_reflection_pad2d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & reflection_pad2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_grad_input_reflection_pad2d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad2d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_reflection_pad2d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor reflection_pad3d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_reflection_pad3d(self, padding);
}
at::Tensor reflection_pad3d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_reflection_pad3d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & reflection_pad3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_reflection_pad3d_out_out(self, padding, out);
}
at::Tensor & reflection_pad3d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_reflection_pad3d_out_out(self, padding, out);
}
at::Tensor & reflection_pad3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_reflection_pad3d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & reflection_pad3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_reflection_pad3d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor reflection_pad3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_reflection_pad3d_backward(grad_output, self, padding);
}
at::Tensor reflection_pad3d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_reflection_pad3d_backward(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & reflection_pad3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_reflection_pad3d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_reflection_pad3d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & reflection_pad3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_reflection_pad3d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor & reflection_pad3d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_reflection_pad3d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor replication_pad1d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_replication_pad1d(self, padding);
}
at::Tensor replication_pad1d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_replication_pad1d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & replication_pad1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_replication_pad1d_out_out(self, padding, out);
}
at::Tensor & replication_pad1d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_replication_pad1d_out_out(self, padding, out);
}
at::Tensor & replication_pad1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_replication_pad1d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & replication_pad1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_replication_pad1d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor replication_pad1d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_replication_pad1d_backward(grad_output, self, padding);
}
at::Tensor replication_pad1d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_replication_pad1d_backward(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & replication_pad1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_replication_pad1d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & replication_pad1d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_replication_pad1d_backward_out_grad_input(grad_output, self, padding, grad_input);
}
at::Tensor & replication_pad1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_replication_pad1d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor & replication_pad1d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_replication_pad1d_backward_out_grad_input(grad_output, self, C10_AS_INTARRAYREF_SLOW(padding), grad_input);
}
at::Tensor replication_pad2d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_replication_pad2d(self, padding);
}
at::Tensor replication_pad2d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_replication_pad2d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & replication_pad2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_replication_pad2d_out_out(self, padding, out);
}
at::Tensor & replication_pad2d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_replication_pad2d_out_out(self, padding, out);
}
at::Tensor & replication_pad2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_replication_pad2d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & replication_pad2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_replication_pad2d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor replication_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU__replication_pad2d_backward(grad_output, self, c10::fromIntArrayRefSlow(padding));
}
at::Tensor replication_pad2d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU__replication_pad2d_backward(grad_output, self, padding);
}
at::Tensor & replication_pad2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_grad_input_replication_pad2d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & replication_pad2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_replication_pad2d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & replication_pad2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_grad_input_replication_pad2d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor & replication_pad2d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_replication_pad2d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor replication_pad3d(const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_replication_pad3d(self, padding);
}
at::Tensor replication_pad3d_symint(const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_replication_pad3d(self, C10_AS_INTARRAYREF_SLOW(padding));
}
at::Tensor & replication_pad3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_replication_pad3d_out_out(self, padding, out);
}
at::Tensor & replication_pad3d_outf(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_replication_pad3d_out_out(self, padding, out);
}
at::Tensor & replication_pad3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_replication_pad3d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor & replication_pad3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & out) {
return wrapper_CPU_replication_pad3d_out_out(self, C10_AS_INTARRAYREF_SLOW(padding), out);
}
at::Tensor replication_pad3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU__replication_pad3d_backward(grad_output, self, c10::fromIntArrayRefSlow(padding));
}
at::Tensor replication_pad3d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU__replication_pad3d_backward(grad_output, self, padding);
}
at::Tensor & replication_pad3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
return wrapper_CPU_grad_input_replication_pad3d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & replication_pad3d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_replication_pad3d_backward_out(grad_output, self, c10::fromIntArrayRefSlow(padding), grad_input);
}
at::Tensor & replication_pad3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding) {
return wrapper_CPU_grad_input_replication_pad3d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor & replication_pad3d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::SymIntArrayRef padding, at::Tensor & grad_input) {
return wrapper_CPU_grad_input_replication_pad3d_backward_out(grad_output, self, padding, grad_input);
}
at::Tensor upsample_linear1d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CPU_upsample_linear1d(self, output_size, align_corners, scales);
}
at::Tensor upsample_linear1d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CPU_upsample_linear1d(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales);
}
at::Tensor & upsample_linear1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CPU_upsample_linear1d_out_out(self, output_size, align_corners, scales, out);
}
at::Tensor & upsample_linear1d_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CPU_upsample_linear1d_out_out(self, output_size, align_corners, scales, out);
}
at::Tensor & upsample_linear1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CPU_upsample_linear1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales, out);
}
at::Tensor & upsample_linear1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CPU_upsample_linear1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales, out);
}
at::Tensor upsample_linear1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CPU_upsample_linear1d_backward(grad_output, output_size, input_size, align_corners, scales);
}
at::Tensor upsample_linear1d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CPU_upsample_linear1d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales);
}
at::Tensor & upsample_linear1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CPU_upsample_linear1d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales, grad_input);
}
at::Tensor & upsample_linear1d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CPU_upsample_linear1d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales, grad_input);
}
at::Tensor & upsample_linear1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales) {
return wrapper_CPU_upsample_linear1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales, grad_input);
}
at::Tensor & upsample_linear1d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CPU_upsample_linear1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales, grad_input);
}
at::Tensor upsample_bilinear2d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bilinear2d(self, output_size, align_corners, scales_h, scales_w);
}
at::Tensor upsample_bilinear2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bilinear2d(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w);
}
at::Tensor & upsample_bilinear2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bilinear2d_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bilinear2d_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_bilinear2d_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bilinear2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bilinear2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bilinear2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_bilinear2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor upsample_bilinear2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bilinear2d_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}
at::Tensor upsample_bilinear2d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bilinear2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w);
}
at::Tensor & upsample_bilinear2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bilinear2d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bilinear2d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_bilinear2d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bilinear2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bilinear2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bilinear2d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_bilinear2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor _upsample_bilinear2d_aa(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bilinear2d_aa(self, output_size, align_corners, scales_h, scales_w);
}
at::Tensor _upsample_bilinear2d_aa_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bilinear2d_aa(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w);
}
at::Tensor & _upsample_bilinear2d_aa_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bilinear2d_aa_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bilinear2d_aa_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU__upsample_bilinear2d_aa_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bilinear2d_aa_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bilinear2d_aa_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bilinear2d_aa_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU__upsample_bilinear2d_aa_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor _upsample_bilinear2d_aa_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bilinear2d_aa_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}
at::Tensor _upsample_bilinear2d_aa_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bilinear2d_aa_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w);
}
at::Tensor & _upsample_bilinear2d_aa_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bilinear2d_aa_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bilinear2d_aa_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU__upsample_bilinear2d_aa_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bilinear2d_aa_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bilinear2d_aa_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bilinear2d_aa_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU__upsample_bilinear2d_aa_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor upsample_bicubic2d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bicubic2d(self, output_size, align_corners, scales_h, scales_w);
}
at::Tensor upsample_bicubic2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bicubic2d(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w);
}
at::Tensor & upsample_bicubic2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bicubic2d_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bicubic2d_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_bicubic2d_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bicubic2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bicubic2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor & upsample_bicubic2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_bicubic2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor upsample_bicubic2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bicubic2d_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}
at::Tensor upsample_bicubic2d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bicubic2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w);
}
at::Tensor & upsample_bicubic2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bicubic2d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bicubic2d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_bicubic2d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bicubic2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_bicubic2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_bicubic2d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_bicubic2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor _upsample_bicubic2d_aa(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bicubic2d_aa(self, output_size, align_corners, scales_h, scales_w);
}
at::Tensor _upsample_bicubic2d_aa_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bicubic2d_aa(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w);
}
at::Tensor & _upsample_bicubic2d_aa_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bicubic2d_aa_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bicubic2d_aa_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU__upsample_bicubic2d_aa_out_out(self, output_size, align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bicubic2d_aa_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bicubic2d_aa_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor & _upsample_bicubic2d_aa_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU__upsample_bicubic2d_aa_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_h, scales_w, out);
}
at::Tensor _upsample_bicubic2d_aa_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bicubic2d_aa_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}
at::Tensor _upsample_bicubic2d_aa_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bicubic2d_aa_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w);
}
at::Tensor & _upsample_bicubic2d_aa_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bicubic2d_aa_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bicubic2d_aa_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU__upsample_bicubic2d_aa_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bicubic2d_aa_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_bicubic2d_aa_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_bicubic2d_aa_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU__upsample_bicubic2d_aa_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_h, scales_w, grad_input);
}
at::Tensor upsample_trilinear3d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_trilinear3d(self, output_size, align_corners, scales_d, scales_h, scales_w);
}
at::Tensor upsample_trilinear3d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_trilinear3d(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_d, scales_h, scales_w);
}
at::Tensor & upsample_trilinear3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_trilinear3d_out_out(self, output_size, align_corners, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_trilinear3d_outf(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_trilinear3d_out_out(self, output_size, align_corners, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_trilinear3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_trilinear3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_trilinear3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_trilinear3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), align_corners, scales_d, scales_h, scales_w, out);
}
at::Tensor upsample_trilinear3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_trilinear3d_backward(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w);
}
at::Tensor upsample_trilinear3d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_trilinear3d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_d, scales_h, scales_w);
}
at::Tensor & upsample_trilinear3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_trilinear3d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_trilinear3d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_trilinear3d_backward_out_grad_input(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_trilinear3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_trilinear3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_trilinear3d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, bool align_corners, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_trilinear3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), align_corners, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor upsample_nearest1d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CPU_upsample_nearest1d(self, output_size, scales);
}
at::Tensor upsample_nearest1d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CPU_upsample_nearest1d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales);
}
at::Tensor & upsample_nearest1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CPU_upsample_nearest1d_out_out(self, output_size, scales, out);
}
at::Tensor & upsample_nearest1d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CPU_upsample_nearest1d_out_out(self, output_size, scales, out);
}
at::Tensor & upsample_nearest1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CPU_upsample_nearest1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales, out);
}
at::Tensor & upsample_nearest1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CPU_upsample_nearest1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales, out);
}
at::Tensor _upsample_nearest_exact1d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CPU__upsample_nearest_exact1d(self, output_size, scales);
}
at::Tensor _upsample_nearest_exact1d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CPU__upsample_nearest_exact1d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales);
}
at::Tensor & _upsample_nearest_exact1d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CPU__upsample_nearest_exact1d_out_out(self, output_size, scales, out);
}
at::Tensor & _upsample_nearest_exact1d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CPU__upsample_nearest_exact1d_out_out(self, output_size, scales, out);
}
at::Tensor & _upsample_nearest_exact1d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales) {
return wrapper_CPU__upsample_nearest_exact1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales, out);
}
at::Tensor & _upsample_nearest_exact1d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales, at::Tensor & out) {
return wrapper_CPU__upsample_nearest_exact1d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales, out);
}
at::Tensor upsample_nearest1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CPU_upsample_nearest1d_backward(grad_output, output_size, input_size, scales);
}
at::Tensor upsample_nearest1d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CPU_upsample_nearest1d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales);
}
at::Tensor & upsample_nearest1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CPU_upsample_nearest1d_backward_out_grad_input(grad_output, output_size, input_size, scales, grad_input);
}
at::Tensor & upsample_nearest1d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CPU_upsample_nearest1d_backward_out_grad_input(grad_output, output_size, input_size, scales, grad_input);
}
at::Tensor & upsample_nearest1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CPU_upsample_nearest1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales, grad_input);
}
at::Tensor & upsample_nearest1d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CPU_upsample_nearest1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales, grad_input);
}
at::Tensor _upsample_nearest_exact1d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CPU__upsample_nearest_exact1d_backward(grad_output, output_size, input_size, scales);
}
at::Tensor _upsample_nearest_exact1d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CPU__upsample_nearest_exact1d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales);
}
at::Tensor & _upsample_nearest_exact1d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CPU__upsample_nearest_exact1d_backward_out_grad_input(grad_output, output_size, input_size, scales, grad_input);
}
at::Tensor & _upsample_nearest_exact1d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CPU__upsample_nearest_exact1d_backward_out_grad_input(grad_output, output_size, input_size, scales, grad_input);
}
at::Tensor & _upsample_nearest_exact1d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales) {
return wrapper_CPU__upsample_nearest_exact1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales, grad_input);
}
at::Tensor & _upsample_nearest_exact1d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales, at::Tensor & grad_input) {
return wrapper_CPU__upsample_nearest_exact1d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales, grad_input);
}
at::Tensor upsample_nearest2d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest2d(self, output_size, scales_h, scales_w);
}
at::Tensor upsample_nearest2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest2d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w);
}
at::Tensor & upsample_nearest2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest2d_out_out(self, output_size, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest2d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_nearest2d_out_out(self, output_size, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w, out);
}
at::Tensor & upsample_nearest2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_nearest2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w, out);
}
at::Tensor _upsample_nearest_exact2d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact2d(self, output_size, scales_h, scales_w);
}
at::Tensor _upsample_nearest_exact2d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact2d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w);
}
at::Tensor & _upsample_nearest_exact2d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact2d_out_out(self, output_size, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact2d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU__upsample_nearest_exact2d_out_out(self, output_size, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact2d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact2d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU__upsample_nearest_exact2d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_h, scales_w, out);
}
at::Tensor upsample_nearest2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest2d_backward(grad_output, output_size, input_size, scales_h, scales_w);
}
at::Tensor upsample_nearest2d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w);
}
at::Tensor & upsample_nearest2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest2d_backward_out_grad_input(grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest2d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_nearest2d_backward_out_grad_input(grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest2d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_nearest2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w, grad_input);
}
at::Tensor _upsample_nearest_exact2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact2d_backward(grad_output, output_size, input_size, scales_h, scales_w);
}
at::Tensor _upsample_nearest_exact2d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact2d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w);
}
at::Tensor & _upsample_nearest_exact2d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact2d_backward_out_grad_input(grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact2d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU__upsample_nearest_exact2d_backward_out_grad_input(grad_output, output_size, input_size, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact2d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact2d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU__upsample_nearest_exact2d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_h, scales_w, grad_input);
}
at::Tensor upsample_nearest3d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest3d(self, output_size, scales_d, scales_h, scales_w);
}
at::Tensor upsample_nearest3d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest3d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w);
}
at::Tensor & upsample_nearest3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest3d_out_out(self, output_size, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest3d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_nearest3d_out_out(self, output_size, scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w, out);
}
at::Tensor & upsample_nearest3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU_upsample_nearest3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w, out);
}
at::Tensor _upsample_nearest_exact3d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact3d(self, output_size, scales_d, scales_h, scales_w);
}
at::Tensor _upsample_nearest_exact3d_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact3d(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w);
}
at::Tensor & _upsample_nearest_exact3d_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact3d_out_out(self, output_size, scales_d, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact3d_outf(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU__upsample_nearest_exact3d_out_out(self, output_size, scales_d, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact3d_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w, out);
}
at::Tensor & _upsample_nearest_exact3d_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
return wrapper_CPU__upsample_nearest_exact3d_out_out(self, C10_AS_INTARRAYREF_SLOW(output_size), scales_d, scales_h, scales_w, out);
}
at::Tensor upsample_nearest3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest3d_backward(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
}
at::Tensor upsample_nearest3d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest3d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w);
}
at::Tensor & upsample_nearest3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest3d_backward_out_grad_input(grad_output, output_size, input_size, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest3d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_nearest3d_backward_out_grad_input(grad_output, output_size, input_size, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU_upsample_nearest3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & upsample_nearest3d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU_upsample_nearest3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w, grad_input);
}
at::Tensor _upsample_nearest_exact3d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact3d_backward(grad_output, output_size, input_size, scales_d, scales_h, scales_w);
}
at::Tensor _upsample_nearest_exact3d_backward_symint(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact3d_backward(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w);
}
at::Tensor & _upsample_nearest_exact3d_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact3d_backward_out_grad_input(grad_output, output_size, input_size, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact3d_backward_outf(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU__upsample_nearest_exact3d_backward_out_grad_input(grad_output, output_size, input_size, scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact3d_backward_symint_out(at::Tensor & grad_input, const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w) {
return wrapper_CPU__upsample_nearest_exact3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w, grad_input);
}
at::Tensor & _upsample_nearest_exact3d_backward_symint_outf(const at::Tensor & grad_output, c10::SymIntArrayRef output_size, c10::SymIntArrayRef input_size, c10::optional<double> scales_d, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
return wrapper_CPU__upsample_nearest_exact3d_backward_out_grad_input(grad_output, C10_AS_INTARRAYREF_SLOW(output_size), C10_AS_INTARRAYREF_SLOW(input_size), scales_d, scales_h, scales_w, grad_input);
}
at::Tensor sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & output) {
return wrapper_CPU_sigmoid_backward(grad_output, output);
}
at::Tensor & sigmoid_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & output) {
return wrapper_CPU_sigmoid_backward_out_grad_input(grad_output, output, grad_input);
}
at::Tensor & sigmoid_backward_outf(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
return wrapper_CPU_sigmoid_backward_out_grad_input(grad_output, output, grad_input);
}
at::Tensor logit_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps) {
return wrapper_CPU_logit_backward(grad_output, self, eps);
}
at::Tensor & logit_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps) {
return wrapper_CPU_logit_backward_out_grad_input(grad_output, self, eps, grad_input);
}
at::Tensor & logit_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, c10::optional<double> eps, at::Tensor & grad_input) {
return wrapper_CPU_logit_backward_out_grad_input(grad_output, self, eps, grad_input);
}
at::Tensor tanh_backward(const at::Tensor & grad_output, const at::Tensor & output) {
return wrapper_CPU_tanh_backward(grad_output, output);
}
at::Tensor & tanh_backward_out(at::Tensor & grad_input, const at::Tensor & grad_output, const at::Tensor & output) {
return wrapper_CPU_tanh_backward_out_grad_input(grad_output, output, grad_input);
}
at::Tensor & tanh_backward_outf(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
return wrapper_CPU_tanh_backward_out_grad_input(grad_output, output, grad_input);
}
at::Tensor slow_conv_transpose2d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
return wrapper_CPU_slow_conv_transpose2d(self, weight, kernel_size, bias, stride, padding, output_padding, dilation);
}
at::Tensor slow_conv_transpose2d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
return wrapper_CPU_slow_conv_transpose2d(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation));
}
at::Tensor & slow_conv_transpose2d_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
return wrapper_CPU_slow_conv_transpose2d_out_out(self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}
at::Tensor & slow_conv_transpose2d_outf(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation, at::Tensor & out) {
return wrapper_CPU_slow_conv_transpose2d_out_out(self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}
at::Tensor & slow_conv_transpose2d_symint_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
return wrapper_CPU_slow_conv_transpose2d_out_out(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation), out);
}
at::Tensor & slow_conv_transpose2d_symint_outf(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
return wrapper_CPU_slow_conv_transpose2d_out_out(self, weight, C10_AS_INTARRAYREF_SLOW(kernel_size), bias, C10_AS_INTARRAYREF_SLOW(stride), C10_AS_INTARRAYREF_SLOW(padding), C10_AS_INTARRAYREF_SLOW(output_padding), C10_AS_INTARRAYREF_SLOW(dilation), out);
}
at::Tensor slow_conv_transpose3d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
return wrapper_CPU__slow_conv_transpose3d(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(output_padding), c10::fromIntArrayRefSlow(dilation));
}
at::Tensor slow_conv_transpose3d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
return wrapper_CPU__slow_conv_transpose3d(self, weight, kernel_size, bias, stride, padding, output_padding, dilation);
}
at::Tensor & slow_conv_transpose3d_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation) {
return wrapper_CPU_out_slow_conv_transpose3d_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(output_padding), c10::fromIntArrayRefSlow(dilation), out);
}
at::Tensor & slow_conv_transpose3d_outf(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef output_padding, at::IntArrayRef dilation, at::Tensor & out) {
return wrapper_CPU_out_slow_conv_transpose3d_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(output_padding), c10::fromIntArrayRefSlow(dilation), out);
}
at::Tensor & slow_conv_transpose3d_symint_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation) {
return wrapper_CPU_out_slow_conv_transpose3d_out(self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}
at::Tensor & slow_conv_transpose3d_symint_outf(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef output_padding, c10::SymIntArrayRef dilation, at::Tensor & out) {
return wrapper_CPU_out_slow_conv_transpose3d_out(self, weight, kernel_size, bias, stride, padding, output_padding, dilation, out);
}
at::Tensor _slow_conv2d_forward(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CPU___slow_conv2d_forward(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding));
}
at::Tensor _slow_conv2d_forward_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
return wrapper_CPU___slow_conv2d_forward(self, weight, kernel_size, bias, stride, padding);
}
at::Tensor & _slow_conv2d_forward_out(at::Tensor & output, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CPU_output__slow_conv2d_forward_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), output);
}
at::Tensor & _slow_conv2d_forward_outf(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & output) {
return wrapper_CPU_output__slow_conv2d_forward_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), output);
}
at::Tensor & _slow_conv2d_forward_symint_out(at::Tensor & output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
return wrapper_CPU_output__slow_conv2d_forward_out(self, weight, kernel_size, bias, stride, padding, output);
}
at::Tensor & _slow_conv2d_forward_symint_outf(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
return wrapper_CPU_output__slow_conv2d_forward_out(self, weight, kernel_size, bias, stride, padding, output);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _slow_conv2d_backward_out(at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CPU_grad_input__slow_conv2d_backward_out(grad_output, self, weight, c10::fromIntArrayRefSlow(kernel_size), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), grad_input, grad_weight, grad_bias);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _slow_conv2d_backward_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias) {
return wrapper_CPU_grad_input__slow_conv2d_backward_out(grad_output, self, weight, c10::fromIntArrayRefSlow(kernel_size), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), grad_input, grad_weight, grad_bias);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _slow_conv2d_backward_symint_out(at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias, const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
return wrapper_CPU_grad_input__slow_conv2d_backward_out(grad_output, self, weight, kernel_size, stride, padding, grad_input, grad_weight, grad_bias);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _slow_conv2d_backward_symint_outf(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & grad_input, at::Tensor & grad_weight, at::Tensor & grad_bias) {
return wrapper_CPU_grad_input__slow_conv2d_backward_out(grad_output, self, weight, kernel_size, stride, padding, grad_input, grad_weight, grad_bias);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _slow_conv2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, ::std::array<bool,3> output_mask) {
return wrapper_CPU_output_mask__slow_conv2d_backward(grad_output, self, weight, c10::fromIntArrayRefSlow(kernel_size), c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), output_mask);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _slow_conv2d_backward_symint(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, ::std::array<bool,3> output_mask) {
return wrapper_CPU_output_mask__slow_conv2d_backward(grad_output, self, weight, kernel_size, stride, padding, output_mask);
}
at::Tensor slow_conv3d_forward(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CPU__slow_conv3d_forward(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding));
}
at::Tensor slow_conv3d_forward_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
return wrapper_CPU__slow_conv3d_forward(self, weight, kernel_size, bias, stride, padding);
}
at::Tensor & slow_conv3d_forward_out(at::Tensor & output, const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding) {
return wrapper_CPU_output_slow_conv3d_forward_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), output);
}
at::Tensor & slow_conv3d_forward_outf(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & output) {
return wrapper_CPU_output_slow_conv3d_forward_out(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), output);
}
at::Tensor & slow_conv3d_forward_symint_out(at::Tensor & output, const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding) {
return wrapper_CPU_output_slow_conv3d_forward_out(self, weight, kernel_size, bias, stride, padding, output);
}
at::Tensor & slow_conv3d_forward_symint_outf(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, at::Tensor & output) {
return wrapper_CPU_output_slow_conv3d_forward_out(self, weight, kernel_size, bias, stride, padding, output);
}
at::Tensor slow_conv_dilated2d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation) {
return wrapper_CPU__slow_conv_dilated2d(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation));
}
at::Tensor slow_conv_dilated2d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
return wrapper_CPU__slow_conv_dilated2d(self, weight, kernel_size, bias, stride, padding, dilation);
}
at::Tensor slow_conv_dilated3d(const at::Tensor & self, const at::Tensor & weight, at::IntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation) {
return wrapper_CPU__slow_conv_dilated3d(self, weight, c10::fromIntArrayRefSlow(kernel_size), bias, c10::fromIntArrayRefSlow(stride), c10::fromIntArrayRefSlow(padding), c10::fromIntArrayRefSlow(dilation));
}
at::Tensor slow_conv_dilated3d_symint(const at::Tensor & self, const at::Tensor & weight, c10::SymIntArrayRef kernel_size, const c10::optional<at::Tensor> & bias, c10::SymIntArrayRef stride, c10::SymIntArrayRef padding, c10::SymIntArrayRef dilation) {
return wrapper_CPU__slow_conv_dilated3d(self, weight, kernel_size, bias, stride, padding, dilation);
}
at::Tensor col2im(const at::Tensor & self, at::IntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CPU__col2im(self, c10::fromIntArrayRefSlow(output_size), kernel_size, dilation, padding, stride);
}
at::Tensor col2im_symint(const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CPU__col2im(self, output_size, kernel_size, dilation, padding, stride);
}
at::Tensor & col2im_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CPU_out_col2im_out(self, c10::fromIntArrayRefSlow(output_size), kernel_size, dilation, padding, stride, out);
}
at::Tensor & col2im_outf(const at::Tensor & self, at::IntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
return wrapper_CPU_out_col2im_out(self, c10::fromIntArrayRefSlow(output_size), kernel_size, dilation, padding, stride, out);
}
at::Tensor & col2im_symint_out(at::Tensor & out, const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CPU_out_col2im_out(self, output_size, kernel_size, dilation, padding, stride, out);
}
at::Tensor & col2im_symint_outf(const at::Tensor & self, c10::SymIntArrayRef output_size, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
return wrapper_CPU_out_col2im_out(self, output_size, kernel_size, dilation, padding, stride, out);
}
at::Tensor im2col(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CPU__im2col(self, kernel_size, dilation, padding, stride);
}
at::Tensor & im2col_out(at::Tensor & out, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride) {
return wrapper_CPU_out_im2col_out(self, kernel_size, dilation, padding, stride, out);
}
at::Tensor & im2col_outf(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef dilation, at::IntArrayRef padding, at::IntArrayRef stride, at::Tensor & out) {
return wrapper_CPU_out_im2col_out(self, kernel_size, dilation, padding, stride, out);
}
at::Tensor isposinf(const at::Tensor & self) {
return wrapper_CPU_isposinf(self);
}
at::Tensor & isposinf_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_isposinf_out_out(self, out);
}
at::Tensor & isposinf_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_isposinf_out_out(self, out);
}
at::Tensor isneginf(const at::Tensor & self) {
return wrapper_CPU_isneginf(self);
}
at::Tensor & isneginf_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_isneginf_out_out(self, out);
}
at::Tensor & isneginf_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_isneginf_out_out(self, out);
}
at::Tensor special_entr(const at::Tensor & self) {
return wrapper_CPU_special_entr(self);
}
at::Tensor & special_entr_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_entr_out_out(self, out);
}
at::Tensor & special_entr_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_entr_out_out(self, out);
}
at::Tensor special_ndtri(const at::Tensor & self) {
return wrapper_CPU_special_ndtri(self);
}
at::Tensor & special_ndtri_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_ndtri_out_out(self, out);
}
at::Tensor & special_ndtri_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_ndtri_out_out(self, out);
}
at::Tensor special_log_ndtr(const at::Tensor & self) {
return wrapper_CPU_special_log_ndtr(self);
}
at::Tensor & special_log_ndtr_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_log_ndtr_out_out(self, out);
}
at::Tensor & special_log_ndtr_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_log_ndtr_out_out(self, out);
}
at::Tensor special_erfcx(const at::Tensor & self) {
return wrapper_CPU_special_erfcx(self);
}
at::Tensor & special_erfcx_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_erfcx_out_out(self, out);
}
at::Tensor & special_erfcx_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_erfcx_out_out(self, out);
}
at::Tensor special_xlog1py(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_special_xlog1py(self, other);
}
at::Tensor & special_xlog1py_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_special_xlog1py_out_out(self, other, out);
}
at::Tensor & special_xlog1py_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_special_xlog1py_out_out(self, other, out);
}
at::Tensor special_zeta(const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_special_zeta(self, other);
}
at::Tensor & special_zeta_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other) {
return wrapper_CPU_special_zeta_out_out(self, other, out);
}
at::Tensor & special_zeta_outf(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
return wrapper_CPU_special_zeta_out_out(self, other, out);
}
at::Tensor special_i0e(const at::Tensor & self) {
return wrapper_CPU_special_i0e(self);
}
at::Tensor & special_i0e_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_i0e_out_out(self, out);
}
at::Tensor & special_i0e_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_i0e_out_out(self, out);
}
at::Tensor special_i1(const at::Tensor & self) {
return wrapper_CPU_special_i1(self);
}
at::Tensor & special_i1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_i1_out_out(self, out);
}
at::Tensor & special_i1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_i1_out_out(self, out);
}
at::Tensor special_i1e(const at::Tensor & self) {
return wrapper_CPU_special_i1e(self);
}
at::Tensor & special_i1e_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_i1e_out_out(self, out);
}
at::Tensor & special_i1e_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_i1e_out_out(self, out);
}
::std::tuple<at::Tensor,at::Tensor> linalg_cholesky_ex(const at::Tensor & self, bool upper, bool check_errors) {
return wrapper_CPU_linalg_cholesky_ex(self, upper, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_cholesky_ex_out(at::Tensor & L, at::Tensor & info, const at::Tensor & self, bool upper, bool check_errors) {
return wrapper_CPU_linalg_cholesky_ex_out_L(self, upper, check_errors, L, info);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_cholesky_ex_outf(const at::Tensor & self, bool upper, bool check_errors, at::Tensor & L, at::Tensor & info) {
return wrapper_CPU_linalg_cholesky_ex_out_L(self, upper, check_errors, L, info);
}
at::Tensor linalg_cross(const at::Tensor & self, const at::Tensor & other, int64_t dim) {
return wrapper_CPU_linalg_cross(self, other, dim);
}
at::Tensor & linalg_cross_out(at::Tensor & out, const at::Tensor & self, const at::Tensor & other, int64_t dim) {
return wrapper_CPU_linalg_cross_out_out(self, other, dim, out);
}
at::Tensor & linalg_cross_outf(const at::Tensor & self, const at::Tensor & other, int64_t dim, at::Tensor & out) {
return wrapper_CPU_linalg_cross_out_out(self, other, dim, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_lu_factor_ex(const at::Tensor & A, bool pivot, bool check_errors) {
return wrapper_CPU_linalg_lu_factor_ex(A, pivot, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_factor_ex_out(at::Tensor & LU, at::Tensor & pivots, at::Tensor & info, const at::Tensor & A, bool pivot, bool check_errors) {
return wrapper_CPU_linalg_lu_factor_ex_out_out(A, pivot, check_errors, LU, pivots, info);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_factor_ex_outf(const at::Tensor & A, bool pivot, bool check_errors, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
return wrapper_CPU_linalg_lu_factor_ex_out_out(A, pivot, check_errors, LU, pivots, info);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_lu(const at::Tensor & A, bool pivot) {
return wrapper_CPU_linalg_lu(A, pivot);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_out(at::Tensor & P, at::Tensor & L, at::Tensor & U, const at::Tensor & A, bool pivot) {
return wrapper_CPU_linalg_lu_out_out(A, pivot, P, L, U);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_lu_outf(const at::Tensor & A, bool pivot, at::Tensor & P, at::Tensor & L, at::Tensor & U) {
return wrapper_CPU_linalg_lu_out_out(A, pivot, P, L, U);
}
at::Tensor linalg_lu_solve(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint) {
return wrapper_CPU_linalg_lu_solve(LU, pivots, B, left, adjoint);
}
at::Tensor & linalg_lu_solve_out(at::Tensor & out, const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint) {
return wrapper_CPU_linalg_lu_solve_out_out(LU, pivots, B, left, adjoint, out);
}
at::Tensor & linalg_lu_solve_outf(const at::Tensor & LU, const at::Tensor & pivots, const at::Tensor & B, bool left, bool adjoint, at::Tensor & out) {
return wrapper_CPU_linalg_lu_solve_out_out(LU, pivots, B, left, adjoint, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _linalg_det(const at::Tensor & A) {
return wrapper_CPU__linalg_det(A);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_det_out(at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, const at::Tensor & A) {
return wrapper_CPU__linalg_det_out_result(A, result, LU, pivots);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_det_outf(const at::Tensor & A, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots) {
return wrapper_CPU__linalg_det_out_result(A, result, LU, pivots);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> linalg_ldl_factor_ex(const at::Tensor & self, bool hermitian, bool check_errors) {
return wrapper_CPU_linalg_ldl_factor_ex(self, hermitian, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_ldl_factor_ex_out(at::Tensor & LD, at::Tensor & pivots, at::Tensor & info, const at::Tensor & self, bool hermitian, bool check_errors) {
return wrapper_CPU_linalg_ldl_factor_ex_out_out(self, hermitian, check_errors, LD, pivots, info);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> linalg_ldl_factor_ex_outf(const at::Tensor & self, bool hermitian, bool check_errors, at::Tensor & LD, at::Tensor & pivots, at::Tensor & info) {
return wrapper_CPU_linalg_ldl_factor_ex_out_out(self, hermitian, check_errors, LD, pivots, info);
}
at::Tensor linalg_ldl_solve(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian) {
return wrapper_CPU_linalg_ldl_solve(LD, pivots, B, hermitian);
}
at::Tensor & linalg_ldl_solve_out(at::Tensor & out, const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian) {
return wrapper_CPU_linalg_ldl_solve_out_out(LD, pivots, B, hermitian, out);
}
at::Tensor & linalg_ldl_solve_outf(const at::Tensor & LD, const at::Tensor & pivots, const at::Tensor & B, bool hermitian, at::Tensor & out) {
return wrapper_CPU_linalg_ldl_solve_out_out(LD, pivots, B, hermitian, out);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> linalg_lstsq_out(at::Tensor & solution, at::Tensor & residuals, at::Tensor & rank, at::Tensor & singular_values, const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver) {
return wrapper_CPU_out_linalg_lstsq_out(self, b, rcond, driver, solution, residuals, rank, singular_values);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> linalg_lstsq_outf(const at::Tensor & self, const at::Tensor & b, c10::optional<double> rcond, c10::optional<c10::string_view> driver, at::Tensor & solution, at::Tensor & residuals, at::Tensor & rank, at::Tensor & singular_values) {
return wrapper_CPU_out_linalg_lstsq_out(self, b, rcond, driver, solution, residuals, rank, singular_values);
}
at::Tensor linalg_matrix_exp(const at::Tensor & self) {
return wrapper_CPU__linalg_matrix_exp(self);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _linalg_slogdet(const at::Tensor & A) {
return wrapper_CPU__linalg_slogdet(A);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_slogdet_out(at::Tensor & sign, at::Tensor & logabsdet, at::Tensor & LU, at::Tensor & pivots, const at::Tensor & A) {
return wrapper_CPU__linalg_slogdet_out_sign(A, sign, logabsdet, LU, pivots);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_slogdet_outf(const at::Tensor & A, at::Tensor & sign, at::Tensor & logabsdet, at::Tensor & LU, at::Tensor & pivots) {
return wrapper_CPU__linalg_slogdet_out_sign(A, sign, logabsdet, LU, pivots);
}
::std::tuple<at::Tensor,at::Tensor> linalg_eig(const at::Tensor & self) {
return wrapper_CPU__linalg_eig(self);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_eig_out(at::Tensor & eigenvalues, at::Tensor & eigenvectors, const at::Tensor & self) {
return wrapper_CPU_out_linalg_eig_out(self, eigenvalues, eigenvectors);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_eig_outf(const at::Tensor & self, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
return wrapper_CPU_out_linalg_eig_out(self, eigenvalues, eigenvectors);
}
::std::tuple<at::Tensor,at::Tensor> _linalg_eigh(const at::Tensor & A, c10::string_view UPLO, bool compute_v) {
return wrapper_CPU__linalg_eigh(A, UPLO, compute_v);
}
::std::tuple<at::Tensor &,at::Tensor &> _linalg_eigh_out(at::Tensor & eigenvalues, at::Tensor & eigenvectors, const at::Tensor & A, c10::string_view UPLO, bool compute_v) {
return wrapper_CPU__linalg_eigh_out_eigenvalues(A, UPLO, compute_v, eigenvalues, eigenvectors);
}
::std::tuple<at::Tensor &,at::Tensor &> _linalg_eigh_outf(const at::Tensor & A, c10::string_view UPLO, bool compute_v, at::Tensor & eigenvalues, at::Tensor & eigenvectors) {
return wrapper_CPU__linalg_eigh_out_eigenvalues(A, UPLO, compute_v, eigenvalues, eigenvectors);
}
at::Tensor linalg_householder_product(const at::Tensor & input, const at::Tensor & tau) {
return wrapper_CPU__linalg_householder_product(input, tau);
}
at::Tensor & linalg_householder_product_out(at::Tensor & out, const at::Tensor & input, const at::Tensor & tau) {
return wrapper_CPU_out_linalg_householder_product_out(input, tau, out);
}
at::Tensor & linalg_householder_product_outf(const at::Tensor & input, const at::Tensor & tau, at::Tensor & out) {
return wrapper_CPU_out_linalg_householder_product_out(input, tau, out);
}
::std::tuple<at::Tensor,at::Tensor> linalg_inv_ex(const at::Tensor & A, bool check_errors) {
return wrapper_CPU_linalg_inv_ex(A, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_inv_ex_out(at::Tensor & inverse, at::Tensor & info, const at::Tensor & A, bool check_errors) {
return wrapper_CPU_linalg_inv_ex_out_inverse(A, check_errors, inverse, info);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_inv_ex_outf(const at::Tensor & A, bool check_errors, at::Tensor & inverse, at::Tensor & info) {
return wrapper_CPU_linalg_inv_ex_out_inverse(A, check_errors, inverse, info);
}
at::Tensor linalg_vector_norm(const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_linalg_vector_norm(self, ord, dim, keepdim, dtype);
}
at::Tensor & linalg_vector_norm_out(at::Tensor & out, const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
return wrapper_CPU_linalg_vector_norm_out_out(self, ord, dim, keepdim, dtype, out);
}
at::Tensor & linalg_vector_norm_outf(const at::Tensor & self, const at::Scalar & ord, at::OptionalIntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
return wrapper_CPU_linalg_vector_norm_out_out(self, ord, dim, keepdim, dtype, out);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _linalg_svd(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver) {
return wrapper_CPU__linalg_svd(A, full_matrices, compute_uv, driver);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_svd_out(at::Tensor & U, at::Tensor & S, at::Tensor & Vh, const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver) {
return wrapper_CPU__linalg_svd_out_U(A, full_matrices, compute_uv, driver, U, S, Vh);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> _linalg_svd_outf(const at::Tensor & A, bool full_matrices, bool compute_uv, c10::optional<c10::string_view> driver, at::Tensor & U, at::Tensor & S, at::Tensor & Vh) {
return wrapper_CPU__linalg_svd_out_U(A, full_matrices, compute_uv, driver, U, S, Vh);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor> _linalg_solve_ex(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors) {
return wrapper_CPU__linalg_solve_ex(A, B, left, check_errors);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_solve_ex_out(at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info, const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors) {
return wrapper_CPU__linalg_solve_ex_out_result(A, B, left, check_errors, result, LU, pivots, info);
}
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &,at::Tensor &> _linalg_solve_ex_outf(const at::Tensor & A, const at::Tensor & B, bool left, bool check_errors, at::Tensor & result, at::Tensor & LU, at::Tensor & pivots, at::Tensor & info) {
return wrapper_CPU__linalg_solve_ex_out_result(A, B, left, check_errors, result, LU, pivots, info);
}
::std::tuple<at::Tensor,at::Tensor> linalg_qr(const at::Tensor & A, c10::string_view mode) {
return wrapper_CPU_linalg_qr(A, mode);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_qr_out(at::Tensor & Q, at::Tensor & R, const at::Tensor & A, c10::string_view mode) {
return wrapper_CPU_linalg_qr_out_out(A, mode, Q, R);
}
::std::tuple<at::Tensor &,at::Tensor &> linalg_qr_outf(const at::Tensor & A, c10::string_view mode, at::Tensor & Q, at::Tensor & R) {
return wrapper_CPU_linalg_qr_out_out(A, mode, Q, R);
}
at::Tensor _test_optional_intlist(const at::Tensor & values, at::OptionalIntArrayRef addends) {
return wrapper_CPU___test_optional_intlist(values, addends);
}
at::Tensor _test_optional_filled_intlist(const at::Tensor & values, at::OptionalIntArrayRef addends) {
return wrapper_CPU___test_optional_filled_intlist(values, addends);
}
at::Tensor _test_optional_floatlist(const at::Tensor & values, c10::optional<at::ArrayRef<double>> addends) {
return wrapper_CPU___test_optional_floatlist(values, addends);
}
at::Tensor segment_reduce(const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & indices, const c10::optional<at::Tensor> & offsets, int64_t axis, bool unsafe, const c10::optional<at::Scalar> & initial) {
return wrapper_CPU__segment_reduce(data, reduce, lengths, indices, offsets, axis, unsafe, initial);
}
at::Tensor _segment_reduce_backward(const at::Tensor & grad, const at::Tensor & output, const at::Tensor & data, c10::string_view reduce, const c10::optional<at::Tensor> & lengths, const c10::optional<at::Tensor> & offsets, int64_t axis, const c10::optional<at::Scalar> & initial) {
return wrapper_CPU___segment_reduce_backward(grad, output, data, reduce, lengths, offsets, axis, initial);
}
at::Tensor _transformer_encoder_layer_fwd(const at::Tensor & src, int64_t embed_dim, int64_t num_heads, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, bool use_gelu, bool norm_first, double eps, const at::Tensor & norm_weight_1, const at::Tensor & norm_bias_1, const at::Tensor & norm_weight_2, const at::Tensor & norm_bias_2, const at::Tensor & ffn_weight_1, const at::Tensor & ffn_bias_1, const at::Tensor & ffn_weight_2, const at::Tensor & ffn_bias_2, const c10::optional<at::Tensor> & mask, c10::optional<int64_t> mask_type) {
return wrapper_CPU___transformer_encoder_layer_fwd(src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, mask_type);
}
::std::tuple<at::Tensor,at::Tensor> _native_multi_head_attention(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, int64_t embed_dim, int64_t num_head, const at::Tensor & qkv_weight, const at::Tensor & qkv_bias, const at::Tensor & proj_weight, const at::Tensor & proj_bias, const c10::optional<at::Tensor> & mask, bool need_weights, bool average_attn_weights, c10::optional<int64_t> mask_type) {
return wrapper_CPU___native_multi_head_attention(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, need_weights, average_attn_weights, mask_type);
}
int64_t _fused_sdp_choice(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const c10::optional<at::Tensor> & attn_mask, double dropout_p, bool is_causal, c10::optional<double> scale) {
return wrapper_CPU___fused_sdp_choice(query, key, value, attn_mask, dropout_p, is_causal, scale);
}
::std::tuple<at::Tensor,at::Tensor> _scaled_dot_product_flash_attention_for_cpu(const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, double dropout_p, bool is_causal, const c10::optional<at::Tensor> & attn_mask, c10::optional<double> scale) {
return wrapper_CPU___scaled_dot_product_flash_attention_for_cpu(query, key, value, dropout_p, is_causal, attn_mask, scale);
}
::std::tuple<at::Tensor,at::Tensor,at::Tensor> _scaled_dot_product_flash_attention_for_cpu_backward(const at::Tensor & grad_out, const at::Tensor & query, const at::Tensor & key, const at::Tensor & value, const at::Tensor & out, const at::Tensor & logsumexp, double dropout_p, bool is_causal, const c10::optional<at::Tensor> & attn_mask, c10::optional<double> scale) {
return wrapper_CPU___scaled_dot_product_flash_attention_for_cpu_backward(grad_out, query, key, value, out, logsumexp, dropout_p, is_causal, attn_mask, scale);
}
at::Tensor special_airy_ai(const at::Tensor & x) {
return wrapper_CPU_special_airy_ai(x);
}
at::Tensor & special_airy_ai_out(at::Tensor & out, const at::Tensor & x) {
return wrapper_CPU_special_airy_ai_out_out(x, out);
}
at::Tensor & special_airy_ai_outf(const at::Tensor & x, at::Tensor & out) {
return wrapper_CPU_special_airy_ai_out_out(x, out);
}
at::Tensor special_bessel_j0(const at::Tensor & self) {
return wrapper_CPU_special_bessel_j0(self);
}
at::Tensor & special_bessel_j0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_bessel_j0_out_out(self, out);
}
at::Tensor & special_bessel_j0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_bessel_j0_out_out(self, out);
}
at::Tensor special_bessel_j1(const at::Tensor & self) {
return wrapper_CPU_special_bessel_j1(self);
}
at::Tensor & special_bessel_j1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_bessel_j1_out_out(self, out);
}
at::Tensor & special_bessel_j1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_bessel_j1_out_out(self, out);
}
at::Tensor special_bessel_y0(const at::Tensor & self) {
return wrapper_CPU_special_bessel_y0(self);
}
at::Tensor & special_bessel_y0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_bessel_y0_out_out(self, out);
}
at::Tensor & special_bessel_y0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_bessel_y0_out_out(self, out);
}
at::Tensor special_bessel_y1(const at::Tensor & self) {
return wrapper_CPU_special_bessel_y1(self);
}
at::Tensor & special_bessel_y1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_bessel_y1_out_out(self, out);
}
at::Tensor & special_bessel_y1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_bessel_y1_out_out(self, out);
}
at::Tensor special_chebyshev_polynomial_t(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_chebyshev_polynomial_t(x, n);
}
at::Tensor & special_chebyshev_polynomial_t_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_chebyshev_polynomial_t_out_out(x, n, out);
}
at::Tensor & special_chebyshev_polynomial_t_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_chebyshev_polynomial_t_out_out(x, n, out);
}
at::Tensor special_chebyshev_polynomial_u(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_chebyshev_polynomial_u(x, n);
}
at::Tensor & special_chebyshev_polynomial_u_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_chebyshev_polynomial_u_out_out(x, n, out);
}
at::Tensor & special_chebyshev_polynomial_u_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_chebyshev_polynomial_u_out_out(x, n, out);
}
at::Tensor special_chebyshev_polynomial_v(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_chebyshev_polynomial_v(x, n);
}
at::Tensor & special_chebyshev_polynomial_v_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_chebyshev_polynomial_v_out_out(x, n, out);
}
at::Tensor & special_chebyshev_polynomial_v_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_chebyshev_polynomial_v_out_out(x, n, out);
}
at::Tensor special_chebyshev_polynomial_w(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_chebyshev_polynomial_w(x, n);
}
at::Tensor & special_chebyshev_polynomial_w_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_chebyshev_polynomial_w_out_out(x, n, out);
}
at::Tensor & special_chebyshev_polynomial_w_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_chebyshev_polynomial_w_out_out(x, n, out);
}
at::Tensor special_hermite_polynomial_h(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_hermite_polynomial_h(x, n);
}
at::Tensor & special_hermite_polynomial_h_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_hermite_polynomial_h_out_out(x, n, out);
}
at::Tensor & special_hermite_polynomial_h_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_hermite_polynomial_h_out_out(x, n, out);
}
at::Tensor special_hermite_polynomial_he(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_hermite_polynomial_he(x, n);
}
at::Tensor & special_hermite_polynomial_he_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_hermite_polynomial_he_out_out(x, n, out);
}
at::Tensor & special_hermite_polynomial_he_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_hermite_polynomial_he_out_out(x, n, out);
}
at::Tensor special_laguerre_polynomial_l(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_laguerre_polynomial_l(x, n);
}
at::Tensor & special_laguerre_polynomial_l_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_laguerre_polynomial_l_out_out(x, n, out);
}
at::Tensor & special_laguerre_polynomial_l_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_laguerre_polynomial_l_out_out(x, n, out);
}
at::Tensor special_legendre_polynomial_p(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_legendre_polynomial_p(x, n);
}
at::Tensor & special_legendre_polynomial_p_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_legendre_polynomial_p_out_out(x, n, out);
}
at::Tensor & special_legendre_polynomial_p_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_legendre_polynomial_p_out_out(x, n, out);
}
at::Tensor special_modified_bessel_i0(const at::Tensor & self) {
return wrapper_CPU_special_modified_bessel_i0(self);
}
at::Tensor & special_modified_bessel_i0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_modified_bessel_i0_out_out(self, out);
}
at::Tensor & special_modified_bessel_i0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_modified_bessel_i0_out_out(self, out);
}
at::Tensor special_modified_bessel_i1(const at::Tensor & self) {
return wrapper_CPU_special_modified_bessel_i1(self);
}
at::Tensor & special_modified_bessel_i1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_modified_bessel_i1_out_out(self, out);
}
at::Tensor & special_modified_bessel_i1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_modified_bessel_i1_out_out(self, out);
}
at::Tensor special_modified_bessel_k0(const at::Tensor & self) {
return wrapper_CPU_special_modified_bessel_k0(self);
}
at::Tensor & special_modified_bessel_k0_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_modified_bessel_k0_out_out(self, out);
}
at::Tensor & special_modified_bessel_k0_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_modified_bessel_k0_out_out(self, out);
}
at::Tensor special_modified_bessel_k1(const at::Tensor & self) {
return wrapper_CPU_special_modified_bessel_k1(self);
}
at::Tensor & special_modified_bessel_k1_out(at::Tensor & out, const at::Tensor & self) {
return wrapper_CPU_special_modified_bessel_k1_out_out(self, out);
}
at::Tensor & special_modified_bessel_k1_outf(const at::Tensor & self, at::Tensor & out) {
return wrapper_CPU_special_modified_bessel_k1_out_out(self, out);
}
at::Tensor special_scaled_modified_bessel_k0(const at::Tensor & x) {
return wrapper_CPU_special_scaled_modified_bessel_k0(x);
}
at::Tensor & special_scaled_modified_bessel_k0_out(at::Tensor & out, const at::Tensor & x) {
return wrapper_CPU_special_scaled_modified_bessel_k0_out_out(x, out);
}
at::Tensor & special_scaled_modified_bessel_k0_outf(const at::Tensor & x, at::Tensor & out) {
return wrapper_CPU_special_scaled_modified_bessel_k0_out_out(x, out);
}
at::Tensor special_scaled_modified_bessel_k1(const at::Tensor & x) {
return wrapper_CPU_special_scaled_modified_bessel_k1(x);
}
at::Tensor & special_scaled_modified_bessel_k1_out(at::Tensor & out, const at::Tensor & x) {
return wrapper_CPU_special_scaled_modified_bessel_k1_out_out(x, out);
}
at::Tensor & special_scaled_modified_bessel_k1_outf(const at::Tensor & x, at::Tensor & out) {
return wrapper_CPU_special_scaled_modified_bessel_k1_out_out(x, out);
}
at::Tensor special_shifted_chebyshev_polynomial_t(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_t(x, n);
}
at::Tensor & special_shifted_chebyshev_polynomial_t_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_t_out_out(x, n, out);
}
at::Tensor & special_shifted_chebyshev_polynomial_t_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_t_out_out(x, n, out);
}
at::Tensor special_shifted_chebyshev_polynomial_u(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_u(x, n);
}
at::Tensor & special_shifted_chebyshev_polynomial_u_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_u_out_out(x, n, out);
}
at::Tensor & special_shifted_chebyshev_polynomial_u_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_u_out_out(x, n, out);
}
at::Tensor special_shifted_chebyshev_polynomial_v(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_v(x, n);
}
at::Tensor & special_shifted_chebyshev_polynomial_v_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_v_out_out(x, n, out);
}
at::Tensor & special_shifted_chebyshev_polynomial_v_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_v_out_out(x, n, out);
}
at::Tensor special_shifted_chebyshev_polynomial_w(const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_w(x, n);
}
at::Tensor & special_shifted_chebyshev_polynomial_w_out(at::Tensor & out, const at::Tensor & x, const at::Tensor & n) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_w_out_out(x, n, out);
}
at::Tensor & special_shifted_chebyshev_polynomial_w_outf(const at::Tensor & x, const at::Tensor & n, at::Tensor & out) {
return wrapper_CPU_special_shifted_chebyshev_polynomial_w_out_out(x, n, out);
}
at::Tensor special_spherical_bessel_j0(const at::Tensor & x) {
return wrapper_CPU_special_spherical_bessel_j0(x);
}
at::Tensor & special_spherical_bessel_j0_out(at::Tensor & out, const at::Tensor & x) {
return wrapper_CPU_special_spherical_bessel_j0_out_out(x, out);
}
at::Tensor & special_spherical_bessel_j0_outf(const at::Tensor & x, at::Tensor & out) {
return wrapper_CPU_special_spherical_bessel_j0_out_out(x, out);
}
at::Tensor _foobar(const at::Tensor & self, bool arg1, bool arg2, bool arg3) {
return wrapper_CPU___foobar(self, arg1, arg2, arg3);
}
} // namespace cpu
} // namespace at
